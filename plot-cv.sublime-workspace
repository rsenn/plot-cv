{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Valu",
				"ValueT"
			],
			[
				"take",
				"takenLines"
			],
			[
				"iterator",
				"iterator_type"
			],
			[
				"Cont",
				"ContainerT"
			],
			[
				"filter",
				"filteredLines"
			],
			[
				"point",
				"point_distance2"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/home/roman/lotto/utils/dom.js",
			"settings":
			{
				"buffer_size": 95931,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/CannyWebcam1.cpp",
			"settings":
			{
				"buffer_size": 30303,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "polygon.cpp",
			"settings":
			{
				"buffer_size": 7597,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is\n * 'psimpl - generic n-dimensional polyline simplification'.\n *\n * The Initial Developer of the Original Code is\n * Elmar de Koning.\n * Portions created by the Initial Developer are Copyright (C) 2010-2011\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n    psimpl - generic n-dimensional polyline simplification\n    Copyright (C) 2010-2011 Elmar de Koning, edekoning@gmail.com\n\n    This file is part of psimpl, and is hosted at SourceForge:\n    http://sourceforge.net/projects/psimpl/\n*/\n\n/*!\n    \\mainpage psimpl - generic n-dimensional polyline simplification\n\n<pre>\n    Author  - Elmar de Koning\n    Support - edekoning@gmail.com\n    Website - http://psimpl.sf.net\n    Article - http://www.codeproject.com/KB/recipes/PolylineSimplification.aspx\n    License - MPL 1.1\n</pre><br>\n\n    \\section sec_psimpl psimpl\n<pre>\n    'psimpl' is a c++ polyline simplification library that is generic, easy to use, and supports\n    the following algorithms:\n\n    Simplification\n    + Nth point - A naive algorithm that keeps only each nth point\n    + Distance between points - Removes successive points that are clustered together\n    + Perpendicular distance - Removes points based on their distance to the line segment defined\n      by their left and right neighbors\n    + Reumann-Witkam - Shifts a strip along the polyline and removes points that fall outside\n    + Opheim - A constrained version of Reumann-Witkam\n    + Lang - Similar to the Perpendicular distance routine, but instead of looking only at direct\n      neighbors, an entire search region is processed\n    + Douglas-Peucker - A classic simplification algorithm that provides an excellent approximation\n      of the original line\n    + A variation on the Douglas-Peucker algorithm - Slower, but yields better results at lower resolutions\n\n    Errors\n    + positional error - Distance of each polyline point to its simplification\n\n    All the algorithms have been implemented in a single standalone C++ header using an STL-style\n    interface that operates on input and output iterators. Polylines can be of any dimension, and\n    defined using floating point or signed integer data types.\n</pre><br>\n    \n\n\n\n\n\n\n\n\n    \\section sec_changelog changelog\n<pre>\n    28-09-2010 - Initial version\n    23-10-2010 - Changed license from CPOL to MPL\n    26-10-2010 - Clarified input (type) requirements, and changed the behavior of the algorithms\n                 under invalid input\n    01-12-2010 - Added the nth point, perpendicular distance and Reumann-Witkam routines; moved all\n                 functions related to distance calculations to the math namespace\n    10-12-2010 - Fixed a bug in the perpendicular distance routine\n    27-02-2011 - Added Opheim simplification, and functions for computing positional errors due to\n                 simplification; renamed simplify_douglas_peucker_alt to simplify_douglas_peucker_n\n    18-06-2011 - Added Lang simplification; fixed divide by zero bug when using integers; fixed a\n                 bug where incorrect output iterators were returned under invalid input; fixed a bug\n                 in douglas_peucker_n where an incorrect number of points could be returned; fixed a\n                 bug in compute_positional_errors2 that required the output and input iterator types\n                 to be the same; fixed a bug in compute_positional_error_statistics where invalid\n                 statistics could be returned under questionable input; documented input iterator\n                 requirements for each algorithm; miscellaneous refactoring of most algorithms.\n</pre>\n*/\n\n#ifndef PSIMPL_GENERIC\n#define PSIMPL_GENERIC\n\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n\n/*!\n    \\brief Root namespace of the polyline simplification library.\n*/\nnamespace psimpl {\n/*!\n    \\brief Contains utility functions and classes.\n*/\nnamespace util {\n/*!\n    \\brief A smart pointer for holding a dynamically allocated array.\n\n    Similar to boost::scoped_array.\n*/\ntemplate <typename T> class scoped_array {\npublic:\n  scoped_array(unsigned n) { array = new T[n]; }\n\n  ~scoped_array() { delete[] array; }\n\n  T& operator[](int offset) { return array[offset]; }\n\n  const T& operator[](int offset) const { return array[offset]; }\n\n  T*\n  get() const {\n    return array;\n  }\n\n  void\n  swap(scoped_array& b) {\n    T* tmp = b.array;\n    b.array = array;\n    array = tmp;\n  }\n\nprivate:\n  scoped_array(const scoped_array&);\n  scoped_array& operator=(const scoped_array&);\n\nprivate:\n  T* array;\n};\n\ntemplate <typename T>\ninline void\nswap(scoped_array<T>& a, scoped_array<T>& b) {\n  a.swap(b);\n}\n} // namespace util\n\n/*!\n    \\brief Contains functions for calculating statistics and distances between various geometric entities.\n*/\nnamespace math {\n/*!\n    \\brief POD structure for storing several statistical values\n*/\nstruct Statistics {\n  Statistics() : max(0), sum(0), mean(0), std(0) {}\n\n  double max;\n  double sum;\n  double mean;\n  double std; //! standard deviation\n};\n\n/*!\n    \\brief Determines if two points have the exact same coordinates.\n\n    \\param[in] p1       the first coordinate of the first point\n    \\param[in] p2       the first coordinate of the second point\n    \\return             true when the points are equal; false otherwise\n*/\ntemplate <unsigned DIM, class InputIterator>\ninline bool\nequal(InputIterator p1, InputIterator p2) {\n  for(unsigned d = 0; d < DIM; ++d) {\n    if(*p1 != *p2) {\n      return false;\n    }\n    ++p1;\n    ++p2;\n  }\n  return true;\n}\n\n/*!\n    \\brief Creates a vector from two points.\n\n    \\param[in] p1       the first coordinate of the first point\n    \\param[in] p2       the first coordinate of the second point\n    \\param[in] result   the resulting vector (p2-p1)\n    \\return             one beyond the last coordinate of the resulting vector\n*/\ntemplate <unsigned DIM, class InputIterator, class OutputIterator>\ninline OutputIterator\nmake_vector(InputIterator p1, InputIterator p2, OutputIterator result) {\n  for(unsigned d = 0; d < DIM; ++d) {\n    *result = *p2 - *p1;\n    ++result;\n    ++p1;\n    ++p2;\n  }\n  return result;\n}\n\n/*!\n    \\brief Computes the dot product of two vectors.\n\n    \\param[in] v1   the first coordinate of the first vector\n    \\param[in] v2   the first coordinate of the second vector\n    \\return         the dot product (v1 * v2)\n*/\ntemplate <unsigned DIM, class InputIterator>\ninline typename std::iterator_traits<InputIterator>::value_type\ndot(InputIterator v1, InputIterator v2) {\n  typename std::iterator_traits<InputIterator>::value_type result = 0;\n  for(unsigned d = 0; d < DIM; ++d) {\n    result += (*v1) * (*v2);\n    ++v1;\n    ++v2;\n  }\n  return result;\n}\n\n/*!\n    \\brief Peforms linear interpolation between two points.\n\n    \\param[in] p1           the first coordinate of the first point\n    \\param[in] p2           the first coordinate of the second point\n    \\param[in] fraction     the fraction used during interpolation\n    \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n    \\return                 one beyond the last coordinate of the interpolated point\n*/\ntemplate <unsigned DIM, class InputIterator, class OutputIterator>\ninline OutputIterator\ninterpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n\n  for(unsigned d = 0; d < DIM; ++d) {\n    *result = *p1 + static_cast<value_type>(fraction * (*p2 - *p1));\n    ++result;\n    ++p1;\n    ++p2;\n  }\n  return result;\n}\n\n/*!\n    \\brief Computes the squared distance of two points\n\n    \\param[in] p1   the first coordinate of the first point\n    \\param[in] p2   the first coordinate of the second point\n    \\return         the squared distance\n*/\ntemplate <unsigned DIM, class InputIterator1, class InputIterator2>\ninline typename std::iterator_traits<InputIterator1>::value_type\npoint_distance2(InputIterator1 p1, InputIterator2 p2) {\n  typename std::iterator_traits<InputIterator1>::value_type result = 0;\n  for(unsigned d = 0; d < DIM; ++d) {\n    result += (*p1 - *p2) * (*p1 - *p2);\n    ++p1;\n    ++p2;\n  }\n  return result;\n}\n\n/*!\n    \\brief Computes the squared distance between an infinite line (l1, l2) and a point p\n\n    \\param[in] l1   the first coordinate of the first point on the line\n    \\param[in] l2   the first coordinate of the second point on the line\n    \\param[in] p    the first coordinate of the test point\n    \\return         the squared distance\n*/\ntemplate <unsigned DIM, class InputIterator>\ninline typename std::iterator_traits<InputIterator>::value_type\nline_distance2(InputIterator l1, InputIterator l2, InputIterator p) {\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n\n  value_type v[DIM]; // vector l1 --> l2\n  value_type w[DIM]; // vector l1 --> p\n\n  make_vector<DIM>(l1, l2, v);\n  make_vector<DIM>(l1, p, w);\n\n  value_type cv = dot<DIM>(v, v); // squared length of v\n  value_type cw = dot<DIM>(w, v); // project w onto v\n\n  // avoid problems with divisions when value_type is an integer type\n  float fraction = cv == 0 ? 0 : static_cast<float>(cw) / static_cast<float>(cv);\n\n  value_type proj[DIM]; // p projected onto line (l1, l2)\n  interpolate<DIM>(l1, l2, fraction, proj);\n\n  return point_distance2<DIM>(p, proj);\n}\n\n/*!\n    \\brief Computes the squared distance between a line segment (s1, s2) and a point p\n\n    \\param[in] s1   the first coordinate of the start point of the segment\n    \\param[in] s2   the first coordinate of the end point of the segment\n    \\param[in] p    the first coordinate of the test point\n    \\return         the squared distance\n*/\ntemplate <unsigned DIM, class InputIterator>\ninline typename std::iterator_traits<InputIterator>::value_type\n  segment_distance2(InputIterator s1, InputIterator s2, InputIterator p) {\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n\n  value_type v[DIM]; // vector s1 --> s2\n  value_type w[DIM]; // vector s1 --> p\n\n  make_vector<DIM>(s1, s2, v);\n  make_vector<DIM>(s1, p, w);\n\n  value_type cw = dot<DIM>(w, v); // project w onto v\n  if(cw <= 0) {\n    // projection of w lies to the left of s1\n    return point_distance2<DIM>(p, s1);\n  }\n\n  value_type cv = dot<DIM>(v, v); // squared length of v\n  if(cv <= cw) {\n    // projection of w lies to the right of s2\n    return point_distance2<DIM>(p, s2);\n  }\n\n  // avoid problems with divisions when value_type is an integer type\n  float fraction = cv == 0 ? 0 : static_cast<float>(cw) / static_cast<float>(cv);\n\n  value_type proj[DIM]; // p projected onto segement (s1, s2)\n  interpolate<DIM>(s1, s2, fraction, proj);\n\n  return point_distance2<DIM>(p, proj);\n}\n\n/*!\n    \\brief Computes the squared distance between a ray (r1, r2) and a point p\n\n    \\param[in] r1   the first coordinate of the start point of the ray\n    \\param[in] r2   the first coordinate of a point on the ray\n    \\param[in] p    the first coordinate of the test point\n    \\return         the squared distance\n*/\ntemplate <unsigned DIM, class InputIterator>\ninline typename std::iterator_traits<InputIterator>::value_type\nray_distance2(InputIterator r1, InputIterator r2, InputIterator p) {\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n\n  value_type v[DIM]; // vector r1 --> r2\n  value_type w[DIM]; // vector r1 --> p\n\n  make_vector<DIM>(r1, r2, v);\n  make_vector<DIM>(r1, p, w);\n\n  value_type cv = dot<DIM>(v, v); // squared length of v\n  value_type cw = dot<DIM>(w, v); // project w onto v\n\n  if(cw <= 0) {\n    // projection of w lies to the left of r1 (not on the ray)\n    return point_distance2<DIM>(p, r1);\n  }\n\n  // avoid problems with divisions when value_type is an integer type\n  float fraction = cv == 0 ? 0 : static_cast<float>(cw) / static_cast<float>(cv);\n\n  value_type proj[DIM]; // p projected onto ray (r1, r2)\n  interpolate<DIM>(r1, r2, fraction, proj);\n\n  return point_distance2<DIM>(p, proj);\n}\n\n/*!\n    \\brief Computes various statistics for the range [first, last)\n\n    \\param[in] first   the first value\n    \\param[in] last    one beyond the last value\n    \\return            the calculated statistics\n*/\ntemplate <class InputIterator>\ninline Statistics\ncompute_statistics(InputIterator first, InputIterator last) {\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  typedef typename std::iterator_traits<InputIterator>::difference_type diff_type;\n\n  Statistics stats;\n\n  diff_type count = std::distance(first, last);\n  if(count == 0) {\n    return stats;\n  }\n\n  value_type init = 0;\n  stats.max = static_cast<double>(*std::max_element(first, last));\n  stats.sum = static_cast<double>(std::accumulate(first, last, init));\n  stats.mean = stats.sum / count;\n  std::transform(first, last, first, std::bind2nd(std::minus<value_type>(), stats.mean));\n  stats.std = std::sqrt(static_cast<double>(std::inner_product(first, last, first, init)) / count);\n  return stats;\n}\n} // namespace math\n\n/*!\n    \\brief Provides various simplification algorithms for n-dimensional simple polylines.\n\n    A polyline is simple when it is non-closed and non-selfintersecting. All algorithms\n    operate on input iterators and output iterators. Note that unisgned integer types are\n    NOT supported.\n*/\ntemplate <unsigned DIM, class InputIterator, class OutputIterator> class PolylineSimplification {\n  typedef typename std::iterator_traits<InputIterator>::difference_type diff_type;\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  typedef typename std::iterator_traits<const value_type*>::difference_type ptr_diff_type;\n\npublic:\n  /*!\n      \\brief Performs the nth point routine (NP).\n\n      NP is an O(n) algorithm for polyline simplification. It keeps only the first, last and\n      each nth point. As an example, consider any random line of 8 points. Using n = 3 will\n      always yield a simplification consisting of points: 1, 4, 7, 8\n\n      \\image html psimpl_np.png\n\n      NP is applied to the range [first, last). The resulting simplified polyline is copied\n      to the output range [result, result + m*DIM), where m is the number of vertices of the\n      simplified polyline. The return value is the end of the output range: result + m*DIM.\n\n      Input (Type) requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The input iterator value type is convertible to a value type of the OutputIterator\n      4- The range [first, last) contains only vertex coordinates in multiples of DIM, f.e.:\n         x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains at least 2 vertices\n      6- n is not 0\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] n        specifies 'each nth point'\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  NthPoint(InputIterator first, InputIterator last, unsigned n, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount < 3 || n < 2) {\n      return std::copy(first, last, result);\n    }\n\n    unsigned remaining = pointCount - 1; // the number of points remaining after key\n    InputIterator key = first;           // indicates the current key\n\n    // the first point is always part of the simplification\n    CopyKey(key, result);\n\n    // copy each nth point\n    while(Forward(key, n, remaining)) {\n      CopyKey(key, result);\n    }\n\n    return result;\n  }\n\n  /*!\n      \\brief Performs the (radial) distance between points routine (RD).\n\n      RD is a brute-force O(n) algorithm for polyline simplification. It reduces successive\n      vertices that are clustered too closely to a single vertex, called a key. The resulting\n      keys form the simplified polyline.\n\n      \\image html psimpl_rd.png\n\n      RD is applied to the range [first, last) using the specified tolerance tol. The\n      resulting simplified polyline is copied to the output range [result, result + m*DIM),\n      where m is the number of vertices of the simplified polyline. The return value is the\n      end of the output range: result + m*DIM.\n\n      Input (Type) requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The input iterator value type is convertible to a value type of the output iterator\n      4- The range [first, last) contains only vertex coordinates in multiples of DIM, f.e.:\n         x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains at least 2 vertices\n      6- tol is not 0\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] tol      radial (point-to-point) distance tolerance\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  RadialDistance(InputIterator first, InputIterator last, value_type tol, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n    value_type tol2 = tol * tol; // squared distance tolerance\n\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount < 3 || tol2 == 0) {\n      return std::copy(first, last, result);\n    }\n\n    InputIterator current = first; // indicates the current key\n    InputIterator next = first;    // used to find the next key\n\n    // the first point is always part of the simplification\n    CopyKeyAdvance(next, result);\n\n    // Skip first and last point, because they are always part of the simplification\n    for(diff_type index = 1; index < pointCount - 1; ++index) {\n      if(math::point_distance2<DIM>(current, next) < tol2) {\n        Advance(next);\n        continue;\n      }\n      current = next;\n      CopyKeyAdvance(next, result);\n    }\n    // the last point is always part of the simplification\n    CopyKeyAdvance(next, result);\n\n    return result;\n  }\n\n  /*!\n      \\brief Repeatedly performs the perpendicular distance routine (PD).\n\n      The algorithm stops after calling the PD routine 'repeat' times OR when the\n      simplification does not improve. Note that this algorithm will need to store\n      up to two intermediate simplification results.\n\n      \\sa PerpendicularDistance(InputIterator, InputIterator, value_type, OutputIterator)\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] tol      perpendicular (segment-to-point) distance tolerance\n      \\param[in] repeat   the number of times to successively apply the PD routine\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  PerpendicularDistance(\n      InputIterator first, InputIterator last, value_type tol, unsigned repeat, OutputIterator result) {\n    if(repeat == 1) {\n      // single pass\n      return PerpendicularDistance(first, last, tol, result);\n    }\n    // only validate repeat; other input is validated by simplify_perpendicular_distance\n    if(repeat < 1) {\n      return std::copy(first, last, result);\n    }\n    diff_type coordCount = std::distance(first, last);\n\n    // first pass: [first, last) --> temporary array 'tempPoly'\n    util::scoped_array<value_type> tempPoly(coordCount);\n    PolylineSimplification<DIM, InputIterator, value_type*> psimpl_to_array;\n    diff_type tempCoordCount =\n        std::distance(tempPoly.get(), psimpl_to_array.PerpendicularDistance(first, last, tol, tempPoly.get()));\n\n    // check if simplification did not improved\n    if(coordCount == tempCoordCount) {\n      return std::copy(tempPoly.get(), tempPoly.get() + coordCount, result);\n    }\n    std::swap(coordCount, tempCoordCount);\n    --repeat;\n\n    // intermediate passes: temporary array 'tempPoly' --> temporary array 'tempResult'\n    if(1 < repeat) {\n      util::scoped_array<value_type> tempResult(coordCount);\n      PolylineSimplification<DIM, value_type*, value_type*> psimpl_arrays;\n\n      while(--repeat) {\n        tempCoordCount = std::distance(\n            tempResult.get(),\n            psimpl_arrays.PerpendicularDistance(tempPoly.get(), tempPoly.get() + coordCount, tol, tempResult.get()));\n\n        // check if simplification did not improved\n        if(coordCount == tempCoordCount) {\n          return std::copy(tempPoly.get(), tempPoly.get() + coordCount, result);\n        }\n        util::swap(tempPoly, tempResult);\n        std::swap(coordCount, tempCoordCount);\n      }\n    }\n\n    // final pass: temporary array 'tempPoly' --> result\n    PolylineSimplification<DIM, value_type*, OutputIterator> psimpl_from_array;\n    return psimpl_from_array.PerpendicularDistance(tempPoly.get(), tempPoly.get() + coordCount, tol, result);\n  }\n\n  /*!\n      \\brief Performs the perpendicular distance routine (PD).\n\n      PD is an O(n) algorithm for polyline simplification. It computes the perpendicular\n      distance of each point pi to the line segment S(pi-1, pi+1). Only when this distance is\n      larger than the given tolerance will pi be part of the simpification. Note that the\n      original polyline can only be reduced by a maximum of 50%. Multiple passes are required\n      to achieve higher points reductions.\n\n      \\image html psimpl_pd.png\n\n      PD is applied to the range [first, last) using the specified tolerance tol. The\n      resulting simplified polyline is copied to the output range [result, result + m*DIM),\n      where m is the number of vertices of the simplified polyline. The return value is the\n      end of the output range: result + m*DIM.\n\n      Input (Type) requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The input iterator value type is convertible to a value type of the output iterator\n      4- The range [first, last) contains only vertex coordinates in multiples of DIM, f.e.:\n         x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains at least 2 vertices\n      6- tol is not 0\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] tol      perpendicular (segment-to-point) distance tolerance\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  PerpendicularDistance(InputIterator first, InputIterator last, value_type tol, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n    value_type tol2 = tol * tol; // squared distance tolerance\n\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount < 3 || tol2 == 0) {\n      return std::copy(first, last, result);\n    }\n\n    InputIterator p0 = first;\n    InputIterator p1 = AdvanceCopy(p0);\n    InputIterator p2 = AdvanceCopy(p1);\n\n    // the first point is always part of the simplification\n    CopyKey(p0, result);\n\n    while(p2 != last) {\n      // test p1 against line segment S(p0, p2)\n      if(math::segment_distance2<DIM>(p0, p2, p1) < tol2) {\n        CopyKey(p2, result);\n        // move up by two points\n        p0 = p2;\n        Advance(p1, 2);\n        if(p1 == last) {\n          // protect against advancing p2 beyond last\n          break;\n        }\n        Advance(p2, 2);\n      } else {\n        CopyKey(p1, result);\n        // move up by one point\n        p0 = p1;\n        p1 = p2;\n        Advance(p2);\n      }\n    }\n    // make sure the last point is part of the simplification\n    if(p1 != last) {\n      CopyKey(p1, result);\n    }\n    return result;\n  }\n\n  /*!\n      \\brief Performs Reumann-Witkam approximation (RW).\n\n      The O(n) RW routine uses a point-to-line (perpendicular) distance tolerance. It defines\n      a line through the first two vertices of the original polyline. For each successive\n      vertex vi its perpendicular distance to this line is calculated. A new key is found at\n      vi-1, when this distance exceeds the specified tolerance. The vertices vi and vi+1 are\n      then used to define a new line, and the process repeats itself.\n\n      \\image html psimpl_rw.png\n\n      RW routine is applied to the range [first, last) using the specified perpendicular\n      distance tolerance tol. The resulting simplified polyline is copied to the output range\n      [result, result + m*DIM), where m is the number of vertices of the simplified polyline.\n      The return value is the end of the output range: result + m*DIM.\n\n      Input (Type) Requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The input iterator value type is convertible to a value type of the output iterator\n      4- The range [first, last) contains vertex coordinates in multiples of DIM,\n         f.e.: x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains at least 2 vertices\n      6- tol is not 0\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] tol      perpendicular (point-to-line) distance tolerance\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  ReumannWitkam(InputIterator first, InputIterator last, value_type tol, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n    value_type tol2 = tol * tol; // squared distance tolerance\n\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount < 3 || tol2 == 0) {\n      return std::copy(first, last, result);\n    }\n\n    // define the line L(p0, p1)\n    InputIterator p0 = first;              // indicates the current key\n    InputIterator p1 = AdvanceCopy(first); // indicates the next point after p0\n\n    // keep track of two test points\n    InputIterator pi = p1; // the previous test point\n    InputIterator pj = p1; // the current test point (pi+1)\n\n    // the first point is always part of the simplification\n    CopyKey(p0, result);\n\n    // check each point pj against L(p0, p1)\n    for(diff_type j = 2; j < pointCount; ++j) {\n      pi = pj;\n      Advance(pj);\n\n      if(math::line_distance2<DIM>(p0, p1, pj) < tol2) {\n        continue;\n      }\n      // found the next key at pi\n      CopyKey(pi, result);\n      // define new line L(pi, pj)\n      p0 = pi;\n      p1 = pj;\n    }\n    // the last point is always part of the simplification\n    CopyKey(pj, result);\n\n    return result;\n  }\n\n  /*!\n      \\brief Performs Opheim approximation (OP).\n\n      The O(n) OP routine is very similar to the Reumann-Witkam (RW) routine, and can be seen\n      as a constrained version of that RW routine. OP uses both a minimum and a maximum\n      distance tolerance to constrain the search area. For each successive vertex vi, its\n      radial distance to the current key vkey (initially v0) is calculated. The last point\n      within the minimum distance tolerance is used to define a ray R (vkey, vi). If no\n      such vi exists, the ray is defined as R(vkey, vkey+1). For each successive vertex vj\n      beyond vi its perpendicular distance to the ray R is calculated. A new key is found at\n      vj-1, when this distance exceeds the minimum tolerance Or when the radial distance\n      between vj and the vkey exceeds the maximum tolerance. After a new key is found, the\n      process repeats itself.\n\n      \\image html psimpl_op.png\n\n      OP routine is applied to the range [first, last) using the specified distance tolerances\n      min_tol and max_tol. The resulting simplified polyline is copied to the output range\n      [result, result + m*DIM), where m is the number of vertices of the simplified polyline.\n      The return value is the end of the output range: result + m*DIM.\n\n      Input (Type) Requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The input iterator value type is convertible to a value type of the output iterator\n      4- The range [first, last) contains vertex coordinates in multiples of DIM,\n         f.e.: x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains at least 2 vertices\n      6- min_tol is not 0\n      7- max_tol is not 0\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] min_tol  radial and perpendicular (point-to-ray) distance tolerance\n      \\param[in] max_tol  radial distance tolerance\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  Opheim(InputIterator first, InputIterator last, value_type min_tol, value_type max_tol, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n    value_type min_tol2 = min_tol * min_tol; // squared minimum distance tolerance\n    value_type max_tol2 = max_tol * max_tol; // squared maximum distance tolerance\n\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount < 3 || min_tol2 == 0 || max_tol2 == 0) {\n      return std::copy(first, last, result);\n    }\n\n    // define the ray R(r0, r1)\n    InputIterator r0 = first; // indicates the current key and start of the ray\n    InputIterator r1 = first; // indicates a point on the ray\n    bool rayDefined = false;\n\n    // keep track of two test points\n    InputIterator pi = r0; // the previous test point\n    InputIterator pj =     // the current test point (pi+1)\n        AdvanceCopy(pi);\n\n    // the first point is always part of the simplification\n    CopyKey(r0, result);\n\n    for(diff_type j = 2; j < pointCount; ++j) {\n      pi = pj;\n      Advance(pj);\n\n      if(!rayDefined) {\n        // discard each point within minimum tolerance\n        if(math::point_distance2<DIM>(r0, pj) < min_tol2) {\n          continue;\n        }\n        // the last point within minimum tolerance pi defines the ray R(r0, r1)\n        r1 = pi;\n        rayDefined = true;\n      }\n\n      // check each point pj against R(r0, r1)\n      if(math::point_distance2<DIM>(r0, pj) < max_tol2 && math::ray_distance2<DIM>(r0, r1, pj) < min_tol2) {\n        continue;\n      }\n      // found the next key at pi\n      CopyKey(pi, result);\n      // define new ray R(pi, pj)\n      r0 = pi;\n      rayDefined = false;\n    }\n    // the last point is always part of the simplification\n    CopyKey(pj, result);\n\n    return result;\n  }\n\n  /*!\n      \\brief Performs Lang approximation (LA).\n\n      The LA routine defines a fixed size search-region. The first and last points of that\n      search region form a segment. This segment is used to calculate the perpendicular\n      distance to each intermediate point. If any calculated distance is larger than the\n      specified tolerance, the search region will be shrunk by excluding its last point. This\n      process will continue untill all calculated distances fall below the specified tolerance\n      , or there are no more intermediate points. At this point all intermediate points are\n      removed and a new search region is defined starting at the last point from old search\n      region.\n      Note that the size of the search region (look_ahead parameter) controls the maximum\n      amount of simplification, e.g.: a size of 20 will always result in a simplification that\n      contains at least 5% of the original points.\n\n      \\image html psimpl_la.png\n\n      LA routine is applied to the range [first, last) using the specified tolerance and\n      look ahead values. The resulting simplified polyline is copied to the output range\n      [result, result + m*DIM), where m is the number of vertices of the simplified polyline.\n      The return value is the end of the output range: result + m*DIM.\n\n      Input (Type) Requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a bidirectional iterator\n      3- The InputIterator value type is convertible to a value type of the output iterator\n      4- The range [first, last) contains vertex coordinates in multiples of DIM,\n         f.e.: x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains at least 2 vertices\n      6- tol is not 0\n      7- look_ahead is not zero\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\param[in] first      the first coordinate of the first polyline point\n      \\param[in] last       one beyond the last coordinate of the last polyline point\n      \\param[in] tol        perpendicular (point-to-segment) distance tolerance\n      \\param[in] look_ahead defines the size of the search region\n      \\param[in] result     destination of the simplified polyline\n      \\return               one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  Lang(InputIterator first, InputIterator last, value_type tol, unsigned look_ahead, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n    value_type tol2 = tol * tol; // squared minimum distance tolerance\n\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount < 3 || look_ahead < 2 || tol2 == 0) {\n      return std::copy(first, last, result);\n    }\n\n    InputIterator current = first; // indicates the current key\n    InputIterator next = first;    // used to find the next key\n\n    unsigned remaining = pointCount - 1; // the number of points remaining after current\n    unsigned moved = Forward(next, look_ahead, remaining);\n\n    // the first point is always part of the simplification\n    CopyKey(current, result);\n\n    while(moved) {\n      value_type d2 = 0;\n      InputIterator p = AdvanceCopy(current);\n\n      while(p != next) {\n        d2 = std::max(d2, math::segment_distance2<DIM>(current, next, p));\n        if(tol2 < d2) {\n          break;\n        }\n        Advance(p);\n      }\n      if(d2 < tol2) {\n        current = next;\n        CopyKey(current, result);\n        moved = Forward(next, look_ahead, remaining);\n      } else {\n        Backward(next, remaining);\n      }\n    }\n    return result;\n  }\n\n  /*!\n      \\brief Performs Douglas-Peucker approximation (DP).\n\n      The DP algorithm uses the RadialDistance (RD) routine O(n) as a preprocessing step.\n      After RD the algorithm is O (n m) in worst case and O(n log m) on average, where m < n\n      (m is the number of points after RD).\n\n      The DP algorithm starts with a simplification that is the single edge joining the first\n      and last vertices of the polyline. The distance of the remaining vertices to that edge\n      are computed. The vertex that is furthest away from theedge (called a key), and has a\n      computed distance that is larger than a specified tolerance, will be added to the\n      simplification. This process will recurse for each edge in the current simplification,\n      untill all vertices of the original polyline are within tolerance.\n\n      \\image html psimpl_dp.png\n\n      Note that this algorithm will create a copy of the input polyline during the vertex\n      reduction step.\n\n      RD followed by DP is applied to the range [first, last) using the specified tolerance\n      tol. The resulting simplified polyline is copied to the output range\n      [result, result + m*DIM), where m is the number of vertices of the simplified polyline.\n      The return value is the end of the output range: result + m*DIM.\n\n      Input (Type) requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The InputIterator value type is convertible to a value type of the output iterator\n      4- The range [first, last) contains vertex coordinates in multiples of DIM, f.e.:\n         x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains at least 2 vertices\n      6- tol is not 0\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] tol      perpendicular (point-to-segment) distance tolerance\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  DouglasPeucker(InputIterator first, InputIterator last, value_type tol, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount < 3 || tol == 0) {\n      return std::copy(first, last, result);\n    }\n    // radial distance routine as preprocessing\n    util::scoped_array<value_type> reduced(coordCount); // radial distance results\n    PolylineSimplification<DIM, InputIterator, value_type*> psimpl_to_array;\n    ptr_diff_type reducedCoordCount =\n        std::distance(reduced.get(), psimpl_to_array.RadialDistance(first, last, tol, reduced.get()));\n    ptr_diff_type reducedPointCount = reducedCoordCount / DIM;\n\n    // douglas-peucker approximation\n    util::scoped_array<unsigned char> keys(pointCount); // douglas-peucker results\n    DPHelper::Approximate(reduced.get(), reducedCoordCount, tol, keys.get());\n\n    // copy all keys\n    const value_type* current = reduced.get();\n    for(ptr_diff_type p = 0; p < reducedPointCount; ++p, current += DIM) {\n      if(keys[p]) {\n        for(unsigned d = 0; d < DIM; ++d) {\n          *result = current[d];\n          ++result;\n        }\n      }\n    }\n    return result;\n  }\n\n  /*!\n      \\brief Performs a Douglas-Peucker approximation variant (DPn).\n\n      This algorithm is a variation of the original implementation. Instead of considering\n      one polyline segment at a time, all segments of the current simplified polyline are\n      evaluated at each step. Only the vertex with the maximum distance from its edge is\n      added to the simplification. This process will recurse untill the the simplification\n      contains the desired amount of vertices.\n\n      The algorithm, which does not use the (radial) distance between points routine as a\n      preprocessing step, is O(n2) in worst case and O(n log n) on average.\n\n      Note that this algorithm will create a copy of the input polyline for performance\n      reasons.\n\n      DPn is applied to the range [first, last). The resulting simplified polyline consists\n      of count vertices and is copied to the output range [result, result + count). The\n      return value is the end of the output range: result + count.\n\n      Input (Type) requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The InputIterator value type is convertible to a value type of the output iterator\n      4- The range [first, last) contains vertex coordinates in multiples of DIM, f.e.:\n         x, y, z, x, y, z, x, y, z when DIM = 3\n      5- The range [first, last) contains a minimum of count vertices\n      6- count is at least 2\n\n      In case these requirements are not met, the entire input range [first, last) is copied\n      to the output range [result, result + (last - first)) OR compile errors may occur.\n\n      \\sa DouglasPeucker\n\n      \\param[in] first    the first coordinate of the first polyline point\n      \\param[in] last     one beyond the last coordinate of the last polyline point\n      \\param[in] count    the maximum number of points of the simplified polyline\n      \\param[in] result   destination of the simplified polyline\n      \\return             one beyond the last coordinate of the simplified polyline\n  */\n  OutputIterator\n  DouglasPeuckerN(InputIterator first, InputIterator last, unsigned count, OutputIterator result) {\n    diff_type coordCount = std::distance(first, last);\n    diff_type pointCount = DIM // protect against zero DIM\n                               ? coordCount / DIM\n                               : 0;\n    // validate input and check if simplification required\n    if(coordCount % DIM || pointCount <= static_cast<diff_type>(count) || count < 2) {\n      return std::copy(first, last, result);\n    }\n\n    // copy coords\n    util::scoped_array<value_type> coords(coordCount);\n    for(ptr_diff_type c = 0; c < coordCount; ++c) {\n      coords[c] = *first;\n      ++first;\n    }\n\n    // douglas-peucker approximation\n    util::scoped_array<unsigned char> keys(pointCount);\n    DPHelper::ApproximateN(coords.get(), coordCount, count, keys.get());\n\n    // copy keys\n    const value_type* current = coords.get();\n    for(ptr_diff_type p = 0; p < pointCount; ++p, current += DIM) {\n      if(keys[p]) {\n        for(unsigned d = 0; d < DIM; ++d) {\n          *result = current[d];\n          ++result;\n        }\n      }\n    }\n    return result;\n  }\n\n  /*!\n      \\brief Computes the squared positional error between a polyline and its simplification.\n\n      For each point in the range [original_first, original_last) the squared distance to the\n      simplification [simplified_first, simplified_last) is calculated. Each positional error\n      is copied to the output range [result, result + count), where count is the number of\n      points in the original polyline. The return value is the end of the output range:\n      result + count.\n\n      Note that both the original and simplified polyline must be defined using the same\n      value_type.\n\n      \\image html psimpl_pos_error.png\n\n      Input (Type) requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The InputIterator value type is convertible to a value type of the output iterator\n      4- The ranges [original_first, original_last) and [simplified_first, simplified_last)\n         contain vertex coordinates in multiples of DIM, f.e.: x, y, z, x, y, z, x, y, z\n         when DIM = 3\n      5- The ranges [original_first, original_last) and [simplified_first, simplified_last)\n         contain a minimum of 2 vertices\n      6- The range [simplified_first, simplified_last) represents a simplification of the\n         range [original_first, original_last), meaning each point in the simplification\n         has the exact same coordinates as some point from the original polyline\n\n      In case these requirements are not met, the valid flag is set to false OR\n      compile errors may occur.\n\n      \\param[in] original_first   the first coordinate of the first polyline point\n      \\param[in] original_last    one beyond the last coordinate of the last polyline point\n      \\param[in] simplified_first the first coordinate of the first simplified polyline point\n      \\param[in] simplified_last  one beyond the last coordinate of the last simplified polyline point\n      \\param[in] result           destination of the squared positional errors\n      \\param[out] valid           [optional] indicates if the computed positional errors are valid\n      \\return                     one beyond the last computed positional error\n  */\n  OutputIterator\n  ComputePositionalErrors2(InputIterator original_first,\n                           InputIterator original_last,\n                           InputIterator simplified_first,\n                           InputIterator simplified_last,\n                           OutputIterator result,\n                           bool* valid = 0) {\n    diff_type original_coordCount = std::distance(original_first, original_last);\n    diff_type original_pointCount = DIM // protect against zero DIM\n                                        ? original_coordCount / DIM\n                                        : 0;\n\n    diff_type simplified_coordCount = std::distance(simplified_first, simplified_last);\n    diff_type simplified_pointCount = DIM // protect against zero DIM\n                                          ? simplified_coordCount / DIM\n                                          : 0;\n\n    // validate input\n    if(original_coordCount % DIM || original_pointCount < 2 || simplified_coordCount % DIM ||\n       simplified_pointCount < 2 || original_pointCount < simplified_pointCount ||\n       !math::equal<DIM>(original_first, simplified_first)) {\n      if(valid) {\n        *valid = false;\n      }\n      return result;\n    }\n\n    // define (simplified) line segment S(simplified_prev, simplified_first)\n    InputIterator simplified_prev = simplified_first;\n    std::advance(simplified_first, DIM);\n\n    // process each simplified line segment\n    while(simplified_first != simplified_last) {\n      // process each original point until it equals the end of the line segment\n      while(original_first != original_last && !math::equal<DIM>(original_first, simplified_first)) {\n        *result = math::segment_distance2<DIM>(simplified_prev, simplified_first, original_first);\n        ++result;\n        std::advance(original_first, DIM);\n      }\n      // update line segment S\n      simplified_prev = simplified_first;\n      std::advance(simplified_first, DIM);\n    }\n    // check if last original point matched\n    if(original_first != original_last) {\n      *result = 0;\n      ++result;\n    }\n\n    if(valid) {\n      *valid = original_first != original_last;\n    }\n    return result;\n  }\n\n  /*!\n      \\brief Computes statistics for the positional errors between a polyline and its simplification.\n\n      Various statistics (mean, max, sum, std) are calculated for the positional errors\n      between the range [original_first, original_last) and its simplification the range\n      [simplified_first, simplified_last).\n\n      Input (Type) requirements:\n      1- DIM is not 0, where DIM represents the dimension of the polyline\n      2- The InputIterator type models the concept of a forward iterator\n      3- The InputIterator value type is convertible to double\n      4- The ranges [original_first, original_last) and [simplified_first, simplified_last)\n         contain vertex coordinates in multiples of DIM, f.e.: x, y, z, x, y, z, x, y, z\n         when DIM = 3\n      5- The ranges [original_first, original_last) and [simplified_first, simplified_last)\n         contain a minimum of 2 vertices\n      6- The range [simplified_first, simplified_last) represents a simplification of the\n         range [original_first, original_last), meaning each point in the simplification\n         has the exact same coordinates as some point from the original polyline\n\n      In case these requirements are not met, the valid flag is set to false OR\n      compile errors may occur.\n\n      \\sa ComputePositionalErrors2\n\n      \\param[in] original_first   the first coordinate of the first polyline point\n      \\param[in] original_last    one beyond the last coordinate of the last polyline point\n      \\param[in] simplified_first the first coordinate of the first simplified polyline point\n      \\param[in] simplified_last  one beyond the last coordinate of the last simplified polyline point\n      \\param[out] valid           [optional] indicates if the computed statistics are valid\n      \\return                     the computed statistics\n  */\n  math::Statistics\n  ComputePositionalErrorStatistics(InputIterator original_first,\n                                   InputIterator original_last,\n                                   InputIterator simplified_first,\n                                   InputIterator simplified_last,\n                                   bool* valid = 0) {\n    diff_type pointCount = std::distance(original_first, original_last) / DIM;\n    util::scoped_array<double> errors(pointCount);\n    PolylineSimplification<DIM, InputIterator, double*> ps;\n\n    diff_type errorCount =\n        std::distance(errors.get(),\n                      ps.ComputePositionalErrors2(\n                          original_first, original_last, simplified_first, simplified_last, errors.get(), valid));\n\n    std::transform(errors.get(), errors.get() + errorCount, errors.get(), std::ptr_fun<double, double>(std::sqrt));\n\n    return math::compute_statistics(errors.get(), errors.get() + errorCount);\n  }\n\nprivate:\n  /*!\n      \\brief Copies the key to the output destination, and increments the iterator.\n\n      \\sa CopyKey\n\n      \\param[in,out] key      the first coordinate of the key\n      \\param[in,out] result   destination of the copied key\n  */\n  inline void\n  CopyKeyAdvance(InputIterator& key, OutputIterator& result) {\n    for(unsigned d = 0; d < DIM; ++d) {\n      *result = *key;\n      ++result;\n      ++key;\n    }\n  }\n\n  /*!\n      \\brief Copies the key to the output destination.\n\n      \\sa CopyKeyAdvance\n\n      \\param[in]     key      the first coordinate of the key\n      \\param[in,out] result   destination of the copied key\n  */\n  inline void\n  CopyKey(InputIterator key, OutputIterator& result) {\n    CopyKeyAdvance(key, result);\n  }\n\n  /*!\n      \\brief Increments the iterator by n points.\n\n      \\sa AdvanceCopy\n\n      \\param[in,out] it  iterator to be advanced\n      \\param[in]     n   number of points to advance\n  */\n  inline void\n  Advance(InputIterator& it, diff_type n = 1) {\n    std::advance(it, n * static_cast<diff_type>(DIM));\n  }\n\n  /*!\n      \\brief Increments a copy of the iterator by n points.\n\n      \\sa Advance\n\n      \\param[in] it   iterator to be advanced\n      \\param[in] n    number of points to advance\n      \\return         an incremented copy of the input iterator\n  */\n  inline InputIterator\n  AdvanceCopy(InputIterator it, diff_type n = 1) {\n    Advance(it, n);\n    return it;\n  }\n\n  /*!\n      \\brief Increments the iterator by n points if possible.\n\n      If there are fewer than n point remaining the iterator will be incremented to the last\n      point.\n\n      \\sa Backward\n\n      \\param[in,out] it           iterator to be advanced\n      \\param[in]     n            number of points to advance\n      \\param[in,out] remaining    number of points remaining after it\n      \\return                     the actual amount of points that the iterator advanced\n  */\n  inline unsigned\n  Forward(InputIterator& it, unsigned n, unsigned& remaining) {\n    n = std::min(n, remaining);\n    Advance(it, n);\n    remaining -= n;\n    return n;\n  }\n\n  /*!\n      \\brief Decrements the iterator by 1 point.\n\n      \\sa Forward\n\n      \\param[in,out] it            iterator to be advanced\n      \\param[in,out] remaining     number of points remaining after it\n  */\n  inline void\n  Backward(InputIterator& it, unsigned& remaining) {\n    Advance(it, -1);\n    ++remaining;\n  }\n\nprivate:\n  /*!\n      \\brief Douglas-Peucker approximation helper class.\n\n      Contains helper implentations for Douglas-Peucker approximation that operate solely on\n      value_type arrays and value_type pointers. Note that the PolylineSimplification\n      class only operates on iterators.\n  */\n  class DPHelper {\n    //! \\brief Defines a sub polyline.\n    struct SubPoly {\n      SubPoly(ptr_diff_type first = 0, ptr_diff_type last = 0) : first(first), last(last) {}\n\n      ptr_diff_type first; //! coord index of the first point\n      ptr_diff_type last;  //! coord index of the last point\n    };\n\n    //! \\brief Defines the key of a polyline.\n    struct KeyInfo {\n      KeyInfo(ptr_diff_type index = 0, value_type dist2 = 0) : index(index), dist2(dist2) {}\n\n      ptr_diff_type index; //! coord index of the key\n      value_type dist2;    //! squared distance of the key to a segment\n    };\n\n    //! \\brief Defines a sub polyline including its key.\n    struct SubPolyAlt {\n      SubPolyAlt(ptr_diff_type first = 0, ptr_diff_type last = 0) : first(first), last(last) {}\n\n      ptr_diff_type first; //! coord index of the first point\n      ptr_diff_type last;  //! coord index of the last point\n      KeyInfo keyInfo;     //! key of this sub poly\n\n      bool\n      operator<(const SubPolyAlt& other) const {\n        return keyInfo.dist2 < other.keyInfo.dist2;\n      }\n    };\n\n  public:\n    /*!\n        \\brief Performs Douglas-Peucker approximation.\n\n        \\param[in] coords       array of polyline coordinates\n        \\param[in] coordCount   number of coordinates in coords []\n        \\param[in] tol          approximation tolerance\n        \\param[out] keys        indicates for each polyline point if it is a key\n    */\n    static void\n    Approximate(const value_type* coords, ptr_diff_type coordCount, value_type tol, unsigned char* keys) {\n      value_type tol2 = tol * tol; // squared distance tolerance\n      ptr_diff_type pointCount = coordCount / DIM;\n      // zero out keys\n      std::fill_n(keys, pointCount, 0);\n      keys[0] = 1;              // the first point is always a key\n      keys[pointCount - 1] = 1; // the last point is always a key\n\n      typedef std::stack<SubPoly> Stack;\n      Stack stack; // LIFO job-queue containing sub-polylines\n\n      SubPoly subPoly(0, coordCount - DIM);\n      stack.push(subPoly); // add complete poly\n\n      while(!stack.empty()) {\n        subPoly = stack.top(); // take a sub poly\n        stack.pop();           // and find its key\n        KeyInfo keyInfo = FindKey(coords, subPoly.first, subPoly.last);\n        if(keyInfo.index && tol2 < keyInfo.dist2) {\n          // store the key if valid\n          keys[keyInfo.index / DIM] = 1;\n          // split the polyline at the key and recurse\n          stack.push(SubPoly(keyInfo.index, subPoly.last));\n          stack.push(SubPoly(subPoly.first, keyInfo.index));\n        }\n      }\n    }\n\n    /*!\n        \\brief Performs Douglas-Peucker approximation.\n\n        \\param[in] coords       array of polyline coordinates\n        \\param[in] coordCount   number of coordinates in coords []\n        \\param[in] countTol     point count tolerance\n        \\param[out] keys        indicates for each polyline point if it is a key\n    */\n    static void\n    ApproximateN(const value_type* coords, ptr_diff_type coordCount, unsigned countTol, unsigned char* keys) {\n      ptr_diff_type pointCount = coordCount / DIM;\n      // zero out keys\n      std::fill_n(keys, pointCount, 0);\n      keys[0] = 1;              // the first point is always a key\n      keys[pointCount - 1] = 1; // the last point is always a key\n      unsigned keyCount = 2;\n\n      if(countTol == 2) {\n        return;\n      }\n\n      typedef std::priority_queue<SubPolyAlt> PriorityQueue;\n      PriorityQueue queue; // sorted (max dist2) job queue containing sub-polylines\n\n      SubPolyAlt subPoly(0, coordCount - DIM);\n      subPoly.keyInfo = FindKey(coords, subPoly.first, subPoly.last);\n      queue.push(subPoly); // add complete poly\n\n      while(!queue.empty()) {\n        subPoly = queue.top(); // take a sub poly\n        queue.pop();\n        // store the key\n        keys[subPoly.keyInfo.index / DIM] = 1;\n        // check point count tolerance\n        keyCount++;\n        if(keyCount == countTol) {\n          break;\n        }\n        // split the polyline at the key and recurse\n        SubPolyAlt left(subPoly.first, subPoly.keyInfo.index);\n        left.keyInfo = FindKey(coords, left.first, left.last);\n        if(left.keyInfo.index) {\n          queue.push(left);\n        }\n        SubPolyAlt right(subPoly.keyInfo.index, subPoly.last);\n        right.keyInfo = FindKey(coords, right.first, right.last);\n        if(right.keyInfo.index) {\n          queue.push(right);\n        }\n      }\n    }\n\n  private:\n    /*!\n        \\brief Finds the key for the given sub polyline.\n\n        Finds the point in the range [first, last] that is furthest away from the\n        segment (first, last). This point is called the key.\n\n        \\param[in] coords   array of polyline coordinates\n        \\param[in] first    the first coordinate of the first polyline point\n        \\param[in] last     the first coordinate of the last polyline point\n        \\return             the index of the key and its distance, or last when a key\n                            could not be found\n    */\n    static KeyInfo\n    FindKey(const value_type* coords, ptr_diff_type first, ptr_diff_type last) {\n      KeyInfo keyInfo;\n\n      for(ptr_diff_type current = first + DIM; current < last; current += DIM) {\n        value_type d2 = math::segment_distance2<DIM>(coords + first, coords + last, coords + current);\n        if(d2 < keyInfo.dist2) {\n          continue;\n        }\n        // update maximum squared distance and the point it belongs to\n        keyInfo.index = current;\n        keyInfo.dist2 = d2;\n      }\n      return keyInfo;\n    }\n  };\n};\n\n/*!\n    \\brief Performs the nth point routine (NP).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::NthPoint.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] n        specifies 'each nth point'\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_nth_point(ForwardIterator first, ForwardIterator last, unsigned n, OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.NthPoint(first, last, n, result);\n}\n\n/*!\n    \\brief Performs the (radial) distance between points routine (RD).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::RadialDistance.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] tol      radial (point-to-point) distance tolerance\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_radial_distance(ForwardIterator first,\n                         ForwardIterator last,\n                         typename std::iterator_traits<ForwardIterator>::value_type tol,\n                         OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.RadialDistance(first, last, tol, result);\n}\n\n/*!\n    \\brief Repeatedly performs the perpendicular distance routine (PD).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::PerpendicularDistance.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] tol      perpendicular (segment-to-point) distance tolerance\n    \\param[in] repeat   the number of times to successively apply the PD routine.\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_perpendicular_distance(ForwardIterator first,\n                                ForwardIterator last,\n                                typename std::iterator_traits<ForwardIterator>::value_type tol,\n                                unsigned repeat,\n                                OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.PerpendicularDistance(first, last, tol, repeat, result);\n}\n\n/*!\n    \\brief Performs the perpendicular distance routine (PD).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::PerpendicularDistance.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] tol      perpendicular (segment-to-point) distance tolerance\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_perpendicular_distance(ForwardIterator first,\n                                ForwardIterator last,\n                                typename std::iterator_traits<ForwardIterator>::value_type tol,\n                                OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.PerpendicularDistance(first, last, tol, result);\n}\n\n/*!\n    \\brief Performs Reumann-Witkam polyline simplification (RW).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::ReumannWitkam.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] tol      perpendicular (point-to-line) distance tolerance\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_reumann_witkam(ForwardIterator first,\n                        ForwardIterator last,\n                        typename std::iterator_traits<ForwardIterator>::value_type tol,\n                        OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.ReumannWitkam(first, last, tol, result);\n}\n\n/*!\n    \\brief Performs Opheim polyline simplification (OP).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::Opheim.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] min_tol  minimum distance tolerance\n    \\param[in] max_tol  maximum distance tolerance\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_opheim(ForwardIterator first,\n                ForwardIterator last,\n                typename std::iterator_traits<ForwardIterator>::value_type min_tol,\n                typename std::iterator_traits<ForwardIterator>::value_type max_tol,\n                OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.Opheim(first, last, min_tol, max_tol, result);\n}\n\n/*!\n    \\brief Performs Lang polyline simplification (LA).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::Lang.\n\n    \\param[in] first      the first coordinate of the first polyline point\n    \\param[in] last       one beyond the last coordinate of the last polyline point\n    \\param[in] tol        perpendicular (point-to-segment) distance tolerance\n    \\param[in] look_ahead defines the size of the search region\n    \\param[in] result     destination of the simplified polyline\n    \\return               one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class BidirectionalIterator, class OutputIterator>\nOutputIterator\nsimplify_lang(BidirectionalIterator first,\n              BidirectionalIterator last,\n              typename std::iterator_traits<BidirectionalIterator>::value_type tol,\n              unsigned look_ahead,\n              OutputIterator result) {\n  PolylineSimplification<DIM, BidirectionalIterator, OutputIterator> ps;\n  return ps.Lang(first, last, tol, look_ahead, result);\n}\n\n/*!\n    \\brief Performs Douglas-Peucker polyline simplification (DP).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::DouglasPeucker.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] tol      perpendicular (point-to-segment) distance tolerance\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_douglas_peucker(ForwardIterator first,\n                         ForwardIterator last,\n                         typename std::iterator_traits<ForwardIterator>::value_type tol,\n                         OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.DouglasPeucker(first, last, tol, result);\n}\n\n/*!\n    \\brief Performs a variant of Douglas-Peucker polyline simplification (DPn).\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::DouglasPeuckerAlt.\n\n    \\param[in] first    the first coordinate of the first polyline point\n    \\param[in] last     one beyond the last coordinate of the last polyline point\n    \\param[in] count    the maximum number of points of the simplified polyline\n    \\param[in] result   destination of the simplified polyline\n    \\return             one beyond the last coordinate of the simplified polyline\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\nsimplify_douglas_peucker_n(ForwardIterator first, ForwardIterator last, unsigned count, OutputIterator result) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.DouglasPeuckerN(first, last, count, result);\n}\n\n/*!\n    \\brief Computes the squared positional error between a polyline and its simplification.\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::ComputePositionalErrors2.\n\n    \\param[in] original_first   the first coordinate of the first polyline point\n    \\param[in] original_last    one beyond the last coordinate of the last polyline point\n    \\param[in] simplified_first the first coordinate of the first simplified polyline point\n    \\param[in] simplified_last  one beyond the last coordinate of the last simplified polyline point\n    \\param[in] result           destination of the squared positional errors\n    \\param[out] valid           [optional] indicates if the computed positional errors are valid\n    \\return                     one beyond the last computed positional error\n*/\ntemplate <unsigned DIM, class ForwardIterator, class OutputIterator>\nOutputIterator\ncompute_positional_errors2(ForwardIterator original_first,\n                           ForwardIterator original_last,\n                           ForwardIterator simplified_first,\n                           ForwardIterator simplified_last,\n                           OutputIterator result,\n                           bool* valid = 0) {\n  PolylineSimplification<DIM, ForwardIterator, OutputIterator> ps;\n  return ps.ComputePositionalErrors2(original_first, original_last, simplified_first, simplified_last, result, valid);\n}\n\n/*!\n    \\brief Computes statistics for the positional errors between a polyline and its simplification.\n\n    This is a convenience function that provides template type deduction for\n    PolylineSimplification::ComputePositionalErrorStatistics.\n\n    \\param[in] original_first   the first coordinate of the first polyline point\n    \\param[in] original_last    one beyond the last coordinate of the last polyline point\n    \\param[in] simplified_first the first coordinate of the first simplified polyline point\n    \\param[in] simplified_last  one beyond the last coordinate of the last simplified polyline point\n    \\param[out] valid           [optional] indicates if the computed statistics are valid\n    \\return                     the computed statistics\n*/\ntemplate <unsigned DIM, class ForwardIterator>\nmath::Statistics\ncompute_positional_error_statistics(ForwardIterator original_first,\n                                    ForwardIterator original_last,\n                                    ForwardIterator simplified_first,\n                                    ForwardIterator simplified_last,\n                                    bool* valid = 0) {\n  PolylineSimplification<DIM, ForwardIterator, ForwardIterator> ps;\n  return ps.ComputePositionalErrorStatistics(original_first, original_last, simplified_first, simplified_last, valid);\n}\n} // namespace psimpl\n\n#endif // PSIMPL_GENERIC\n",
			"file": "src/psimpl.h",
			"file_size": 73980,
			"file_write_time": 132180889133148608,
			"settings":
			{
				"buffer_size": 72234,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "#include <opencv2/core/core.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n#include <cmath>\n#include \"psimpl.h\"\n#include <iostream>\n#include <type_traits>\n#include <exception>\n#include <string>\n\ntemplate <class T, typename std::enable_if<std::is_integral<T>::value || std::is_floating_point<T>::value, T>::type* = nullptr>\ninline std::string\nto_string(const T& t, size_t n_pad = 3, char ch_pad = ' ') {\n  std::ostringstream oss;\n  oss << t;\n  std::string ret(oss.str());\n\n  if(ret.length() < n_pad)\n    ret.insert(ret.begin(), n_pad - ret.length(), ch_pad);\n  else if(ret.length() > n_pad) {\n    size_t i = ret.find('.');\n\n    if(i != std::string::npos) {\n      ret.resize(std::max(i, n_pad));\n    }\n  }\n  return ret;\n}\n\ntemplate <class T>\ninline std::string\nto_string(const cv::Point_<T>& pt, size_t n_pad = 3, char ch_pad = '0') {\n  std::ostringstream oss;\n  oss << to_string(pt.x) << ',' << to_string(pt.y);\n  return oss.str();\n}\n\ntemplate <class InputIterator>\ninline typename std::iterator_traits<InputIterator>::value_type\nsegment_distance2(InputIterator s1, InputIterator s2, InputIterator p) {\n  typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  return psimpl::math::segment_distance2<2, InputIterator>(s1, s2, p);\n}\n\ntemplate <class ValueT>\ninline ValueT\npoint_distance(const cv::Point_<ValueT>& p1, const cv::Point_<ValueT>& p2) {\n  return std::sqrt(psimpl::math::point_distance2<2>(&p1.x, &p2.x));\n}\n\ntemplate <class ValueT> class Line {\npublic:\n  typedef cv::Point_<ValueT> point_type;\n  typedef Line<ValueT> line_type;\n  typedef ValueT value_type;\n\n  point_type a, b;\n\n  Line(const point_type& p1, const point_type& p2) : a(p1), b(p2) {}\n\n  Line(ValueT x1, ValueT y1, ValueT x2, ValueT y2) : a(x1, y1), b(x2, y2) {}\n\n  ValueT\n  length() const {\n    point_type diff = a - b;\n    return std::sqrt(diff.x * diff.x + diff.y * diff.y);\n  }\n\n  point_type\n  at(double sigma) const {\n    point_type ret;\n    ret.x = (a.x + b.x) / 2;\n    ret.y = (a.y + b.y) / 2;\n    return ret;\n  }\n\n  point_type\n  center() const {\n    return point_type((a.x + b.x) / 2, (a.y + b.y) / 2);\n  }\n  point_type\n  start() const {\n    return a;\n  }\n  point_type\n  end() const {\n    return b;\n  }\n\n  point_type\n  slope() const {\n    point_type diff = b - a;\n    return diff;\n  }\n\n  const point_type&\n  pivot() const {\n    return a;\n  }\n\n  const point_type&\n  to() const {\n    return b;\n  }\n\n  void\n  swap() {\n    point_type temp = a;\n    a = b;\n    b = temp;\n  }\n\n  double\n  angle() const {\n    point_type diff = a - b;\n    return std::atan2(diff.x, diff.y);\n  }\n\n  double\n  distance(const point_type& p) const {\n    return std::sqrt(segment_distance2(&a.x, &b.x, &p.x));\n  }\n  std::pair<ValueT, ValueT>\n  endpoint_distance(const Line<ValueT>& l) const {\n    std::pair<ValueT, ValueT> dist1 = endpoint_distance(l.a), dist2 = endpoint_distance(l.b);\n\n    return std::make_pair(dist1.first < dist1.second ? dist1.first : dist1.second, dist2.first < dist2.second ? dist2.first : dist2.second);\n  }\n\n  std::pair<ValueT, ValueT>\n  endpoint_distance(const cv::Point_<ValueT>& p) const {\n    return std::make_pair<ValueT, ValueT>(point_distance<ValueT>(a, p), point_distance<ValueT>(b, p));\n  }\n\n  template <class OtherT>\n  std::pair<line_type&, line_type&>\n  nearest(const Line<OtherT>& l) const {\n    return std::make_pair<ValueT, ValueT>(distance(l.a), distance(l.b));\n  }\n\n  template <class OtherT>\n  bool\n  operator==(const Line<OtherT>& other) const {\n    return other.a == this->a && other.b == this->b;\n  }\n\n  ValueT\n  min_distance(const Line<ValueT>& l2, size_t* point_index = nullptr) const {\n    std::pair<ValueT, ValueT> dist = endpoint_distance(l2);\n    /* if(intersect(l2))\n       return 0;*/\n    if(point_index)\n      *point_index = dist.first < dist.second ? 0 : 1;\n    return dist.first < dist.second ? dist.first : dist.second;\n  }\n\n  ValueT\n  angle_diff(const Line<ValueT>& l) const {\n    return l.angle() - angle();\n  }\n\n  /**\n   * Calculates intersect of two lines if exists.\n   *\n   * @param line1 First line.\n   * @param line2 Second line.\n   * @param intersect Result intersect.\n   * @return True if there is intersect of two lines, otherwise false.\n   */\n  inline bool\n  intersect(const Line<ValueT>& line2, cv::Point_<ValueT>* pt = nullptr) const {\n    point_type x = line2.pivot() - pivot();\n    point_type d1 = slope();\n    point_type d2 = line2.slope();\n\n    float inter = d1.x * d2.y - d1.y * d2.x;\n\n    if(fabs(inter) < 1e-8) {\n      return false;\n    }\n\n    double t1 = (x.x * d2.y - x.y * d2.x) / inter;\n    if(pt)\n      *pt = pivot() + d1 * t1;\n\n    return true;\n  }\n\n  template <class OtherValueT>\n  bool\n  operator<(const Line<OtherValueT>& l2) const {\n    cv::Point2f a, b;\n    a = center();\n    b = l2.center();\n    return a.y < b.y ? true : a.x < b.x;\n  }\n\n  template <class Char = char>\n  std::basic_string<Char>\n  str(const std::string& comma = \",\", const std::string& sep = \"|\") const {\n    point_type p = pivot(), s = slope();\n\n    std::basic_ostringstream<Char> os;\n    // os << '[';\n    os << to_string(a.x) << comma << to_string(a.y);\n    os << sep << to_string(b.x);\n    os << comma << to_string(b.y);\n    os << '=' << to_string(length());\n    // os << '@' << to_string(floor(angle()*180/ M_PI));\n    // os << ']';\n    return os.str();\n  }\n\n  /*template <class Char, class ValueT>\n  inline std::basic_ostream<Char>&\n  operator<<(std::basic_ostream<Char>& os, const Line<ValueT>& line) {\n    os << line.a.x << ',' << line.a.y;\n    os << \" -> \";\n    os << line.b.x << ',' << line.b.y;\n  }\n  */\n};\n\ntemplate <class T, class Char = char>\ninline std::basic_string<Char>\nto_string(const Line<T>& line) {\n  std::basic_string<Char> ret;\n  ret = line.str(\",\", \"|\");\n\n  return ret;\n}\n\ntemplate <class ValueT, template <typename> typename Container = std::vector, class Char = char>\ninline std::basic_string<Char>\nto_string(const Container<Line<ValueT>>& lines) {\n  typedef typename Container<Line<ValueT>>::const_iterator iterator_type;\n  typedef Line<ValueT> value_type;\n  std::basic_string<Char> ret;\n  iterator_type end = lines.cend();\n  for(iterator_type it = lines.cbegin(); it != end; ++it) {\n    if(ret.length())\n      ret += \" \";\n    ret += to_string<ValueT, Char>(*it);\n  }\n  return ret;\n}\n\ntemplate <class Char, class Value>\ninline std::basic_ostream<Char>&\noperator<<(std::basic_ostream<Char>& os, const std::vector<Line<Value>>& c) {\n  typedef typename std::vector<Line<Value>>::const_iterator iterator_type;\n  iterator_type end = c.cend();\n  int i = 0;\n  for(iterator_type it = c.cbegin(); it != end; ++it) {\n    if(i++ > 0)\n      os << \" \";\n    os << to_string(*it);\n  }\n  return os;\n}\n\ntemplate <class ContainerT>\n\ntypename ContainerT::iterator\nfindNearestLine(const typename ContainerT::value_type& line, ContainerT& lines) {\n  typedef typename ContainerT::iterator iterator_type;\n  typedef typename ContainerT::value_type line_type;\n  typedef typename line_type::value_type value_type;\n  value_type distance = 1e10;\n  iterator_type end = lines.end();\n  iterator_type ret = end;\n\n  for(iterator_type it = lines.begin(); it != end; ++it) {\n    value_type d = (*it).min_distance(line);\n    if(*it == line)\n      continue;\n    if(d < distance) {\n      distance = d;\n      ret = it;\n    }\n  }\n  return ret;\n}\ntemplate <class ContainerT>\ntypename ContainerT::iterator\nfindNearestLine(const typename ContainerT::iterator& line, ContainerT& lines) {\n  typedef typename ContainerT::iterator iterator_type;\n  typedef typename ContainerT::value_type point_type;\n  typedef typename point_type::value_type value_type;\n  value_type distance = 1e10;\n  iterator_type index = lines.end();\n  iterator_type end = lines.end();\n\n  for(iterator_type it = lines.begin(); it != end; ++it) {\n    value_type d = (*it).min_distance(*line);\n    if(std::distance(line, it) == 0)\n      continue;\n    if(d < distance) {\n      distance = d;\n      index = it;\n    }\n  }\n  return index;\n}\n/*\ntemplate <class InputIterator>\nInputIterator\nfindNearestLine(const InputIterator& line, InputIterator from, InputIterator to) {\n  typedef InputIterator iterator_type;\n  typedef typename std::iterator_traits<InputIterator>::value_type point_type;\n  typedef typename point_type::value_type value_type;\n  value_type distance = 1e10;\n  iterator_type index = to;\n\n  for(iterator_type it = from; it != to; ++it) {\n    value_type d = (*it).min_distance(*line);\n    if(std::distance(line, it) == 0)\n      continue;\n    if(d < distance) {\n      distance = d;\n      index = it;\n    }\n  }\n  return index;\n}\n*/\n\ntemplate <class T> class LineEnd {\n  Line<T>* line;\n  size_t point_index;\nx1\nprotected:\n  cv::Point_<T>*\n  ptr() {\n    return line == nullptr ? nullptr : point_index > 0 ? &line->b : &line->a;\n  }\n  const cv::Point_<T>*\n  const_ptr() const {\n    return line == nullptr ? nullptr : point_index > 0 ? &line->b : &line->a;\n  }\n\npublic:\n  LineEnd(Line<T>& l, size_t pt_i) : line(&l), point_index(pt_i) {}\n\n  cv::Point_<T>& point() {return *ptr(); }\n  cv::Point_<T> const& point() const {return *const_ptr(); }\n\n  operator cv::Point_<T>() const { return point(); }\n};",
			"file": "src/line.h",
			"file_size": 9071,
			"file_write_time": 132181094562026765,
			"settings":
			{
				"buffer_size": 9073,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 324 files for \"min_dist\" (regex)\n\n/home/roman/Dokumente/Sources/contours/plot-cv/src/CannyWebcam1.cpp:\n  609      /* if(line == *it)\n  610         continue;*/\n  611:     ret.push_back(it->min_distance(line));\n  612    }\n  613    return ret;\n  ...\n  808            std::copy_if(lines.cbegin(), lines.cend(), std::back_inserter(adjacent), [&](const Line<float>& l2) -> bool {\n  809              size_t point_index;\n  810:             double min_dist = line.min_distance(l2, &point_index);\n  811              bool intersects = line.intersect(l2);\n  812:             return (/*intersects ||*/ min_dist < 20);\n  813            });\n  814  \n  815            distances.clear();\n  816:           std::transform(adjacent.cbegin(), adjacent.cend(), std::back_inserter(distances), [&line](const Line<float>& l2) -> float { return line.min_distance(l2); });\n  817            angleoffs.clear();\n  818            std::transform(adjacent.cbegin(), adjacent.cend(), std::back_inserter(angleoffs), [&line](const Line<float>& l2) -> float { return line.angle_diff(l2); });\n\n/home/roman/Dokumente/Sources/contours/plot-cv/src/line.h:\n  145  \n  146    ValueT\n  147:   min_distance(const Line<ValueT>& l2, size_t* point_index = nullptr) const {\n  148      std::pair<ValueT, ValueT> dist = endpoint_distance(l2);\n  149      /* if(intersect(l2))\n  ...\n  271  \n  272    for(iterator_type it = lines.begin(); it != end; ++it) {\n  273:     value_type d = (*it).min_distance(line);\n  274      if(*it == line)\n  275        continue;\n  ...\n  292  \n  293    for(iterator_type it = lines.begin(); it != end; ++it) {\n  294:     value_type d = (*it).min_distance(*line);\n  295      if(std::distance(line, it) == 0)\n  296        continue;\n  ...\n  313  \n  314    for(iterator_type it = from; it != to; ++it) {\n  315:     value_type d = (*it).min_distance(*line);\n  316      if(std::distance(line, it) == 0)\n  317        continue;\n\n/home/roman/Dokumente/Sources/contours/plot-cv/src/pyrlk_optical_flow.cpp:\n   83        \"{ o output         | pyrlk_output.jpg| specify output save path when input is images }\"\n   84        \"{ points           | 1000            | specify points count [GoodFeatureToTrack] }\"\n   85:       \"{ min_dist         | 0               | specify minimal distance between points [GoodFeatureToTrack] }\"\n   86        \"{ m cpu_mode       | false           | run without OpenCL }\";\n   87  \n   ..\n  101    string outfile = cmd.get<string>(\"output\");\n  102    int points = cmd.get<int>(\"points\");\n  103:   double minDist = cmd.get<double>(\"min_dist\");\n  104    int inputName = cmd.get<int>(\"c\");\n  105  \n\n11 matches across 3 files\n",
			"settings":
			{
				"buffer_size": 2620,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "x /*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                          License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#ifdef __OPENCV_BUILD\n#error this is a compatibility header which should not be used inside the OpenCV library\n#endif\n\n#include \"opencv2/core.hpp\"\n",
			"file": "/usr/include/opencv4/opencv2/core/core.hpp",
			"file_size": 2366,
			"file_write_time": 132135618280000000,
			"settings":
			{
				"buffer_size": 2368,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "",
			"file": "/usr/include/opencv2",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "P/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                          License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#ifndef OPENCV_CORE_TYPES_HPP\n#define OPENCV_CORE_TYPES_HPP\n\n#ifndef __cplusplus\n#  error types.hpp header must be compiled as C++\n#endif\n\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <limits>\n\n#include \"opencv2/core/cvdef.h\"\n#include \"opencv2/core/cvstd.hpp\"\n#include \"opencv2/core/matx.hpp\"\n\nnamespace cv\n{\n\n//! @addtogroup core_basic\n//! @{\n\n//////////////////////////////// Complex //////////////////////////////\n\n/** @brief  A complex number class.\n\n  The template class is similar and compatible with std::complex, however it provides slightly\n  more convenient access to the real and imaginary parts using through the simple field access, as opposite\n  to std::complex::real() and std::complex::imag().\n*/\ntemplate<typename _Tp> class Complex\n{\npublic:\n\n    //! default constructor\n    Complex();\n    Complex( _Tp _re, _Tp _im = 0 );\n\n    //! conversion to another data type\n    template<typename T2> operator Complex<T2>() const;\n    //! conjugation\n    Complex conj() const;\n\n    _Tp re, im; //< the real and the imaginary parts\n};\n\ntypedef Complex<float> Complexf;\ntypedef Complex<double> Complexd;\n\ntemplate<typename _Tp> class DataType< Complex<_Tp> >\n{\npublic:\n    typedef Complex<_Tp> value_type;\n    typedef value_type   work_type;\n    typedef _Tp          channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n    };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Complex<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Complex<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };\n} // namespace\n\n\n//////////////////////////////// Point_ ////////////////////////////////\n\n/** @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\n    pt1 = pt2 + pt3;\n    pt1 = pt2 - pt3;\n    pt1 = pt2 * a;\n    pt1 = a * pt2;\n    pt1 = pt2 / a;\n    pt1 += pt2;\n    pt1 -= pt2;\n    pt1 *= a;\n    pt1 /= a;\n    double value = norm(pt); // L2 norm\n    pt1 == pt2;\n    pt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\n    typedef Point_<int> Point2i;\n    typedef Point2i Point;\n    typedef Point_<float> Point2f;\n    typedef Point_<double> Point2d;\n@endcode\nExample:\n@code\n    Point2f a(0.3f, 0.f), b(0.f, 0.4f);\n    Point pt = (a + b)*10.f;\n    cout << pt.x << \", \" << pt.y << endl;\n@endcode\n*/\ntemplate<typename _Tp> class Point_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Point_();\n    Point_(_Tp _x, _Tp _y);\n    Point_(const Point_& pt);\n    Point_(Point_&& pt) CV_NOEXCEPT;\n    Point_(const Size_<_Tp>& sz);\n    Point_(const Vec<_Tp, 2>& v);\n\n    Point_& operator = (const Point_& pt);\n    Point_& operator = (Point_&& pt) CV_NOEXCEPT;\n    //! conversion to another data type\n    template<typename _Tp2> operator Point_<_Tp2>() const;\n\n    //! conversion to the old-style C structures\n    operator Vec<_Tp, 2>() const;\n\n    //! dot product\n    _Tp dot(const Point_& pt) const;\n    //! dot product computed in double-precision arithmetics\n    double ddot(const Point_& pt) const;\n    //! cross-product\n    double cross(const Point_& pt) const;\n    //! checks whether the point is inside the specified rectangle\n    bool inside(const Rect_<_Tp>& r) const;\n    _Tp x; //!< x coordinate of the point\n    _Tp y; //!< y coordinate of the point\n};\n\ntypedef Point_<int> Point2i;\ntypedef Point_<int64> Point2l;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\ntypedef Point2i Point;\n\ntemplate<typename _Tp> class DataType< Point_<_Tp> >\n{\npublic:\n    typedef Point_<_Tp>                               value_type;\n    typedef Point_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                       channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Point_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Point_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };\n} // namespace\n\n\n//////////////////////////////// Point3_ ////////////////////////////////\n\n/** @brief Template class for 3D points specified by its coordinates `x`, `y` and `z`.\n\nAn instance of the class is interchangeable with the C structure CvPoint2D32f . Similarly to\nPoint_ , the coordinates of 3D points can be converted to another type. The vector arithmetic and\ncomparison operations are also supported.\n\nThe following Point3_\\<\\> aliases are available:\n@code\n    typedef Point3_<int> Point3i;\n    typedef Point3_<float> Point3f;\n    typedef Point3_<double> Point3d;\n@endcode\n@see cv::Point3i, cv::Point3f and cv::Point3d\n*/\ntemplate<typename _Tp> class Point3_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Point3_();\n    Point3_(_Tp _x, _Tp _y, _Tp _z);\n    Point3_(const Point3_& pt);\n    Point3_(Point3_&& pt) CV_NOEXCEPT;\n    explicit Point3_(const Point_<_Tp>& pt);\n    Point3_(const Vec<_Tp, 3>& v);\n\n    Point3_& operator = (const Point3_& pt);\n    Point3_& operator = (Point3_&& pt) CV_NOEXCEPT;\n    //! conversion to another data type\n    template<typename _Tp2> operator Point3_<_Tp2>() const;\n    //! conversion to cv::Vec<>\n    operator Vec<_Tp, 3>() const;\n\n    //! dot product\n    _Tp dot(const Point3_& pt) const;\n    //! dot product computed in double-precision arithmetics\n    double ddot(const Point3_& pt) const;\n    //! cross product of the 2 3D points\n    Point3_ cross(const Point3_& pt) const;\n    _Tp x; //!< x coordinate of the 3D point\n    _Tp y; //!< y coordinate of the 3D point\n    _Tp z; //!< z coordinate of the 3D point\n};\n\ntypedef Point3_<int> Point3i;\ntypedef Point3_<float> Point3f;\ntypedef Point3_<double> Point3d;\n\ntemplate<typename _Tp> class DataType< Point3_<_Tp> >\n{\npublic:\n    typedef Point3_<_Tp>                               value_type;\n    typedef Point3_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                        channel_type;\n\n    enum { generic_type = 0,\n           channels     = 3,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Point3_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Point3_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 3) }; };\n} // namespace\n\n//////////////////////////////// Size_ ////////////////////////////////\n\n/** @brief Template class for specifying the size of an image or rectangle.\n\nThe class includes two members called width and height. The structure can be converted to and from\nthe old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison\noperations as for Point_ is available.\n\nOpenCV defines the following Size_\\<\\> aliases:\n@code\n    typedef Size_<int> Size2i;\n    typedef Size2i Size;\n    typedef Size_<float> Size2f;\n@endcode\n*/\ntemplate<typename _Tp> class Size_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Size_();\n    Size_(_Tp _width, _Tp _height);\n    Size_(const Size_& sz);\n    Size_(Size_&& sz) CV_NOEXCEPT;\n    Size_(const Point_<_Tp>& pt);\n\n    Size_& operator = (const Size_& sz);\n    Size_& operator = (Size_&& sz) CV_NOEXCEPT;\n    //! the area (width*height)\n    _Tp area() const;\n    //! aspect ratio (width/height)\n    double aspectRatio() const;\n    //! true if empty\n    bool empty() const;\n\n    //! conversion of another data type.\n    template<typename _Tp2> operator Size_<_Tp2>() const;\n\n    _Tp width; //!< the width\n    _Tp height; //!< the height\n};\n\ntypedef Size_<int> Size2i;\ntypedef Size_<int64> Size2l;\ntypedef Size_<float> Size2f;\ntypedef Size_<double> Size2d;\ntypedef Size2i Size;\n\ntemplate<typename _Tp> class DataType< Size_<_Tp> >\n{\npublic:\n    typedef Size_<_Tp>                               value_type;\n    typedef Size_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                      channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Size_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Size_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };\n} // namespace\n\n//////////////////////////////// Rect_ ////////////////////////////////\n\n/** @brief Template class for 2D rectangles\n\ndescribed by the following parameters:\n-   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y\n    in OpenCV. Though, in your algorithms you may count x and y from the bottom-left corner.\n-   Rectangle width and height.\n\nOpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the\nright and bottom boundaries are not. For example, the method Rect_::contains returns true if\n\n\\f[x  \\leq pt.x < x+width,\n      y  \\leq pt.y < y+height\\f]\n\nVirtually every loop over an image ROI in OpenCV (where ROI is specified by Rect_\\<int\\> ) is\nimplemented as:\n@code\n    for(int y = roi.y; y < roi.y + roi.height; y++)\n        for(int x = roi.x; x < roi.x + roi.width; x++)\n        {\n            // ...\n        }\n@endcode\nIn addition to the class members, the following operations on rectangles are implemented:\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{point}\\f$ (shifting a rectangle by a certain offset)\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{size}\\f$ (expanding or shrinking a rectangle by a\n    certain amount)\n-   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)\n-   rect = rect1 & rect2 (rectangle intersection)\n-   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )\n-   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)\n-   rect == rect1, rect != rect1 (rectangle comparison)\n\nThis is an example how the partial ordering on rectangles can be established (rect1 \\f$\\subseteq\\f$\nrect2):\n@code\n    template<typename _Tp> inline bool\n    operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)\n    {\n        return (r1 & r2) == r1;\n    }\n@endcode\nFor your convenience, the Rect_\\<\\> alias is available: cv::Rect\n*/\ntemplate<typename _Tp> class Rect_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Rect_();\n    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);\n    Rect_(const Rect_& r);\n    Rect_(Rect_&& r) CV_NOEXCEPT;\n    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);\n    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);\n\n    Rect_& operator = ( const Rect_& r );\n    Rect_& operator = ( Rect_&& r ) CV_NOEXCEPT;\n    //! the top-left corner\n    Point_<_Tp> tl() const;\n    //! the bottom-right corner\n    Point_<_Tp> br() const;\n\n    //! size (width, height) of the rectangle\n    Size_<_Tp> size() const;\n    //! area (width*height) of the rectangle\n    _Tp area() const;\n    //! true if empty\n    bool empty() const;\n\n    //! conversion to another data type\n    template<typename _Tp2> operator Rect_<_Tp2>() const;\n\n    //! checks whether the rectangle contains the point\n    bool contains(const Point_<_Tp>& pt) const;\n\n    _Tp x; //!< x coordinate of the top-left corner\n    _Tp y; //!< y coordinate of the top-left corner\n    _Tp width; //!< width of the rectangle\n    _Tp height; //!< height of the rectangle\n};\n\ntypedef Rect_<int> Rect2i;\ntypedef Rect_<float> Rect2f;\ntypedef Rect_<double> Rect2d;\ntypedef Rect2i Rect;\n\ntemplate<typename _Tp> class DataType< Rect_<_Tp> >\n{\npublic:\n    typedef Rect_<_Tp>                               value_type;\n    typedef Rect_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                      channel_type;\n\n    enum { generic_type = 0,\n           channels     = 4,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Rect_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Rect_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };\n} // namespace\n\n///////////////////////////// RotatedRect /////////////////////////////\n\n/** @brief The class represents rotated (i.e. not up-right) rectangles on a plane.\n\nEach rectangle is specified by the center point (mass center), length of each side (represented by\n#Size2f structure) and the rotation angle in degrees.\n\nThe sample below demonstrates how to use RotatedRect:\n@snippet snippets/core_various.cpp RotatedRect_demo\n![image](pics/rotatedrect.png)\n\n@sa CamShift, fitEllipse, minAreaRect, CvBox2D\n*/\nclass CV_EXPORTS RotatedRect\n{\npublic:\n    //! default constructor\n    RotatedRect();\n    /** full constructor\n    @param center The rectangle mass center.\n    @param size Width and height of the rectangle.\n    @param angle The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc.,\n    the rectangle becomes an up-right rectangle.\n    */\n    RotatedRect(const Point2f& center, const Size2f& size, float angle);\n    /**\n    Any 3 end points of the RotatedRect. They must be given in order (either clockwise or\n    anticlockwise).\n     */\n    RotatedRect(const Point2f& point1, const Point2f& point2, const Point2f& point3);\n\n    /** returns 4 vertices of the rectangle\n    @param pts The points array for storing rectangle vertices. The order is bottomLeft, topLeft, topRight, bottomRight.\n    */\n    void points(Point2f pts[]) const;\n    //! returns the minimal up-right integer rectangle containing the rotated rectangle\n    Rect boundingRect() const;\n    //! returns the minimal (exact) floating point rectangle containing the rotated rectangle, not intended for use with images\n    Rect_<float> boundingRect2f() const;\n    //! returns the rectangle mass center\n    Point2f center;\n    //! returns width and height of the rectangle\n    Size2f size;\n    //! returns the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.\n    float angle;\n};\n\ntemplate<> class DataType< RotatedRect >\n{\npublic:\n    typedef RotatedRect  value_type;\n    typedef value_type   work_type;\n    typedef float        channel_type;\n\n    enum { generic_type = 0,\n           channels     = (int)sizeof(value_type)/sizeof(channel_type), // 5\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<>\nstruct Depth< RotatedRect > { enum { value = Depth<float>::value }; };\ntemplate<>\nstruct Type< RotatedRect > { enum { value = CV_MAKETYPE(Depth<float>::value, (int)sizeof(RotatedRect)/sizeof(float)) }; };\n} // namespace\n\n\n//////////////////////////////// Range /////////////////////////////////\n\n/** @brief Template class specifying a continuous subsequence (slice) of a sequence.\n\nThe class is used to specify a row or a column span in a matrix ( Mat ) and for many other purposes.\nRange(a,b) is basically the same as a:b in Matlab or a..b in Python. As in Python, start is an\ninclusive left boundary of the range and end is an exclusive right boundary of the range. Such a\nhalf-opened interval is usually denoted as \\f$[start,end)\\f$ .\n\nThe static method Range::all() returns a special variable that means \"the whole sequence\" or \"the\nwhole range\", just like \" : \" in Matlab or \" ... \" in Python. All the methods and functions in\nOpenCV that take Range support this special Range::all() value. But, of course, in case of your own\ncustom processing, you will probably have to check and handle it explicitly:\n@code\n    void my_function(..., const Range& r, ....)\n    {\n        if(r == Range::all()) {\n            // process all the data\n        }\n        else {\n            // process [r.start, r.end)\n        }\n    }\n@endcode\n*/\nclass CV_EXPORTS Range\n{\npublic:\n    Range();\n    Range(int _start, int _end);\n    int size() const;\n    bool empty() const;\n    static Range all();\n\n    int start, end;\n};\n\ntemplate<> class DataType<Range>\n{\npublic:\n    typedef Range      value_type;\n    typedef value_type work_type;\n    typedef int        channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<>\nstruct Depth< Range > { enum { value = Depth<int>::value }; };\ntemplate<>\nstruct Type< Range > { enum { value = CV_MAKETYPE(Depth<int>::value, 2) }; };\n} // namespace\n\n\n//////////////////////////////// Scalar_ ///////////////////////////////\n\n/** @brief Template class for a 4-element vector derived from Vec.\n\nBeing derived from Vec\\<_Tp, 4\\> , Scalar\\_ and Scalar can be used just as typical 4-element\nvectors. In addition, they can be converted to/from CvScalar . The type Scalar is widely used in\nOpenCV to pass pixel values.\n*/\ntemplate<typename _Tp> class Scalar_ : public Vec<_Tp, 4>\n{\npublic:\n    //! default constructor\n    Scalar_();\n    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);\n    Scalar_(_Tp v0);\n\n    Scalar_(const Scalar_& s);\n    Scalar_(Scalar_&& s) CV_NOEXCEPT;\n\n    Scalar_& operator=(const Scalar_& s);\n    Scalar_& operator=(Scalar_&& s) CV_NOEXCEPT;\n\n    template<typename _Tp2, int cn>\n    Scalar_(const Vec<_Tp2, cn>& v);\n\n    //! returns a scalar with all elements set to v0\n    static Scalar_<_Tp> all(_Tp v0);\n\n    //! conversion to another data type\n    template<typename T2> operator Scalar_<T2>() const;\n\n    //! per-element product\n    Scalar_<_Tp> mul(const Scalar_<_Tp>& a, double scale=1 ) const;\n\n    //! returns (v0, -v1, -v2, -v3)\n    Scalar_<_Tp> conj() const;\n\n    //! returns true iff v1 == v2 == v3 == 0\n    bool isReal() const;\n};\n\ntypedef Scalar_<double> Scalar;\n\ntemplate<typename _Tp> class DataType< Scalar_<_Tp> >\n{\npublic:\n    typedef Scalar_<_Tp>                               value_type;\n    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                        channel_type;\n\n    enum { generic_type = 0,\n           channels     = 4,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Scalar_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Scalar_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };\n} // namespace\n\n\n/////////////////////////////// KeyPoint ////////////////////////////////\n\n/** @brief Data structure for salient point detectors.\n\nThe class instance stores a keypoint, i.e. a point feature found by one of many available keypoint\ndetectors, such as Harris corner detector, #FAST, %StarDetector, %SURF, %SIFT etc.\n\nThe keypoint is characterized by the 2D position, scale (proportional to the diameter of the\nneighborhood that needs to be taken into account), orientation and some other parameters. The\nkeypoint neighborhood is then analyzed by another algorithm that builds a descriptor (usually\nrepresented as a feature vector). The keypoints representing the same object in different images\ncan then be matched using %KDTree or another method.\n*/\nclass CV_EXPORTS_W_SIMPLE KeyPoint\n{\npublic:\n    //! the default constructor\n    CV_WRAP KeyPoint();\n    /**\n    @param _pt x & y coordinates of the keypoint\n    @param _size keypoint diameter\n    @param _angle keypoint orientation\n    @param _response keypoint detector response on the keypoint (that is, strength of the keypoint)\n    @param _octave pyramid octave in which the keypoint has been detected\n    @param _class_id object id\n     */\n    KeyPoint(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);\n    /**\n    @param x x-coordinate of the keypoint\n    @param y y-coordinate of the keypoint\n    @param _size keypoint diameter\n    @param _angle keypoint orientation\n    @param _response keypoint detector response on the keypoint (that is, strength of the keypoint)\n    @param _octave pyramid octave in which the keypoint has been detected\n    @param _class_id object id\n     */\n    CV_WRAP KeyPoint(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);\n\n    size_t hash() const;\n\n    /**\n    This method converts vector of keypoints to vector of points or the reverse, where each keypoint is\n    assigned the same size and the same orientation.\n\n    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n    @param points2f Array of (x,y) coordinates of each keypoint\n    @param keypointIndexes Array of indexes of keypoints to be converted to points. (Acts like a mask to\n    convert only specified keypoints)\n    */\n    CV_WRAP static void convert(const std::vector<KeyPoint>& keypoints,\n                                CV_OUT std::vector<Point2f>& points2f,\n                                const std::vector<int>& keypointIndexes=std::vector<int>());\n    /** @overload\n    @param points2f Array of (x,y) coordinates of each keypoint\n    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n    @param size keypoint diameter\n    @param response keypoint detector response on the keypoint (that is, strength of the keypoint)\n    @param octave pyramid octave in which the keypoint has been detected\n    @param class_id object id\n    */\n    CV_WRAP static void convert(const std::vector<Point2f>& points2f,\n                                CV_OUT std::vector<KeyPoint>& keypoints,\n                                float size=1, float response=1, int octave=0, int class_id=-1);\n\n    /**\n    This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint\n    regions' intersection and area of keypoint regions' union (considering keypoint region as circle).\n    If they don't overlap, we get zero. If they coincide at same location with same size, we get 1.\n    @param kp1 First keypoint\n    @param kp2 Second keypoint\n    */\n    CV_WRAP static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);\n\n    CV_PROP_RW Point2f pt; //!< coordinates of the keypoints\n    CV_PROP_RW float size; //!< diameter of the meaningful keypoint neighborhood\n    CV_PROP_RW float angle; //!< computed orientation of the keypoint (-1 if not applicable);\n                            //!< it's in [0,360) degrees and measured relative to\n                            //!< image coordinate system, ie in clockwise.\n    CV_PROP_RW float response; //!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling\n    CV_PROP_RW int octave; //!< octave (pyramid layer) from which the keypoint has been extracted\n    CV_PROP_RW int class_id; //!< object class (if the keypoints need to be clustered by an object they belong to)\n};\n\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\ntemplate<> class DataType<KeyPoint>\n{\npublic:\n    typedef KeyPoint      value_type;\n    typedef float         work_type;\n    typedef float         channel_type;\n\n    enum { generic_type = 0,\n           depth        = DataType<channel_type>::depth,\n           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 7\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),\n           type         = CV_MAKETYPE(depth, channels)\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n#endif\n\n\n//////////////////////////////// DMatch /////////////////////////////////\n\n/** @brief Class for matching keypoint descriptors\n\nquery descriptor index, train descriptor index, train image index, and distance between\ndescriptors.\n*/\nclass CV_EXPORTS_W_SIMPLE DMatch\n{\npublic:\n    CV_WRAP DMatch();\n    CV_WRAP DMatch(int _queryIdx, int _trainIdx, float _distance);\n    CV_WRAP DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance);\n\n    CV_PROP_RW int queryIdx; //!< query descriptor index\n    CV_PROP_RW int trainIdx; //!< train descriptor index\n    CV_PROP_RW int imgIdx;   //!< train image index\n\n    CV_PROP_RW float distance;\n\n    // less is better\n    bool operator<(const DMatch &m) const;\n};\n\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\ntemplate<> class DataType<DMatch>\n{\npublic:\n    typedef DMatch      value_type;\n    typedef int         work_type;\n    typedef int         channel_type;\n\n    enum { generic_type = 0,\n           depth        = DataType<channel_type>::depth,\n           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 4\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),\n           type         = CV_MAKETYPE(depth, channels)\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n#endif\n\n\n///////////////////////////// TermCriteria //////////////////////////////\n\n/** @brief The class defining termination criteria for iterative algorithms.\n\nYou can initialize it by default constructor and then override any parameters, or the structure may\nbe fully initialized using the advanced variant of the constructor.\n*/\nclass CV_EXPORTS TermCriteria\n{\npublic:\n    /**\n      Criteria type, can be one of: COUNT, EPS or COUNT + EPS\n    */\n    enum Type\n    {\n        COUNT=1, //!< the maximum number of iterations or elements to compute\n        MAX_ITER=COUNT, //!< ditto\n        EPS=2 //!< the desired accuracy or change in parameters at which the iterative algorithm stops\n    };\n\n    //! default constructor\n    TermCriteria();\n    /**\n    @param type The type of termination criteria, one of TermCriteria::Type\n    @param maxCount The maximum number of iterations or elements to compute.\n    @param epsilon The desired accuracy or change in parameters at which the iterative algorithm stops.\n    */\n    TermCriteria(int type, int maxCount, double epsilon);\n\n    inline bool isValid() const\n    {\n        const bool isCount = (type & COUNT) && maxCount > 0;\n        const bool isEps = (type & EPS) && !cvIsNaN(epsilon);\n        return isCount || isEps;\n    }\n\n    int type; //!< the type of termination criteria: COUNT, EPS or COUNT + EPS\n    int maxCount; //!< the maximum number of iterations/elements\n    double epsilon; //!< the desired accuracy\n};\n\n\n//! @} core_basic\n\n///////////////////////// raster image moments //////////////////////////\n\n//! @addtogroup imgproc_shape\n//! @{\n\n/** @brief struct returned by cv::moments\n\nThe spatial moments \\f$\\texttt{Moments::m}_{ji}\\f$ are computed as:\n\n\\f[\\texttt{m} _{ji}= \\sum _{x,y}  \\left ( \\texttt{array} (x,y)  \\cdot x^j  \\cdot y^i \\right )\\f]\n\nThe central moments \\f$\\texttt{Moments::mu}_{ji}\\f$ are computed as:\n\n\\f[\\texttt{mu} _{ji}= \\sum _{x,y}  \\left ( \\texttt{array} (x,y)  \\cdot (x -  \\bar{x} )^j  \\cdot (y -  \\bar{y} )^i \\right )\\f]\n\nwhere \\f$(\\bar{x}, \\bar{y})\\f$ is the mass center:\n\n\\f[\\bar{x} = \\frac{\\texttt{m}_{10}}{\\texttt{m}_{00}} , \\; \\bar{y} = \\frac{\\texttt{m}_{01}}{\\texttt{m}_{00}}\\f]\n\nThe normalized central moments \\f$\\texttt{Moments::nu}_{ij}\\f$ are computed as:\n\n\\f[\\texttt{nu} _{ji}= \\frac{\\texttt{mu}_{ji}}{\\texttt{m}_{00}^{(i+j)/2+1}} .\\f]\n\n@note\n\\f$\\texttt{mu}_{00}=\\texttt{m}_{00}\\f$, \\f$\\texttt{nu}_{00}=1\\f$\n\\f$\\texttt{nu}_{10}=\\texttt{mu}_{10}=\\texttt{mu}_{01}=\\texttt{mu}_{10}=0\\f$ , hence the values are not\nstored.\n\nThe moments of a contour are defined in the same way but computed using the Green's formula (see\n<http://en.wikipedia.org/wiki/Green_theorem>). So, due to a limited raster resolution, the moments\ncomputed for a contour are slightly different from the moments computed for the same rasterized\ncontour.\n\n@note\nSince the contour moments are computed using Green formula, you may get seemingly odd results for\ncontours with self-intersections, e.g. a zero area (m00) for butterfly-shaped contours.\n */\nclass CV_EXPORTS_W_MAP Moments\n{\npublic:\n    //! the default constructor\n    Moments();\n    //! the full constructor\n    Moments(double m00, double m10, double m01, double m20, double m11,\n            double m02, double m30, double m21, double m12, double m03 );\n    ////! the conversion from CvMoments\n    //Moments( const CvMoments& moments );\n    ////! the conversion to CvMoments\n    //operator CvMoments() const;\n\n    //! @name spatial moments\n    //! @{\n    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;\n    //! @}\n\n    //! @name central moments\n    //! @{\n    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;\n    //! @}\n\n    //! @name central normalized moments\n    //! @{\n    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;\n    //! @}\n};\n\ntemplate<> class DataType<Moments>\n{\npublic:\n    typedef Moments     value_type;\n    typedef double      work_type;\n    typedef double      channel_type;\n\n    enum { generic_type = 0,\n           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 24\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<>\nstruct Depth< Moments > { enum { value = Depth<double>::value }; };\ntemplate<>\nstruct Type< Moments > { enum { value = CV_MAKETYPE(Depth<double>::value, (int)(sizeof(Moments)/sizeof(double))) }; };\n} // namespace\n\n//! @} imgproc_shape\n\n//! @cond IGNORED\n\n/////////////////////////////////////////////////////////////////////////\n///////////////////////////// Implementation ////////////////////////////\n/////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////// Complex ////////////////////////////////\n\ntemplate<typename _Tp> inline\nComplex<_Tp>::Complex()\n    : re(0), im(0) {}\n\ntemplate<typename _Tp> inline\nComplex<_Tp>::Complex( _Tp _re, _Tp _im )\n    : re(_re), im(_im) {}\n\ntemplate<typename _Tp> template<typename T2> inline\nComplex<_Tp>::operator Complex<T2>() const\n{\n    return Complex<T2>(saturate_cast<T2>(re), saturate_cast<T2>(im));\n}\n\ntemplate<typename _Tp> inline\nComplex<_Tp> Complex<_Tp>::conj() const\n{\n    return Complex<_Tp>(re, -im);\n}\n\n\ntemplate<typename _Tp> static inline\nbool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return a.re == b.re && a.im == b.im;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return a.re != b.re || a.im != b.im;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return Complex<_Tp>( a.re + b.re, a.im + b.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    a.re += b.re; a.im += b.im;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return Complex<_Tp>( a.re - b.re, a.im - b.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    a.re -= b.re; a.im -= b.im;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (const Complex<_Tp>& a)\n{\n    return Complex<_Tp>(-a.re, -a.im);\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return Complex<_Tp>( a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)\n{\n    return Complex<_Tp>( a.re*b, a.im*b );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>( a.re*b, a.im*b );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)\n{\n    return Complex<_Tp>( a.re + b, a.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)\n{ return Complex<_Tp>( a.re - b, a.im ); }\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>( a.re + b, a.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>( b - a.re, -a.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)\n{\n    a.re += b; return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)\n{\n    a.re -= b; return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)\n{\n    a.re *= b; a.im *= b; return a;\n}\n\ntemplate<typename _Tp> static inline\ndouble abs(const Complex<_Tp>& a)\n{\n    return std::sqrt( (double)a.re*a.re + (double)a.im*a.im);\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator / (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    double t = 1./((double)b.re*b.re + (double)b.im*b.im);\n    return Complex<_Tp>( (_Tp)((a.re*b.re + a.im*b.im)*t),\n                        (_Tp)((-a.re*b.im + a.im*b.re)*t) );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator /= (Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    a = a / b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator / (const Complex<_Tp>& a, _Tp b)\n{\n    _Tp t = (_Tp)1/b;\n    return Complex<_Tp>( a.re*t, a.im*t );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator / (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>(b)/a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator /= (const Complex<_Tp>& a, _Tp b)\n{\n    _Tp t = (_Tp)1/b;\n    a.re *= t; a.im *= t; return a;\n}\n\n\n\n//////////////////////////////// 2D Point ///////////////////////////////\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_()\n    : x(0), y(0) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(_Tp _x, _Tp _y)\n    : x(_x), y(_y) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(const Point_& pt)\n    : x(pt.x), y(pt.y) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(Point_&& pt) CV_NOEXCEPT\n    : x(std::move(pt.x)), y(std::move(pt.y)) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(const Size_<_Tp>& sz)\n    : x(sz.width), y(sz.height) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(const Vec<_Tp,2>& v)\n    : x(v[0]), y(v[1]) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)\n{\n    x = pt.x; y = pt.y;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>& Point_<_Tp>::operator = (Point_&& pt) CV_NOEXCEPT\n{\n    x = std::move(pt.x); y = std::move(pt.y);\n    return *this;\n}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nPoint_<_Tp>::operator Point_<_Tp2>() const\n{\n    return Point_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y));\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::operator Vec<_Tp, 2>() const\n{\n    return Vec<_Tp, 2>(x, y);\n}\n\ntemplate<typename _Tp> inline\n_Tp Point_<_Tp>::dot(const Point_& pt) const\n{\n    return saturate_cast<_Tp>(x*pt.x + y*pt.y);\n}\n\ntemplate<typename _Tp> inline\ndouble Point_<_Tp>::ddot(const Point_& pt) const\n{\n    return (double)x*pt.x + (double)y*pt.y;\n}\n\ntemplate<typename _Tp> inline\ndouble Point_<_Tp>::cross(const Point_& pt) const\n{\n    return (double)x*pt.y - (double)y*pt.x;\n}\n\ntemplate<typename _Tp> inline bool\nPoint_<_Tp>::inside( const Rect_<_Tp>& r ) const\n{\n    return r.contains(*this);\n}\n\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator += (Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    a.x += b.x;\n    a.y += b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator *= (Point_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator *= (Point_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator *= (Point_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator /= (Point_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator /= (Point_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator /= (Point_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\ndouble norm(const Point_<_Tp>& pt)\n{\n    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y);\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return a.x == b.x && a.y == b.y;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return a.x != b.x || a.y != b.y;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator - (const Point_<_Tp>& a)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Point_<_Tp>& a, int b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (int a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Point_<_Tp>& a, float b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (float a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Point_<_Tp>& a, double b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (double a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)\n{\n    Matx<_Tp, 2, 1> tmp = a * Vec<_Tp,2>(b.x, b.y);\n    return Point_<_Tp>(tmp.val[0], tmp.val[1]);\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)\n{\n    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, 1);\n    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator / (const Point_<_Tp>& a, int b)\n{\n    Point_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator / (const Point_<_Tp>& a, float b)\n{\n    Point_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator / (const Point_<_Tp>& a, double b)\n{\n    Point_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\n\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int>& pt);\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int64>& pt);\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<float>& pt);\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<double>& pt);\n\ntemplate<> inline int normL2Sqr<int>(const Point_<int>& pt) { return pt.dot(pt); }\ntemplate<> inline int64 normL2Sqr<int64>(const Point_<int64>& pt) { return pt.dot(pt); }\ntemplate<> inline float normL2Sqr<float>(const Point_<float>& pt) { return pt.dot(pt); }\ntemplate<> inline double normL2Sqr<double>(const Point_<int>& pt) { return pt.dot(pt); }\n\ntemplate<> inline double normL2Sqr<double>(const Point_<float>& pt) { return pt.ddot(pt); }\ntemplate<> inline double normL2Sqr<double>(const Point_<double>& pt) { return pt.ddot(pt); }\n\n\n\n//////////////////////////////// 3D Point ///////////////////////////////\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_()\n    : x(0), y(0), z(0) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z)\n    : x(_x), y(_y), z(_z) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(const Point3_& pt)\n    : x(pt.x), y(pt.y), z(pt.z) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(Point3_&& pt) CV_NOEXCEPT\n    : x(std::move(pt.x)), y(std::move(pt.y)), z(std::move(pt.z)) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(const Point_<_Tp>& pt)\n    : x(pt.x), y(pt.y), z(_Tp()) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(const Vec<_Tp, 3>& v)\n    : x(v[0]), y(v[1]), z(v[2]) {}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nPoint3_<_Tp>::operator Point3_<_Tp2>() const\n{\n    return Point3_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(z));\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::operator Vec<_Tp, 3>() const\n{\n    return Vec<_Tp, 3>(x, y, z);\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)\n{\n    x = pt.x; y = pt.y; z = pt.z;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>& Point3_<_Tp>::operator = (Point3_&& pt) CV_NOEXCEPT\n{\n    x = std::move(pt.x); y = std::move(pt.y); z = std::move(pt.z);\n    return *this;\n}\n\ntemplate<typename _Tp> inline\n_Tp Point3_<_Tp>::dot(const Point3_& pt) const\n{\n    return saturate_cast<_Tp>(x*pt.x + y*pt.y + z*pt.z);\n}\n\ntemplate<typename _Tp> inline\ndouble Point3_<_Tp>::ddot(const Point3_& pt) const\n{\n    return (double)x*pt.x + (double)y*pt.y + (double)z*pt.z;\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const\n{\n    return Point3_<_Tp>(y*pt.z - z*pt.y, z*pt.x - x*pt.z, x*pt.y - y*pt.x);\n}\n\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    a.x += b.x;\n    a.y += b.y;\n    a.z += b.z;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    a.z -= b.z;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator *= (Point3_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    a.z = saturate_cast<_Tp>(a.z * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator *= (Point3_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    a.z = saturate_cast<_Tp>(a.z * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator *= (Point3_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    a.z = saturate_cast<_Tp>(a.z * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator /= (Point3_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    a.z = saturate_cast<_Tp>(a.z / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator /= (Point3_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    a.z = saturate_cast<_Tp>(a.z / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator /= (Point3_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    a.z = saturate_cast<_Tp>(a.z / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\ndouble norm(const Point3_<_Tp>& pt)\n{\n    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y + (double)pt.z*pt.z);\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return a.x == b.x && a.y == b.y && a.z == b.z;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return a.x != b.x || a.y != b.y || a.z != b.z;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y), saturate_cast<_Tp>(a.z + b.z));\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y), saturate_cast<_Tp>(a.z - b.z));\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator - (const Point3_<_Tp>& a)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y), saturate_cast<_Tp>(-a.z) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Point3_<_Tp>& a, int b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b), saturate_cast<_Tp>(a.z*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (int a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Point3_<_Tp>& a, float b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (float a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Point3_<_Tp>& a, double b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (double a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)\n{\n    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, b.z);\n    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);\n}\n\ntemplate<typename _Tp> static inline\nMatx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)\n{\n    return a * Matx<_Tp, 4, 1>(b.x, b.y, b.z, 1);\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator / (const Point3_<_Tp>& a, int b)\n{\n    Point3_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator / (const Point3_<_Tp>& a, float b)\n{\n    Point3_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator / (const Point3_<_Tp>& a, double b)\n{\n    Point3_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\n\n\n////////////////////////////////// Size /////////////////////////////////\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_()\n    : width(0), height(0) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(_Tp _width, _Tp _height)\n    : width(_width), height(_height) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(const Size_& sz)\n    : width(sz.width), height(sz.height) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(Size_&& sz) CV_NOEXCEPT\n    : width(std::move(sz.width)), height(std::move(sz.height)) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(const Point_<_Tp>& pt)\n    : width(pt.x), height(pt.y) {}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nSize_<_Tp>::operator Size_<_Tp2>() const\n{\n    return Size_<_Tp2>(saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));\n}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)\n{\n    width = sz.width; height = sz.height;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>& Size_<_Tp>::operator = (Size_<_Tp>&& sz) CV_NOEXCEPT\n{\n    width = std::move(sz.width); height = std::move(sz.height);\n    return *this;\n}\n\ntemplate<typename _Tp> inline\n_Tp Size_<_Tp>::area() const\n{\n    const _Tp result = width * height;\n    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer\n        || width == 0 || result / width == height); // make sure the result fits in the return value\n    return result;\n}\n\ntemplate<typename _Tp> inline\ndouble Size_<_Tp>::aspectRatio() const\n{\n    return width / static_cast<double>(height);\n}\n\ntemplate<typename _Tp> inline\nbool Size_<_Tp>::empty() const\n{\n    return width <= 0 || height <= 0;\n}\n\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator *= (Size_<_Tp>& a, _Tp b)\n{\n    a.width *= b;\n    a.height *= b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)\n{\n    Size_<_Tp> tmp(a);\n    tmp *= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator /= (Size_<_Tp>& a, _Tp b)\n{\n    a.width /= b;\n    a.height /= b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator / (const Size_<_Tp>& a, _Tp b)\n{\n    Size_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    a.width += b.width;\n    a.height += b.height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    Size_<_Tp> tmp(a);\n    tmp += b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    a.width -= b.width;\n    a.height -= b.height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    Size_<_Tp> tmp(a);\n    tmp -= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    return a.width == b.width && a.height == b.height;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    return !(a == b);\n}\n\n\n\n////////////////////////////////// Rect /////////////////////////////////\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_()\n    : x(0), y(0), width(0), height(0) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height)\n    : x(_x), y(_y), width(_width), height(_height) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(const Rect_<_Tp>& r)\n    : x(r.x), y(r.y), width(r.width), height(r.height) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(Rect_<_Tp>&& r) CV_NOEXCEPT\n    : x(std::move(r.x)), y(std::move(r.y)), width(std::move(r.width)), height(std::move(r.height)) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz)\n    : x(org.x), y(org.y), width(sz.width), height(sz.height) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)\n{\n    x = std::min(pt1.x, pt2.x);\n    y = std::min(pt1.y, pt2.y);\n    width = std::max(pt1.x, pt2.x) - x;\n    height = std::max(pt1.y, pt2.y) - y;\n}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )\n{\n    x = r.x;\n    y = r.y;\n    width = r.width;\n    height = r.height;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>& Rect_<_Tp>::operator = ( Rect_<_Tp>&& r ) CV_NOEXCEPT\n{\n    x = std::move(r.x);\n    y = std::move(r.y);\n    width = std::move(r.width);\n    height = std::move(r.height);\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp> Rect_<_Tp>::tl() const\n{\n    return Point_<_Tp>(x,y);\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp> Rect_<_Tp>::br() const\n{\n    return Point_<_Tp>(x + width, y + height);\n}\n\ntemplate<typename _Tp> inline\nSize_<_Tp> Rect_<_Tp>::size() const\n{\n    return Size_<_Tp>(width, height);\n}\n\ntemplate<typename _Tp> inline\n_Tp Rect_<_Tp>::area() const\n{\n    const _Tp result = width * height;\n    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer\n        || width == 0 || result / width == height); // make sure the result fits in the return value\n    return result;\n}\n\ntemplate<typename _Tp> inline\nbool Rect_<_Tp>::empty() const\n{\n    return width <= 0 || height <= 0;\n}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nRect_<_Tp>::operator Rect_<_Tp2>() const\n{\n    return Rect_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));\n}\n\ntemplate<typename _Tp> inline\nbool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const\n{\n    return x <= pt.x && pt.x < x + width && y <= pt.y && pt.y < y + height;\n}\n\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )\n{\n    a.x += b.x;\n    a.y += b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )\n{\n    a.width += b.width;\n    a.height += b.height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )\n{\n    const _Tp width = a.width - b.width;\n    const _Tp height = a.height - b.height;\n    CV_DbgAssert(width >= 0 && height >= 0);\n    a.width = width;\n    a.height = height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )\n{\n    _Tp x1 = std::max(a.x, b.x);\n    _Tp y1 = std::max(a.y, b.y);\n    a.width = std::min(a.x + a.width, b.x + b.width) - x1;\n    a.height = std::min(a.y + a.height, b.y + b.height) - y1;\n    a.x = x1;\n    a.y = y1;\n    if( a.width <= 0 || a.height <= 0 )\n        a = Rect();\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )\n{\n    if (a.empty()) {\n        a = b;\n    }\n    else if (!b.empty()) {\n        _Tp x1 = std::min(a.x, b.x);\n        _Tp y1 = std::min(a.y, b.y);\n        a.width = std::max(a.x + a.width, b.x + b.width) - x1;\n        a.height = std::max(a.y + a.height, b.y + b.height) - y1;\n        a.x = x1;\n        a.y = y1;\n    }\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    return a.x != b.x || a.y != b.y || a.width != b.width || a.height != b.height;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Rect_<_Tp>( a.x + b.x, a.y + b.y, a.width, a.height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Rect_<_Tp>( a.x - b.x, a.y - b.y, a.width, a.height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)\n{\n    return Rect_<_Tp>( a.x, a.y, a.width + b.width, a.height + b.height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator - (const Rect_<_Tp>& a, const Size_<_Tp>& b)\n{\n    const _Tp width = a.width - b.width;\n    const _Tp height = a.height - b.height;\n    CV_DbgAssert(width >= 0 && height >= 0);\n    return Rect_<_Tp>( a.x, a.y, width, height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    Rect_<_Tp> c = a;\n    return c &= b;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    Rect_<_Tp> c = a;\n    return c |= b;\n}\n\n/**\n * @brief measure dissimilarity between two sample sets\n *\n * computes the complement of the Jaccard Index as described in <https://en.wikipedia.org/wiki/Jaccard_index>.\n * For rectangles this reduces to computing the intersection over the union.\n */\ntemplate<typename _Tp> static inline\ndouble jaccardDistance(const Rect_<_Tp>& a, const Rect_<_Tp>& b) {\n    _Tp Aa = a.area();\n    _Tp Ab = b.area();\n\n    if ((Aa + Ab) <= std::numeric_limits<_Tp>::epsilon()) {\n        // jaccard_index = 1 -> distance = 0\n        return 0.0;\n    }\n\n    double Aab = (a & b).area();\n    // distance = 1 - jaccard_index\n    return 1.0 - Aab / (Aa + Ab - Aab);\n}\n\n////////////////////////////// RotatedRect //////////////////////////////\n\ninline\nRotatedRect::RotatedRect()\n    : center(), size(), angle(0) {}\n\ninline\nRotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)\n    : center(_center), size(_size), angle(_angle) {}\n\n///////////////////////////////// Range /////////////////////////////////\n\ninline\nRange::Range()\n    : start(0), end(0) {}\n\ninline\nRange::Range(int _start, int _end)\n    : start(_start), end(_end) {}\n\ninline\nint Range::size() const\n{\n    return end - start;\n}\n\ninline\nbool Range::empty() const\n{\n    return start == end;\n}\n\ninline\nRange Range::all()\n{\n    return Range(INT_MIN, INT_MAX);\n}\n\n\nstatic inline\nbool operator == (const Range& r1, const Range& r2)\n{\n    return r1.start == r2.start && r1.end == r2.end;\n}\n\nstatic inline\nbool operator != (const Range& r1, const Range& r2)\n{\n    return !(r1 == r2);\n}\n\nstatic inline\nbool operator !(const Range& r)\n{\n    return r.start == r.end;\n}\n\nstatic inline\nRange operator & (const Range& r1, const Range& r2)\n{\n    Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end));\n    r.end = std::max(r.end, r.start);\n    return r;\n}\n\nstatic inline\nRange& operator &= (Range& r1, const Range& r2)\n{\n    r1 = r1 & r2;\n    return r1;\n}\n\nstatic inline\nRange operator + (const Range& r1, int delta)\n{\n    return Range(r1.start + delta, r1.end + delta);\n}\n\nstatic inline\nRange operator + (int delta, const Range& r1)\n{\n    return Range(r1.start + delta, r1.end + delta);\n}\n\nstatic inline\nRange operator - (const Range& r1, int delta)\n{\n    return r1 + (-delta);\n}\n\n\n\n///////////////////////////////// Scalar ////////////////////////////////\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_()\n{\n    this->val[0] = this->val[1] = this->val[2] = this->val[3] = 0;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)\n{\n    this->val[0] = v0;\n    this->val[1] = v1;\n    this->val[2] = v2;\n    this->val[3] = v3;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(const Scalar_<_Tp>& s) : Vec<_Tp, 4>(s) {\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(Scalar_<_Tp>&& s) CV_NOEXCEPT {\n    this->val[0] = std::move(s.val[0]);\n    this->val[1] = std::move(s.val[1]);\n    this->val[2] = std::move(s.val[2]);\n    this->val[3] = std::move(s.val[3]);\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>& Scalar_<_Tp>::operator=(const Scalar_<_Tp>& s) {\n    this->val[0] = s.val[0];\n    this->val[1] = s.val[1];\n    this->val[2] = s.val[2];\n    this->val[3] = s.val[3];\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>& Scalar_<_Tp>::operator=(Scalar_<_Tp>&& s) CV_NOEXCEPT {\n    this->val[0] = std::move(s.val[0]);\n    this->val[1] = std::move(s.val[1]);\n    this->val[2] = std::move(s.val[2]);\n    this->val[3] = std::move(s.val[3]);\n    return *this;\n}\n\ntemplate<typename _Tp> template<typename _Tp2, int cn> inline\nScalar_<_Tp>::Scalar_(const Vec<_Tp2, cn>& v)\n{\n    int i;\n    for( i = 0; i < (cn < 4 ? cn : 4); i++ )\n        this->val[i] = cv::saturate_cast<_Tp>(v.val[i]);\n    for( ; i < 4; i++ )\n        this->val[i] = 0;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(_Tp v0)\n{\n    this->val[0] = v0;\n    this->val[1] = this->val[2] = this->val[3] = 0;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)\n{\n    return Scalar_<_Tp>(v0, v0, v0, v0);\n}\n\n\ntemplate<typename _Tp> inline\nScalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& a, double scale ) const\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(this->val[0] * a.val[0] * scale),\n                        saturate_cast<_Tp>(this->val[1] * a.val[1] * scale),\n                        saturate_cast<_Tp>(this->val[2] * a.val[2] * scale),\n                        saturate_cast<_Tp>(this->val[3] * a.val[3] * scale));\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp> Scalar_<_Tp>::conj() const\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>( this->val[0]),\n                        saturate_cast<_Tp>(-this->val[1]),\n                        saturate_cast<_Tp>(-this->val[2]),\n                        saturate_cast<_Tp>(-this->val[3]));\n}\n\ntemplate<typename _Tp> inline\nbool Scalar_<_Tp>::isReal() const\n{\n    return this->val[1] == 0 && this->val[2] == 0 && this->val[3] == 0;\n}\n\n\ntemplate<typename _Tp> template<typename T2> inline\nScalar_<_Tp>::operator Scalar_<T2>() const\n{\n    return Scalar_<T2>(saturate_cast<T2>(this->val[0]),\n                       saturate_cast<T2>(this->val[1]),\n                       saturate_cast<T2>(this->val[2]),\n                       saturate_cast<T2>(this->val[3]));\n}\n\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a.val[0] += b.val[0];\n    a.val[1] += b.val[1];\n    a.val[2] += b.val[2];\n    a.val[3] += b.val[3];\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a.val[0] -= b.val[0];\n    a.val[1] -= b.val[1];\n    a.val[2] -= b.val[2];\n    a.val[3] -= b.val[3];\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )\n{\n    a.val[0] *= v;\n    a.val[1] *= v;\n    a.val[2] *= v;\n    a.val[3] *= v;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nbool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )\n{\n    return a.val[0] == b.val[0] && a.val[1] == b.val[1] &&\n           a.val[2] == b.val[2] && a.val[3] == b.val[3];\n}\n\ntemplate<typename _Tp> static inline\nbool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )\n{\n    return a.val[0] != b.val[0] || a.val[1] != b.val[1] ||\n           a.val[2] != b.val[2] || a.val[3] != b.val[3];\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return Scalar_<_Tp>(a.val[0] + b.val[0],\n                        a.val[1] + b.val[1],\n                        a.val[2] + b.val[2],\n                        a.val[3] + b.val[3]);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] - b.val[0]),\n                        saturate_cast<_Tp>(a.val[1] - b.val[1]),\n                        saturate_cast<_Tp>(a.val[2] - b.val[2]),\n                        saturate_cast<_Tp>(a.val[3] - b.val[3]));\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)\n{\n    return Scalar_<_Tp>(a.val[0] * alpha,\n                        a.val[1] * alpha,\n                        a.val[2] * alpha,\n                        a.val[3] * alpha);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)\n{\n    return a*alpha;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator - (const Scalar_<_Tp>& a)\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(-a.val[0]),\n                        saturate_cast<_Tp>(-a.val[1]),\n                        saturate_cast<_Tp>(-a.val[2]),\n                        saturate_cast<_Tp>(-a.val[3]));\n}\n\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3]),\n                        saturate_cast<_Tp>(a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2]),\n                        saturate_cast<_Tp>(a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1]),\n                        saturate_cast<_Tp>(a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]));\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a = a * b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator / (const Scalar_<_Tp>& a, _Tp alpha)\n{\n    return Scalar_<_Tp>(a.val[0] / alpha,\n                        a.val[1] / alpha,\n                        a.val[2] / alpha,\n                        a.val[3] / alpha);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<float> operator / (const Scalar_<float>& a, float alpha)\n{\n    float s = 1 / alpha;\n    return Scalar_<float>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<double> operator / (const Scalar_<double>& a, double alpha)\n{\n    double s = 1 / alpha;\n    return Scalar_<double>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator /= (Scalar_<_Tp>& a, _Tp alpha)\n{\n    a = a / alpha;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator / (_Tp a, const Scalar_<_Tp>& b)\n{\n    _Tp s = a / (b[0]*b[0] + b[1]*b[1] + b[2]*b[2] + b[3]*b[3]);\n    return b.conj() * s;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator / (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return a * ((_Tp)1 / b);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator /= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a = a / b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)\n{\n    Matx<double, 4, 1> c((Matx<double, 4, 4>)a, b, Matx_MatMulOp());\n    return reinterpret_cast<const Scalar&>(c);\n}\n\ntemplate<> inline\nScalar operator * (const Matx<double, 4, 4>& a, const Scalar& b)\n{\n    Matx<double, 4, 1> c(a, b, Matx_MatMulOp());\n    return reinterpret_cast<const Scalar&>(c);\n}\n\n\n\n//////////////////////////////// KeyPoint ///////////////////////////////\n\ninline\nKeyPoint::KeyPoint()\n    : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}\n\ninline\nKeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)\n    : pt(_pt), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}\n\ninline\nKeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)\n    : pt(x, y), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}\n\n\n\n///////////////////////////////// DMatch ////////////////////////////////\n\ninline\nDMatch::DMatch()\n    : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(FLT_MAX) {}\n\ninline\nDMatch::DMatch(int _queryIdx, int _trainIdx, float _distance)\n    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(-1), distance(_distance) {}\n\ninline\nDMatch::DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance)\n    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) {}\n\ninline\nbool DMatch::operator < (const DMatch &m) const\n{\n    return distance < m.distance;\n}\n\n\n\n////////////////////////////// TermCriteria /////////////////////////////\n\ninline\nTermCriteria::TermCriteria()\n    : type(0), maxCount(0), epsilon(0) {}\n\ninline\nTermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)\n    : type(_type), maxCount(_maxCount), epsilon(_epsilon) {}\n\n//! @endcond\n\n} // cv\n\n#endif //OPENCV_CORE_TYPES_HPP\n",
			"file": "/usr/include/opencv4/opencv2/core/types.hpp",
			"file_size": 72186,
			"file_write_time": 132135618280000000,
			"settings":
			{
				"buffer_size": 72187,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/basicscanner.cpp",
			"settings":
			{
				"buffer_size": 4062,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Dokumente/Sources/contours/plot-cv"
	],
	"file_history":
	[
		"/home/roman/Dokumente/Sources/contours/plot-cv/plot-cv.sublime-project",
		"/usr/include/opencv4/opencv2/core/types",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src/line.h",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src/CannyWebcam1.cpp"
	],
	"find":
	{
		"height": 36.0
	},
	"find_in_files":
	{
		"height": 109.0,
		"where_history":
		[
			"/home/roman/Dokumente/Sources/contours/plot-cv,*.cpp,*.h*",
			"/home/roman/Dokumente/Sources/contours/plot-cv,*.cpp,*.h",
			"/home/roman/Dokumente/Sources/contours/plot-cv,*.cpp",
			"/home/roman/Dokumente/Sources/contours/plot-cv",
			"/home/roman/Dokumente/Sources/contours/plot-cv/src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"min_dist",
			"dist.secon",
			"point_dis",
			"ValueT",
			"point_dis",
			"point_distance",
			"point_distance\n",
			"point_dist",
			"endpoint_distance",
			"point_distance",
			"point_dis",
			"point_distance",
			"sqrt",
			"Point_",
			"sqrt",
			"Point_",
			"distance",
			"min_dist",
			"gleoff",
			"to_string",
			"segment_dis",
			"']'",
			"to_string",
			"-> \"",
			"<<\\(",
			"<<(",
			"filterLines",
			"to_string",
			"template.*template",
			"template.*CLASS",
			"to_str",
			"<<",
			"<< ",
			"to_string",
			"operator<<",
			"to_string",
			"lines",
			"to_string",
			"656",
			"std::bas",
			"to_str",
			"basic_str",
			"to_string",
			"<<",
			"to_string",
			"enable_if",
			"to_strin",
			"to_string",
			"pivot",
			"line\\.",
			"angleoff",
			"angle\\(",
			"angle",
			"segment_distance2",
			"min_dis",
			"intersect",
			"cv::Point_<ValueT>",
			"intersec",
			"91",
			"intersect",
			"slopeVector",
			"Line2D_",
			"min_distance",
			"lineDistances",
			"lineDis",
			"interse",
			"segment",
			"intersect",
			"EPSI",
			"other.0",
			"a\\[1]",
			"a\\[0]",
			"b\\[([0-9]+)]",
			"intersec",
			"intersect",
			"angle_diff",
			"lineDistances",
			"lineDis",
			"lineDistances",
			"angle_diffs",
			"lineDis",
			"lineDistances",
			"min_distance",
			"other",
			"lineDistances",
			"cbeg",
			"histogram",
			"basic_os",
			"<< ",
			"lineDis",
			"lineDistances",
			"adja",
			"802",
			"filterLines",
			"adjace",
			"lineDistances",
			"min_distance",
			"lineDistances",
			"find",
			"Adja",
			"iterator.*tra",
			"lines;",
			"lines;\t",
			"accumulat",
			"drawAllLines",
			"HSVtoRGB",
			"drawAllLines",
			"sort",
			"imgGrayscale",
			"imgGray",
			"graySca",
			"drawAllLines",
			"drawAllLinens",
			"hsv",
			"hue",
			"length",
			"iterator_tra",
			"Line<floa",
			"Container<Line<ValueT>>",
			"template.*template",
			"back_",
			"filtered",
			"length",
			"length\\(",
			"point_dis",
			"length",
			"drawAllC",
			"um lin"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"",
			"point_type",
			"Line",
			"other.a",
			"b",
			"a",
			"other.\\1",
			"ContainerT",
			"lines",
			"point_type"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 5,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/home/roman/lotto/utils/dom.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 95931,
						"regions":
						{
						},
						"selection":
						[
							[
								52419,
								52419
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/Babel/JavaScript (Babel).sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"use_tab_stops": false
						},
						"translation.x": 0.0,
						"translation.y": 51570.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/CannyWebcam1.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 30303,
						"regions":
						{
						},
						"selection":
						[
							[
								25971,
								25971
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"typescript_plugin_format_options":
							{
								"convertTabsToSpaces": true,
								"indentSize": 2,
								"tabSize": 2
							}
						},
						"translation.x": 0.0,
						"translation.y": 21653.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "polygon.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7597,
						"regions":
						{
						},
						"selection":
						[
							[
								7242,
								7242
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 5152.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/psimpl.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 72234,
						"regions":
						{
						},
						"selection":
						[
							[
								9695,
								9695
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8344.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/line.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9073,
						"regions":
						{
						},
						"selection":
						[
							[
								8138,
								8138
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"typescript_plugin_format_options":
							{
								"convertTabsToSpaces": true,
								"indentSize": 2,
								"tabSize": 2
							}
						},
						"translation.x": 0.0,
						"translation.y": 8465.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 5,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2620,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										198,
										206
									],
									[
										449,
										457
									],
									[
										465,
										473
									],
									[
										599,
										607
									],
									[
										833,
										841
									],
									[
										1157,
										1165
									],
									[
										1444,
										1452
									],
									[
										1626,
										1634
									],
									[
										1816,
										1824
									],
									[
										2196,
										2204
									],
									[
										2529,
										2537
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/usr/include/opencv4/opencv2/core/core.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2368,
						"regions":
						{
						},
						"selection":
						[
							[
								2,
								2
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/usr/include/opencv2",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/usr/include/opencv4/opencv2/core/types.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 72187,
						"regions":
						{
						},
						"selection":
						[
							[
								38197,
								38197
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 32041.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "src/basicscanner.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4062,
						"regions":
						{
						},
						"selection":
						[
							[
								601,
								601
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3276.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 36.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.CSS Extended Completions":
	{
		"height": 0.0
	},
	"output.doc":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "plot-cv.sublime-project",
	"replace":
	{
		"height": 68.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"canny",
				"src/CannyWebcam1.cpp"
			],
			[
				"line",
				"src/line.h"
			],
			[
				"cann",
				"src/CannyWebcam1.cpp"
			],
			[
				"psim",
				"src/psimpl.h"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
