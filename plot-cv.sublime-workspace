{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Valu",
				"ValueT"
			],
			[
				"take",
				"takenLines"
			],
			[
				"iterator",
				"iterator_type"
			],
			[
				"Cont",
				"ContainerT"
			],
			[
				"filter",
				"filteredLines"
			],
			[
				"point",
				"point_distance2"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "PointVec\nPoint2fVec\ncoordPointer\ncoordPointer\nsimplifyPolyline\ncoord_type\nout_point\nout_hier\nout_points\nfilter_contours\npolylineFromContour\ncv::Scalar\nHSVtoRGB\nsvg::Color\nfromScalar\nconvertPoints\ntransformPoints\nexport_svg\npolygonArea\napplyCLAHE\nBrightnessAndContrastAuto\ncv::Mat\nimageToBinary\ngetContours\ngetMassCenters\nToPointVec\nangle\nfindRectangles\ndrawPolylines\ninvertColor\nhoughLines\ndrawLines\ncornerHarrisDetection\ntrackbar\nwriteImage\ndrawAllContours\ndrawAllLines\niterator_type\nfilterLines\niterator_type\nvalue_type\nPredicateTraits\n function\nfilterLines\nangle_diffs\niterator_type\npoint_type\nvalue_type\nret_type\nlineDistances\niterator_type\nline_type\nvalue_type\nret_type\noperator<<\niterator_type\nmain\nline_type\nline_list\nref_list",
			"settings":
			{
				"buffer_size": 733,
				"line_ending": "Unix",
				"name": "ðŒ† Outline",
				"scratch": true
			}
		},
		{
			"file": "/home/roman/lotto/utils/dom.js",
			"settings":
			{
				"buffer_size": 95931,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/CannyWebcam1.cpp",
			"settings":
			{
				"buffer_size": 31253,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "polygon.cpp",
			"settings":
			{
				"buffer_size": 7597,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/psimpl.h",
			"settings":
			{
				"buffer_size": 70996,
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/line.h",
			"settings":
			{
				"buffer_size": 9722,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "x /*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                          License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#ifdef __OPENCV_BUILD\n#error this is a compatibility header which should not be used inside the OpenCV library\n#endif\n\n#include \"opencv2/core.hpp\"\n",
			"file": "/usr/include/opencv4/opencv2/core/core.hpp",
			"file_size": 2366,
			"file_write_time": 132135618280000000,
			"settings":
			{
				"buffer_size": 2368,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "",
			"file": "/usr/include/opencv2",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "P/*M///////////////////////////////////////////////////////////////////////////////////////\n//\n//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.\n//\n//  By downloading, copying, installing or using the software you agree to this license.\n//  If you do not agree to this license, do not download, install,\n//  copy or use the software.\n//\n//\n//                          License Agreement\n//                For Open Source Computer Vision Library\n//\n// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.\n// Copyright (C) 2009, Willow Garage Inc., all rights reserved.\n// Copyright (C) 2013, OpenCV Foundation, all rights reserved.\n// Third party copyrights are property of their respective owners.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//   * Redistribution's of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//\n//   * Redistribution's in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//\n//   * The name of the copyright holders may not be used to endorse or promote products\n//     derived from this software without specific prior written permission.\n//\n// This software is provided by the copyright holders and contributors \"as is\" and\n// any express or implied warranties, including, but not limited to, the implied\n// warranties of merchantability and fitness for a particular purpose are disclaimed.\n// In no event shall the Intel Corporation or contributors be liable for any direct,\n// indirect, incidental, special, exemplary, or consequential damages\n// (including, but not limited to, procurement of substitute goods or services;\n// loss of use, data, or profits; or business interruption) however caused\n// and on any theory of liability, whether in contract, strict liability,\n// or tort (including negligence or otherwise) arising in any way out of\n// the use of this software, even if advised of the possibility of such damage.\n//\n//M*/\n\n#ifndef OPENCV_CORE_TYPES_HPP\n#define OPENCV_CORE_TYPES_HPP\n\n#ifndef __cplusplus\n#  error types.hpp header must be compiled as C++\n#endif\n\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <limits>\n\n#include \"opencv2/core/cvdef.h\"\n#include \"opencv2/core/cvstd.hpp\"\n#include \"opencv2/core/matx.hpp\"\n\nnamespace cv\n{\n\n//! @addtogroup core_basic\n//! @{\n\n//////////////////////////////// Complex //////////////////////////////\n\n/** @brief  A complex number class.\n\n  The template class is similar and compatible with std::complex, however it provides slightly\n  more convenient access to the real and imaginary parts using through the simple field access, as opposite\n  to std::complex::real() and std::complex::imag().\n*/\ntemplate<typename _Tp> class Complex\n{\npublic:\n\n    //! default constructor\n    Complex();\n    Complex( _Tp _re, _Tp _im = 0 );\n\n    //! conversion to another data type\n    template<typename T2> operator Complex<T2>() const;\n    //! conjugation\n    Complex conj() const;\n\n    _Tp re, im; //< the real and the imaginary parts\n};\n\ntypedef Complex<float> Complexf;\ntypedef Complex<double> Complexd;\n\ntemplate<typename _Tp> class DataType< Complex<_Tp> >\n{\npublic:\n    typedef Complex<_Tp> value_type;\n    typedef value_type   work_type;\n    typedef _Tp          channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n    };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Complex<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Complex<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };\n} // namespace\n\n\n//////////////////////////////// Point_ ////////////////////////////////\n\n/** @brief Template class for 2D points specified by its coordinates `x` and `y`.\n\nAn instance of the class is interchangeable with C structures, CvPoint and CvPoint2D32f . There is\nalso a cast operator to convert point coordinates to the specified type. The conversion from\nfloating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion\nuses this operation for each of the coordinates. Besides the class members listed in the\ndeclaration above, the following operations on points are implemented:\n@code\n    pt1 = pt2 + pt3;\n    pt1 = pt2 - pt3;\n    pt1 = pt2 * a;\n    pt1 = a * pt2;\n    pt1 = pt2 / a;\n    pt1 += pt2;\n    pt1 -= pt2;\n    pt1 *= a;\n    pt1 /= a;\n    double value = norm(pt); // L2 norm\n    pt1 == pt2;\n    pt1 != pt2;\n@endcode\nFor your convenience, the following type aliases are defined:\n@code\n    typedef Point_<int> Point2i;\n    typedef Point2i Point;\n    typedef Point_<float> Point2f;\n    typedef Point_<double> Point2d;\n@endcode\nExample:\n@code\n    Point2f a(0.3f, 0.f), b(0.f, 0.4f);\n    Point pt = (a + b)*10.f;\n    cout << pt.x << \", \" << pt.y << endl;\n@endcode\n*/\ntemplate<typename _Tp> class Point_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Point_();\n    Point_(_Tp _x, _Tp _y);\n    Point_(const Point_& pt);\n    Point_(Point_&& pt) CV_NOEXCEPT;\n    Point_(const Size_<_Tp>& sz);\n    Point_(const Vec<_Tp, 2>& v);\n\n    Point_& operator = (const Point_& pt);\n    Point_& operator = (Point_&& pt) CV_NOEXCEPT;\n    //! conversion to another data type\n    template<typename _Tp2> operator Point_<_Tp2>() const;\n\n    //! conversion to the old-style C structures\n    operator Vec<_Tp, 2>() const;\n\n    //! dot product\n    _Tp dot(const Point_& pt) const;\n    //! dot product computed in double-precision arithmetics\n    double ddot(const Point_& pt) const;\n    //! cross-product\n    double cross(const Point_& pt) const;\n    //! checks whether the point is inside the specified rectangle\n    bool inside(const Rect_<_Tp>& r) const;\n    _Tp x; //!< x coordinate of the point\n    _Tp y; //!< y coordinate of the point\n};\n\ntypedef Point_<int> Point2i;\ntypedef Point_<int64> Point2l;\ntypedef Point_<float> Point2f;\ntypedef Point_<double> Point2d;\ntypedef Point2i Point;\n\ntemplate<typename _Tp> class DataType< Point_<_Tp> >\n{\npublic:\n    typedef Point_<_Tp>                               value_type;\n    typedef Point_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                       channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Point_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Point_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };\n} // namespace\n\n\n//////////////////////////////// Point3_ ////////////////////////////////\n\n/** @brief Template class for 3D points specified by its coordinates `x`, `y` and `z`.\n\nAn instance of the class is interchangeable with the C structure CvPoint2D32f . Similarly to\nPoint_ , the coordinates of 3D points can be converted to another type. The vector arithmetic and\ncomparison operations are also supported.\n\nThe following Point3_\\<\\> aliases are available:\n@code\n    typedef Point3_<int> Point3i;\n    typedef Point3_<float> Point3f;\n    typedef Point3_<double> Point3d;\n@endcode\n@see cv::Point3i, cv::Point3f and cv::Point3d\n*/\ntemplate<typename _Tp> class Point3_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Point3_();\n    Point3_(_Tp _x, _Tp _y, _Tp _z);\n    Point3_(const Point3_& pt);\n    Point3_(Point3_&& pt) CV_NOEXCEPT;\n    explicit Point3_(const Point_<_Tp>& pt);\n    Point3_(const Vec<_Tp, 3>& v);\n\n    Point3_& operator = (const Point3_& pt);\n    Point3_& operator = (Point3_&& pt) CV_NOEXCEPT;\n    //! conversion to another data type\n    template<typename _Tp2> operator Point3_<_Tp2>() const;\n    //! conversion to cv::Vec<>\n    operator Vec<_Tp, 3>() const;\n\n    //! dot product\n    _Tp dot(const Point3_& pt) const;\n    //! dot product computed in double-precision arithmetics\n    double ddot(const Point3_& pt) const;\n    //! cross product of the 2 3D points\n    Point3_ cross(const Point3_& pt) const;\n    _Tp x; //!< x coordinate of the 3D point\n    _Tp y; //!< y coordinate of the 3D point\n    _Tp z; //!< z coordinate of the 3D point\n};\n\ntypedef Point3_<int> Point3i;\ntypedef Point3_<float> Point3f;\ntypedef Point3_<double> Point3d;\n\ntemplate<typename _Tp> class DataType< Point3_<_Tp> >\n{\npublic:\n    typedef Point3_<_Tp>                               value_type;\n    typedef Point3_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                        channel_type;\n\n    enum { generic_type = 0,\n           channels     = 3,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Point3_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Point3_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 3) }; };\n} // namespace\n\n//////////////////////////////// Size_ ////////////////////////////////\n\n/** @brief Template class for specifying the size of an image or rectangle.\n\nThe class includes two members called width and height. The structure can be converted to and from\nthe old OpenCV structures CvSize and CvSize2D32f . The same set of arithmetic and comparison\noperations as for Point_ is available.\n\nOpenCV defines the following Size_\\<\\> aliases:\n@code\n    typedef Size_<int> Size2i;\n    typedef Size2i Size;\n    typedef Size_<float> Size2f;\n@endcode\n*/\ntemplate<typename _Tp> class Size_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Size_();\n    Size_(_Tp _width, _Tp _height);\n    Size_(const Size_& sz);\n    Size_(Size_&& sz) CV_NOEXCEPT;\n    Size_(const Point_<_Tp>& pt);\n\n    Size_& operator = (const Size_& sz);\n    Size_& operator = (Size_&& sz) CV_NOEXCEPT;\n    //! the area (width*height)\n    _Tp area() const;\n    //! aspect ratio (width/height)\n    double aspectRatio() const;\n    //! true if empty\n    bool empty() const;\n\n    //! conversion of another data type.\n    template<typename _Tp2> operator Size_<_Tp2>() const;\n\n    _Tp width; //!< the width\n    _Tp height; //!< the height\n};\n\ntypedef Size_<int> Size2i;\ntypedef Size_<int64> Size2l;\ntypedef Size_<float> Size2f;\ntypedef Size_<double> Size2d;\ntypedef Size2i Size;\n\ntemplate<typename _Tp> class DataType< Size_<_Tp> >\n{\npublic:\n    typedef Size_<_Tp>                               value_type;\n    typedef Size_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                      channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Size_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Size_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 2) }; };\n} // namespace\n\n//////////////////////////////// Rect_ ////////////////////////////////\n\n/** @brief Template class for 2D rectangles\n\ndescribed by the following parameters:\n-   Coordinates of the top-left corner. This is a default interpretation of Rect_::x and Rect_::y\n    in OpenCV. Though, in your algorithms you may count x and y from the bottom-left corner.\n-   Rectangle width and height.\n\nOpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the\nright and bottom boundaries are not. For example, the method Rect_::contains returns true if\n\n\\f[x  \\leq pt.x < x+width,\n      y  \\leq pt.y < y+height\\f]\n\nVirtually every loop over an image ROI in OpenCV (where ROI is specified by Rect_\\<int\\> ) is\nimplemented as:\n@code\n    for(int y = roi.y; y < roi.y + roi.height; y++)\n        for(int x = roi.x; x < roi.x + roi.width; x++)\n        {\n            // ...\n        }\n@endcode\nIn addition to the class members, the following operations on rectangles are implemented:\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{point}\\f$ (shifting a rectangle by a certain offset)\n-   \\f$\\texttt{rect} = \\texttt{rect} \\pm \\texttt{size}\\f$ (expanding or shrinking a rectangle by a\n    certain amount)\n-   rect += point, rect -= point, rect += size, rect -= size (augmenting operations)\n-   rect = rect1 & rect2 (rectangle intersection)\n-   rect = rect1 | rect2 (minimum area rectangle containing rect1 and rect2 )\n-   rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)\n-   rect == rect1, rect != rect1 (rectangle comparison)\n\nThis is an example how the partial ordering on rectangles can be established (rect1 \\f$\\subseteq\\f$\nrect2):\n@code\n    template<typename _Tp> inline bool\n    operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)\n    {\n        return (r1 & r2) == r1;\n    }\n@endcode\nFor your convenience, the Rect_\\<\\> alias is available: cv::Rect\n*/\ntemplate<typename _Tp> class Rect_\n{\npublic:\n    typedef _Tp value_type;\n\n    //! default constructor\n    Rect_();\n    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);\n    Rect_(const Rect_& r);\n    Rect_(Rect_&& r) CV_NOEXCEPT;\n    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);\n    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);\n\n    Rect_& operator = ( const Rect_& r );\n    Rect_& operator = ( Rect_&& r ) CV_NOEXCEPT;\n    //! the top-left corner\n    Point_<_Tp> tl() const;\n    //! the bottom-right corner\n    Point_<_Tp> br() const;\n\n    //! size (width, height) of the rectangle\n    Size_<_Tp> size() const;\n    //! area (width*height) of the rectangle\n    _Tp area() const;\n    //! true if empty\n    bool empty() const;\n\n    //! conversion to another data type\n    template<typename _Tp2> operator Rect_<_Tp2>() const;\n\n    //! checks whether the rectangle contains the point\n    bool contains(const Point_<_Tp>& pt) const;\n\n    _Tp x; //!< x coordinate of the top-left corner\n    _Tp y; //!< y coordinate of the top-left corner\n    _Tp width; //!< width of the rectangle\n    _Tp height; //!< height of the rectangle\n};\n\ntypedef Rect_<int> Rect2i;\ntypedef Rect_<float> Rect2f;\ntypedef Rect_<double> Rect2d;\ntypedef Rect2i Rect;\n\ntemplate<typename _Tp> class DataType< Rect_<_Tp> >\n{\npublic:\n    typedef Rect_<_Tp>                               value_type;\n    typedef Rect_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                      channel_type;\n\n    enum { generic_type = 0,\n           channels     = 4,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Rect_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Rect_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };\n} // namespace\n\n///////////////////////////// RotatedRect /////////////////////////////\n\n/** @brief The class represents rotated (i.e. not up-right) rectangles on a plane.\n\nEach rectangle is specified by the center point (mass center), length of each side (represented by\n#Size2f structure) and the rotation angle in degrees.\n\nThe sample below demonstrates how to use RotatedRect:\n@snippet snippets/core_various.cpp RotatedRect_demo\n![image](pics/rotatedrect.png)\n\n@sa CamShift, fitEllipse, minAreaRect, CvBox2D\n*/\nclass CV_EXPORTS RotatedRect\n{\npublic:\n    //! default constructor\n    RotatedRect();\n    /** full constructor\n    @param center The rectangle mass center.\n    @param size Width and height of the rectangle.\n    @param angle The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc.,\n    the rectangle becomes an up-right rectangle.\n    */\n    RotatedRect(const Point2f& center, const Size2f& size, float angle);\n    /**\n    Any 3 end points of the RotatedRect. They must be given in order (either clockwise or\n    anticlockwise).\n     */\n    RotatedRect(const Point2f& point1, const Point2f& point2, const Point2f& point3);\n\n    /** returns 4 vertices of the rectangle\n    @param pts The points array for storing rectangle vertices. The order is bottomLeft, topLeft, topRight, bottomRight.\n    */\n    void points(Point2f pts[]) const;\n    //! returns the minimal up-right integer rectangle containing the rotated rectangle\n    Rect boundingRect() const;\n    //! returns the minimal (exact) floating point rectangle containing the rotated rectangle, not intended for use with images\n    Rect_<float> boundingRect2f() const;\n    //! returns the rectangle mass center\n    Point2f center;\n    //! returns width and height of the rectangle\n    Size2f size;\n    //! returns the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.\n    float angle;\n};\n\ntemplate<> class DataType< RotatedRect >\n{\npublic:\n    typedef RotatedRect  value_type;\n    typedef value_type   work_type;\n    typedef float        channel_type;\n\n    enum { generic_type = 0,\n           channels     = (int)sizeof(value_type)/sizeof(channel_type), // 5\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<>\nstruct Depth< RotatedRect > { enum { value = Depth<float>::value }; };\ntemplate<>\nstruct Type< RotatedRect > { enum { value = CV_MAKETYPE(Depth<float>::value, (int)sizeof(RotatedRect)/sizeof(float)) }; };\n} // namespace\n\n\n//////////////////////////////// Range /////////////////////////////////\n\n/** @brief Template class specifying a continuous subsequence (slice) of a sequence.\n\nThe class is used to specify a row or a column span in a matrix ( Mat ) and for many other purposes.\nRange(a,b) is basically the same as a:b in Matlab or a..b in Python. As in Python, start is an\ninclusive left boundary of the range and end is an exclusive right boundary of the range. Such a\nhalf-opened interval is usually denoted as \\f$[start,end)\\f$ .\n\nThe static method Range::all() returns a special variable that means \"the whole sequence\" or \"the\nwhole range\", just like \" : \" in Matlab or \" ... \" in Python. All the methods and functions in\nOpenCV that take Range support this special Range::all() value. But, of course, in case of your own\ncustom processing, you will probably have to check and handle it explicitly:\n@code\n    void my_function(..., const Range& r, ....)\n    {\n        if(r == Range::all()) {\n            // process all the data\n        }\n        else {\n            // process [r.start, r.end)\n        }\n    }\n@endcode\n*/\nclass CV_EXPORTS Range\n{\npublic:\n    Range();\n    Range(int _start, int _end);\n    int size() const;\n    bool empty() const;\n    static Range all();\n\n    int start, end;\n};\n\ntemplate<> class DataType<Range>\n{\npublic:\n    typedef Range      value_type;\n    typedef value_type work_type;\n    typedef int        channel_type;\n\n    enum { generic_type = 0,\n           channels     = 2,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<>\nstruct Depth< Range > { enum { value = Depth<int>::value }; };\ntemplate<>\nstruct Type< Range > { enum { value = CV_MAKETYPE(Depth<int>::value, 2) }; };\n} // namespace\n\n\n//////////////////////////////// Scalar_ ///////////////////////////////\n\n/** @brief Template class for a 4-element vector derived from Vec.\n\nBeing derived from Vec\\<_Tp, 4\\> , Scalar\\_ and Scalar can be used just as typical 4-element\nvectors. In addition, they can be converted to/from CvScalar . The type Scalar is widely used in\nOpenCV to pass pixel values.\n*/\ntemplate<typename _Tp> class Scalar_ : public Vec<_Tp, 4>\n{\npublic:\n    //! default constructor\n    Scalar_();\n    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);\n    Scalar_(_Tp v0);\n\n    Scalar_(const Scalar_& s);\n    Scalar_(Scalar_&& s) CV_NOEXCEPT;\n\n    Scalar_& operator=(const Scalar_& s);\n    Scalar_& operator=(Scalar_&& s) CV_NOEXCEPT;\n\n    template<typename _Tp2, int cn>\n    Scalar_(const Vec<_Tp2, cn>& v);\n\n    //! returns a scalar with all elements set to v0\n    static Scalar_<_Tp> all(_Tp v0);\n\n    //! conversion to another data type\n    template<typename T2> operator Scalar_<T2>() const;\n\n    //! per-element product\n    Scalar_<_Tp> mul(const Scalar_<_Tp>& a, double scale=1 ) const;\n\n    //! returns (v0, -v1, -v2, -v3)\n    Scalar_<_Tp> conj() const;\n\n    //! returns true iff v1 == v2 == v3 == 0\n    bool isReal() const;\n};\n\ntypedef Scalar_<double> Scalar;\n\ntemplate<typename _Tp> class DataType< Scalar_<_Tp> >\n{\npublic:\n    typedef Scalar_<_Tp>                               value_type;\n    typedef Scalar_<typename DataType<_Tp>::work_type> work_type;\n    typedef _Tp                                        channel_type;\n\n    enum { generic_type = 0,\n           channels     = 4,\n           fmt          = traits::SafeFmt<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<typename _Tp>\nstruct Depth< Scalar_<_Tp> > { enum { value = Depth<_Tp>::value }; };\ntemplate<typename _Tp>\nstruct Type< Scalar_<_Tp> > { enum { value = CV_MAKETYPE(Depth<_Tp>::value, 4) }; };\n} // namespace\n\n\n/////////////////////////////// KeyPoint ////////////////////////////////\n\n/** @brief Data structure for salient point detectors.\n\nThe class instance stores a keypoint, i.e. a point feature found by one of many available keypoint\ndetectors, such as Harris corner detector, #FAST, %StarDetector, %SURF, %SIFT etc.\n\nThe keypoint is characterized by the 2D position, scale (proportional to the diameter of the\nneighborhood that needs to be taken into account), orientation and some other parameters. The\nkeypoint neighborhood is then analyzed by another algorithm that builds a descriptor (usually\nrepresented as a feature vector). The keypoints representing the same object in different images\ncan then be matched using %KDTree or another method.\n*/\nclass CV_EXPORTS_W_SIMPLE KeyPoint\n{\npublic:\n    //! the default constructor\n    CV_WRAP KeyPoint();\n    /**\n    @param _pt x & y coordinates of the keypoint\n    @param _size keypoint diameter\n    @param _angle keypoint orientation\n    @param _response keypoint detector response on the keypoint (that is, strength of the keypoint)\n    @param _octave pyramid octave in which the keypoint has been detected\n    @param _class_id object id\n     */\n    KeyPoint(Point2f _pt, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);\n    /**\n    @param x x-coordinate of the keypoint\n    @param y y-coordinate of the keypoint\n    @param _size keypoint diameter\n    @param _angle keypoint orientation\n    @param _response keypoint detector response on the keypoint (that is, strength of the keypoint)\n    @param _octave pyramid octave in which the keypoint has been detected\n    @param _class_id object id\n     */\n    CV_WRAP KeyPoint(float x, float y, float _size, float _angle=-1, float _response=0, int _octave=0, int _class_id=-1);\n\n    size_t hash() const;\n\n    /**\n    This method converts vector of keypoints to vector of points or the reverse, where each keypoint is\n    assigned the same size and the same orientation.\n\n    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n    @param points2f Array of (x,y) coordinates of each keypoint\n    @param keypointIndexes Array of indexes of keypoints to be converted to points. (Acts like a mask to\n    convert only specified keypoints)\n    */\n    CV_WRAP static void convert(const std::vector<KeyPoint>& keypoints,\n                                CV_OUT std::vector<Point2f>& points2f,\n                                const std::vector<int>& keypointIndexes=std::vector<int>());\n    /** @overload\n    @param points2f Array of (x,y) coordinates of each keypoint\n    @param keypoints Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB\n    @param size keypoint diameter\n    @param response keypoint detector response on the keypoint (that is, strength of the keypoint)\n    @param octave pyramid octave in which the keypoint has been detected\n    @param class_id object id\n    */\n    CV_WRAP static void convert(const std::vector<Point2f>& points2f,\n                                CV_OUT std::vector<KeyPoint>& keypoints,\n                                float size=1, float response=1, int octave=0, int class_id=-1);\n\n    /**\n    This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint\n    regions' intersection and area of keypoint regions' union (considering keypoint region as circle).\n    If they don't overlap, we get zero. If they coincide at same location with same size, we get 1.\n    @param kp1 First keypoint\n    @param kp2 Second keypoint\n    */\n    CV_WRAP static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);\n\n    CV_PROP_RW Point2f pt; //!< coordinates of the keypoints\n    CV_PROP_RW float size; //!< diameter of the meaningful keypoint neighborhood\n    CV_PROP_RW float angle; //!< computed orientation of the keypoint (-1 if not applicable);\n                            //!< it's in [0,360) degrees and measured relative to\n                            //!< image coordinate system, ie in clockwise.\n    CV_PROP_RW float response; //!< the response by which the most strong keypoints have been selected. Can be used for the further sorting or subsampling\n    CV_PROP_RW int octave; //!< octave (pyramid layer) from which the keypoint has been extracted\n    CV_PROP_RW int class_id; //!< object class (if the keypoints need to be clustered by an object they belong to)\n};\n\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\ntemplate<> class DataType<KeyPoint>\n{\npublic:\n    typedef KeyPoint      value_type;\n    typedef float         work_type;\n    typedef float         channel_type;\n\n    enum { generic_type = 0,\n           depth        = DataType<channel_type>::depth,\n           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 7\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),\n           type         = CV_MAKETYPE(depth, channels)\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n#endif\n\n\n//////////////////////////////// DMatch /////////////////////////////////\n\n/** @brief Class for matching keypoint descriptors\n\nquery descriptor index, train descriptor index, train image index, and distance between\ndescriptors.\n*/\nclass CV_EXPORTS_W_SIMPLE DMatch\n{\npublic:\n    CV_WRAP DMatch();\n    CV_WRAP DMatch(int _queryIdx, int _trainIdx, float _distance);\n    CV_WRAP DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance);\n\n    CV_PROP_RW int queryIdx; //!< query descriptor index\n    CV_PROP_RW int trainIdx; //!< train descriptor index\n    CV_PROP_RW int imgIdx;   //!< train image index\n\n    CV_PROP_RW float distance;\n\n    // less is better\n    bool operator<(const DMatch &m) const;\n};\n\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\ntemplate<> class DataType<DMatch>\n{\npublic:\n    typedef DMatch      value_type;\n    typedef int         work_type;\n    typedef int         channel_type;\n\n    enum { generic_type = 0,\n           depth        = DataType<channel_type>::depth,\n           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 4\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8),\n           type         = CV_MAKETYPE(depth, channels)\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n#endif\n\n\n///////////////////////////// TermCriteria //////////////////////////////\n\n/** @brief The class defining termination criteria for iterative algorithms.\n\nYou can initialize it by default constructor and then override any parameters, or the structure may\nbe fully initialized using the advanced variant of the constructor.\n*/\nclass CV_EXPORTS TermCriteria\n{\npublic:\n    /**\n      Criteria type, can be one of: COUNT, EPS or COUNT + EPS\n    */\n    enum Type\n    {\n        COUNT=1, //!< the maximum number of iterations or elements to compute\n        MAX_ITER=COUNT, //!< ditto\n        EPS=2 //!< the desired accuracy or change in parameters at which the iterative algorithm stops\n    };\n\n    //! default constructor\n    TermCriteria();\n    /**\n    @param type The type of termination criteria, one of TermCriteria::Type\n    @param maxCount The maximum number of iterations or elements to compute.\n    @param epsilon The desired accuracy or change in parameters at which the iterative algorithm stops.\n    */\n    TermCriteria(int type, int maxCount, double epsilon);\n\n    inline bool isValid() const\n    {\n        const bool isCount = (type & COUNT) && maxCount > 0;\n        const bool isEps = (type & EPS) && !cvIsNaN(epsilon);\n        return isCount || isEps;\n    }\n\n    int type; //!< the type of termination criteria: COUNT, EPS or COUNT + EPS\n    int maxCount; //!< the maximum number of iterations/elements\n    double epsilon; //!< the desired accuracy\n};\n\n\n//! @} core_basic\n\n///////////////////////// raster image moments //////////////////////////\n\n//! @addtogroup imgproc_shape\n//! @{\n\n/** @brief struct returned by cv::moments\n\nThe spatial moments \\f$\\texttt{Moments::m}_{ji}\\f$ are computed as:\n\n\\f[\\texttt{m} _{ji}= \\sum _{x,y}  \\left ( \\texttt{array} (x,y)  \\cdot x^j  \\cdot y^i \\right )\\f]\n\nThe central moments \\f$\\texttt{Moments::mu}_{ji}\\f$ are computed as:\n\n\\f[\\texttt{mu} _{ji}= \\sum _{x,y}  \\left ( \\texttt{array} (x,y)  \\cdot (x -  \\bar{x} )^j  \\cdot (y -  \\bar{y} )^i \\right )\\f]\n\nwhere \\f$(\\bar{x}, \\bar{y})\\f$ is the mass center:\n\n\\f[\\bar{x} = \\frac{\\texttt{m}_{10}}{\\texttt{m}_{00}} , \\; \\bar{y} = \\frac{\\texttt{m}_{01}}{\\texttt{m}_{00}}\\f]\n\nThe normalized central moments \\f$\\texttt{Moments::nu}_{ij}\\f$ are computed as:\n\n\\f[\\texttt{nu} _{ji}= \\frac{\\texttt{mu}_{ji}}{\\texttt{m}_{00}^{(i+j)/2+1}} .\\f]\n\n@note\n\\f$\\texttt{mu}_{00}=\\texttt{m}_{00}\\f$, \\f$\\texttt{nu}_{00}=1\\f$\n\\f$\\texttt{nu}_{10}=\\texttt{mu}_{10}=\\texttt{mu}_{01}=\\texttt{mu}_{10}=0\\f$ , hence the values are not\nstored.\n\nThe moments of a contour are defined in the same way but computed using the Green's formula (see\n<http://en.wikipedia.org/wiki/Green_theorem>). So, due to a limited raster resolution, the moments\ncomputed for a contour are slightly different from the moments computed for the same rasterized\ncontour.\n\n@note\nSince the contour moments are computed using Green formula, you may get seemingly odd results for\ncontours with self-intersections, e.g. a zero area (m00) for butterfly-shaped contours.\n */\nclass CV_EXPORTS_W_MAP Moments\n{\npublic:\n    //! the default constructor\n    Moments();\n    //! the full constructor\n    Moments(double m00, double m10, double m01, double m20, double m11,\n            double m02, double m30, double m21, double m12, double m03 );\n    ////! the conversion from CvMoments\n    //Moments( const CvMoments& moments );\n    ////! the conversion to CvMoments\n    //operator CvMoments() const;\n\n    //! @name spatial moments\n    //! @{\n    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;\n    //! @}\n\n    //! @name central moments\n    //! @{\n    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;\n    //! @}\n\n    //! @name central normalized moments\n    //! @{\n    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;\n    //! @}\n};\n\ntemplate<> class DataType<Moments>\n{\npublic:\n    typedef Moments     value_type;\n    typedef double      work_type;\n    typedef double      channel_type;\n\n    enum { generic_type = 0,\n           channels     = (int)(sizeof(value_type)/sizeof(channel_type)), // 24\n           fmt          = DataType<channel_type>::fmt + ((channels - 1) << 8)\n#ifdef OPENCV_TRAITS_ENABLE_DEPRECATED\n           ,depth        = DataType<channel_type>::depth\n           ,type         = CV_MAKETYPE(depth, channels)\n#endif\n         };\n\n    typedef Vec<channel_type, channels> vec_type;\n};\n\nnamespace traits {\ntemplate<>\nstruct Depth< Moments > { enum { value = Depth<double>::value }; };\ntemplate<>\nstruct Type< Moments > { enum { value = CV_MAKETYPE(Depth<double>::value, (int)(sizeof(Moments)/sizeof(double))) }; };\n} // namespace\n\n//! @} imgproc_shape\n\n//! @cond IGNORED\n\n/////////////////////////////////////////////////////////////////////////\n///////////////////////////// Implementation ////////////////////////////\n/////////////////////////////////////////////////////////////////////////\n\n//////////////////////////////// Complex ////////////////////////////////\n\ntemplate<typename _Tp> inline\nComplex<_Tp>::Complex()\n    : re(0), im(0) {}\n\ntemplate<typename _Tp> inline\nComplex<_Tp>::Complex( _Tp _re, _Tp _im )\n    : re(_re), im(_im) {}\n\ntemplate<typename _Tp> template<typename T2> inline\nComplex<_Tp>::operator Complex<T2>() const\n{\n    return Complex<T2>(saturate_cast<T2>(re), saturate_cast<T2>(im));\n}\n\ntemplate<typename _Tp> inline\nComplex<_Tp> Complex<_Tp>::conj() const\n{\n    return Complex<_Tp>(re, -im);\n}\n\n\ntemplate<typename _Tp> static inline\nbool operator == (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return a.re == b.re && a.im == b.im;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return a.re != b.re || a.im != b.im;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator + (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return Complex<_Tp>( a.re + b.re, a.im + b.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator += (Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    a.re += b.re; a.im += b.im;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return Complex<_Tp>( a.re - b.re, a.im - b.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator -= (Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    a.re -= b.re; a.im -= b.im;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (const Complex<_Tp>& a)\n{\n    return Complex<_Tp>(-a.re, -a.im);\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator * (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    return Complex<_Tp>( a.re*b.re - a.im*b.im, a.re*b.im + a.im*b.re );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator * (const Complex<_Tp>& a, _Tp b)\n{\n    return Complex<_Tp>( a.re*b, a.im*b );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator * (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>( a.re*b, a.im*b );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator + (const Complex<_Tp>& a, _Tp b)\n{\n    return Complex<_Tp>( a.re + b, a.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (const Complex<_Tp>& a, _Tp b)\n{ return Complex<_Tp>( a.re - b, a.im ); }\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator + (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>( a.re + b, a.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator - (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>( b - a.re, -a.im );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator += (Complex<_Tp>& a, _Tp b)\n{\n    a.re += b; return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator -= (Complex<_Tp>& a, _Tp b)\n{\n    a.re -= b; return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator *= (Complex<_Tp>& a, _Tp b)\n{\n    a.re *= b; a.im *= b; return a;\n}\n\ntemplate<typename _Tp> static inline\ndouble abs(const Complex<_Tp>& a)\n{\n    return std::sqrt( (double)a.re*a.re + (double)a.im*a.im);\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator / (const Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    double t = 1./((double)b.re*b.re + (double)b.im*b.im);\n    return Complex<_Tp>( (_Tp)((a.re*b.re + a.im*b.im)*t),\n                        (_Tp)((-a.re*b.im + a.im*b.re)*t) );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp>& operator /= (Complex<_Tp>& a, const Complex<_Tp>& b)\n{\n    a = a / b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator / (const Complex<_Tp>& a, _Tp b)\n{\n    _Tp t = (_Tp)1/b;\n    return Complex<_Tp>( a.re*t, a.im*t );\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator / (_Tp b, const Complex<_Tp>& a)\n{\n    return Complex<_Tp>(b)/a;\n}\n\ntemplate<typename _Tp> static inline\nComplex<_Tp> operator /= (const Complex<_Tp>& a, _Tp b)\n{\n    _Tp t = (_Tp)1/b;\n    a.re *= t; a.im *= t; return a;\n}\n\n\n\n//////////////////////////////// 2D Point ///////////////////////////////\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_()\n    : x(0), y(0) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(_Tp _x, _Tp _y)\n    : x(_x), y(_y) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(const Point_& pt)\n    : x(pt.x), y(pt.y) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(Point_&& pt) CV_NOEXCEPT\n    : x(std::move(pt.x)), y(std::move(pt.y)) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(const Size_<_Tp>& sz)\n    : x(sz.width), y(sz.height) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::Point_(const Vec<_Tp,2>& v)\n    : x(v[0]), y(v[1]) {}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>& Point_<_Tp>::operator = (const Point_& pt)\n{\n    x = pt.x; y = pt.y;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>& Point_<_Tp>::operator = (Point_&& pt) CV_NOEXCEPT\n{\n    x = std::move(pt.x); y = std::move(pt.y);\n    return *this;\n}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nPoint_<_Tp>::operator Point_<_Tp2>() const\n{\n    return Point_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y));\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp>::operator Vec<_Tp, 2>() const\n{\n    return Vec<_Tp, 2>(x, y);\n}\n\ntemplate<typename _Tp> inline\n_Tp Point_<_Tp>::dot(const Point_& pt) const\n{\n    return saturate_cast<_Tp>(x*pt.x + y*pt.y);\n}\n\ntemplate<typename _Tp> inline\ndouble Point_<_Tp>::ddot(const Point_& pt) const\n{\n    return (double)x*pt.x + (double)y*pt.y;\n}\n\ntemplate<typename _Tp> inline\ndouble Point_<_Tp>::cross(const Point_& pt) const\n{\n    return (double)x*pt.y - (double)y*pt.x;\n}\n\ntemplate<typename _Tp> inline bool\nPoint_<_Tp>::inside( const Rect_<_Tp>& r ) const\n{\n    return r.contains(*this);\n}\n\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator += (Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    a.x += b.x;\n    a.y += b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator -= (Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator *= (Point_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator *= (Point_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator *= (Point_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator /= (Point_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator /= (Point_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp>& operator /= (Point_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\ndouble norm(const Point_<_Tp>& pt)\n{\n    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y);\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return a.x == b.x && a.y == b.y;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return a.x != b.x || a.y != b.y;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator + (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator - (const Point_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator - (const Point_<_Tp>& a)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Point_<_Tp>& a, int b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (int a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Point_<_Tp>& a, float b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (float a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Point_<_Tp>& a, double b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (double a, const Point_<_Tp>& b)\n{\n    return Point_<_Tp>( saturate_cast<_Tp>(b.x*a), saturate_cast<_Tp>(b.y*a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator * (const Matx<_Tp, 2, 2>& a, const Point_<_Tp>& b)\n{\n    Matx<_Tp, 2, 1> tmp = a * Vec<_Tp,2>(b.x, b.y);\n    return Point_<_Tp>(tmp.val[0], tmp.val[1]);\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point_<_Tp>& b)\n{\n    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, 1);\n    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator / (const Point_<_Tp>& a, int b)\n{\n    Point_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator / (const Point_<_Tp>& a, float b)\n{\n    Point_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint_<_Tp> operator / (const Point_<_Tp>& a, double b)\n{\n    Point_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\n\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int>& pt);\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<int64>& pt);\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<float>& pt);\ntemplate<typename _AccTp> static inline _AccTp normL2Sqr(const Point_<double>& pt);\n\ntemplate<> inline int normL2Sqr<int>(const Point_<int>& pt) { return pt.dot(pt); }\ntemplate<> inline int64 normL2Sqr<int64>(const Point_<int64>& pt) { return pt.dot(pt); }\ntemplate<> inline float normL2Sqr<float>(const Point_<float>& pt) { return pt.dot(pt); }\ntemplate<> inline double normL2Sqr<double>(const Point_<int>& pt) { return pt.dot(pt); }\n\ntemplate<> inline double normL2Sqr<double>(const Point_<float>& pt) { return pt.ddot(pt); }\ntemplate<> inline double normL2Sqr<double>(const Point_<double>& pt) { return pt.ddot(pt); }\n\n\n\n//////////////////////////////// 3D Point ///////////////////////////////\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_()\n    : x(0), y(0), z(0) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(_Tp _x, _Tp _y, _Tp _z)\n    : x(_x), y(_y), z(_z) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(const Point3_& pt)\n    : x(pt.x), y(pt.y), z(pt.z) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(Point3_&& pt) CV_NOEXCEPT\n    : x(std::move(pt.x)), y(std::move(pt.y)), z(std::move(pt.z)) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(const Point_<_Tp>& pt)\n    : x(pt.x), y(pt.y), z(_Tp()) {}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::Point3_(const Vec<_Tp, 3>& v)\n    : x(v[0]), y(v[1]), z(v[2]) {}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nPoint3_<_Tp>::operator Point3_<_Tp2>() const\n{\n    return Point3_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(z));\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>::operator Vec<_Tp, 3>() const\n{\n    return Vec<_Tp, 3>(x, y, z);\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>& Point3_<_Tp>::operator = (const Point3_& pt)\n{\n    x = pt.x; y = pt.y; z = pt.z;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp>& Point3_<_Tp>::operator = (Point3_&& pt) CV_NOEXCEPT\n{\n    x = std::move(pt.x); y = std::move(pt.y); z = std::move(pt.z);\n    return *this;\n}\n\ntemplate<typename _Tp> inline\n_Tp Point3_<_Tp>::dot(const Point3_& pt) const\n{\n    return saturate_cast<_Tp>(x*pt.x + y*pt.y + z*pt.z);\n}\n\ntemplate<typename _Tp> inline\ndouble Point3_<_Tp>::ddot(const Point3_& pt) const\n{\n    return (double)x*pt.x + (double)y*pt.y + (double)z*pt.z;\n}\n\ntemplate<typename _Tp> inline\nPoint3_<_Tp> Point3_<_Tp>::cross(const Point3_<_Tp>& pt) const\n{\n    return Point3_<_Tp>(y*pt.z - z*pt.y, z*pt.x - x*pt.z, x*pt.y - y*pt.x);\n}\n\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator += (Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    a.x += b.x;\n    a.y += b.y;\n    a.z += b.z;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator -= (Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    a.z -= b.z;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator *= (Point3_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    a.z = saturate_cast<_Tp>(a.z * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator *= (Point3_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    a.z = saturate_cast<_Tp>(a.z * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator *= (Point3_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x * b);\n    a.y = saturate_cast<_Tp>(a.y * b);\n    a.z = saturate_cast<_Tp>(a.z * b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator /= (Point3_<_Tp>& a, int b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    a.z = saturate_cast<_Tp>(a.z / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator /= (Point3_<_Tp>& a, float b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    a.z = saturate_cast<_Tp>(a.z / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp>& operator /= (Point3_<_Tp>& a, double b)\n{\n    a.x = saturate_cast<_Tp>(a.x / b);\n    a.y = saturate_cast<_Tp>(a.y / b);\n    a.z = saturate_cast<_Tp>(a.z / b);\n    return a;\n}\n\ntemplate<typename _Tp> static inline\ndouble norm(const Point3_<_Tp>& pt)\n{\n    return std::sqrt((double)pt.x*pt.x + (double)pt.y*pt.y + (double)pt.z*pt.z);\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return a.x == b.x && a.y == b.y && a.z == b.z;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return a.x != b.x || a.y != b.y || a.z != b.z;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator + (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x + b.x), saturate_cast<_Tp>(a.y + b.y), saturate_cast<_Tp>(a.z + b.z));\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator - (const Point3_<_Tp>& a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x - b.x), saturate_cast<_Tp>(a.y - b.y), saturate_cast<_Tp>(a.z - b.z));\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator - (const Point3_<_Tp>& a)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(-a.x), saturate_cast<_Tp>(-a.y), saturate_cast<_Tp>(-a.z) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Point3_<_Tp>& a, int b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x*b), saturate_cast<_Tp>(a.y*b), saturate_cast<_Tp>(a.z*b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (int a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Point3_<_Tp>& a, float b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (float a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Point3_<_Tp>& a, double b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(a.x * b), saturate_cast<_Tp>(a.y * b), saturate_cast<_Tp>(a.z * b) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (double a, const Point3_<_Tp>& b)\n{\n    return Point3_<_Tp>( saturate_cast<_Tp>(b.x * a), saturate_cast<_Tp>(b.y * a), saturate_cast<_Tp>(b.z * a) );\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator * (const Matx<_Tp, 3, 3>& a, const Point3_<_Tp>& b)\n{\n    Matx<_Tp, 3, 1> tmp = a * Vec<_Tp,3>(b.x, b.y, b.z);\n    return Point3_<_Tp>(tmp.val[0], tmp.val[1], tmp.val[2]);\n}\n\ntemplate<typename _Tp> static inline\nMatx<_Tp, 4, 1> operator * (const Matx<_Tp, 4, 4>& a, const Point3_<_Tp>& b)\n{\n    return a * Matx<_Tp, 4, 1>(b.x, b.y, b.z, 1);\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator / (const Point3_<_Tp>& a, int b)\n{\n    Point3_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator / (const Point3_<_Tp>& a, float b)\n{\n    Point3_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nPoint3_<_Tp> operator / (const Point3_<_Tp>& a, double b)\n{\n    Point3_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\n\n\n////////////////////////////////// Size /////////////////////////////////\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_()\n    : width(0), height(0) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(_Tp _width, _Tp _height)\n    : width(_width), height(_height) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(const Size_& sz)\n    : width(sz.width), height(sz.height) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(Size_&& sz) CV_NOEXCEPT\n    : width(std::move(sz.width)), height(std::move(sz.height)) {}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>::Size_(const Point_<_Tp>& pt)\n    : width(pt.x), height(pt.y) {}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nSize_<_Tp>::operator Size_<_Tp2>() const\n{\n    return Size_<_Tp2>(saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));\n}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>& Size_<_Tp>::operator = (const Size_<_Tp>& sz)\n{\n    width = sz.width; height = sz.height;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nSize_<_Tp>& Size_<_Tp>::operator = (Size_<_Tp>&& sz) CV_NOEXCEPT\n{\n    width = std::move(sz.width); height = std::move(sz.height);\n    return *this;\n}\n\ntemplate<typename _Tp> inline\n_Tp Size_<_Tp>::area() const\n{\n    const _Tp result = width * height;\n    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer\n        || width == 0 || result / width == height); // make sure the result fits in the return value\n    return result;\n}\n\ntemplate<typename _Tp> inline\ndouble Size_<_Tp>::aspectRatio() const\n{\n    return width / static_cast<double>(height);\n}\n\ntemplate<typename _Tp> inline\nbool Size_<_Tp>::empty() const\n{\n    return width <= 0 || height <= 0;\n}\n\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator *= (Size_<_Tp>& a, _Tp b)\n{\n    a.width *= b;\n    a.height *= b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator * (const Size_<_Tp>& a, _Tp b)\n{\n    Size_<_Tp> tmp(a);\n    tmp *= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator /= (Size_<_Tp>& a, _Tp b)\n{\n    a.width /= b;\n    a.height /= b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator / (const Size_<_Tp>& a, _Tp b)\n{\n    Size_<_Tp> tmp(a);\n    tmp /= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator += (Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    a.width += b.width;\n    a.height += b.height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator + (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    Size_<_Tp> tmp(a);\n    tmp += b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp>& operator -= (Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    a.width -= b.width;\n    a.height -= b.height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nSize_<_Tp> operator - (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    Size_<_Tp> tmp(a);\n    tmp -= b;\n    return tmp;\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    return a.width == b.width && a.height == b.height;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Size_<_Tp>& a, const Size_<_Tp>& b)\n{\n    return !(a == b);\n}\n\n\n\n////////////////////////////////// Rect /////////////////////////////////\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_()\n    : x(0), y(0), width(0), height(0) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height)\n    : x(_x), y(_y), width(_width), height(_height) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(const Rect_<_Tp>& r)\n    : x(r.x), y(r.y), width(r.width), height(r.height) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(Rect_<_Tp>&& r) CV_NOEXCEPT\n    : x(std::move(r.x)), y(std::move(r.y)), width(std::move(r.width)), height(std::move(r.height)) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz)\n    : x(org.x), y(org.y), width(sz.width), height(sz.height) {}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>::Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2)\n{\n    x = std::min(pt1.x, pt2.x);\n    y = std::min(pt1.y, pt2.y);\n    width = std::max(pt1.x, pt2.x) - x;\n    height = std::max(pt1.y, pt2.y) - y;\n}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>& Rect_<_Tp>::operator = ( const Rect_<_Tp>& r )\n{\n    x = r.x;\n    y = r.y;\n    width = r.width;\n    height = r.height;\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nRect_<_Tp>& Rect_<_Tp>::operator = ( Rect_<_Tp>&& r ) CV_NOEXCEPT\n{\n    x = std::move(r.x);\n    y = std::move(r.y);\n    width = std::move(r.width);\n    height = std::move(r.height);\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp> Rect_<_Tp>::tl() const\n{\n    return Point_<_Tp>(x,y);\n}\n\ntemplate<typename _Tp> inline\nPoint_<_Tp> Rect_<_Tp>::br() const\n{\n    return Point_<_Tp>(x + width, y + height);\n}\n\ntemplate<typename _Tp> inline\nSize_<_Tp> Rect_<_Tp>::size() const\n{\n    return Size_<_Tp>(width, height);\n}\n\ntemplate<typename _Tp> inline\n_Tp Rect_<_Tp>::area() const\n{\n    const _Tp result = width * height;\n    CV_DbgAssert(!std::numeric_limits<_Tp>::is_integer\n        || width == 0 || result / width == height); // make sure the result fits in the return value\n    return result;\n}\n\ntemplate<typename _Tp> inline\nbool Rect_<_Tp>::empty() const\n{\n    return width <= 0 || height <= 0;\n}\n\ntemplate<typename _Tp> template<typename _Tp2> inline\nRect_<_Tp>::operator Rect_<_Tp2>() const\n{\n    return Rect_<_Tp2>(saturate_cast<_Tp2>(x), saturate_cast<_Tp2>(y), saturate_cast<_Tp2>(width), saturate_cast<_Tp2>(height));\n}\n\ntemplate<typename _Tp> inline\nbool Rect_<_Tp>::contains(const Point_<_Tp>& pt) const\n{\n    return x <= pt.x && pt.x < x + width && y <= pt.y && pt.y < y + height;\n}\n\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator += ( Rect_<_Tp>& a, const Point_<_Tp>& b )\n{\n    a.x += b.x;\n    a.y += b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Point_<_Tp>& b )\n{\n    a.x -= b.x;\n    a.y -= b.y;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator += ( Rect_<_Tp>& a, const Size_<_Tp>& b )\n{\n    a.width += b.width;\n    a.height += b.height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator -= ( Rect_<_Tp>& a, const Size_<_Tp>& b )\n{\n    const _Tp width = a.width - b.width;\n    const _Tp height = a.height - b.height;\n    CV_DbgAssert(width >= 0 && height >= 0);\n    a.width = width;\n    a.height = height;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator &= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )\n{\n    _Tp x1 = std::max(a.x, b.x);\n    _Tp y1 = std::max(a.y, b.y);\n    a.width = std::min(a.x + a.width, b.x + b.width) - x1;\n    a.height = std::min(a.y + a.height, b.y + b.height) - y1;\n    a.x = x1;\n    a.y = y1;\n    if( a.width <= 0 || a.height <= 0 )\n        a = Rect();\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp>& operator |= ( Rect_<_Tp>& a, const Rect_<_Tp>& b )\n{\n    if (a.empty()) {\n        a = b;\n    }\n    else if (!b.empty()) {\n        _Tp x1 = std::min(a.x, b.x);\n        _Tp y1 = std::min(a.y, b.y);\n        a.width = std::max(a.x + a.width, b.x + b.width) - x1;\n        a.height = std::max(a.y + a.height, b.y + b.height) - y1;\n        a.x = x1;\n        a.y = y1;\n    }\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nbool operator == (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    return a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height;\n}\n\ntemplate<typename _Tp> static inline\nbool operator != (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    return a.x != b.x || a.y != b.y || a.width != b.width || a.height != b.height;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator + (const Rect_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Rect_<_Tp>( a.x + b.x, a.y + b.y, a.width, a.height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator - (const Rect_<_Tp>& a, const Point_<_Tp>& b)\n{\n    return Rect_<_Tp>( a.x - b.x, a.y - b.y, a.width, a.height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator + (const Rect_<_Tp>& a, const Size_<_Tp>& b)\n{\n    return Rect_<_Tp>( a.x, a.y, a.width + b.width, a.height + b.height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator - (const Rect_<_Tp>& a, const Size_<_Tp>& b)\n{\n    const _Tp width = a.width - b.width;\n    const _Tp height = a.height - b.height;\n    CV_DbgAssert(width >= 0 && height >= 0);\n    return Rect_<_Tp>( a.x, a.y, width, height );\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator & (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    Rect_<_Tp> c = a;\n    return c &= b;\n}\n\ntemplate<typename _Tp> static inline\nRect_<_Tp> operator | (const Rect_<_Tp>& a, const Rect_<_Tp>& b)\n{\n    Rect_<_Tp> c = a;\n    return c |= b;\n}\n\n/**\n * @brief measure dissimilarity between two sample sets\n *\n * computes the complement of the Jaccard Index as described in <https://en.wikipedia.org/wiki/Jaccard_index>.\n * For rectangles this reduces to computing the intersection over the union.\n */\ntemplate<typename _Tp> static inline\ndouble jaccardDistance(const Rect_<_Tp>& a, const Rect_<_Tp>& b) {\n    _Tp Aa = a.area();\n    _Tp Ab = b.area();\n\n    if ((Aa + Ab) <= std::numeric_limits<_Tp>::epsilon()) {\n        // jaccard_index = 1 -> distance = 0\n        return 0.0;\n    }\n\n    double Aab = (a & b).area();\n    // distance = 1 - jaccard_index\n    return 1.0 - Aab / (Aa + Ab - Aab);\n}\n\n////////////////////////////// RotatedRect //////////////////////////////\n\ninline\nRotatedRect::RotatedRect()\n    : center(), size(), angle(0) {}\n\ninline\nRotatedRect::RotatedRect(const Point2f& _center, const Size2f& _size, float _angle)\n    : center(_center), size(_size), angle(_angle) {}\n\n///////////////////////////////// Range /////////////////////////////////\n\ninline\nRange::Range()\n    : start(0), end(0) {}\n\ninline\nRange::Range(int _start, int _end)\n    : start(_start), end(_end) {}\n\ninline\nint Range::size() const\n{\n    return end - start;\n}\n\ninline\nbool Range::empty() const\n{\n    return start == end;\n}\n\ninline\nRange Range::all()\n{\n    return Range(INT_MIN, INT_MAX);\n}\n\n\nstatic inline\nbool operator == (const Range& r1, const Range& r2)\n{\n    return r1.start == r2.start && r1.end == r2.end;\n}\n\nstatic inline\nbool operator != (const Range& r1, const Range& r2)\n{\n    return !(r1 == r2);\n}\n\nstatic inline\nbool operator !(const Range& r)\n{\n    return r.start == r.end;\n}\n\nstatic inline\nRange operator & (const Range& r1, const Range& r2)\n{\n    Range r(std::max(r1.start, r2.start), std::min(r1.end, r2.end));\n    r.end = std::max(r.end, r.start);\n    return r;\n}\n\nstatic inline\nRange& operator &= (Range& r1, const Range& r2)\n{\n    r1 = r1 & r2;\n    return r1;\n}\n\nstatic inline\nRange operator + (const Range& r1, int delta)\n{\n    return Range(r1.start + delta, r1.end + delta);\n}\n\nstatic inline\nRange operator + (int delta, const Range& r1)\n{\n    return Range(r1.start + delta, r1.end + delta);\n}\n\nstatic inline\nRange operator - (const Range& r1, int delta)\n{\n    return r1 + (-delta);\n}\n\n\n\n///////////////////////////////// Scalar ////////////////////////////////\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_()\n{\n    this->val[0] = this->val[1] = this->val[2] = this->val[3] = 0;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(_Tp v0, _Tp v1, _Tp v2, _Tp v3)\n{\n    this->val[0] = v0;\n    this->val[1] = v1;\n    this->val[2] = v2;\n    this->val[3] = v3;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(const Scalar_<_Tp>& s) : Vec<_Tp, 4>(s) {\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(Scalar_<_Tp>&& s) CV_NOEXCEPT {\n    this->val[0] = std::move(s.val[0]);\n    this->val[1] = std::move(s.val[1]);\n    this->val[2] = std::move(s.val[2]);\n    this->val[3] = std::move(s.val[3]);\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>& Scalar_<_Tp>::operator=(const Scalar_<_Tp>& s) {\n    this->val[0] = s.val[0];\n    this->val[1] = s.val[1];\n    this->val[2] = s.val[2];\n    this->val[3] = s.val[3];\n    return *this;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>& Scalar_<_Tp>::operator=(Scalar_<_Tp>&& s) CV_NOEXCEPT {\n    this->val[0] = std::move(s.val[0]);\n    this->val[1] = std::move(s.val[1]);\n    this->val[2] = std::move(s.val[2]);\n    this->val[3] = std::move(s.val[3]);\n    return *this;\n}\n\ntemplate<typename _Tp> template<typename _Tp2, int cn> inline\nScalar_<_Tp>::Scalar_(const Vec<_Tp2, cn>& v)\n{\n    int i;\n    for( i = 0; i < (cn < 4 ? cn : 4); i++ )\n        this->val[i] = cv::saturate_cast<_Tp>(v.val[i]);\n    for( ; i < 4; i++ )\n        this->val[i] = 0;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp>::Scalar_(_Tp v0)\n{\n    this->val[0] = v0;\n    this->val[1] = this->val[2] = this->val[3] = 0;\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp> Scalar_<_Tp>::all(_Tp v0)\n{\n    return Scalar_<_Tp>(v0, v0, v0, v0);\n}\n\n\ntemplate<typename _Tp> inline\nScalar_<_Tp> Scalar_<_Tp>::mul(const Scalar_<_Tp>& a, double scale ) const\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(this->val[0] * a.val[0] * scale),\n                        saturate_cast<_Tp>(this->val[1] * a.val[1] * scale),\n                        saturate_cast<_Tp>(this->val[2] * a.val[2] * scale),\n                        saturate_cast<_Tp>(this->val[3] * a.val[3] * scale));\n}\n\ntemplate<typename _Tp> inline\nScalar_<_Tp> Scalar_<_Tp>::conj() const\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>( this->val[0]),\n                        saturate_cast<_Tp>(-this->val[1]),\n                        saturate_cast<_Tp>(-this->val[2]),\n                        saturate_cast<_Tp>(-this->val[3]));\n}\n\ntemplate<typename _Tp> inline\nbool Scalar_<_Tp>::isReal() const\n{\n    return this->val[1] == 0 && this->val[2] == 0 && this->val[3] == 0;\n}\n\n\ntemplate<typename _Tp> template<typename T2> inline\nScalar_<_Tp>::operator Scalar_<T2>() const\n{\n    return Scalar_<T2>(saturate_cast<T2>(this->val[0]),\n                       saturate_cast<T2>(this->val[1]),\n                       saturate_cast<T2>(this->val[2]),\n                       saturate_cast<T2>(this->val[3]));\n}\n\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator += (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a.val[0] += b.val[0];\n    a.val[1] += b.val[1];\n    a.val[2] += b.val[2];\n    a.val[3] += b.val[3];\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator -= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a.val[0] -= b.val[0];\n    a.val[1] -= b.val[1];\n    a.val[2] -= b.val[2];\n    a.val[3] -= b.val[3];\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator *= ( Scalar_<_Tp>& a, _Tp v )\n{\n    a.val[0] *= v;\n    a.val[1] *= v;\n    a.val[2] *= v;\n    a.val[3] *= v;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nbool operator == ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )\n{\n    return a.val[0] == b.val[0] && a.val[1] == b.val[1] &&\n           a.val[2] == b.val[2] && a.val[3] == b.val[3];\n}\n\ntemplate<typename _Tp> static inline\nbool operator != ( const Scalar_<_Tp>& a, const Scalar_<_Tp>& b )\n{\n    return a.val[0] != b.val[0] || a.val[1] != b.val[1] ||\n           a.val[2] != b.val[2] || a.val[3] != b.val[3];\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator + (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return Scalar_<_Tp>(a.val[0] + b.val[0],\n                        a.val[1] + b.val[1],\n                        a.val[2] + b.val[2],\n                        a.val[3] + b.val[3]);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator - (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(a.val[0] - b.val[0]),\n                        saturate_cast<_Tp>(a.val[1] - b.val[1]),\n                        saturate_cast<_Tp>(a.val[2] - b.val[2]),\n                        saturate_cast<_Tp>(a.val[3] - b.val[3]));\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator * (const Scalar_<_Tp>& a, _Tp alpha)\n{\n    return Scalar_<_Tp>(a.val[0] * alpha,\n                        a.val[1] * alpha,\n                        a.val[2] * alpha,\n                        a.val[3] * alpha);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)\n{\n    return a*alpha;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator - (const Scalar_<_Tp>& a)\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(-a.val[0]),\n                        saturate_cast<_Tp>(-a.val[1]),\n                        saturate_cast<_Tp>(-a.val[2]),\n                        saturate_cast<_Tp>(-a.val[3]));\n}\n\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator * (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return Scalar_<_Tp>(saturate_cast<_Tp>(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3]),\n                        saturate_cast<_Tp>(a[0]*b[1] + a[1]*b[0] + a[2]*b[3] - a[3]*b[2]),\n                        saturate_cast<_Tp>(a[0]*b[2] - a[1]*b[3] + a[2]*b[0] + a[3]*b[1]),\n                        saturate_cast<_Tp>(a[0]*b[3] + a[1]*b[2] - a[2]*b[1] + a[3]*b[0]));\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator *= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a = a * b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator / (const Scalar_<_Tp>& a, _Tp alpha)\n{\n    return Scalar_<_Tp>(a.val[0] / alpha,\n                        a.val[1] / alpha,\n                        a.val[2] / alpha,\n                        a.val[3] / alpha);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<float> operator / (const Scalar_<float>& a, float alpha)\n{\n    float s = 1 / alpha;\n    return Scalar_<float>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<double> operator / (const Scalar_<double>& a, double alpha)\n{\n    double s = 1 / alpha;\n    return Scalar_<double>(a.val[0] * s, a.val[1] * s, a.val[2] * s, a.val[3] * s);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator /= (Scalar_<_Tp>& a, _Tp alpha)\n{\n    a = a / alpha;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator / (_Tp a, const Scalar_<_Tp>& b)\n{\n    _Tp s = a / (b[0]*b[0] + b[1]*b[1] + b[2]*b[2] + b[3]*b[3]);\n    return b.conj() * s;\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp> operator / (const Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    return a * ((_Tp)1 / b);\n}\n\ntemplate<typename _Tp> static inline\nScalar_<_Tp>& operator /= (Scalar_<_Tp>& a, const Scalar_<_Tp>& b)\n{\n    a = a / b;\n    return a;\n}\n\ntemplate<typename _Tp> static inline\nScalar operator * (const Matx<_Tp, 4, 4>& a, const Scalar& b)\n{\n    Matx<double, 4, 1> c((Matx<double, 4, 4>)a, b, Matx_MatMulOp());\n    return reinterpret_cast<const Scalar&>(c);\n}\n\ntemplate<> inline\nScalar operator * (const Matx<double, 4, 4>& a, const Scalar& b)\n{\n    Matx<double, 4, 1> c(a, b, Matx_MatMulOp());\n    return reinterpret_cast<const Scalar&>(c);\n}\n\n\n\n//////////////////////////////// KeyPoint ///////////////////////////////\n\ninline\nKeyPoint::KeyPoint()\n    : pt(0,0), size(0), angle(-1), response(0), octave(0), class_id(-1) {}\n\ninline\nKeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)\n    : pt(_pt), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}\n\ninline\nKeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)\n    : pt(x, y), size(_size), angle(_angle), response(_response), octave(_octave), class_id(_class_id) {}\n\n\n\n///////////////////////////////// DMatch ////////////////////////////////\n\ninline\nDMatch::DMatch()\n    : queryIdx(-1), trainIdx(-1), imgIdx(-1), distance(FLT_MAX) {}\n\ninline\nDMatch::DMatch(int _queryIdx, int _trainIdx, float _distance)\n    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(-1), distance(_distance) {}\n\ninline\nDMatch::DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance)\n    : queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx), distance(_distance) {}\n\ninline\nbool DMatch::operator < (const DMatch &m) const\n{\n    return distance < m.distance;\n}\n\n\n\n////////////////////////////// TermCriteria /////////////////////////////\n\ninline\nTermCriteria::TermCriteria()\n    : type(0), maxCount(0), epsilon(0) {}\n\ninline\nTermCriteria::TermCriteria(int _type, int _maxCount, double _epsilon)\n    : type(_type), maxCount(_maxCount), epsilon(_epsilon) {}\n\n//! @endcond\n\n} // cv\n\n#endif //OPENCV_CORE_TYPES_HPP\n",
			"file": "/usr/include/opencv4/opencv2/core/types.hpp",
			"file_size": 72186,
			"file_write_time": 132135618280000000,
			"settings":
			{
				"buffer_size": 72187,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/basicscanner.cpp",
			"settings":
			{
				"buffer_size": 4062,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 126.0,
		"last_filter": "install pa",
		"selected_items":
		[
			[
				"install pa",
				"Package Control: Install Package"
			],
			[
				"tags",
				"CTags: Show Symbols (all)"
			],
			[
				"outline",
				"Browse Mode: Outline (Right)"
			]
		],
		"width": 583.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Dokumente/Sources/contours/plot-cv"
	],
	"file_history":
	[
		"/home/roman/Dokumente/Sources/contours/plot-cv/plot-cv.sublime-project",
		"/usr/include/opencv4/opencv2/core/types",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src/line.h",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src/CannyWebcam1.cpp"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 109.0,
		"where_history":
		[
			"/home/roman/Dokumente/Sources/contours/plot-cv,*.cpp,*.h*",
			"/home/roman/Dokumente/Sources/contours/plot-cv,*.cpp,*.h",
			"/home/roman/Dokumente/Sources/contours/plot-cv,*.cpp",
			"/home/roman/Dokumente/Sources/contours/plot-cv",
			"/home/roman/Dokumente/Sources/contours/plot-cv/src",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"lines.cbeg",
			"filterLines",
			"lineType",
			"filterLin",
			"-> bool",
			"Pred",
			"filterL",
			"lINE<",
			"filterLines",
			"filterLine",
			"ilterLine",
			"filterLine",
			"filterLines",
			"filterLin",
			"filterLines",
			"filterLine",
			"pair",
			"adjacency_list",
			"adjacent\\.",
			"adjacent",
			"filteredLines",
			"adjacent",
			"filterLine",
			"filterLines",
			"<< par",
			"operator<<",
			"parallel",
			"<< para",
			"<<",
			"filterLines",
			"adjacent",
			"linesHier",
			"lineHier",
			"\\.cend",
			"\\.cbegin",
			"const Line",
			"const.* Line",
			"const.*Line",
			"lines.cbegi",
			"lines.cend",
			"const Line<float>",
			"min_dis",
			"LineEnd",
			"min_dis",
			"LineEnd",
			"min_dis",
			"std::ssize_t",
			"ssize_t",
			"LineEnd",
			"min_dis",
			"lineDis",
			"distances",
			"Vec4i",
			"ostr",
			" list",
			"list",
			"std::vec",
			"std::",
			"main\\(",
			"Vec4i",
			"frame-",
			"min_dist",
			"dist.secon",
			"point_dis",
			"ValueT",
			"point_dis",
			"point_distance",
			"point_distance\n",
			"point_dist",
			"endpoint_distance",
			"point_distance",
			"point_dis",
			"point_distance",
			"sqrt",
			"Point_",
			"sqrt",
			"Point_",
			"distance",
			"min_dist",
			"gleoff",
			"to_string",
			"segment_dis",
			"']'",
			"to_string",
			"-> \"",
			"<<\\(",
			"<<(",
			"filterLines",
			"to_string",
			"template.*template",
			"template.*CLASS",
			"to_str",
			"<<",
			"<< ",
			"to_string",
			"operator<<",
			"to_string",
			"lines",
			"to_string",
			"656",
			"std::bas",
			"to_str",
			"basic_str",
			"to_string",
			"<<",
			"to_string",
			"enable_if",
			"to_strin",
			"to_string",
			"pivot",
			"line\\.",
			"angleoff",
			"angle\\(",
			"angle",
			"segment_distance2",
			"min_dis",
			"intersect",
			"cv::Point_<ValueT>",
			"intersec",
			"91",
			"intersect",
			"slopeVector",
			"Line2D_",
			"min_distance",
			"lineDistances",
			"lineDis",
			"interse",
			"segment"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"value_type",
			"adjacent_lines.",
			".end",
			".begin",
			"Line",
			"lines.begi",
			"lines.end",
			"Line<float>",
			"int",
			"",
			"point_type",
			"Line",
			"other.a",
			"b",
			"a",
			"other.\\1",
			"ContainerT",
			"lines",
			"point_type"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 733,
						"regions":
						{
						},
						"selection":
						[
							[
								537,
								537
							]
						],
						"settings":
						{
							"current_file": "/home/roman/Dokumente/Sources/contours/plot-cv/src/CannyWebcam1.cpp",
							"outline_rename_mode": false,
							"symkeys":
							[
								[
									510,
									518
								],
								[
									553,
									563
								],
								[
									854,
									866
								],
								[
									987,
									999
								],
								[
									1139,
									1155
								],
								[
									1231,
									1241
								],
								[
									2038,
									2047
								],
								[
									2150,
									2158
								],
								[
									2442,
									2452
								],
								[
									2728,
									2743
								],
								[
									3176,
									3195
								],
								[
									3725,
									3744
								],
								[
									4376,
									4397
								],
								[
									4502,
									4515
								],
								[
									4812,
									4827
								],
								[
									4999,
									5009
								],
								[
									6338,
									6349
								],
								[
									7175,
									7185
								],
								[
									8178,
									8203
								],
								[
									10334,
									10355
								],
								[
									10804,
									10815
								],
								[
									11142,
									11156
								],
								[
									11573,
									11583
								],
								[
									11886,
									11891
								],
								[
									12167,
									12181
								],
								[
									13595,
									13608
								],
								[
									13800,
									13811
								],
								[
									13977,
									13987
								],
								[
									14305,
									14314
								],
								[
									14542,
									14563
								],
								[
									15396,
									15404
								],
								[
									15462,
									15472
								],
								[
									15703,
									15718
								],
								[
									16181,
									16193
								],
								[
									16402,
									16415
								],
								[
									16820,
									16831
								],
								[
									16912,
									16925
								],
								[
									16994,
									17004
								],
								[
									17264,
									17279
								],
								[
									17387,
									17395
								],
								[
									17448,
									17459
								],
								[
									17761,
									17772
								],
								[
									17857,
									17870
								],
								[
									17939,
									17949
								],
								[
									17993,
									18003
								],
								[
									18039,
									18047
								],
								[
									18307,
									18320
								],
								[
									18449,
									18462
								],
								[
									18531,
									18540
								],
								[
									18583,
									18593
								],
								[
									18624,
									18632
								],
								[
									18926,
									18936
								],
								[
									19052,
									19065
								],
								[
									19318,
									19322
								],
								[
									23050,
									23059
								],
								[
									23093,
									23102
								],
								[
									23130,
									23138
								]
							],
							"symlist":
							[
								"PointVec",
								"Point2fVec",
								"coordPointer",
								"coordPointer",
								"simplifyPolyline",
								"coord_type",
								"out_point",
								"out_hier",
								"out_points",
								"filter_contours",
								"polylineFromContour",
								"cv::Scalar\nHSVtoRGB",
								"svg::Color\nfromScalar",
								"convertPoints",
								"transformPoints",
								"export_svg",
								"polygonArea",
								"applyCLAHE",
								"BrightnessAndContrastAuto",
								"cv::Mat\nimageToBinary",
								"getContours",
								"getMassCenters",
								"ToPointVec",
								"angle",
								"findRectangles",
								"drawPolylines",
								"invertColor",
								"houghLines",
								"drawLines",
								"cornerHarrisDetection",
								"trackbar",
								"writeImage",
								"drawAllContours",
								"drawAllLines",
								"iterator_type",
								"filterLines",
								"iterator_type",
								"value_type",
								"PredicateTraits",
								" function",
								"filterLines",
								"angle_diffs",
								"iterator_type",
								"point_type",
								"value_type",
								"ret_type",
								"lineDistances",
								"iterator_type",
								"line_type",
								"value_type",
								"ret_type",
								"operator<<",
								"iterator_type",
								"main",
								"line_type",
								"line_list",
								"ref_list"
							],
							"syntax": "Packages/Outline/outline.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 1,
					"file": "/home/roman/lotto/utils/dom.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 95931,
						"regions":
						{
						},
						"selection":
						[
							[
								52419,
								52419
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/Babel/JavaScript (Babel).sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"use_tab_stops": false
						},
						"translation.x": 0.0,
						"translation.y": 31314.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/CannyWebcam1.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31253,
						"regions":
						{
						},
						"selection":
						[
							[
								17761,
								17772
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"typescript_plugin_format_options":
							{
								"convertTabsToSpaces": true,
								"indentSize": 2,
								"tabSize": 2
							}
						},
						"translation.x": 0.0,
						"translation.y": 9629.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "polygon.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7597,
						"regions":
						{
						},
						"selection":
						[
							[
								7242,
								7242
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3128.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/psimpl.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 70996,
						"regions":
						{
						},
						"selection":
						[
							[
								13409,
								13409
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6501.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/line.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9722,
						"regions":
						{
						},
						"selection":
						[
							[
								9722,
								9722
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"typescript_plugin_format_options":
							{
								"convertTabsToSpaces": true,
								"indentSize": 2,
								"tabSize": 2
							}
						},
						"translation.x": 0.0,
						"translation.y": 6088.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/usr/include/opencv4/opencv2/core/core.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2368,
						"regions":
						{
						},
						"selection":
						[
							[
								2,
								2
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/usr/include/opencv2",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/usr/include/opencv4/opencv2/core/types.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 72187,
						"regions":
						{
						},
						"selection":
						[
							[
								38197,
								38197
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 19457.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "src/basicscanner.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4062,
						"regions":
						{
						},
						"selection":
						[
							[
								601,
								601
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "<",
									"selector": "text.html"
								},
								{
									"characters": ".#",
									"selector": "text.html"
								}
							],
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1632.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 25.0
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				2,
				0,
				3,
				2
			],
			[
				0,
				0,
				2,
				2
			]
		],
		"cols":
		[
			0.0,
			0.2,
			0.8,
			1.0
		],
		"rows":
		[
			0.0,
			0.5,
			1.0
		]
	},
	"menu_visible": true,
	"output.CSS Extended Completions":
	{
		"height": 0.0
	},
	"output.doc":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "plot-cv.sublime-project",
	"replace":
	{
		"height": 74.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"canny",
				"src/CannyWebcam1.cpp"
			],
			[
				"line",
				"src/line.h"
			],
			[
				"cann",
				"src/CannyWebcam1.cpp"
			],
			[
				"psim",
				"src/psimpl.h"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
