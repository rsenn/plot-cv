{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"poly",
				"polygonArea"
			],
			[
				"Parsigr",
				"ParsigramBalances"
			],
			[
				"require_",
				"require_parsigram"
			],
			[
				"capture_",
				"capture_api_errors"
			],
			[
				"acti",
				"activate_token"
			],
			[
				"encode",
				"encode_query_string"
			],
			[
				"getaddres",
				"getaddressesbylabel\tabc"
			],
			[
				"split",
				"split_string\tabc"
			],
			[
				"capture",
				"capture_api_errors\tabc"
			],
			[
				"Trans",
				"TransactionEndpoint\tabc"
			],
			[
				"capture_er",
				"capture_errors_json"
			],
			[
				"cap",
				"capture_errors_json"
			]
		]
	},
	"buffers":
	[
		{
			"file": "CMakeLists.txt",
			"settings":
			{
				"buffer_size": 7621,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/adaptiveThresholding.cpp",
			"settings":
			{
				"buffer_size": 2144,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/9a.Training.cpp",
			"settings":
			{
				"buffer_size": 5992,
				"line_ending": "Windows"
			}
		},
		{
			"file": "src/c",
			"settings":
			{
				"buffer_size": 4968,
				"line_ending": "Unix"
			}
		},
		{
			"file": "o_angle.cpp",
			"settings":
			{
				"buffer_size": 7645,
				"encoding": "UTF-8 with BOM",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "// OpenCVWebcamTest.cpp\n\n#include <opencv2/core/core.hpp>\n#include <opencv2/highgui/highgui.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n\n#include <iostream>\ntypedef std::vector<cv::Point> PointVec;\ntypedef std::vector<cv::Point2f> Point2fVec;\n\nint thresh = 10;\nint max_thresh = 255;\n\n// Function that calculates the absolute value\n\ntemplate <class T, class O>\nvoid\nout_point(O& os, const cv::Point_<T>& pt) {\n  os << pt.x;\n  os << ',';\n  os << pt.y;\n}\n\ntemplate <class O>\nvoid\nout_hier(O& os, const cv::Vec4i& v) {\n  os << '{';\n  os << \"next:\" << v[0];\n  os << \",prev:\" << v[1];\n  os << \",children:\" << v[2];\n  os << \",parent:\" << v[3];\n  os << '}';\n}\n\n/**\n * @brief      Ã”utput point list\n * @return     { description_of_the_return_value }\n */\ntemplate <class O>\nvoid\nout_points(O& os, const std::vector<cv::Point>& pl) {\n  size_t i, n = pl.size();\n  for(i = 0; i < n; ++i) {\n    if(i > 0)\n      os << ' ';\n    out_point(os, pl[i]);\n  }\n}\n\ntemplate <class T>\nstd::string\nto_string(const T& t) {\n  std::ostringstream oss;\n  oss << t;\n  return oss.str();\n}\n\n// of a double type.\ndouble\nnumAbs(double num) {\n  double inv = num * -1;\n  return (num <= 0) ? inv : num;\n}\n// Function that calculates the area given a\n// std::vector of vertices in the XY plane.\ntemplate <class P>\ndouble\npolygonArea(std::vector<P> list) {\n\n  if(list.size() < 3)\n    return 0;\n  double area = 0;                     // Total Area\n  double diff = 0;                     // Difference Of Y{i + 1} - Y{i - 1}\n  unsigned int last = list.size() - 1; // Size Of Vector - 1\n  /* Given vertices from 1 to n, we first loop through\n  the vertices 2 to n - 1. We will take into account\n  vertex 1 and vertex n sepereately */\n  for(unsigned int i = 1; i < last; i++) {\n    diff = list[i + 1].y - list[i - 1].y;\n    area += list[i].x * diff;\n  }\n  /* Now We Consider The Vertex 1 And The Vertex N */\n  diff = list[1].y - list[last].y;\n  area += list[0].x * diff; // Vertex 1\n  diff = list[0].y - list[last - 1].y;\n  area += list[last].x * diff; // Vertex N\n  /* Calculate The Final Answer */\n  area = 0.5 * numAbs(area);\n  return area; // Return The Area\n}\n\nvoid\napplyCLAHE(const cv::Mat& bgr_image, cv::Mat& image_clahe) {\n  cv::Mat lab_image;\n  cv::cvtColor(bgr_image, lab_image, CV_BGR2Lab);\n\n  // Extract the L channel\n  std::vector<cv::Mat> lab_planes(3);\n  cv::split(lab_image, lab_planes); // now we have the L image in lab_planes[0]\n\n  // apply the CLAHE algorithm to the L channel\n  cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE();\n  clahe->setClipLimit(4);\n  cv::Mat dst;\n  clahe->apply(lab_planes[0], dst);\n\n  // Merge the the color planes back into an Lab image\n  dst.copyTo(lab_planes[0]);\n  cv::merge(lab_planes, lab_image);\n\n  // convert back to RGB\n  cv::cvtColor(lab_image, image_clahe, CV_Lab2BGR);\n}\n\n/**\n *  \\brief Automatic brightness and contrast optimization with optional histogram clipping\n *  \\param [in]src Input image GRAY or BGR or BGRA\n *  \\param [out]dst Destination image\n *  \\param clipHistPercent cut wings of histogram at given percent tipical=>1, 0=>Disabled\n *  \\note In case of BGRA image, we won't touch the transparency\n */\nvoid\nBrightnessAndContrastAuto(const cv::Mat& src, cv::Mat& dst, float clipHistPercent = 0) {\n\n  CV_Assert(clipHistPercent >= 0);\n  CV_Assert((src.type() == CV_8UC1) || (src.type() == CV_8UC3) || (src.type() == CV_8UC4));\n\n  int histSize = 256;\n  float alpha, beta;\n  double minGray = 0, maxGray = 0;\n\n  // to calculate grayscale histogram\n  cv::Mat gray;\n  if(src.type() == CV_8UC1)\n    gray = src;\n  else if(src.type() == CV_8UC3)\n    cvtColor(src, gray, CV_BGR2GRAY);\n  else if(src.type() == CV_8UC4)\n    cvtColor(src, gray, CV_BGRA2GRAY);\n  if(clipHistPercent == 0) {\n    // keep full available range\n    cv::minMaxLoc(gray, &minGray, &maxGray);\n  } else {\n    cv::Mat hist; // the grayscale histogram\n\n    float range[] = {0, 256};\n    const float* histRange = {range};\n    bool uniform = true;\n    bool accumulate = false;\n    calcHist(&gray, 1, 0, cv::Mat(), hist, 1, &histSize, &histRange, uniform, accumulate);\n\n    // calculate cumulative distribution from the histogram\n    std::vector<float> accumulator(histSize);\n    accumulator[0] = hist.at<float>(0);\n    for(int i = 1; i < histSize; i++) {\n      accumulator[i] = accumulator[i - 1] + hist.at<float>(i);\n    }\n\n    // locate points that cuts at required value\n    float max = accumulator.back();\n    clipHistPercent *= (max / 100.0); // make percent as absolute\n    clipHistPercent /= 2.0;           // left and right wings\n    // locate left cut\n    minGray = 0;\n    while(accumulator[minGray] < clipHistPercent) minGray++;\n\n    // locate right cut\n    maxGray = histSize - 1;\n    while(accumulator[maxGray] >= (max - clipHistPercent)) maxGray--;\n  }\n\n  // current range\n  float inputRange = maxGray - minGray;\n\n  alpha = (histSize - 1) / inputRange; // alpha expands current range to histsize range\n  beta = -minGray * alpha;             // beta shifts current range so that minGray will go to 0\n\n  // Apply brightness and contrast normalization\n  // convertTo operates with saurate_cast\n  src.convertTo(dst, -1, alpha, beta);\n\n  // restore alpha channel from source\n  if(dst.type() == CV_8UC4) {\n    int from_to[] = {3, 3};\n    cv::mixChannels(&src, 4, &dst, 1, from_to, 1);\n  }\n  return;\n}\ncv::Mat\nimageToBinary(cv::Mat start) {\n  cv::Mat gray_image, thresh_image;\n  cvtColor(start, gray_image, CV_BGR2GRAY);\n  threshold(gray_image, thresh_image, 100, 255, cv::THRESH_BINARY);\n\n  medianBlur(thresh_image, thresh_image, 5);\n\n  return thresh_image;\n}\n\n/**\n * @brief      Gets the contours.\n *\n * @param[in]  start      The start\n * @param      hierarchy  The hierarchy\n * @param[in]  flag       The flag\n *\n * @return     The contours.\n */\nstd::vector<PointVec>\ngetContours(cv::Mat start, std::vector<cv::Vec4i>& hierarchy, int flag = CV_RETR_EXTERNAL) {\n\n  cv::Mat dst = cv::Mat::zeros(start.rows, start.cols, CV_8UC3);\n  std::vector<PointVec> contours;\n\n  start = start > 1;\n\n  cv::findContours(start, contours, hierarchy, flag, CV_CHAIN_APPROX_SIMPLE);\n\n  return contours;\n}\n\nstd::vector<cv::Point2f>\ngetMassCenters(std::vector<std::vector<cv::Point>> contours) {\n\n  std::vector<cv::Moments> mu(contours.size());\n  std::vector<cv::Point2f> mc(contours.size());\n\n  for(size_t i = 0; i < contours.size(); i++) {\n    mu[i] = cv::moments(contours[i], false);\n  }\n\n  for(size_t i = 0; i < contours.size(); i++) {\n    mc[i] = cv::Point2f(mu[i].m10 / mu[i].m00, mu[i].m01 / mu[i].m00);\n  }\n\n  return mc;\n}\n\ntemplate <class InputType>\nstd::vector<cv::Point>\nToPointVec(const std::vector<InputType>& v) {\n  std::vector<cv::Point> ret;\n\n  std::for_each(v.cbegin(), v.cend(), [&ret](const InputType& pt) { ret.push_back(cv::Point(pt.x, pt.y)); });\n\n  return ret;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\nint\nmain(int argc, char* argv[]) {\n  int camID = argc > 1 ? atoi(argv[1]) : 0;\n\n  cv::VideoCapture capWebcam(camID); // declare a VideoCapture object and associate to webcam, 0 => use 1st webcam\n\n  if(capWebcam.isOpened() == false) { // check if VideoCapture object was associated to webcam successfully\n    std::cout << \"error: capWebcam not accessed successfully\\n\\n\"; // if not, print error message to std out\n    getchar();                                                     // may have to modify this line if not using Windows\n    return (0);                                                    // and exit program\n  }\n\n  cv::Mat imgRaw, imgOriginal, imgTemp, imgGrayscale, imgBlurred, imgCanny; // Canny edge image\n\n  char charCheckForEscKey = 0;\n\n  // declare windows\n  //  note: you can use CV_WINDOW_NORMAL which allows resizing the window\n  cv::namedWindow(\"imgOriginal\", CV_WINDOW_AUTOSIZE);\n  // or CV_WINDOW_AUTOSIZE for a fixed size window matching the resolution of the image\n  cv::namedWindow(\"imgCanny\", CV_WINDOW_AUTOSIZE);\n  cv::namedWindow(\"imgGrayscale\", CV_WINDOW_AUTOSIZE);\n\n  while(charCheckForEscKey != 27 && capWebcam.isOpened()) { // until the Esc key is pressed or webcam connection is lost\n    bool blnFrameReadSuccessfully = capWebcam.read(imgRaw); // get next frame\n\n    if(!blnFrameReadSuccessfully || imgRaw.empty()) {     // if frame not read successfully\n      std::cout << \"error: frame not read from webcam\\n\"; // print error message to std out\n      break;                                              // and jump out of while loop\n    }\n    // cv::normalize(imgOriginal,imgTemp,0,255,cv::NORM_L1);\n    imgRaw.copyTo(imgOriginal);\n\n    cvtColor(imgOriginal, imgGrayscale, CV_BGR2GRAY); // convert to grayscale\n\n    /// Apply Histogram Equalization\n    //  cv::equalizeHist(imgTemp, imgGrayscale);\n\n    cv::GaussianBlur(imgGrayscale, imgBlurred, cv::Size(5, 5), 1.75);\n\n    cv::Canny(imgBlurred, imgCanny, thresh, thresh * 2, 3);\n    equalizeHist(imgGrayscale, imgGrayscale);\n\n    //  applyCLAHE(imgOriginal, imgOriginal);XY\n\n    std::vector<Point2fVec> contours2;\n    std::vector<cv::Vec4i> hier;\n    std::vector<PointVec> contours = getContours(imgCanny, hier, CV_RETR_TREE);\n\n    std::ostringstream contourStr;\n\n    std::for_each(contours.cbegin(), contours.cend(), [&](const std::vector<cv::Point>& a) {\n      if(a.size() >= 3) {\n\n        if(contourStr.str().size())\n          contourStr << \"\\n\";\n        out_points(contourStr, a);\n      }\n    });\n\n    std::cout << contourStr.str() << std::endl;\n\n    for(size_t i = 0; i < contours.size(); ++i) {\n      std::vector<cv::Point> c = contours[i];\n      cv::Vec4i h = hier[i];\n\n      std::cout << '#' << i << std::endl;\n      out_points(std::cout, c);\n      ///  std::cout << c << std::endl;\n      out_hier(std::cout, h);\n      std::cout << std::endl;\n    }\n\n    //       cv:: drawContours( imgOriginal, contours, -1, cv::Scalar(0,0,255), 1, cv::LINE_AA, hier );\n\n    /*\n        std::for_each(contours.cbegin(), contours.cend(), [&contours2](const std::vector<cv::Point>& a) {\n          double area = polygonArea(a);\n          if(a.size() >= 3 && area > 8) {\n            Point2fVec b;\n            cv::approxPolyDP(a, b, 0.5, true);\n            contours2.push_back(b);\n          }\n        });\n\n        std::sort(contours2.begin(), contours2.end(), [](Point2fVec a, Point2fVec b) -> bool {\n          return polygonArea<cv::Point2f>(a) >= polygonArea<cv::Point2f>(b);\n        });\n\n        for(size_t i = 0; i < std::min<size_t>(100, contours2.size()); ++i) {\n          int npts = contours2[i].size();\n          double area = polygonArea(contours2[i]);\n        //  std::cout << i << \": \" << area << std::endl;\nh s\n          if(npts > 0) {\n            std::vector<cv::Point> pl = ToPointVec(contours2[i]);\n            cv::polylines(imgOriginal, pl, true, cv::Scalar(0, 0, 255), 1);\n          }\n        }\n    */\n    // CV_WINDOW_AUTOSIZE is the default\n    cv::imshow(\"imgOriginal\", imgOriginal);   // show windows\n    cv::imshow(\"imgCanny\", imgCanny);         //\n    cv::imshow(\"imgGrayscale\", imgGrayscale); //\n\n    charCheckForE bscKey = cv::waitKey(1); // delay (in ms) and get key press, if any\n  }                                      // end while\n\n  return (0);\n}\n",
			"file": "src/CannyWebcam1.cpp",
			"file_size": 11098,
			"file_write_time": 132127441931602671,
			"settings":
			{
				"buffer_size": 11102,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/simple_svg_writer.h",
			"settings":
			{
				"buffer_size": 11340,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/Contour_detection.cpp",
			"settings":
			{
				"buffer_size": 1660,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/warpPerspective_demo.cpp",
			"settings":
			{
				"buffer_size": 5568,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 342 files for \"VideoCapture\\([^)]\" (regex, case sensitive)\n\n/home/roman/Dokumente/Sources/contours/plot-cv/camera_c.cpp:\n   30:   capture = new VideoCapture(0);\n\n/home/roman/Dokumente/Sources/contours/plot-cv/cameraimages.cpp:\n   23:   mImageCapture = new cv::VideoCapture(*mImagePath);\n\n/home/roman/Dokumente/Sources/contours/plot-cv/capturecontroller.cpp:\n   25:     m_capture = new cv::VideoCapture(deviceId);\n   27:     m_capture = new cv::VideoCapture(\n   28:         \"rkcamsrc device=/dev/video0 io-mode=4 ! video/x-raw,format=NV12,width=640,height=480 ! videoconvert ! appsink\",\n\n/home/roman/Dokumente/Sources/contours/plot-cv/src/cap.cpp:\n  476: VideoCapture::VideoCapture(const string& filename) { open(filename); }\n  478: VideoCapture::VideoCapture(int device) { open(device); }\n\n/home/roman/Dokumente/Sources/contours/plot-cv/src/cvcap.cpp:\n  330: VideoCapture::VideoCapture(const string& filename) { open(filename); }\n  332: VideoCapture::VideoCapture(int device) { open(device); }\n\n/home/roman/Dokumente/Sources/contours/plot-cv/src/kinfu_demo.cpp:\n  103:       vc = VideoCapture(VideoCaptureAPIs::CAP_OPENNI2 + cam);\n  107:         vc = VideoCapture(VideoCaptureAPIs::CAP_REALSENSE + cam);\n\n/home/roman/Dokumente/Sources/contours/plot-cv/src/native.cpp:\n  107:         engine->capture = new cv::VideoCapture(0);\n\n/home/roman/Dokumente/Sources/contours/plot-cv/utils.cpp:\n   59:     cap = VideoCapture(filename);\n   61:     cap = VideoCapture(0);\n\n/home/roman/Dokumente/Sources/contours/plot-cv/VideoCapture.cpp:\n   60: //   VideoCapture::VideoCapture(int device)\n   67:   static const char method_name[] = \"highgui::VideoCapture::VideoCapture(int device)\";\n   70:     VideoCapture* _retval_ = new VideoCapture(device);\n\n/home/roman/Dokumente/Sources/contours/plot-cv/yastereocam.cpp:\n   11:   _capL = new cv::VideoCapture(0);\n   23:   _capR = new cv::VideoCapture(1);\n\n18 matches across 10 files\n",
			"settings":
			{
				"buffer_size": 1920,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "camera_c.cpp",
			"settings":
			{
				"buffer_size": 6276,
				"line_ending": "Unix"
			}
		},
		{
			"file": "capturecontroller.cpp",
			"settings":
			{
				"buffer_size": 4108,
				"line_ending": "Unix"
			}
		},
		{
			"file": "cap_winrt_capture.cpp",
			"settings":
			{
				"buffer_size": 6079,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Makefile/Make.sublime-build",
					""
				],
				[
					"Packages/Makefile/Make.sublime-build",
					"Clean"
				]
			],
			[
				"Packages/Makefile/Make.sublime-build",
				"Clean"
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"schemee",
				"SchemeEditor: Edit Current Scheme"
			],
			[
				"out",
				"Browse Mode: Outline (Right)"
			],
			[
				"schemd",
				"SchemeEditor: Edit Current Scheme"
			],
			[
				"install pac",
				"Package Control: Install Package"
			],
			[
				"add re",
				"Package Control: Add Repository"
			],
			[
				"install ",
				"Package Control: Install Package"
			],
			[
				"install pa",
				"Package Control: Install Package"
			],
			[
				"adva",
				"Package Control: Advanced Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"instalp",
				"Package Control: Install Package"
			],
			[
				"schemeed",
				"SchemeEditor: Edit Current Scheme"
			],
			[
				"adv",
				"Package Control: Advanced Install Package"
			],
			[
				"html",
				"HTMLPrettify"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"install p",
				"Package Control: Install Package"
			],
			[
				"install pack",
				"Package Control: Install Package"
			],
			[
				"Package Control: install",
				"Package Control: Install Package"
			],
			[
				"edit ",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"scheme",
				"Color Scheme Editor: Goto previous matching scope"
			],
			[
				"INSTALL",
				"Package Control: Install Package"
			],
			[
				"INST",
				"Package Control: Install Package"
			],
			[
				"REMOVE",
				"Package Control: Remove Package"
			],
			[
				"SCHEMED",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"edit",
				"SchemeEditor: Edit installed scheme"
			],
			[
				"color",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"install p$",
				"Package Control: Install Package"
			],
			[
				"remove pac",
				"Package Control: Remove Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"DELETE",
				"Delete Blank Lines"
			],
			[
				"moon",
				"Browse Mode: Outline (Left)"
			],
			[
				"outline",
				"Browse Mode: Outline (Right)"
			],
			[
				"lua",
				"Set Syntax: Lua"
			],
			[
				"moonscr",
				"Build With: Compile MoonScript"
			],
			[
				"moons",
				"Set Syntax: MoonScript"
			],
			[
				"repository",
				"Package Control: Remove Repository"
			],
			[
				"REPOS",
				"Package Control: Add Repository"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 425.0,
		"history":
		[
			"sublime.log_commands(True)",
			"sublime.log_commands(False)",
			"sublime.log_commands(True)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Dokumente/Sources/contours/plot-cv",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src"
	],
	"file_history":
	[
		"/home/roman/Dokumente/Sources/contours/plot-cv/VideoCapture.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src/CannyWebcam1.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/CannyWebcam1",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src/code6-2.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/src/contour.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/video-stream-writer-impl-test.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/video.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/VideoCapturePeopleCounter.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/utils.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/useful_functions.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/trackFilteredObject.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/tests.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/sourcemanager.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/scheduler.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/raspicam_still_cv.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/raspicam_cv.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/process.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/movie-maker-test.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/MainPage.xaml.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/main.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/linemarker.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/AdvancedCapture.xaml.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/camera_c.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/camera.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/cameraimages.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/cap_winrt_capture.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/cap_winrt_video.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/configuration_manager.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/events.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/FaceDetector.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/frame_source.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/hardware.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/image_track.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/VideoSurveillancePeopleCounter.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/mainwindow.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/camshiftkalman.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/capturecontroller.cpp",
		"/home/roman/Dokumente/Sources/contours/plot-cv/yastereocam.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/facerec-door-lock/hardware.cpp",
		"/home/roman/Dokumente/Sources/contours/node-camera/src/native/camera.cpp",
		"/home/roman/Dokumente/Sources/contours/barossaurus/sources/linemarker.cpp",
		"/home/roman/Dokumente/Sources/contours/barossaurus/sources/mainwindow.cpp",
		"/home/roman/Dokumente/Sources/contours/Scene-text-recognition/src/utils.cpp",
		"/home/roman/Dokumente/Sources/contours/surveillance-people-counter/src/modules/counter/VideoSurveillancePeopleCounter.cpp",
		"/home/roman/Dokumente/Sources/contours/VideoSurveillancePeopleCounter.cpp",
		"/home/roman/Dokumente/Sources/contours/utils.cpp",
		"/home/roman/Dokumente/Sources/contours/camera.cpp",
		"/home/roman/Dokumente/Sources/contours/overhead-camera-people-counter/src/modules/counter/VideoCapturePeopleCounter.cpp",
		"/home/roman/Dokumente/Sources/contours/VideoCapturePeopleCounter.cpp",
		"/home/roman/Dokumente/Sources/contours/camshiftkalman.cpp",
		"/home/roman/Dokumente/Sources/contours/Active-Contours/src/MediaManager/sourcemanager.cpp",
		"/home/roman/Dokumente/Sources/contours/camshiftKalman/camshiftKalman/camshiftkalman.cpp",
		"/home/roman/Dokumente/Sources/contours/sourcemanager.cpp",
		"/home/roman/Dokumente/Sources/contours/cnc-vision/capturecontroller.cpp",
		"/home/roman/Dokumente/Sources/contours/barosaurus/sources/linemarker.cpp",
		"/home/roman/Dokumente/Sources/contours/barosaurus/sources/mainwindow.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/perf/perf_input.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/src/cap_winrt_capture.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/src/cap_winrt_video.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/test/test_video_io.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/test/test_gstreamer.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/test/test_dynamic.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/test/test_ffmpeg.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/test/test_camera.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/videoio/test/test_mfx.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/video/perf/perf_bgfg_mog2.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/video/perf/opencl/perf_bgfg_mog2.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/video/perf/opencl/perf_bgfg_knn.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/video/perf/perf_bgfg_knn.cpp",
		"/home/roman/Dokumente/Sources/opencv/modules/video/test/ocl/test_bgfg_mog2.cpp",
		"/home/roman/Dokumente/Sources/opencv/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Windows/MainPage.xaml.cpp",
		"/home/roman/Dokumente/Sources/opencv/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.WindowsPhone/MainPage.xaml.cpp",
		"/home/roman/Dokumente/Sources/opencv/samples/winrt_universal/VideoCaptureXAML/video_capture_xaml/video_capture_xaml.Shared/main.cpp",
		"/home/roman/Dokumente/Sources/opencv/samples/winrt/ImageManipulations/AdvancedCapture.xaml.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/cudacodec/perf/perf_video.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/cudacodec/test/test_video.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/tracking/perf/perf_Tracker.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/tracking/test/test_trackers.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/cudabgsegm/perf/perf_bgsegm.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/cudabgsegm/test/test_bgsegm.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/face/test/test_mace.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/superres/src/frame_source.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/cudalegacy/perf/perf_bgsegm.cpp",
		"/home/roman/Dokumente/Sources/opencv_contrib/modules/videostab/src/frame_source.cpp",
		"/home/roman/Dokumente/Sources/opencv_for_cutter/cnc-vision/capturecontroller.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/basic_streaming/cameraimages.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/raspberry-pi-fpv-visor/src/lib/test/video-stream-writer-impl-test.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/pedestrian-counting/useful_functions.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/gpu/perf/perf_video.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/gpu/test/test_bgfg.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/gpu/test/test_video.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/calib3d/test/test_fisheye.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/superres/src/frame_source.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/highgui/perf/perf_input.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/highgui/test/test_video_io.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/highgui/test/test_basic_props.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/highgui/test/test_ffmpeg.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/highgui/test/test_video_pos.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/ocl/perf/perf_bgfg.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/ocl/test/test_bgfg.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/modules/java/generator/src/cpp/VideoCapture.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/samples/gpu/performance/tests.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry_Kinect_OpenCV/libs/opencv-2.4.13/samples/winrt/ImageManipulations/AdvancedCapture.xaml.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Parking_System_pi/process.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/TimeLapseCamera_Stereo/src/yastereocam.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/zonedetector/camera_c.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/RROC/Additional_Libs/raspicam-0.1.1/src/raspicam_cv.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/RROC/Additional_Libs/raspicam-0.1.1/src/raspicam_still_cv.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/gtk-opencv-patterns/src/lib/tst/movie-maker-test.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry-Pi-OpenCV-Video-Surveillance/configuration_manager.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry-Pi-OpenCV-Video-Surveillance/events.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/Raspberry-Pi-OpenCV-Video-Surveillance/scheduler.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/cudacodec/perf/perf_video.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/cudacodec/test/test_video.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/videoio/perf/perf_input.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/videoio/src/cap_winrt_capture.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/videoio/src/cap_winrt_video.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/videoio/test/test_video_io.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/videoio/test/test_basic_props.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/videoio/test/test_ffmpeg.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/videoio/test/test_video_pos.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/video/perf/opencl/perf_bgfg_mog2.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/video/test/ocl/test_bgfg_mog2.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/cudabgsegm/perf/perf_bgsegm.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/cudabgsegm/test/test_bgsegm.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/calib3d/test/test_fisheye.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/superres/src/frame_source.cpp",
		"/home/roman/Dokumente/Sources/rpi-opencv/PiCar/Assets/opencv-3.2.0/modules/cudalegacy/perf/perf_bgsegm.cpp"
	],
	"find":
	{
		"height": 41.0
	},
	"find_in_files":
	{
		"height": 258.0,
		"where_history":
		[
			"/home/roman/Dokumente/Sources/contours/plot-cv,*.cpp"
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"Canny",
			"        if(countourStr.str().size())\n          countourStr << \"\\n\";\n",
			"out_points",
			"out_hier",
			"VideoCapture\\([^)]",
			"device",
			"VideoCapture\\([^)]",
			"VideoCapture([^)]",
			"VideoCapture",
			"Capture",
			"video_rea",
			"/V",
			"VideoCap",
			"VideoCap\n",
			"VideoCap"
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": false,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7621,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/CMake/CMake.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/adaptiveThresholding.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2144,
						"regions":
						{
						},
						"selection":
						[
							[
								2073,
								2073
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/9a.Training.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5992,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"color_scheme": "Packages/Rainglow/rainglow/Azure Contrast (rainglow).tmTheme",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4968,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "o_angle.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7645,
						"regions":
						{
						},
						"selection":
						[
							[
								376,
								376
							]
						],
						"settings":
						{
							"color_scheme": "Packages/Rainglow/rainglow/Azure Contrast (rainglow).tmTheme",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 23.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/CannyWebcam1.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11102,
						"regions":
						{
						},
						"selection":
						[
							[
								10105,
								10102
							]
						],
						"settings":
						{
							"color_scheme": "Packages/Rainglow/rainglow/Yule Contrast (rainglow).tmTheme",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6262.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/simple_svg_writer.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11340,
						"regions":
						{
						},
						"selection":
						[
							[
								5664,
								5664
							]
						],
						"settings":
						{
							"color_scheme": "Packages/Rainglow/rainglow/Yule Contrast (rainglow).tmTheme",
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2534.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/Contour_detection.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1660,
						"regions":
						{
						},
						"selection":
						[
							[
								1118,
								1118
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 733.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/warpPerspective_demo.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5568,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"color_scheme": "Packages/Rainglow/rainglow/Azure Contrast (rainglow).tmTheme",
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 1158.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 9,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1920,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										154,
										168
									],
									[
										270,
										284
									],
									[
										399,
										413
									],
									[
										454,
										475
									],
									[
										678,
										692
									],
									[
										756,
										770
									],
									[
										883,
										897
									],
									[
										961,
										975
									],
									[
										1090,
										1104
									],
									[
										1161,
										1175
									],
									[
										1319,
										1333
									],
									[
										1412,
										1426
									],
									[
										1453,
										1467
									],
									[
										1562,
										1576
									],
									[
										1654,
										1668
									],
									[
										1721,
										1735
									],
									[
										1833,
										1847
									],
									[
										1875,
										1889
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								165,
								165
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 1,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "camera_c.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6276,
						"regions":
						{
						},
						"selection":
						[
							[
								813,
								813
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 133.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "capturecontroller.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4108,
						"regions":
						{
						},
						"selection":
						[
							[
								540,
								540
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 418.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "cap_winrt_capture.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6079,
						"regions":
						{
						},
						"selection":
						[
							[
								3954,
								3954
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1937.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 55.0
	},
	"input":
	{
		"height": 79.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.SublimeLinter Messages":
	{
		"height": 194.0
	},
	"output.exec":
	{
		"height": 419.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 96.0
	},
	"pinned_build_system": "Packages/Makefile/Make.sublime-build",
	"project": "plot-cv.sublime-project",
	"replace":
	{
		"height": 106.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"simple_s",
				"src/simple_svg_writer.h"
			],
			[
				"ada",
				"src/adaptiveThresholding.cpp"
			],
			[
				"contour_",
				"src/Contour_detection.cpp"
			],
			[
				"o_ang",
				"o_angle.cpp"
			],
			[
				"o_",
				"o_angle.cpp"
			],
			[
				"cannywe",
				"src/CannyWebcam1.cpp"
			],
			[
				"weca",
				"CannyWebcam1"
			],
			[
				"ima",
				"image_track.cpp"
			],
			[
				"Face",
				"FaceDetector.cpp"
			],
			[
				"canny.cpp",
				"canny.cpp"
			],
			[
				"hexed",
				"hexedit.c"
			],
			[
				"parse.c",
				"parse.c"
			],
			[
				"GNUMa",
				"GNUmakefile"
			],
			[
				"GENMA",
				"genmakefile.c"
			],
			[
				"payme",
				"applications/payment.moon"
			],
			[
				"users.moon",
				"applications/users.moon"
			],
			[
				"socket.moo",
				"applications/socket.moon"
			],
			[
				"config.moo",
				"config.moon"
			],
			[
				"config.moon",
				"config.moon"
			],
			[
				"payment",
				"applications/payment.moon"
			],
			[
				"socket",
				"applications/socket.moon"
			],
			[
				"webso",
				"helpers/websocket.moon"
			],
			[
				"websock",
				"helpers/websocket.moon"
			],
			[
				"payment.moo",
				"applications/payment.moon"
			],
			[
				"parsigram.html",
				"static/parsigram.html"
			],
			[
				"config.mo",
				"docker/backend/config.moon"
			],
			[
				"test-pa",
				"test-parsigram.moon"
			],
			[
				"test-pars",
				"test-parsigram.moon"
			],
			[
				"test-per",
				"test-perfectmoney.moon"
			],
			[
				"test-perf",
				"test-perfectmoney.lua"
			],
			[
				"parsi",
				"helpers/parsigram.moon"
			],
			[
				"app.moo",
				"app.moon"
			],
			[
				"test-pe",
				"test-perfectmoney.moon"
			],
			[
				"test-",
				"test-parsigram.moon"
			],
			[
				"pay",
				"applications/payment.moon"
			],
			[
				"drawings.moo",
				"applications/drawings.moon"
			],
			[
				"api.moon",
				"applications/api.moon"
			],
			[
				"users.moo",
				"applications/users.moon"
			],
			[
				"paymen",
				"applications/payment.moon"
			],
			[
				"models",
				"helpers/models.moon"
			],
			[
				"models.m",
				"helpers/models.moon"
			],
			[
				"bitcoin.moo",
				"helpers/bitcoin.moon"
			],
			[
				"api.moo",
				"applications/api.moon"
			],
			[
				"api.mo",
				"helpers/api.moon"
			],
			[
				"perfe",
				"helpers/perfectmoney.moon"
			],
			[
				"parsigram.moo",
				"helpers/parsigram.moon"
			],
			[
				"test-p",
				"test-perfectmoney.moon"
			],
			[
				"perfectmoney.moo",
				"helpers/perfectmoney.moon"
			],
			[
				"perfect",
				"helpers/perfectmoney.moon"
			],
			[
				"api.m",
				"helpers/api.moon"
			],
			[
				"pars",
				"helpers/parsigram.moon"
			],
			[
				"",
				"test-parsigram.moon"
			],
			[
				"json.moo",
				"helpers/json.moon"
			],
			[
				"parsigram.mo",
				"helpers/parsigram.moon"
			],
			[
				"valida",
				"helpers/validate.moon"
			],
			[
				"validate",
				"~/Documents/Sources/lapis-1.7.0-1/lapis/lapis/validate.moon"
			],
			[
				"games",
				"applications/games.moon"
			],
			[
				"games.moo",
				"models/games.moon"
			],
			[
				"vali",
				"helpers/validate.moon"
			],
			[
				"sheta",
				"static/shetab-deposit.html"
			],
			[
				"parsig",
				"helpers/parsigram.moon"
			],
			[
				"nginx.conf",
				"nginx.conf"
			],
			[
				"nginx",
				"nginx.conf"
			],
			[
				"gate",
				"doc/parsigram/gateway.html"
			],
			[
				"test.html",
				"static/test.html"
			],
			[
				"query.",
				"helpers/query.moon"
			],
			[
				"test.moo",
				"test.moon"
			],
			[
				"mobile",
				"static/css/mobile.css"
			],
			[
				"desktop",
				"static/css/desktop.css"
			],
			[
				"application.m",
				"applications/users.moon"
			],
			[
				"users.mo",
				"applications/users.moon"
			],
			[
				"json-to",
				"scripts/convert-json-to-po.sh"
			],
			[
				"users.",
				"applications/users.moon"
			],
			[
				"ngin.",
				"nginx.conf"
			],
			[
				"app.m",
				"app.moon"
			],
			[
				"embe",
				"embed.html"
			],
			[
				"ngix",
				"nginx.conf"
			],
			[
				"components.cs",
				"static/css/components.css"
			],
			[
				"games.moon",
				"models/games.moon"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 452.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
