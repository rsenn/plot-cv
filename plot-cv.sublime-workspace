{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"js_is_",
				"js_is_null_or_undefined"
			],
			[
				"path_skip_se",
				"path_skip_separator_s"
			],
			[
				"WRITABLE_METHO",
				"WRITABLE_METHOD_CLOSE"
			],
			[
				"list_fo",
				"list_for_each_prev"
			],
			[
				"JS_Th",
				"JS_ThrowOutOfMemory"
			],
			[
				"JS_",
				"JS_ThrowOutOfMemory"
			],
			[
				"underly",
				"underlying_source"
			],
			[
				"Tok",
				"TokenSequence"
			],
			[
				"JS_GetPr",
				"JS_GetPropertyStr"
			],
			[
				"JS_Thro",
				"JS_ThrowOutOfMemory"
			],
			[
				"getAt",
				"getAttributeNames"
			],
			[
				"self",
				"self_closing_tags"
			],
			[
				"self_",
				"self_closing_tags"
			],
			[
				"JS_PROP",
				"JS_PROP_ENUMERABLE"
			],
			[
				"depe",
				"dependencyMap"
			],
			[
				"de",
				"dependencyMap"
			],
			[
				"dep",
				"dependencyMap"
			],
			[
				"js_is_null",
				"js_is_null_or_undefined"
			],
			[
				"JS_P",
				"JS_PROP_ENUMERABLE"
			],
			[
				"JS_SetP",
				"JS_SetPropertyUint32"
			],
			[
				"spec",
				"specifiers"
			],
			[
				"Num",
				"NumericRange"
			],
			[
				"token_r",
				"token_release_rt"
			],
			[
				"JS_Thr",
				"JS_ThrowTypeError"
			],
			[
				"js_",
				"js_location_data"
			],
			[
				"debug_js_mall",
				"debug_js_malloc_usable_size"
			],
			[
				"repl",
				"replaceRange"
			],
			[
				"js_malloc_u",
				"js_malloc_usable_size_rt"
			],
			[
				"malloc",
				"malloc_usable_size"
			],
			[
				"all",
				"alloc_block_list"
			],
			[
				"alloc",
				"alloc_block_list"
			],
			[
				"path_skip",
				"path_skip_component"
			],
			[
				"JS_Set",
				"JS_SetPropertyUint32"
			],
			[
				"jsm_mo",
				"jsm_module_loader"
			],
			[
				"JS_Throw",
				"JS_ThrowInternalError"
			],
			[
				"JS_AtomTo",
				"JS_AtomToValue"
			],
			[
				"inspect",
				"inspectSymbol"
			],
			[
				"at",
				"attributes"
			],
			[
				"parent",
				"parentElement"
			],
			[
				"owner",
				"ownerElement"
			],
			[
				"get",
				"getPrototypeOf"
			],
			[
				"child",
				"childElementCount"
			],
			[
				"getO",
				"getOwnPropertyNames"
			],
			[
				"getOwn",
				"getOwnPropertySymbols(...)"
			],
			[
				"js_misc_im",
				"js_misc_immutable_constructor"
			],
			[
				"obj",
				"object_tostring"
			],
			[
				"js_misc_immu",
				"js_misc_immutable_free"
			],
			[
				"js_misc_imm",
				"js_misc_immutable_constructor"
			],
			[
				"CMAKE_IMPORT",
				"CMAKE_IMPORT_LIBRARY_SUFFIX"
			],
			[
				"CMAKE_CUR",
				"CMAKE_CURRENT_BINARY_DIR"
			],
			[
				"js_is",
				"js_is_null_or_undefined"
			],
			[
				"js_asy",
				"js_async_socket_class_id"
			],
			[
				"JS_NewObj",
				"JS_NewObjectProtoClass"
			],
			[
				"async_",
				"async_socket_proto"
			],
			[
				"JS_Get",
				"JS_GetOpaque"
			],
			[
				"js_socket_class",
				"js_socket_class_id"
			],
			[
				"g",
				"getOwnPropertyNames(...)"
			],
			[
				"JS_Free",
				"JS_FreeCString"
			],
			[
				"js_sockaddr_cl",
				"js_sockaddr_class_id"
			],
			[
				"js_so",
				"js_sockaddr_constructor"
			],
			[
				"js_sys",
				"js_syscallerror_class_id"
			],
			[
				"js_string",
				"js_stringdecoder_class_id"
			],
			[
				"js_pred",
				"js_predicate_class_id"
			],
			[
				"js_syn",
				"js_syntaxerror_class"
			],
			[
				"js_child",
				"js_child_process_class_id"
			],
			[
				"js_b",
				"js_blob_class_id"
			],
			[
				"js_loca",
				"js_location_class_id"
			],
			[
				"js_token_in",
				"js_token_inspect_funcs"
			],
			[
				"JS_SetPr",
				"JS_SetPropertyFunctionList"
			],
			[
				"set",
				"setReadHandler"
			],
			[
				"js_get_",
				"js_get_propertystr_bool"
			],
			[
				"js_misc_ate",
				"js_misc_atexit_functions"
			],
			[
				"isF",
				"isFunction"
			],
			[
				"tab",
				"tab_atom_len"
			],
			[
				"isARr",
				"isArrayBuffer"
			],
			[
				"BIT",
				"BITFIELD_FROMARRAY"
			],
			[
				"to",
				"toStringTag"
			],
			[
				"inotify",
				"inotify_add_watch"
			],
			[
				"JS_SetProp",
				"JS_SetPropertyUint32"
			],
			[
				"JS_GEt",
				"JS_GetGlobalObject"
			],
			[
				"dbuf_put",
				"dbuf_put_colorstr"
			],
			[
				"REPEATER_",
				"REPEATER_REJECTED"
			],
			[
				"REP",
				"REPEATER_DONE"
			],
			[
				"resol",
				"resolving_funcs"
			],
			[
				"JS_NEwCFun",
				"JS_NewCFunctionData"
			],
			[
				"js_function",
				"js_function_bind_this"
			],
			[
				"js_repeater_iter",
				"js_repeater_iteration"
			],
			[
				"REPEA",
				"REPEATER_REJECTED"
			],
			[
				"JS_New",
				"JS_NewCFunctionData"
			],
			[
				"exe",
				"execution"
			],
			[
				"REPEAT",
				"REPEATER_STOPPED"
			],
			[
				"JS_THro",
				"JS_ThrowOutOfMemory"
			],
			[
				"repeater",
				"repeater_finalizer"
			],
			[
				"BACK",
				"BACKGROUND_RED"
			],
			[
				"js_inspec",
				"js_inspect_tostring"
			],
			[
				"JS_Atom",
				"JS_AtomToValue"
			],
			[
				"JS_GetP",
				"JS_GetPropertyStr"
			],
			[
				"js_misc_glob_err",
				"js_misc_glob_errfunc_ctx"
			],
			[
				"js_misc",
				"js_misc_glob"
			],
			[
				"js_mi",
				"js_misc_glob_errfunc"
			],
			[
				"js_misc_glob_",
				"js_misc_glob_errfunc_ctx"
			],
			[
				"JS_VALUE_",
				"JS_VALUE_GET_OBJ"
			],
			[
				"js_io_Read",
				"js_io_readhandler_fn"
			],
			[
				"JS_NewS",
				"JS_NewStringLen"
			],
			[
				"target_link",
				"target_link_directories"
			],
			[
				"brea",
				"breakLength"
			],
			[
				"WIF",
				"WIFSIGNALED"
			],
			[
				"JS_VALUE",
				"JS_VALUE_GET_PTR"
			],
			[
				"module_",
				"module_func"
			],
			[
				"initiali",
				"initialization"
			],
			[
				"qjsm_sock",
				"qjsm_socklen_t_size"
			],
			[
				"getCas",
				"getClassConstructor"
			],
			[
				"js_syscall",
				"js_syscallerror_proto_funcs"
			],
			[
				"syscal",
				"syscallerror_proto"
			],
			[
				"JS_SetProper",
				"JS_SetPropertyStr"
			],
			[
				"JS_CGET",
				"JS_CGETSET_ENUMERABLE_DEF"
			],
			[
				"sys",
				"syscallerror_ctor"
			],
			[
				"Sys",
				"SyscallError"
			],
			[
				"JS_CGETSET",
				"JS_CGETSET_MAGIC_DEF"
			],
			[
				"JS_T",
				"JS_ThrowTypeError"
			],
			[
				"STRING",
				"STRINGDECODER_ENCODING"
			],
			[
				"STRINGDECODER_EN",
				"STRINGDECODER_ENCODING"
			],
			[
				"STRINGDE",
				"STRINGDECODER_END"
			],
			[
				"ringbuffer_",
				"ringbuffer_continuous_length"
			],
			[
				"string",
				"stringdecoder_proto"
			],
			[
				"ringbuffer_res",
				"ringbuffer_resize"
			],
			[
				"ringb",
				"ringbuffer_normalize"
			],
			[
				"ringbuffer",
				"ringbuffer_length"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "â€”â“‚â€“ pipe ( ) â€¦ â€” macro function\n  â“‰  sighandler_t ; â€” typedef\n  â“‚  environ â€¦ â€” macro object\n  â“‚  USE_WORKER â€¦ â€” macro object\n  â“‰  JSOSRWHandler ; â€” typedef\n  â“‰  JSOSSignalHandler ; â€” typedef\n  â“‰  JSOSTimer ; â€” typedef\n  â“‰  JSWorkerMessage ; â€” typedef\n  â“‰  JSWorkerMessagePipe ; â€” typedef\n  â“‰  JSWorkerMessageHandler ; â€” typedef\n  â“‰  JSThreadState ; â€” typedef\nâ€”â’»â€“ js_std_dbuf_init ( ) { â€¦ } â€” function\nâ€”â’»â€“ my_isdigit ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_printf_internal ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_load_file ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_loadScript ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_loadFile ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_module_loader_so ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_module_loader_so ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_module_set_import_meta ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_module_loader ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_exit ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_getenv ( ) { â€¦ } â€” function\nâ€”â’»â€“ setenv ( ) { â€¦ } â€” function\nâ€”â’»â€“ unsetenv ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_setenv ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_unsetenv ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_getenviron ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_gc ( ) { â€¦ } â€” function\nâ€”â’»â€“ interrupt_handler ( ) { â€¦ } â€” function\nâ€”â’»â€“ get_bool_option ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_evalScript ( ) { â€¦ } â€” function\n  â“‰  JSSTDFile ; â€” typedef\nâ€”â’»â€“ js_std_file_finalizer ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_get_errno ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_strerror ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_parseExtJSON ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_new_std_file ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_set_error_object ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_open ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_popen ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_fdopen ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_tmpfile ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_sprintf ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_printf ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_get ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_puts ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_close ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_printf ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_flush ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_tell ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_seek ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_eof ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_error ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_clearerr ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_fileno ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_read_write ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_getline ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_readAsString ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_getByte ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_file_putByte ( ) { â€¦ } â€” function\n  â“‚  URL_GET_PROGRAM â€¦ â€” macro object\n  â“‚  URL_GET_BUF_SIZE â€¦ â€” macro object\nâ€”â’»â€“ http_get_header_line ( ) { â€¦ } â€” function\nâ€”â’»â€“ http_get_status ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_urlGet ( ) { â€¦ } â€” function\nâ€”â“‚â€“ DEF ( ) â€¦ â€” macro function\nâ€”â’»â€“ js_std_init ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_init_module_std ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_open ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_close ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_seek ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_read_write ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_isatty ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_ttyGetWinSize ( ) { â€¦ } â€” function\n  â“‚  __ENABLE_VIRTUAL_TERMINAL_PROCESSING â€¦ â€” macro object\n  â“‚  __ENABLE_VIRTUAL_TERMINAL_INPUT â€¦ â€” macro object\nâ€”â’»â€“ js_os_ttySetRaw ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_ttyGetWinSize ( ) { â€¦ } â€” function\nâ€”â’»â€“ term_exit ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_ttySetRaw ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_remove ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_rename ( ) { â€¦ } â€” function\nâ€”â’»â€“ is_main_thread ( ) { â€¦ } â€” function\nâ€”â’»â€“ find_rh ( ) { â€¦ } â€” function\nâ€”â’»â€“ free_rw_handler ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_setReadHandler ( ) { â€¦ } â€” function\nâ€”â’»â€“ find_sh ( ) { â€¦ } â€” function\nâ€”â’»â€“ free_sh ( ) { â€¦ } â€” function\nâ€”â’»â€“ os_signal_handler ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_signal ( ) { â€¦ } â€” function\nâ€”â’»â€“ get_time_ms ( ) { â€¦ } â€” function\nâ€”â’»â€“ get_time_ms ( ) { â€¦ } â€” function\nâ€”â’»â€“ unlink_timer ( ) { â€¦ } â€” function\nâ€”â’»â€“ free_timer ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_timer_finalizer ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_timer_mark ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_setTimeout ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_clearTimeout ( ) { â€¦ } â€” function\nâ€”â’»â€“ call_handler ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_poll ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_free_message ( ) { â€¦ } â€” function\nâ€”â’»â€“ handle_posted_message ( ) { â€¦ } â€” function\nâ€”â’»â€“ handle_posted_message ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_poll ( ) { â€¦ } â€” function\nâ€”â’»â€“ make_obj_error ( ) { â€¦ } â€” function\nâ€”â’»â€“ make_string_error ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_getcwd ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_chdir ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_mkdir ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_readdir ( ) { â€¦ } â€” function\nâ€”â’»â€“ timespec_to_ms ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_stat ( ) { â€¦ } â€” function\nâ€”â’»â€“ ms_to_timeval ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_utimes ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_sleep ( ) { â€¦ } â€” function\nâ€”â’»â€“ realpath ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_realpath ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_symlink ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_readlink ( ) { â€¦ } â€” function\nâ€”â’»â€“ build_envp ( ) { â€¦ } â€” function\nâ€”â’»â€“ my_execvpe ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_exec ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_waitpid ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_pipe ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_kill ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_dup ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_os_dup2 ( ) { â€¦ } â€” function\n  â“‰  JSWorkerData ; â€” typedef\n  â“‰  WorkerFuncArgs ; â€” typedef\n  â“‰  JSSABHeader ; â€” typedef\nâ€”â’»â€“ atomic_add_int ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_sab_alloc ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_sab_free ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_sab_dup ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_new_message_pipe ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_dup_message_pipe ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_free_message ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_free_message_pipe ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_free_port ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_worker_finalizer ( ) { â€¦ } â€” function\nâ€”â’»â€“ worker_func ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_worker_ctor_internal ( ) { â€¦ } â€” function\nâ€”â’»â€“ JS_GetModuleLoaderFunc ( ) { â€¦ } â€” function\nâ€”â’»â€“ JS_GetModuleLoaderOpaque ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_worker_ctor ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_worker_postMessage ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_worker_set_onmessage ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_worker_get_onmessage ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_set_worker_new_context_func ( ) { â€¦ } â€” function\n  â“‚  OS_PLATFORM â€¦ â€” macro object\n  â“‚  OS_PLATFORM â€¦ â€” macro object\n  â“‚  OS_PLATFORM â€¦ â€” macro object\n  â“‚  OS_PLATFORM â€¦ â€” macro object\n  â“‚  OS_PLATFORM â€¦ â€” macro object\nâ€”â“‚â€“ OS_FLAG ( ) â€¦ â€” macro function\nâ€”â’»â€“ js_os_init ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_init_module_os ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_print ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_add_helpers ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_init_handlers ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_free_handlers ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_dump_obj ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_dump_error1 ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_dump_error ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_promise_rejection_tracker ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_loop ( ) { â€¦ } â€” function\nâ€”â’»â€“ js_std_eval_binary ( ) { â€¦ } â€” function",
			"settings":
			{
				"buffer_size": 6715,
				"line_ending": "Unix",
				"name": "ðŒ† Outline",
				"scratch": true
			},
			"undo_stack":
			[
				[
					1,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/functions.cmake",
						"symkeys":
						[
							[
								9,
								13
							],
							[
								31,
								35
							],
							[
								48,
								57
							],
							[
								83,
								92
							],
							[
								116,
								125
							],
							[
								152,
								155
							],
							[
								162,
								165
							],
							[
								217,
								220
							],
							[
								264,
								265
							],
							[
								301,
								310
							],
							[
								318,
								319
							],
							[
								340,
								343
							],
							[
								349,
								350
							],
							[
								373,
								377
							],
							[
								408,
								420
							],
							[
								485,
								488
							],
							[
								535,
								542
							],
							[
								566,
								573
							],
							[
								595,
								605
							],
							[
								611,
								618
							],
							[
								686,
								694
							],
							[
								754,
								757
							],
							[
								802,
								806
							],
							[
								825,
								832
							],
							[
								860,
								870
							],
							[
								876,
								883
							],
							[
								948,
								957
							],
							[
								983,
								989
							],
							[
								1010,
								1014
							],
							[
								1043,
								1049
							],
							[
								1052,
								1055
							],
							[
								1078,
								1082
							],
							[
								1094,
								1104
							],
							[
								1110,
								1116
							],
							[
								1184,
								1193
							],
							[
								1219,
								1225
							],
							[
								1246,
								1250
							],
							[
								1279,
								1282
							],
							[
								1285,
								1291
							],
							[
								1314,
								1318
							],
							[
								1330,
								1340
							],
							[
								1346,
								1352
							],
							[
								1420,
								1433
							],
							[
								1461,
								1465
							],
							[
								1487,
								1491
							],
							[
								1524,
								1535
							],
							[
								1541,
								1544
							],
							[
								1572,
								1575
							],
							[
								1598,
								1602
							],
							[
								1615,
								1622
							],
							[
								1628,
								1632
							],
							[
								1703,
								1721
							],
							[
								1748,
								1752
							],
							[
								1841,
								1847
							],
							[
								1891,
								1901
							],
							[
								1905,
								1909
							],
							[
								2057,
								2061
							],
							[
								2067,
								2077
							],
							[
								2090,
								2100
							],
							[
								2115,
								2125
							],
							[
								2157,
								2161
							],
							[
								2268,
								2278
							],
							[
								2334,
								2349
							],
							[
								2368,
								2372
							],
							[
								2402,
								2406
							],
							[
								2447,
								2451
							],
							[
								2457,
								2467
							],
							[
								2491,
								2495
							],
							[
								2531,
								2545
							],
							[
								2563,
								2567
							],
							[
								2597,
								2600
							],
							[
								2674,
								2684
							],
							[
								2768,
								2771
							],
							[
								2777,
								2787
							],
							[
								2810,
								2814
							],
							[
								2849,
								2862
							],
							[
								2874,
								2878
							],
							[
								2884,
								2887
							],
							[
								2913,
								2917
							],
							[
								2929,
								2932
							],
							[
								2938,
								2942
							],
							[
								2997,
								3005
							],
							[
								3040,
								3044
							],
							[
								3050,
								3055
							],
							[
								3072,
								3077
							],
							[
								3099,
								3105
							],
							[
								3121,
								3126
							],
							[
								3148,
								3154
							],
							[
								3172,
								3177
							],
							[
								3229,
								3233
							],
							[
								3249,
								3253
							],
							[
								3268,
								3273
							],
							[
								3289,
								3295
							],
							[
								3317,
								3321
							],
							[
								3336,
								3341
							],
							[
								3369,
								3373
							],
							[
								3406,
								3412
							],
							[
								3418,
								3424
							],
							[
								3491,
								3501
							],
							[
								3514,
								3520
							],
							[
								3526,
								3530
							],
							[
								3552,
								3556
							],
							[
								3582,
								3586
							],
							[
								3642,
								3646
							],
							[
								3691,
								3695
							],
							[
								3707,
								3711
							],
							[
								3717,
								3723
							]
						],
						"symlist":
						[
							"DUMP",
							"ARGN",
							"SEPARATOR",
							"SEPARATOR",
							"SEPARATOR",
							"VAR",
							"VAR",
							"VAR",
							"A",
							"SEPARATOR",
							"A",
							"VAR",
							"A",
							"ARGN",
							"CANONICALIZE",
							"STR",
							"TMP_STR",
							"TMP_STR",
							"OUTPUT_VAR",
							"TMP_STR",
							"BASENAME",
							"STR",
							"ARGN",
							"TMP_STR",
							"OUTPUT_VAR",
							"TMP_STR",
							"ADDPREFIX",
							"OUTPUT",
							"ARGN",
							"PREFIX",
							"ARG",
							"ARGN",
							"OUTPUT_VAR",
							"OUTPUT",
							"ADDSUFFIX",
							"OUTPUT",
							"ARGN",
							"ARG",
							"SUFFIX",
							"ARGN",
							"OUTPUT_VAR",
							"OUTPUT",
							"RELATIVE_PATH",
							"LIST",
							"ARGN",
							"RELATIVE_TO",
							"ARG",
							"ARG",
							"ARGN",
							"OUT_VAR",
							"LIST",
							"CHECK_FUNCTION_DEF",
							"FUNC",
							"FUNC_U",
							"RESULT_VAR",
							"ARGN",
							"FUNC",
							"RESULT_VAR",
							"RESULT_VAR",
							"RESULT_VAR",
							"FUNC",
							"RESULT_VAR",
							"CHECK_FUNCTIONS",
							"ARGN",
							"FUNC",
							"FUNC",
							"RESULT_VAR",
							"ARGN",
							"CHECK_INCLUDES",
							"ARGN",
							"INC",
							"RESULT_VAR",
							"INC",
							"RESULT_VAR",
							"ARGN",
							"APPEND_PARENT",
							"LIST",
							"VAR",
							"ARGN",
							"VAR",
							"LIST",
							"CONTAINS",
							"LIST",
							"VALUE",
							"INDEX",
							"RESULT",
							"INDEX",
							"RESULT",
							"INDEX",
							"LIST",
							"ITEM",
							"VALUE",
							"RESULT",
							"ITEM",
							"VALUE",
							"LIST",
							"OUTPUT",
							"RESULT",
							"ADD_UNIQUE",
							"RESULT",
							"LIST",
							"ARGN",
							"ITEM",
							"ITEM",
							"ARGN",
							"LIST",
							"RESULT"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACNAAAATWF0MlRleHR1cmUodGV4dHVyZV9jdikKICBtYWluKC4uLmFyZ3MpCiAgaCA9PgogIGhzbGEgPT4KICBjbGFtcCA9IChuLCBtaW4sIG1heCkgPT4KICBpbnRlcnBvbGF0ZSA9ICh4LCB5LCBzaWdtYSkgPT4KKHh4LCBpKSA9PgogIGMgPT4KICBuID0+AAAAAAAAAADrAgAAAAAAAAAAAAA",
					"CAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8"
				],
				[
					2,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-glfw.js",
						"symkeys":
						[
							[
								829,
								861
							],
							[
								1553,
								1575
							],
							[
								2657,
								2661
							],
							[
								2693,
								2700
							],
							[
								2726,
								2750
							],
							[
								2792,
								2822
							],
							[
								2849,
								2859
							],
							[
								2956,
								2960
							],
							[
								3610,
								3614
							]
						],
						"symlist":
						[
							"function Mat2Texture(texture_cv)",
							"function main(...args)",
							"h =>",
							"hsla =>",
							"clamp = (n, min, max) =>",
							"interpolate = (x, y, sigma) =>",
							"(xx, i) =>",
							"c =>",
							"n =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADrAgAARFVNUApBUkdOClNFUEFSQVRPUgpTRVBBUkFUT1IKU0VQQVJBVE9SClZBUgpWQVIKVkFSCkEKU0VQQVJBVE9SCkEKVkFSCkEKQVJHTgpDQU5PTklDQUxJWkUKU1RSClRNUF9TVFIKVE1QX1NUUgpPVVRQVVRfVkFSClRNUF9TVFIKQkFTRU5BTUUKU1RSCkFSR04KVE1QX1NUUgpPVVRQVVRfVkFSClRNUF9TVFIKQUREUFJFRklYCk9VVFBVVApBUkdOClBSRUZJWApBUkcKQVJHTgpPVVRQVVRfVkFSCk9VVFBVVApBRERTVUZGSVgKT1VUUFVUCkFSR04KQVJHClNVRkZJWApBUkdOCk9VVFBVVF9WQVIKT1VUUFVUClJFTEFUSVZFX1BBVEgKTElTVApBUkdOClJFTEFUSVZFX1RPCkFSRwpBUkcKQVJHTgpPVVRfVkFSCkxJU1QKQ0hFQ0tfRlVOQ1RJT05fREVGCkZVTkMKRlVOQ19VClJFU1VMVF9WQVIKQVJHTgpGVU5DClJFU1VMVF9WQVIKUkVTVUxUX1ZBUgpSRVNVTFRfVkFSCkZVTkMKUkVTVUxUX1ZBUgpDSEVDS19GVU5DVElPTlMKQVJHTgpGVU5DCkZVTkMKUkVTVUxUX1ZBUgpBUkdOCkNIRUNLX0lOQ0xVREVTCkFSR04KSU5DClJFU1VMVF9WQVIKSU5DClJFU1VMVF9WQVIKQVJHTgpBUFBFTkRfUEFSRU5UCkxJU1QKVkFSCkFSR04KVkFSCkxJU1QKQ09OVEFJTlMKTElTVApWQUxVRQpJTkRFWApSRVNVTFQKSU5ERVgKUkVTVUxUCklOREVYCkxJU1QKSVRFTQpWQUxVRQpSRVNVTFQKSVRFTQpWQUxVRQpMSVNUCk9VVFBVVApSRVNVTFQKQUREX1VOSVFVRQpSRVNVTFQKTElTVApBUkdOCklURU0KSVRFTQpBUkdOCkxJU1QKUkVTVUxUAAAAAAAAAACNAAAAAAAAAAAAAAA",
					"CAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAAAAAA"
				],
				[
					1,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACNAAAATWF0MlRleHR1cmUodGV4dHVyZV9jdikKICBtYWluKC4uLmFyZ3MpCiAgaCA9PgogIGhzbGEgPT4KICBjbGFtcCA9IChuLCBtaW4sIG1heCkgPT4KICBpbnRlcnBvbGF0ZSA9ICh4LCB5LCBzaWdtYSkgPT4KKHh4LCBpKSA9PgogIGMgPT4KICBuID0+AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/"
				],
				[
					2,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3120,
								3124
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"AQAAAAAAAAAAAAAAvQAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					3,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					4,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					5,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/draw-utils.js",
						"symkeys":
						[
							[
								531,
								574
							],
							[
								1549,
								1564
							],
							[
								1614,
								1639
							],
							[
								1699,
								1725
							],
							[
								1779,
								1807
							],
							[
								1865,
								1885
							],
							[
								1940,
								1964
							],
							[
								2023,
								2059
							],
							[
								2132,
								2171
							],
							[
								2245,
								2266
							],
							[
								2322,
								2344
							],
							[
								2401,
								2431
							],
							[
								2496,
								2534
							],
							[
								2607,
								2620
							],
							[
								2668,
								2691
							],
							[
								2749,
								2771
							],
							[
								2853,
								2857
							],
							[
								2885,
								2890
							],
							[
								2953,
								2958
							],
							[
								3026,
								3031
							],
							[
								3106,
								3110
							],
							[
								3134,
								3147
							],
							[
								3231,
								3246
							],
							[
								3322,
								3337
							],
							[
								3746,
								3751
							],
							[
								3828,
								3837
							],
							[
								4027,
								4051
							],
							[
								4462,
								4493
							],
							[
								4729,
								4762
							]
						],
						"symlist":
						[
							" function GLFW(width, height, options = {})",
							"handlePos(x, y)",
							"handleSize(width, height)",
							"handleClose(window = this)",
							"handleRefresh(window = this)",
							"handleFocus(focused)",
							"handleIconify(iconified)",
							"handleFramebufferSize(width, height)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"handleCursorEnter(cur)",
							"handleScroll(xoffset, yoffset)",
							"handleKey(key, scancode, action, mods)",
							"handleChar(c)",
							"handleCharMods(c, mods)",
							"handleDrop(argc, argv)",
							"GLFW",
							"get()",
							"get()",
							"get()",
							"GLFW",
							"move(...args)",
							"resize(...args)",
							"setTitle(title)",
							"end()",
							"show(mat)",
							" function Mat2Image(mat)",
							" function DrawImage(image, pos)",
							" function DrawCircle(pos, radius)"
						]
					},
					"AQAAAAAAAAAAAAAAcwIAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					6,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABzAgAAR0xGVyh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pCiAgaGFuZGxlUG9zKHgsIHkpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUNsb3NlKHdpbmRvdyA9IHRoaXMpCiAgaGFuZGxlUmVmcmVzaCh3aW5kb3cgPSB0aGlzKQogIGhhbmRsZUZvY3VzKGZvY3VzZWQpCiAgaGFuZGxlSWNvbmlmeShpY29uaWZpZWQpCiAgaGFuZGxlRnJhbWVidWZmZXJTaXplKHdpZHRoLCBoZWlnaHQpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgaGFuZGxlQ3Vyc29yRW50ZXIoY3VyKQogIGhhbmRsZVNjcm9sbCh4b2Zmc2V0LCB5b2Zmc2V0KQogIGhhbmRsZUtleShrZXksIHNjYW5jb2RlLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ2hhcihjKQogIGhhbmRsZUNoYXJNb2RzKGMsIG1vZHMpCiAgaGFuZGxlRHJvcChhcmdjLCBhcmd2KQpHTEZXCiAgZ2V0KCkKICBnZXQoKQogIGdldCgpCkdMRlcKICBtb3ZlKC4uLmFyZ3MpCiAgcmVzaXplKC4uLmFyZ3MpCiAgc2V0VGl0bGUodGl0bGUpCiAgZW5kKCkKICBzaG93KG1hdCkKTWF0MkltYWdlKG1hdCkKRHJhd0ltYWdlKGltYWdlLCBwb3MpCkRyYXdDaXJjbGUocG9zLCByYWRpdXMpAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					7,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/draw-utils.js",
						"symkeys":
						[
							[
								531,
								574
							],
							[
								1549,
								1564
							],
							[
								1614,
								1639
							],
							[
								1699,
								1725
							],
							[
								1779,
								1807
							],
							[
								1865,
								1885
							],
							[
								1940,
								1964
							],
							[
								2023,
								2059
							],
							[
								2132,
								2171
							],
							[
								2245,
								2266
							],
							[
								2322,
								2344
							],
							[
								2401,
								2431
							],
							[
								2496,
								2534
							],
							[
								2607,
								2620
							],
							[
								2668,
								2691
							],
							[
								2749,
								2771
							],
							[
								2853,
								2857
							],
							[
								2885,
								2890
							],
							[
								2953,
								2958
							],
							[
								3026,
								3031
							],
							[
								3106,
								3110
							],
							[
								3134,
								3147
							],
							[
								3231,
								3246
							],
							[
								3322,
								3337
							],
							[
								3746,
								3751
							],
							[
								3828,
								3837
							],
							[
								4027,
								4051
							],
							[
								4462,
								4493
							],
							[
								4729,
								4762
							]
						],
						"symlist":
						[
							" function GLFW(width, height, options = {})",
							"handlePos(x, y)",
							"handleSize(width, height)",
							"handleClose(window = this)",
							"handleRefresh(window = this)",
							"handleFocus(focused)",
							"handleIconify(iconified)",
							"handleFramebufferSize(width, height)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"handleCursorEnter(cur)",
							"handleScroll(xoffset, yoffset)",
							"handleKey(key, scancode, action, mods)",
							"handleChar(c)",
							"handleCharMods(c, mods)",
							"handleDrop(argc, argv)",
							"GLFW",
							"get()",
							"get()",
							"get()",
							"GLFW",
							"move(...args)",
							"resize(...args)",
							"setTitle(title)",
							"end()",
							"show(mat)",
							" function Mat2Image(mat)",
							" function DrawImage(image, pos)",
							" function DrawCircle(pos, radius)"
						]
					},
					"AQAAAAAAAAAAAAAAcwIAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					8,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3120,
								3124
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABzAgAAR0xGVyh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pCiAgaGFuZGxlUG9zKHgsIHkpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUNsb3NlKHdpbmRvdyA9IHRoaXMpCiAgaGFuZGxlUmVmcmVzaCh3aW5kb3cgPSB0aGlzKQogIGhhbmRsZUZvY3VzKGZvY3VzZWQpCiAgaGFuZGxlSWNvbmlmeShpY29uaWZpZWQpCiAgaGFuZGxlRnJhbWVidWZmZXJTaXplKHdpZHRoLCBoZWlnaHQpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgaGFuZGxlQ3Vyc29yRW50ZXIoY3VyKQogIGhhbmRsZVNjcm9sbCh4b2Zmc2V0LCB5b2Zmc2V0KQogIGhhbmRsZUtleShrZXksIHNjYW5jb2RlLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ2hhcihjKQogIGhhbmRsZUNoYXJNb2RzKGMsIG1vZHMpCiAgaGFuZGxlRHJvcChhcmdjLCBhcmd2KQpHTEZXCiAgZ2V0KCkKICBnZXQoKQogIGdldCgpCkdMRlcKICBtb3ZlKC4uLmFyZ3MpCiAgcmVzaXplKC4uLmFyZ3MpCiAgc2V0VGl0bGUodGl0bGUpCiAgZW5kKCkKICBzaG93KG1hdCkKTWF0MkltYWdlKG1hdCkKRHJhd0ltYWdlKGltYWdlLCBwb3MpCkRyYXdDaXJjbGUocG9zLCByYWRpdXMpAAAAAAAAAAC9AAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					9,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-glfw.js",
						"symkeys":
						[
							[
								829,
								861
							],
							[
								1553,
								1575
							],
							[
								2657,
								2661
							],
							[
								2693,
								2700
							],
							[
								2726,
								2750
							],
							[
								2792,
								2822
							],
							[
								2849,
								2859
							],
							[
								2956,
								2960
							],
							[
								3610,
								3614
							]
						],
						"symlist":
						[
							"function Mat2Texture(texture_cv)",
							"function main(...args)",
							"h =>",
							"hsla =>",
							"clamp = (n, min, max) =>",
							"interpolate = (x, y, sigma) =>",
							"(xx, i) =>",
							"c =>",
							"n =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAACNAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					10,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3120,
								3124
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACNAAAATWF0MlRleHR1cmUodGV4dHVyZV9jdikKICBtYWluKC4uLmFyZ3MpCiAgaCA9PgogIGhzbGEgPT4KICBjbGFtcCA9IChuLCBtaW4sIG1heCkgPT4KICBpbnRlcnBvbGF0ZSA9ICh4LCB5LCBzaWdtYSkgPT4KKHh4LCBpKSA9PgogIGMgPT4KICBuID0+AAAAAAAAAAC9AAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					11,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/draw-utils.js",
						"symkeys":
						[
							[
								531,
								574
							],
							[
								1549,
								1564
							],
							[
								1614,
								1639
							],
							[
								1699,
								1725
							],
							[
								1779,
								1807
							],
							[
								1865,
								1885
							],
							[
								1940,
								1964
							],
							[
								2023,
								2059
							],
							[
								2132,
								2171
							],
							[
								2245,
								2266
							],
							[
								2322,
								2344
							],
							[
								2401,
								2431
							],
							[
								2496,
								2534
							],
							[
								2607,
								2620
							],
							[
								2668,
								2691
							],
							[
								2749,
								2771
							],
							[
								2853,
								2857
							],
							[
								2885,
								2890
							],
							[
								2953,
								2958
							],
							[
								3026,
								3031
							],
							[
								3106,
								3110
							],
							[
								3134,
								3147
							],
							[
								3231,
								3246
							],
							[
								3322,
								3337
							],
							[
								3746,
								3751
							],
							[
								3828,
								3837
							],
							[
								4027,
								4051
							],
							[
								4462,
								4493
							],
							[
								4729,
								4762
							]
						],
						"symlist":
						[
							" function GLFW(width, height, options = {})",
							"handlePos(x, y)",
							"handleSize(width, height)",
							"handleClose(window = this)",
							"handleRefresh(window = this)",
							"handleFocus(focused)",
							"handleIconify(iconified)",
							"handleFramebufferSize(width, height)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"handleCursorEnter(cur)",
							"handleScroll(xoffset, yoffset)",
							"handleKey(key, scancode, action, mods)",
							"handleChar(c)",
							"handleCharMods(c, mods)",
							"handleDrop(argc, argv)",
							"GLFW",
							"get()",
							"get()",
							"get()",
							"GLFW",
							"move(...args)",
							"resize(...args)",
							"setTitle(title)",
							"end()",
							"show(mat)",
							" function Mat2Image(mat)",
							" function DrawImage(image, pos)",
							" function DrawCircle(pos, radius)"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAABzAgAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					12,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/draw-utils.js",
						"symkeys":
						[
							[
								531,
								574
							],
							[
								1483,
								1498
							],
							[
								1548,
								1573
							],
							[
								1633,
								1659
							],
							[
								1713,
								1741
							],
							[
								1799,
								1819
							],
							[
								1874,
								1898
							],
							[
								1957,
								1993
							],
							[
								2066,
								2105
							],
							[
								2179,
								2200
							],
							[
								2256,
								2278
							],
							[
								2335,
								2365
							],
							[
								2430,
								2468
							],
							[
								2541,
								2554
							],
							[
								2602,
								2625
							],
							[
								2683,
								2705
							],
							[
								2787,
								2791
							],
							[
								2819,
								2824
							],
							[
								2887,
								2892
							],
							[
								2960,
								2965
							],
							[
								3040,
								3044
							],
							[
								3068,
								3081
							],
							[
								3165,
								3180
							],
							[
								3256,
								3271
							],
							[
								3680,
								3685
							],
							[
								3762,
								3771
							],
							[
								3961,
								3985
							],
							[
								4396,
								4427
							],
							[
								4663,
								4696
							]
						],
						"symlist":
						[
							" function GLFW(width, height, options = {})",
							"handlePos(x, y)",
							"handleSize(width, height)",
							"handleClose(window = this)",
							"handleRefresh(window = this)",
							"handleFocus(focused)",
							"handleIconify(iconified)",
							"handleFramebufferSize(width, height)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"handleCursorEnter(cur)",
							"handleScroll(xoffset, yoffset)",
							"handleKey(key, scancode, action, mods)",
							"handleChar(c)",
							"handleCharMods(c, mods)",
							"handleDrop(argc, argv)",
							"GLFW",
							"get()",
							"get()",
							"get()",
							"GLFW",
							"move(...args)",
							"resize(...args)",
							"setTitle(title)",
							"end()",
							"show(mat)",
							" function Mat2Image(mat)",
							" function DrawImage(image, pos)",
							" function DrawCircle(pos, radius)"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABzAgAAR0xGVyh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pCiAgaGFuZGxlUG9zKHgsIHkpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUNsb3NlKHdpbmRvdyA9IHRoaXMpCiAgaGFuZGxlUmVmcmVzaCh3aW5kb3cgPSB0aGlzKQogIGhhbmRsZUZvY3VzKGZvY3VzZWQpCiAgaGFuZGxlSWNvbmlmeShpY29uaWZpZWQpCiAgaGFuZGxlRnJhbWVidWZmZXJTaXplKHdpZHRoLCBoZWlnaHQpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgaGFuZGxlQ3Vyc29yRW50ZXIoY3VyKQogIGhhbmRsZVNjcm9sbCh4b2Zmc2V0LCB5b2Zmc2V0KQogIGhhbmRsZUtleShrZXksIHNjYW5jb2RlLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ2hhcihjKQogIGhhbmRsZUNoYXJNb2RzKGMsIG1vZHMpCiAgaGFuZGxlRHJvcChhcmdjLCBhcmd2KQpHTEZXCiAgZ2V0KCkKICBnZXQoKQogIGdldCgpCkdMRlcKICBtb3ZlKC4uLmFyZ3MpCiAgcmVzaXplKC4uLmFyZ3MpCiAgc2V0VGl0bGUodGl0bGUpCiAgZW5kKCkKICBzaG93KG1hdCkKTWF0MkltYWdlKG1hdCkKRHJhd0ltYWdlKGltYWdlLCBwb3MpCkRyYXdDaXJjbGUocG9zLCByYWRpdXMpAAAAAAAAAABzAgAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					13,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3120,
								3124
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABzAgAAR0xGVyh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pCiAgaGFuZGxlUG9zKHgsIHkpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUNsb3NlKHdpbmRvdyA9IHRoaXMpCiAgaGFuZGxlUmVmcmVzaCh3aW5kb3cgPSB0aGlzKQogIGhhbmRsZUZvY3VzKGZvY3VzZWQpCiAgaGFuZGxlSWNvbmlmeShpY29uaWZpZWQpCiAgaGFuZGxlRnJhbWVidWZmZXJTaXplKHdpZHRoLCBoZWlnaHQpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgaGFuZGxlQ3Vyc29yRW50ZXIoY3VyKQogIGhhbmRsZVNjcm9sbCh4b2Zmc2V0LCB5b2Zmc2V0KQogIGhhbmRsZUtleShrZXksIHNjYW5jb2RlLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ2hhcihjKQogIGhhbmRsZUNoYXJNb2RzKGMsIG1vZHMpCiAgaGFuZGxlRHJvcChhcmdjLCBhcmd2KQpHTEZXCiAgZ2V0KCkKICBnZXQoKQogIGdldCgpCkdMRlcKICBtb3ZlKC4uLmFyZ3MpCiAgcmVzaXplKC4uLmFyZ3MpCiAgc2V0VGl0bGUodGl0bGUpCiAgZW5kKCkKICBzaG93KG1hdCkKTWF0MkltYWdlKG1hdCkKRHJhd0ltYWdlKGltYWdlLCBwb3MpCkRyYXdDaXJjbGUocG9zLCByYWRpdXMpAAAAAAAAAAC9AAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					14,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					15,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3120,
								3124
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"AQAAAAAAAAAAAAAAvQAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					16,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3190,
								3194
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAAC9AAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					17,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3189,
								3193
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAAC9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvQAAACAgbWFpbiguLi5hcmdzKQogIGhhbmRsZVNpemUod2lkdGgsIGhlaWdodCkKICBoYW5kbGVLZXkoa2V5Q29kZSkKJ1x4MDAnOiAoKSA9PgpROiAoKSA9PgogIGhhbmRsZUNoYXJNb2RzKGNoYXIsIG1vZHMpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgbiA9PgAAAAAAAAAAvQAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					18,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					19,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/draw-utils.js",
						"symkeys":
						[
							[
								531,
								574
							],
							[
								1483,
								1498
							],
							[
								1548,
								1573
							],
							[
								1633,
								1659
							],
							[
								1713,
								1741
							],
							[
								1799,
								1819
							],
							[
								1874,
								1898
							],
							[
								1957,
								1993
							],
							[
								2066,
								2105
							],
							[
								2179,
								2200
							],
							[
								2256,
								2278
							],
							[
								2335,
								2365
							],
							[
								2430,
								2468
							],
							[
								2541,
								2554
							],
							[
								2602,
								2625
							],
							[
								2683,
								2705
							],
							[
								2787,
								2791
							],
							[
								2819,
								2824
							],
							[
								2887,
								2892
							],
							[
								2960,
								2965
							],
							[
								3040,
								3044
							],
							[
								3068,
								3081
							],
							[
								3165,
								3180
							],
							[
								3256,
								3271
							],
							[
								3680,
								3685
							],
							[
								3762,
								3771
							],
							[
								3961,
								3985
							],
							[
								4396,
								4427
							],
							[
								4663,
								4696
							]
						],
						"symlist":
						[
							" function GLFW(width, height, options = {})",
							"handlePos(x, y)",
							"handleSize(width, height)",
							"handleClose(window = this)",
							"handleRefresh(window = this)",
							"handleFocus(focused)",
							"handleIconify(iconified)",
							"handleFramebufferSize(width, height)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"handleCursorEnter(cur)",
							"handleScroll(xoffset, yoffset)",
							"handleKey(key, scancode, action, mods)",
							"handleChar(c)",
							"handleCharMods(c, mods)",
							"handleDrop(argc, argv)",
							"GLFW",
							"get()",
							"get()",
							"get()",
							"GLFW",
							"move(...args)",
							"resize(...args)",
							"setTitle(title)",
							"end()",
							"show(mat)",
							" function Mat2Image(mat)",
							" function DrawImage(image, pos)",
							" function DrawCircle(pos, radius)"
						]
					},
					"AQAAAAAAAAAAAAAAcwIAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					26,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABzAgAAR0xGVyh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pCiAgaGFuZGxlUG9zKHgsIHkpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUNsb3NlKHdpbmRvdyA9IHRoaXMpCiAgaGFuZGxlUmVmcmVzaCh3aW5kb3cgPSB0aGlzKQogIGhhbmRsZUZvY3VzKGZvY3VzZWQpCiAgaGFuZGxlSWNvbmlmeShpY29uaWZpZWQpCiAgaGFuZGxlRnJhbWVidWZmZXJTaXplKHdpZHRoLCBoZWlnaHQpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgaGFuZGxlQ3Vyc29yRW50ZXIoY3VyKQogIGhhbmRsZVNjcm9sbCh4b2Zmc2V0LCB5b2Zmc2V0KQogIGhhbmRsZUtleShrZXksIHNjYW5jb2RlLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ2hhcihjKQogIGhhbmRsZUNoYXJNb2RzKGMsIG1vZHMpCiAgaGFuZGxlRHJvcChhcmdjLCBhcmd2KQpHTEZXCiAgZ2V0KCkKICBnZXQoKQogIGdldCgpCkdMRlcKICBtb3ZlKC4uLmFyZ3MpCiAgcmVzaXplKC4uLmFyZ3MpCiAgc2V0VGl0bGUodGl0bGUpCiAgZW5kKCkKICBzaG93KG1hdCkKTWF0MkltYWdlKG1hdCkKRHJhd0ltYWdlKGltYWdlLCBwb3MpCkRyYXdDaXJjbGUocG9zLCByYWRpdXMpAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAZwIAAAAAAABqAgAAAAAAAAAAAAAAAPC/"
				],
				[
					27,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-nanovg.js",
						"symkeys":
						[
							[
								409,
								431
							],
							[
								795,
								820
							],
							[
								883,
								901
							],
							[
								1134,
								1147
							],
							[
								1167,
								1175
							],
							[
								1243,
								1269
							],
							[
								1336,
								1375
							],
							[
								1455,
								1476
							],
							[
								3189,
								3193
							]
						],
						"symlist":
						[
							"function main(...args)",
							"handleSize(width, height)",
							"handleKey(keyCode)",
							"'\\x00': () =>",
							"Q: () =>",
							"handleCharMods(char, mods)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"n =>"
						]
					},
					"AQAAAAAAAAAAAAAAvQAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					28,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/test-opencv.js",
						"symkeys":
						[
							[
								729,
								751
							],
							[
								1521,
								1551
							],
							[
								1641,
								1671
							],
							[
								1737,
								1748
							],
							[
								2002,
								2023
							],
							[
								2197,
								2208
							],
							[
								2232,
								2243
							],
							[
								2353,
								2377
							],
							[
								2493,
								2515
							],
							[
								2609,
								2639
							],
							[
								2673,
								2701
							],
							[
								2861,
								2870
							],
							[
								2919,
								2927
							],
							[
								2975,
								2981
							],
							[
								3112,
								3119
							],
							[
								3197,
								3219
							],
							[
								4991,
								5015
							],
							[
								5494,
								5501
							],
							[
								7084,
								7121
							],
							[
								7193,
								7227
							],
							[
								7381,
								7410
							],
							[
								7514,
								7548
							],
							[
								7626,
								7661
							],
							[
								7954,
								7994
							],
							[
								8343,
								8377
							],
							[
								8615,
								8619
							],
							[
								8681,
								8692
							],
							[
								8793,
								8807
							],
							[
								8864,
								8868
							],
							[
								9425,
								9469
							],
							[
								10551,
								10593
							],
							[
								11042,
								11078
							],
							[
								12035,
								12039
							],
							[
								12088,
								12103
							],
							[
								12177,
								12181
							],
							[
								12250,
								12259
							],
							[
								12412,
								12431
							],
							[
								12492,
								12508
							],
							[
								12575,
								12579
							],
							[
								12613,
								12617
							],
							[
								12650,
								12659
							],
							[
								12692,
								12700
							],
							[
								12746,
								12750
							],
							[
								12783,
								12787
							],
							[
								12820,
								12829
							],
							[
								12862,
								12870
							],
							[
								12993,
								13011
							],
							[
								14062,
								14099
							],
							[
								15048,
								15056
							],
							[
								15730,
								15755
							],
							[
								16357,
								16371
							],
							[
								16755,
								16780
							],
							[
								17117,
								17133
							],
							[
								17245,
								17257
							],
							[
								17273,
								17288
							],
							[
								17325,
								17339
							]
						],
						"symlist":
						[
							"function GLFW(...args)",
							"function WriteImage(name, mat)",
							"function SaveConfig(configObj)",
							"([k, v]) =>",
							"function LoadConfig()",
							"([k, v]) =>",
							"([k, v]) =>",
							"function InspectMat(mat)",
							"function ToHex(number)",
							"function Accumulator(callback)",
							"self = function(name, value)",
							"entries()",
							"values()",
							"keys()",
							"clear()",
							"function main(...args)",
							" (event, x, y, flags) =>",
							"file =>",
							" function AcquireFrame(src, dst)",
							" function Grayscale(src, dst)",
							" function Blur(src, dst)",
							" function Threshold(src, dst)",
							" function Morphology(src, dst)",
							" function Skeletonization(src, dst)",
							" function ShowTrace(src, dst)",
							"n =>",
							"([n, m]) =>",
							"([h, s, l]) =>",
							"c =>",
							" function LineSegmentDetector(src, dst)",
							" function PixelNeighborhood(src, dst)",
							" function HoughLinesP(src, dst)",
							"l =>",
							"GetAngle = l =>",
							"l =>",
							"(a, b) =>",
							"isHorizontal = l =>",
							"firstLast = a =>",
							"l =>",
							"l =>",
							"(a, b) =>",
							"([l]) =>",
							"l =>",
							"l =>",
							"(a, b) =>",
							"([l]) =>",
							"angle2Color = a =>",
							" function HoughCircles(src, dst)",
							" i =>",
							" function RedrawStatus()",
							"(name, idx) =>",
							" function RedrawWindow()",
							"(name, param) =>",
							"processor =>",
							".before = () =>",
							".after = () =>"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAAC9AAAAICBtYWluKC4uLmFyZ3MpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUtleShrZXlDb2RlKQonXHgwMCc6ICgpID0+ClE6ICgpID0+CiAgaGFuZGxlQ2hhck1vZHMoY2hhciwgbW9kcykKICBoYW5kbGVNb3VzZUJ1dHRvbihidXR0b24sIGFjdGlvbiwgbW9kcykKICBoYW5kbGVDdXJzb3JQb3MoeCwgeSkKICBuID0+AAAAAAAAAABbAwAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					29,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABbAwAAR0xGVyguLi5hcmdzKQpXcml0ZUltYWdlKG5hbWUsIG1hdCkKU2F2ZUNvbmZpZyhjb25maWdPYmopCihbaywgdl0pID0+CkxvYWRDb25maWcoKQooW2ssIHZdKSA9PgooW2ssIHZdKSA9PgpJbnNwZWN0TWF0KG1hdCkKVG9IZXgobnVtYmVyKQpBY2N1bXVsYXRvcihjYWxsYmFjaykKICBzZWxmID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpCiAgZW50cmllcygpCiAgdmFsdWVzKCkKICBrZXlzKCkKICBjbGVhcigpCiAgbWFpbiguLi5hcmdzKQogIChldmVudCwgeCwgeSwgZmxhZ3MpID0+CiAgZmlsZSA9PgpBY3F1aXJlRnJhbWUoc3JjLCBkc3QpCkdyYXlzY2FsZShzcmMsIGRzdCkKQmx1cihzcmMsIGRzdCkKVGhyZXNob2xkKHNyYywgZHN0KQpNb3JwaG9sb2d5KHNyYywgZHN0KQpTa2VsZXRvbml6YXRpb24oc3JjLCBkc3QpClNob3dUcmFjZShzcmMsIGRzdCkKICBuID0+CihbbiwgbV0pID0+CihbaCwgcywgbF0pID0+CiAgYyA9PgpMaW5lU2VnbWVudERldGVjdG9yKHNyYywgZHN0KQpQaXhlbE5laWdoYm9yaG9vZChzcmMsIGRzdCkKSG91Z2hMaW5lc1Aoc3JjLCBkc3QpCiAgbCA9PgpHZXRBbmdsZSA9IGwgPT4KICBsID0+CihhLCBiKSA9PgogIGlzSG9yaXpvbnRhbCA9IGwgPT4KICBmaXJzdExhc3QgPSBhID0+CiAgbCA9PgogIGwgPT4KKGEsIGIpID0+CihbbF0pID0+CiAgbCA9PgogIGwgPT4KKGEsIGIpID0+CihbbF0pID0+CiAgYW5nbGUyQ29sb3IgPSBhID0+CkhvdWdoQ2lyY2xlcyhzcmMsIGRzdCkKICBpID0+ClJlZHJhd1N0YXR1cygpCihuYW1lLCBpZHgpID0+ClJlZHJhd1dpbmRvdygpCihuYW1lLCBwYXJhbSkgPT4KICBwcm9jZXNzb3IgPT4KICAuYmVmb3JlID0gKCkgPT4KICAuYWZ0ZXIgPSAoKSA9PgAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					30,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					31,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/draw-utils.js",
						"symkeys":
						[
							[
								531,
								574
							],
							[
								1483,
								1498
							],
							[
								1548,
								1573
							],
							[
								1633,
								1659
							],
							[
								1713,
								1741
							],
							[
								1799,
								1819
							],
							[
								1874,
								1898
							],
							[
								1957,
								1993
							],
							[
								2066,
								2105
							],
							[
								2179,
								2200
							],
							[
								2256,
								2278
							],
							[
								2335,
								2365
							],
							[
								2430,
								2468
							],
							[
								2541,
								2554
							],
							[
								2602,
								2625
							],
							[
								2683,
								2705
							],
							[
								2787,
								2791
							],
							[
								2819,
								2824
							],
							[
								2887,
								2892
							],
							[
								2960,
								2965
							],
							[
								3040,
								3044
							],
							[
								3068,
								3081
							],
							[
								3165,
								3180
							],
							[
								3256,
								3271
							],
							[
								3680,
								3685
							],
							[
								3762,
								3771
							],
							[
								3961,
								3985
							],
							[
								4396,
								4427
							],
							[
								4663,
								4696
							]
						],
						"symlist":
						[
							" function GLFW(width, height, options = {})",
							"handlePos(x, y)",
							"handleSize(width, height)",
							"handleClose(window = this)",
							"handleRefresh(window = this)",
							"handleFocus(focused)",
							"handleIconify(iconified)",
							"handleFramebufferSize(width, height)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"handleCursorEnter(cur)",
							"handleScroll(xoffset, yoffset)",
							"handleKey(key, scancode, action, mods)",
							"handleChar(c)",
							"handleCharMods(c, mods)",
							"handleDrop(argc, argv)",
							"GLFW",
							"get()",
							"get()",
							"get()",
							"GLFW",
							"move(...args)",
							"resize(...args)",
							"setTitle(title)",
							"end()",
							"show(mat)",
							" function Mat2Image(mat)",
							" function DrawImage(image, pos)",
							" function DrawCircle(pos, radius)"
						]
					},
					"AQAAAAAAAAAAAAAAcwIAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					32,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABzAgAAR0xGVyh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pCiAgaGFuZGxlUG9zKHgsIHkpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUNsb3NlKHdpbmRvdyA9IHRoaXMpCiAgaGFuZGxlUmVmcmVzaCh3aW5kb3cgPSB0aGlzKQogIGhhbmRsZUZvY3VzKGZvY3VzZWQpCiAgaGFuZGxlSWNvbmlmeShpY29uaWZpZWQpCiAgaGFuZGxlRnJhbWVidWZmZXJTaXplKHdpZHRoLCBoZWlnaHQpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgaGFuZGxlQ3Vyc29yRW50ZXIoY3VyKQogIGhhbmRsZVNjcm9sbCh4b2Zmc2V0LCB5b2Zmc2V0KQogIGhhbmRsZUtleShrZXksIHNjYW5jb2RlLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ2hhcihjKQogIGhhbmRsZUNoYXJNb2RzKGMsIG1vZHMpCiAgaGFuZGxlRHJvcChhcmdjLCBhcmd2KQpHTEZXCiAgZ2V0KCkKICBnZXQoKQogIGdldCgpCkdMRlcKICBtb3ZlKC4uLmFyZ3MpCiAgcmVzaXplKC4uLmFyZ3MpCiAgc2V0VGl0bGUodGl0bGUpCiAgZW5kKCkKICBzaG93KG1hdCkKTWF0MkltYWdlKG1hdCkKRHJhd0ltYWdlKGltYWdlLCBwb3MpCkRyYXdDaXJjbGUocG9zLCByYWRpdXMpAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					33,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/draw-utils.js",
						"symkeys":
						[
							[
								531,
								574
							],
							[
								1483,
								1498
							],
							[
								1548,
								1573
							],
							[
								1633,
								1659
							],
							[
								1713,
								1741
							],
							[
								1799,
								1819
							],
							[
								1874,
								1898
							],
							[
								1957,
								1993
							],
							[
								2066,
								2105
							],
							[
								2179,
								2200
							],
							[
								2256,
								2278
							],
							[
								2335,
								2365
							],
							[
								2430,
								2468
							],
							[
								2541,
								2554
							],
							[
								2602,
								2625
							],
							[
								2683,
								2705
							],
							[
								2787,
								2791
							],
							[
								2819,
								2824
							],
							[
								2887,
								2892
							],
							[
								2960,
								2965
							],
							[
								3040,
								3044
							],
							[
								3068,
								3081
							],
							[
								3165,
								3180
							],
							[
								3256,
								3271
							],
							[
								3680,
								3685
							],
							[
								3762,
								3771
							],
							[
								3961,
								3985
							],
							[
								4396,
								4427
							],
							[
								4663,
								4696
							]
						],
						"symlist":
						[
							" function GLFW(width, height, options = {})",
							"handlePos(x, y)",
							"handleSize(width, height)",
							"handleClose(window = this)",
							"handleRefresh(window = this)",
							"handleFocus(focused)",
							"handleIconify(iconified)",
							"handleFramebufferSize(width, height)",
							"handleMouseButton(button, action, mods)",
							"handleCursorPos(x, y)",
							"handleCursorEnter(cur)",
							"handleScroll(xoffset, yoffset)",
							"handleKey(key, scancode, action, mods)",
							"handleChar(c)",
							"handleCharMods(c, mods)",
							"handleDrop(argc, argv)",
							"GLFW",
							"get()",
							"get()",
							"get()",
							"GLFW",
							"move(...args)",
							"resize(...args)",
							"setTitle(title)",
							"end()",
							"show(mat)",
							" function Mat2Image(mat)",
							" function DrawImage(image, pos)",
							" function DrawCircle(pos, radius)"
						]
					},
					"AQAAAAAAAAAAAAAAcwIAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					34,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABzAgAAR0xGVyh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pCiAgaGFuZGxlUG9zKHgsIHkpCiAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KQogIGhhbmRsZUNsb3NlKHdpbmRvdyA9IHRoaXMpCiAgaGFuZGxlUmVmcmVzaCh3aW5kb3cgPSB0aGlzKQogIGhhbmRsZUZvY3VzKGZvY3VzZWQpCiAgaGFuZGxlSWNvbmlmeShpY29uaWZpZWQpCiAgaGFuZGxlRnJhbWVidWZmZXJTaXplKHdpZHRoLCBoZWlnaHQpCiAgaGFuZGxlTW91c2VCdXR0b24oYnV0dG9uLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpCiAgaGFuZGxlQ3Vyc29yRW50ZXIoY3VyKQogIGhhbmRsZVNjcm9sbCh4b2Zmc2V0LCB5b2Zmc2V0KQogIGhhbmRsZUtleShrZXksIHNjYW5jb2RlLCBhY3Rpb24sIG1vZHMpCiAgaGFuZGxlQ2hhcihjKQogIGhhbmRsZUNoYXJNb2RzKGMsIG1vZHMpCiAgaGFuZGxlRHJvcChhcmdjLCBhcmd2KQpHTEZXCiAgZ2V0KCkKICBnZXQoKQogIGdldCgpCkdMRlcKICBtb3ZlKC4uLmFyZ3MpCiAgcmVzaXplKC4uLmFyZ3MpCiAgc2V0VGl0bGUodGl0bGUpCiAgZW5kKCkKICBzaG93KG1hdCkKTWF0MkltYWdlKG1hdCkKRHJhd0ltYWdlKGltYWdlLCBwb3MpCkRyYXdDaXJjbGUocG9zLCByYWRpdXMpAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					35,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/qjs-opencv/point.js",
						"symkeys":
						[
							[
								30,
								35
							],
							[
								77,
								90
							],
							[
								137,
								144
							],
							[
								191,
								198
							],
							[
								291,
								298
							],
							[
								389,
								394
							],
							[
								488,
								496
							],
							[
								594,
								606
							],
							[
								697,
								702
							],
							[
								793,
								798
							],
							[
								889,
								894
							],
							[
								985,
								990
							],
							[
								1082,
								1088
							],
							[
								1179,
								1184
							],
							[
								1277,
								1284
							],
							[
								1377,
								1384
							],
							[
								1477,
								1484
							],
							[
								1576,
								1582
							],
							[
								1678,
								1688
							],
							[
								1783,
								1792
							],
							[
								2231,
								2244
							],
							[
								2331,
								2349
							],
							[
								2431,
								2444
							],
							[
								2530,
								2547
							]
						],
						"symlist":
						[
							"Point",
							"constructor()",
							"get x()",
							"get y()",
							"cross()",
							"dot()",
							"inside()",
							"difference()",
							"add()",
							"sub()",
							"mul()",
							"div()",
							"norm()",
							"abs()",
							"angle()",
							"round()",
							"floor()",
							"ceil()",
							"toString()",
							"toArray()",
							"static from()",
							"static fromAngle()",
							"static diff()",
							"static distance()"
						]
					},
					"AQAAAAAAAAAAAAAADwEAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					36,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAAAPAQAAUG9pbnQKICBjb25zdHJ1Y3RvcigpCiAgZ2V0IHgoKQogIGdldCB5KCkKICBjcm9zcygpCiAgZG90KCkKICBpbnNpZGUoKQogIGRpZmZlcmVuY2UoKQogIGFkZCgpCiAgc3ViKCkKICBtdWwoKQogIGRpdigpCiAgbm9ybSgpCiAgYWJzKCkKICBhbmdsZSgpCiAgcm91bmQoKQogIGZsb29yKCkKICBjZWlsKCkKICB0b1N0cmluZygpCiAgdG9BcnJheSgpCiAgc3RhdGljIGZyb20oKQogIHN0YXRpYyBmcm9tQW5nbGUoKQogIHN0YXRpYyBkaWZmKCkKICBzdGF0aWMgZGlzdGFuY2UoKQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					37,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/lib/geom/point.js",
						"symkeys":
						[
							[
								66,
								73
							],
							[
								82,
								90
							],
							[
								113,
								126
							],
							[
								289,
								313
							],
							[
								1667,
								1691
							],
							[
								1825,
								1830
							],
							[
								1855,
								1860
							],
							[
								1906,
								1911
							],
							[
								1950,
								1987
							],
							[
								2038,
								2077
							],
							[
								2126,
								2164
							],
							[
								2213,
								2247
							],
							[
								2374,
								2408
							],
							[
								2533,
								2572
							],
							[
								2687,
								2726
							],
							[
								2825,
								2861
							],
							[
								2893,
								2913
							],
							[
								3017,
								3056
							],
							[
								3155,
								3189
							],
							[
								3288,
								3321
							],
							[
								3421,
								3459
							],
							[
								3580,
								3617
							],
							[
								3739,
								3772
							],
							[
								3826,
								3858
							],
							[
								3911,
								3977
							],
							[
								4075,
								4134
							],
							[
								4156,
								4161
							],
							[
								4218,
								4258
							],
							[
								4330,
								4395
							],
							[
								4621,
								4654
							],
							[
								4748,
								4782
							],
							[
								4879,
								4916
							],
							[
								4969,
								5004
							],
							[
								5037,
								5092
							],
							[
								5183,
								5230
							],
							[
								5301,
								5353
							],
							[
								5400,
								5405
							],
							[
								5456,
								5521
							],
							[
								5766,
								5771
							],
							[
								5799,
								5810
							],
							[
								6003,
								6049
							],
							[
								6514,
								6519
							],
							[
								6561,
								6607
							],
							[
								6655,
								6665
							],
							[
								6779,
								6787
							],
							[
								7185,
								7245
							],
							[
								7351,
								7427
							],
							[
								7560,
								7602
							],
							[
								7678,
								7713
							],
							[
								7756,
								7795
							],
							[
								7913,
								7966
							],
							[
								8286,
								8291
							],
							[
								8350,
								8392
							],
							[
								8534,
								8572
							],
							[
								8585,
								8590
							],
							[
								8631,
								8636
							],
							[
								8682,
								8717
							],
							[
								8730,
								8735
							],
							[
								8825,
								8850
							],
							[
								8892,
								8896
							],
							[
								8903,
								8932
							],
							[
								8933,
								8938
							],
							[
								8973,
								9017
							],
							[
								9018,
								9023
							],
							[
								9065,
								9096
							],
							[
								9097,
								9102
							],
							[
								9139,
								9168
							],
							[
								9169,
								9174
							],
							[
								9209,
								9231
							],
							[
								9232,
								9237
							],
							[
								9265,
								9287
							],
							[
								9288,
								9293
							],
							[
								9321,
								9345
							],
							[
								9346,
								9351
							],
							[
								9381,
								9425
							],
							[
								9426,
								9431
							],
							[
								9481,
								9512
							],
							[
								9732,
								9752
							],
							[
								9753,
								9758
							],
							[
								9806,
								9840
							],
							[
								9952,
								10028
							],
							[
								10123,
								10137
							],
							[
								10406,
								10411
							],
							[
								10443,
								10468
							],
							[
								10567,
								10592
							],
							[
								10717,
								10734
							],
							[
								10901,
								10906
							],
							[
								10985,
								10996
							],
							[
								11126,
								11132
							]
						],
						"symlist":
						[
							" () =>",
							" sym =>",
							"CTOR = obj =>",
							" function Point(...args)",
							"Point.getOther = args =>",
							"Point",
							"get()",
							"get()",
							"Point.prototype.move = function(x, y)",
							"Point.prototype.moveTo = function(x, y)",
							"Point.prototype.clear = function(x, y)",
							"Point.prototype.set = function(fn)",
							"Point.prototype.clone = function()",
							"Point.prototype.sum = function(...args)",
							"Point.prototype.add = function(...args)",
							"Point.prototype.diff = function(arg)",
							"fn = function(other)",
							"Point.prototype.sub = function(...args)",
							"Point.prototype.prod = function(f)",
							"Point.prototype.mul = function(f)",
							"Point.prototype.quot = function(other)",
							"Point.prototype.div = function(other)",
							"Point.prototype.comp = function()",
							"Point.prototype.neg = function()",
							"Point.prototype.distanceSquared = function(other = { x: 0, y: 0 })",
							"Point.prototype.distance = function(other = { x: 0, y: 0 })",
							"Point",
							"Point.prototype.equals = function(other)",
							"Point.prototype.round = function(precision = 0.001, digits, type)",
							"Point.prototype.ceil = function()",
							"Point.prototype.floor = function()",
							"Point.prototype.dot = function(other)",
							"Point.prototype.values = function()",
							"Point.prototype.fromAngle = function(angle, dist = 1.0)",
							"Point.prototype.toAngle = function(deg = false)",
							"Point.prototype.angle = function(other, deg = false)",
							"Point",
							"Point.prototype.rotate = function(angle, origin = { x: 0, y: 0 })",
							"Point",
							" function()",
							"Point.prototype.toString = function(opts = {})",
							"Point",
							"Point.prototype.toSource = function(opts = {})",
							"pad = a =>",
							"c = t =>",
							"Point.prototype.toObject = function(proto = Point.prototype)",
							"Point.prototype.toCSS = function(precision = 0.001, edges = ['left', 'top'])",
							"Point.prototype.toFixed = function(digits)",
							"Point.prototype.isNull = function()",
							"Point.prototype.inside = function(rect)",
							"Point.prototype.transform = function(m, round = true)",
							"Point",
							"Point.prototype.scaleTo = function(minmax)",
							"Point.prototype.normalize = function()",
							"Point",
							"Point",
							"Point.prototype.normal = function()",
							"Point",
							"Point.fromString = str =>",
							"n =>",
							"Point.move = (point, x, y) =>",
							"Point",
							"Point.angle = (point, other, deg = false) =>",
							"Point",
							"Point.inside = (point, rect) =>",
							"Point",
							"Point.sub = (point, other) =>",
							"Point",
							"Point.prod = (a, b) =>",
							"Point",
							"Point.quot = (a, b) =>",
							"Point",
							"Point.equals = (a, b) =>",
							"Point",
							"Point.round = (point, prec, digits, type) =>",
							"Point",
							"Point.fromAngle = (angle, f) =>",
							" (point, ...args) =>",
							"Point",
							"Point.interpolate = (p1, p2, a) =>",
							"Point.toSource = (point, { space = ' ', padding = ' ', separator = ',' }) =>",
							"isPoint = o =>",
							"Point",
							" function(depth, options)",
							"Point.bind = (...args) =>",
							"(acc, name, i) =>",
							"Point",
							" function()",
							" () =>"
						]
					},
					"AQAAAAAAAAAAAAAAywkAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					38,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADLCQAAICAoKSA9PgogIHN5bSA9PgpDVE9SID0gb2JqID0+ClBvaW50KC4uLmFyZ3MpClBvaW50LmdldE90aGVyID0gYXJncyA9PgpQb2ludAogIGdldCgpCiAgZ2V0KCkKUG9pbnQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KQpQb2ludC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkKUG9pbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oeCwgeSkKUG9pbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZuKQpQb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiguLi5hcmdzKQpQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oLi4uYXJncykKUG9pbnQucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbihhcmcpCiAgZm4gPSBmdW5jdGlvbihvdGhlcikKUG9pbnQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKC4uLmFyZ3MpClBvaW50LnByb3RvdHlwZS5wcm9kID0gZnVuY3Rpb24oZikKUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGYpClBvaW50LnByb3RvdHlwZS5xdW90ID0gZnVuY3Rpb24ob3RoZXIpClBvaW50LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihvdGhlcikKUG9pbnQucHJvdG90eXBlLmNvbXAgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5kaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbihvdGhlciA9IHsgeDogMCwgeTogMCB9KQpQb2ludC5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihvdGhlciA9IHsgeDogMCwgeTogMCB9KQpQb2ludApQb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpClBvaW50LnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKHByZWNpc2lvbiA9IDAuMDAxLCBkaWdpdHMsIHR5cGUpClBvaW50LnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24oKQpQb2ludC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihvdGhlcikKUG9pbnQucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkKUG9pbnQucHJvdG90eXBlLmZyb21BbmdsZSA9IGZ1bmN0aW9uKGFuZ2xlLCBkaXN0ID0gMS4wKQpQb2ludC5wcm90b3R5cGUudG9BbmdsZSA9IGZ1bmN0aW9uKGRlZyA9IGZhbHNlKQpQb2ludC5wcm90b3R5cGUuYW5nbGUgPSBmdW5jdGlvbihvdGhlciwgZGVnID0gZmFsc2UpClBvaW50ClBvaW50LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSwgb3JpZ2luID0geyB4OiAwLCB5OiAwIH0pClBvaW50CiAgZnVuY3Rpb24oKQpQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRzID0ge30pClBvaW50ClBvaW50LnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uKG9wdHMgPSB7fSkKICBwYWQgPSBhID0+CiAgYyA9IHQgPT4KUG9pbnQucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24ocHJvdG8gPSBQb2ludC5wcm90b3R5cGUpClBvaW50LnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uKHByZWNpc2lvbiA9IDAuMDAxLCBlZGdlcyA9IFsnbGVmdCcsICd0b3AnXSkKUG9pbnQucHJvdG90eXBlLnRvRml4ZWQgPSBmdW5jdGlvbihkaWdpdHMpClBvaW50LnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5pbnNpZGUgPSBmdW5jdGlvbihyZWN0KQpQb2ludC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24obSwgcm91bmQgPSB0cnVlKQpQb2ludApQb2ludC5wcm90b3R5cGUuc2NhbGVUbyA9IGZ1bmN0aW9uKG1pbm1heCkKUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkKUG9pbnQKUG9pbnQKUG9pbnQucHJvdG90eXBlLm5vcm1hbCA9IGZ1bmN0aW9uKCkKUG9pbnQKUG9pbnQuZnJvbVN0cmluZyA9IHN0ciA9PgogIG4gPT4KUG9pbnQubW92ZSA9IChwb2ludCwgeCwgeSkgPT4KUG9pbnQKUG9pbnQuYW5nbGUgPSAocG9pbnQsIG90aGVyLCBkZWcgPSBmYWxzZSkgPT4KUG9pbnQKUG9pbnQuaW5zaWRlID0gKHBvaW50LCByZWN0KSA9PgpQb2ludApQb2ludC5zdWIgPSAocG9pbnQsIG90aGVyKSA9PgpQb2ludApQb2ludC5wcm9kID0gKGEsIGIpID0+ClBvaW50ClBvaW50LnF1b3QgPSAoYSwgYikgPT4KUG9pbnQKUG9pbnQuZXF1YWxzID0gKGEsIGIpID0+ClBvaW50ClBvaW50LnJvdW5kID0gKHBvaW50LCBwcmVjLCBkaWdpdHMsIHR5cGUpID0+ClBvaW50ClBvaW50LmZyb21BbmdsZSA9IChhbmdsZSwgZikgPT4KICAocG9pbnQsIC4uLmFyZ3MpID0+ClBvaW50ClBvaW50LmludGVycG9sYXRlID0gKHAxLCBwMiwgYSkgPT4KUG9pbnQudG9Tb3VyY2UgPSAocG9pbnQsIHsgc3BhY2UgPSAnICcsIHBhZGRpbmcgPSAnICcsIHNlcGFyYXRvciA9ICcsJyB9KSA9PgogIGlzUG9pbnQgPSBvID0+ClBvaW50CiAgZnVuY3Rpb24oZGVwdGgsIG9wdGlvbnMpClBvaW50LmJpbmQgPSAoLi4uYXJncykgPT4KKGFjYywgbmFtZSwgaSkgPT4KUG9pbnQKICBmdW5jdGlvbigpCiAgKCkgPT4AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					39,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/lib/geom/point.js",
						"symkeys":
						[
							[
								66,
								73
							],
							[
								82,
								90
							],
							[
								113,
								126
							],
							[
								289,
								313
							],
							[
								1667,
								1691
							],
							[
								1825,
								1830
							],
							[
								1855,
								1860
							],
							[
								1906,
								1911
							],
							[
								1950,
								1987
							],
							[
								2038,
								2077
							],
							[
								2126,
								2164
							],
							[
								2213,
								2247
							],
							[
								2374,
								2408
							],
							[
								2533,
								2572
							],
							[
								2687,
								2726
							],
							[
								2825,
								2861
							],
							[
								2893,
								2913
							],
							[
								3017,
								3056
							],
							[
								3155,
								3189
							],
							[
								3288,
								3321
							],
							[
								3421,
								3459
							],
							[
								3580,
								3617
							],
							[
								3739,
								3772
							],
							[
								3826,
								3858
							],
							[
								3911,
								3977
							],
							[
								4075,
								4134
							],
							[
								4156,
								4161
							],
							[
								4218,
								4258
							],
							[
								4330,
								4395
							],
							[
								4621,
								4654
							],
							[
								4748,
								4782
							],
							[
								4879,
								4916
							],
							[
								4969,
								5004
							],
							[
								5037,
								5092
							],
							[
								5183,
								5230
							],
							[
								5301,
								5353
							],
							[
								5400,
								5405
							],
							[
								5456,
								5521
							],
							[
								5766,
								5771
							],
							[
								5799,
								5810
							],
							[
								6003,
								6049
							],
							[
								6514,
								6519
							],
							[
								6561,
								6607
							],
							[
								6655,
								6665
							],
							[
								6779,
								6787
							],
							[
								7185,
								7245
							],
							[
								7351,
								7427
							],
							[
								7560,
								7602
							],
							[
								7678,
								7713
							],
							[
								7756,
								7795
							],
							[
								7913,
								7966
							],
							[
								8286,
								8291
							],
							[
								8350,
								8392
							],
							[
								8534,
								8572
							],
							[
								8585,
								8590
							],
							[
								8631,
								8636
							],
							[
								8682,
								8717
							],
							[
								8730,
								8735
							],
							[
								8825,
								8850
							],
							[
								8892,
								8896
							],
							[
								8903,
								8932
							],
							[
								8933,
								8938
							],
							[
								8973,
								9017
							],
							[
								9018,
								9023
							],
							[
								9065,
								9096
							],
							[
								9097,
								9102
							],
							[
								9139,
								9168
							],
							[
								9169,
								9174
							],
							[
								9209,
								9231
							],
							[
								9232,
								9237
							],
							[
								9265,
								9287
							],
							[
								9288,
								9293
							],
							[
								9321,
								9345
							],
							[
								9346,
								9351
							],
							[
								9381,
								9425
							],
							[
								9426,
								9431
							],
							[
								9481,
								9512
							],
							[
								9732,
								9752
							],
							[
								9753,
								9758
							],
							[
								9806,
								9840
							],
							[
								9952,
								10028
							],
							[
								10123,
								10137
							],
							[
								10406,
								10411
							],
							[
								10443,
								10468
							],
							[
								10567,
								10592
							],
							[
								10717,
								10734
							],
							[
								10901,
								10906
							],
							[
								10985,
								10996
							],
							[
								11126,
								11132
							]
						],
						"symlist":
						[
							" () =>",
							" sym =>",
							"CTOR = obj =>",
							" function Point(...args)",
							"Point.getOther = args =>",
							"Point",
							"get()",
							"get()",
							"Point.prototype.move = function(x, y)",
							"Point.prototype.moveTo = function(x, y)",
							"Point.prototype.clear = function(x, y)",
							"Point.prototype.set = function(fn)",
							"Point.prototype.clone = function()",
							"Point.prototype.sum = function(...args)",
							"Point.prototype.add = function(...args)",
							"Point.prototype.diff = function(arg)",
							"fn = function(other)",
							"Point.prototype.sub = function(...args)",
							"Point.prototype.prod = function(f)",
							"Point.prototype.mul = function(f)",
							"Point.prototype.quot = function(other)",
							"Point.prototype.div = function(other)",
							"Point.prototype.comp = function()",
							"Point.prototype.neg = function()",
							"Point.prototype.distanceSquared = function(other = { x: 0, y: 0 })",
							"Point.prototype.distance = function(other = { x: 0, y: 0 })",
							"Point",
							"Point.prototype.equals = function(other)",
							"Point.prototype.round = function(precision = 0.001, digits, type)",
							"Point.prototype.ceil = function()",
							"Point.prototype.floor = function()",
							"Point.prototype.dot = function(other)",
							"Point.prototype.values = function()",
							"Point.prototype.fromAngle = function(angle, dist = 1.0)",
							"Point.prototype.toAngle = function(deg = false)",
							"Point.prototype.angle = function(other, deg = false)",
							"Point",
							"Point.prototype.rotate = function(angle, origin = { x: 0, y: 0 })",
							"Point",
							" function()",
							"Point.prototype.toString = function(opts = {})",
							"Point",
							"Point.prototype.toSource = function(opts = {})",
							"pad = a =>",
							"c = t =>",
							"Point.prototype.toObject = function(proto = Point.prototype)",
							"Point.prototype.toCSS = function(precision = 0.001, edges = ['left', 'top'])",
							"Point.prototype.toFixed = function(digits)",
							"Point.prototype.isNull = function()",
							"Point.prototype.inside = function(rect)",
							"Point.prototype.transform = function(m, round = true)",
							"Point",
							"Point.prototype.scaleTo = function(minmax)",
							"Point.prototype.normalize = function()",
							"Point",
							"Point",
							"Point.prototype.normal = function()",
							"Point",
							"Point.fromString = str =>",
							"n =>",
							"Point.move = (point, x, y) =>",
							"Point",
							"Point.angle = (point, other, deg = false) =>",
							"Point",
							"Point.inside = (point, rect) =>",
							"Point",
							"Point.sub = (point, other) =>",
							"Point",
							"Point.prod = (a, b) =>",
							"Point",
							"Point.quot = (a, b) =>",
							"Point",
							"Point.equals = (a, b) =>",
							"Point",
							"Point.round = (point, prec, digits, type) =>",
							"Point",
							"Point.fromAngle = (angle, f) =>",
							" (point, ...args) =>",
							"Point",
							"Point.interpolate = (p1, p2, a) =>",
							"Point.toSource = (point, { space = ' ', padding = ' ', separator = ',' }) =>",
							"isPoint = o =>",
							"Point",
							" function(depth, options)",
							"Point.bind = (...args) =>",
							"(acc, name, i) =>",
							"Point",
							" function()",
							" () =>"
						]
					},
					"AQAAAAAAAAAAAAAAywkAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					1,
					2,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AwAAAAAAAAAAAAAAAAAAAAAAAADLCQAAICAoKSA9PgogIHN5bSA9PgpDVE9SID0gb2JqID0+ClBvaW50KC4uLmFyZ3MpClBvaW50LmdldE90aGVyID0gYXJncyA9PgpQb2ludAogIGdldCgpCiAgZ2V0KCkKUG9pbnQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KQpQb2ludC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkKUG9pbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oeCwgeSkKUG9pbnQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZuKQpQb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiguLi5hcmdzKQpQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oLi4uYXJncykKUG9pbnQucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbihhcmcpCiAgZm4gPSBmdW5jdGlvbihvdGhlcikKUG9pbnQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKC4uLmFyZ3MpClBvaW50LnByb3RvdHlwZS5wcm9kID0gZnVuY3Rpb24oZikKUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGYpClBvaW50LnByb3RvdHlwZS5xdW90ID0gZnVuY3Rpb24ob3RoZXIpClBvaW50LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihvdGhlcikKUG9pbnQucHJvdG90eXBlLmNvbXAgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5kaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbihvdGhlciA9IHsgeDogMCwgeTogMCB9KQpQb2ludC5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihvdGhlciA9IHsgeDogMCwgeTogMCB9KQpQb2ludApQb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpClBvaW50LnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKHByZWNpc2lvbiA9IDAuMDAxLCBkaWdpdHMsIHR5cGUpClBvaW50LnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24oKQpQb2ludC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihvdGhlcikKUG9pbnQucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkKUG9pbnQucHJvdG90eXBlLmZyb21BbmdsZSA9IGZ1bmN0aW9uKGFuZ2xlLCBkaXN0ID0gMS4wKQpQb2ludC5wcm90b3R5cGUudG9BbmdsZSA9IGZ1bmN0aW9uKGRlZyA9IGZhbHNlKQpQb2ludC5wcm90b3R5cGUuYW5nbGUgPSBmdW5jdGlvbihvdGhlciwgZGVnID0gZmFsc2UpClBvaW50ClBvaW50LnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSwgb3JpZ2luID0geyB4OiAwLCB5OiAwIH0pClBvaW50CiAgZnVuY3Rpb24oKQpQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRzID0ge30pClBvaW50ClBvaW50LnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uKG9wdHMgPSB7fSkKICBwYWQgPSBhID0+CiAgYyA9IHQgPT4KUG9pbnQucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24ocHJvdG8gPSBQb2ludC5wcm90b3R5cGUpClBvaW50LnByb3RvdHlwZS50b0NTUyA9IGZ1bmN0aW9uKHByZWNpc2lvbiA9IDAuMDAxLCBlZGdlcyA9IFsnbGVmdCcsICd0b3AnXSkKUG9pbnQucHJvdG90eXBlLnRvRml4ZWQgPSBmdW5jdGlvbihkaWdpdHMpClBvaW50LnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbigpClBvaW50LnByb3RvdHlwZS5pbnNpZGUgPSBmdW5jdGlvbihyZWN0KQpQb2ludC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24obSwgcm91bmQgPSB0cnVlKQpQb2ludApQb2ludC5wcm90b3R5cGUuc2NhbGVUbyA9IGZ1bmN0aW9uKG1pbm1heCkKUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkKUG9pbnQKUG9pbnQKUG9pbnQucHJvdG90eXBlLm5vcm1hbCA9IGZ1bmN0aW9uKCkKUG9pbnQKUG9pbnQuZnJvbVN0cmluZyA9IHN0ciA9PgogIG4gPT4KUG9pbnQubW92ZSA9IChwb2ludCwgeCwgeSkgPT4KUG9pbnQKUG9pbnQuYW5nbGUgPSAocG9pbnQsIG90aGVyLCBkZWcgPSBmYWxzZSkgPT4KUG9pbnQKUG9pbnQuaW5zaWRlID0gKHBvaW50LCByZWN0KSA9PgpQb2ludApQb2ludC5zdWIgPSAocG9pbnQsIG90aGVyKSA9PgpQb2ludApQb2ludC5wcm9kID0gKGEsIGIpID0+ClBvaW50ClBvaW50LnF1b3QgPSAoYSwgYikgPT4KUG9pbnQKUG9pbnQuZXF1YWxzID0gKGEsIGIpID0+ClBvaW50ClBvaW50LnJvdW5kID0gKHBvaW50LCBwcmVjLCBkaWdpdHMsIHR5cGUpID0+ClBvaW50ClBvaW50LmZyb21BbmdsZSA9IChhbmdsZSwgZikgPT4KICAocG9pbnQsIC4uLmFyZ3MpID0+ClBvaW50ClBvaW50LmludGVycG9sYXRlID0gKHAxLCBwMiwgYSkgPT4KUG9pbnQudG9Tb3VyY2UgPSAocG9pbnQsIHsgc3BhY2UgPSAnICcsIHBhZGRpbmcgPSAnICcsIHNlcGFyYXRvciA9ICcsJyB9KSA9PgogIGlzUG9pbnQgPSBvID0+ClBvaW50CiAgZnVuY3Rpb24oZGVwdGgsIG9wdGlvbnMpClBvaW50LmJpbmQgPSAoLi4uYXJncykgPT4KKGFjYywgbmFtZSwgaSkgPT4KUG9pbnQKICBmdW5jdGlvbigpCiAgKCkgPT4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvw"
				],
				[
					2,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/check-discogs.js",
						"symkeys":
						[
							[
								237,
								265
							],
							[
								623,
								627
							],
							[
								1448,
								1477
							],
							[
								1942,
								1946
							],
							[
								2043,
								2047
							],
							[
								2096,
								2102
							],
							[
								2131,
								2137
							],
							[
								2221,
								2228
							],
							[
								2489,
								2508
							],
							[
								2633,
								2652
							],
							[
								3187,
								3213
							]
						],
						"symlist":
						[
							"async function main(...args)",
							"n =>",
							" function ColorStr(c, str)",
							"p =>",
							"p =>",
							"str =>",
							"str =>",
							"part =>",
							"(line, field, i) =>",
							"(line, field, i) =>",
							"async function dl(orderId)"
						]
					},
					"AQAAAAAAAAAAAAAAhwAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					3,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACHAAAAICBtYWluKC4uLmFyZ3MpCiAgbiA9PgpDb2xvclN0cihjLCBzdHIpCiAgcCA9PgogIHAgPT4KICBzdHIgPT4KICBzdHIgPT4KICBwYXJ0ID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgogIGRsKG9yZGVySWQpAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					4,
					3,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/check-discogs.js",
						"symkeys":
						[
							[
								237,
								265
							],
							[
								623,
								627
							],
							[
								1448,
								1477
							],
							[
								1942,
								1946
							],
							[
								2043,
								2047
							],
							[
								2096,
								2102
							],
							[
								2131,
								2137
							],
							[
								2221,
								2228
							],
							[
								2489,
								2508
							],
							[
								2633,
								2652
							],
							[
								3187,
								3213
							]
						],
						"symlist":
						[
							"async function main(...args)",
							"n =>",
							" function ColorStr(c, str)",
							"p =>",
							"p =>",
							"str =>",
							"str =>",
							"part =>",
							"(line, field, i) =>",
							"(line, field, i) =>",
							"async function dl(orderId)"
						]
					},
					"BQAAAAAAAAAAAAAAhwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIcAAAAgIG1haW4oLi4uYXJncykKICBuID0+CkNvbG9yU3RyKGMsIHN0cikKICBwID0+CiAgcCA9PgogIHN0ciA9PgogIHN0ciA9PgogIHBhcnQgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgoobGluZSwgZmllbGQsIGkpID0+CiAgZGwob3JkZXJJZCkAAAAAAAAAAIcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHAAAAICBtYWluKC4uLmFyZ3MpCiAgbiA9PgpDb2xvclN0cihjLCBzdHIpCiAgcCA9PgogIHAgPT4KICBzdHIgPT4KICBzdHIgPT4KICBwYXJ0ID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgogIGRsKG9yZGVySWQpAAAAAAAAAACHAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					5,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/check-discogs.js",
						"symkeys":
						[
							[
								237,
								265
							],
							[
								623,
								627
							],
							[
								1448,
								1477
							],
							[
								1942,
								1946
							],
							[
								2043,
								2047
							],
							[
								2096,
								2102
							],
							[
								2131,
								2137
							],
							[
								2221,
								2228
							],
							[
								2489,
								2508
							],
							[
								2633,
								2652
							],
							[
								3187,
								3213
							]
						],
						"symlist":
						[
							"async function main(...args)",
							"n =>",
							" function ColorStr(c, str)",
							"p =>",
							"p =>",
							"str =>",
							"str =>",
							"part =>",
							"(line, field, i) =>",
							"(line, field, i) =>",
							"async function dl(orderId)"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACHAAAAICBtYWluKC4uLmFyZ3MpCiAgbiA9PgpDb2xvclN0cihjLCBzdHIpCiAgcCA9PgogIHAgPT4KICBzdHIgPT4KICBzdHIgPT4KICBwYXJ0ID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgogIGRsKG9yZGVySWQpAAAAAAAAAACHAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					6,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/check-discogs.js",
						"symkeys":
						[
							[
								237,
								265
							],
							[
								623,
								627
							],
							[
								1488,
								1517
							],
							[
								1982,
								1986
							],
							[
								2083,
								2087
							],
							[
								2136,
								2142
							],
							[
								2171,
								2177
							],
							[
								2261,
								2268
							],
							[
								2529,
								2548
							],
							[
								2673,
								2692
							],
							[
								3227,
								3253
							]
						],
						"symlist":
						[
							"async function main(...args)",
							"n =>",
							" function ColorStr(c, str)",
							"p =>",
							"p =>",
							"str =>",
							"str =>",
							"part =>",
							"(line, field, i) =>",
							"(line, field, i) =>",
							"async function dl(orderId)"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACHAAAAICBtYWluKC4uLmFyZ3MpCiAgbiA9PgpDb2xvclN0cihjLCBzdHIpCiAgcCA9PgogIHAgPT4KICBzdHIgPT4KICBzdHIgPT4KICBwYXJ0ID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgogIGRsKG9yZGVySWQpAAAAAAAAAACHAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					7,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/check-discogs.js",
						"symkeys":
						[
							[
								237,
								265
							],
							[
								623,
								627
							],
							[
								1488,
								1517
							],
							[
								1982,
								1986
							],
							[
								2083,
								2087
							],
							[
								2136,
								2142
							],
							[
								2171,
								2177
							],
							[
								2261,
								2268
							],
							[
								2529,
								2548
							],
							[
								2673,
								2692
							],
							[
								3227,
								3253
							]
						],
						"symlist":
						[
							"async function main(...args)",
							"n =>",
							" function ColorStr(c, str)",
							"p =>",
							"p =>",
							"str =>",
							"str =>",
							"part =>",
							"(line, field, i) =>",
							"(line, field, i) =>",
							"async function dl(orderId)"
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACHAAAAICBtYWluKC4uLmFyZ3MpCiAgbiA9PgpDb2xvclN0cihjLCBzdHIpCiAgcCA9PgogIHAgPT4KICBzdHIgPT4KICBzdHIgPT4KICBwYXJ0ID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgogIGRsKG9yZGVySWQpAAAAAAAAAACHAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					8,
					2,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/check-discogs.js",
						"symkeys":
						[
							[
								237,
								265
							],
							[
								623,
								627
							],
							[
								1488,
								1517
							],
							[
								1982,
								1986
							],
							[
								2083,
								2087
							],
							[
								2136,
								2142
							],
							[
								2171,
								2177
							],
							[
								2261,
								2268
							],
							[
								2529,
								2548
							],
							[
								2673,
								2692
							],
							[
								3227,
								3253
							]
						],
						"symlist":
						[
							"async function main(...args)",
							"n =>",
							" function ColorStr(c, str)",
							"p =>",
							"p =>",
							"str =>",
							"str =>",
							"part =>",
							"(line, field, i) =>",
							"(line, field, i) =>",
							"async function dl(orderId)"
						]
					},
					"BAAAAAAAAAAAAAAAAAAAAAAAAACHAAAAICBtYWluKC4uLmFyZ3MpCiAgbiA9PgpDb2xvclN0cihjLCBzdHIpCiAgcCA9PgogIHAgPT4KICBzdHIgPT4KICBzdHIgPT4KICBwYXJ0ID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgogIGRsKG9yZGVySWQpAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhwAAACAgbWFpbiguLi5hcmdzKQogIG4gPT4KQ29sb3JTdHIoYywgc3RyKQogIHAgPT4KICBwID0+CiAgc3RyID0+CiAgc3RyID0+CiAgcGFydCA9PgoobGluZSwgZmllbGQsIGkpID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KICBkbChvcmRlcklkKQAAAAAAAAAAhwAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					9,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAACHAAAAICBtYWluKC4uLmFyZ3MpCiAgbiA9PgpDb2xvclN0cihjLCBzdHIpCiAgcCA9PgogIHAgPT4KICBzdHIgPT4KICBzdHIgPT4KICBwYXJ0ID0+CihsaW5lLCBmaWVsZCwgaSkgPT4KKGxpbmUsIGZpZWxkLCBpKSA9PgogIGRsKG9yZGVySWQpAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					10,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/lib/devtools.js",
						"symkeys":
						[
							[
								772,
								798
							],
							[
								933,
								950
							],
							[
								1164,
								1168
							],
							[
								1253,
								1257
							],
							[
								1745,
								1761
							],
							[
								1841,
								1862
							],
							[
								2131,
								2147
							],
							[
								2213,
								2234
							],
							[
								2405,
								2428
							],
							[
								2471,
								2481
							],
							[
								2547,
								2551
							],
							[
								2649,
								2654
							],
							[
								2704,
								2731
							],
							[
								2784,
								2790
							],
							[
								4603,
								4628
							],
							[
								4822,
								4826
							],
							[
								4890,
								4895
							],
							[
								4960,
								4981
							],
							[
								5275,
								5279
							],
							[
								5330,
								5334
							],
							[
								5450,
								5454
							],
							[
								5500,
								5504
							],
							[
								5531,
								5553
							],
							[
								5637,
								5644
							],
							[
								5674,
								5681
							],
							[
								5732,
								5736
							],
							[
								5813,
								5817
							],
							[
								6709,
								6736
							],
							[
								6994,
								6998
							],
							[
								7213,
								7223
							],
							[
								7330,
								7340
							],
							[
								7412,
								7416
							],
							[
								7479,
								7485
							],
							[
								7503,
								7519
							],
							[
								7549,
								7555
							],
							[
								7768,
								7779
							],
							[
								7818,
								7833
							],
							[
								8031,
								8051
							],
							[
								8591,
								8611
							],
							[
								9660,
								9684
							],
							[
								10185,
								10214
							],
							[
								10256,
								10263
							],
							[
								10308,
								10329
							],
							[
								10648,
								10668
							],
							[
								10783,
								10799
							],
							[
								11063,
								11069
							],
							[
								11661,
								11679
							],
							[
								11737,
								11757
							],
							[
								11875,
								11891
							],
							[
								12084,
								12100
							],
							[
								12302,
								12318
							],
							[
								12503,
								12537
							],
							[
								12599,
								12611
							],
							[
								12754,
								12776
							],
							[
								13676,
								13704
							],
							[
								14003,
								14075
							],
							[
								14258,
								14289
							],
							[
								14442,
								14484
							],
							[
								14508,
								14528
							],
							[
								15009,
								15037
							],
							[
								15109,
								15135
							],
							[
								15215,
								15241
							],
							[
								15463,
								15488
							],
							[
								15839,
								15858
							],
							[
								16343,
								16368
							],
							[
								16646,
								16650
							],
							[
								16940,
								16974
							],
							[
								17142,
								17156
							],
							[
								17274,
								17295
							],
							[
								17983,
								18009
							],
							[
								18227,
								18240
							],
							[
								19658,
								19664
							],
							[
								19806,
								19812
							],
							[
								20328,
								20366
							],
							[
								21513,
								21538
							],
							[
								21635,
								21665
							],
							[
								21937,
								21963
							],
							[
								22064,
								22087
							],
							[
								22166,
								22189
							],
							[
								22249,
								22253
							],
							[
								22444,
								22454
							],
							[
								22867,
								22877
							],
							[
								23487,
								23497
							],
							[
								23523,
								23528
							],
							[
								24460,
								24466
							],
							[
								24515,
								24521
							],
							[
								24587,
								24593
							],
							[
								24637,
								24646
							],
							[
								24744,
								24751
							],
							[
								24798,
								24805
							],
							[
								24949,
								24961
							],
							[
								25680,
								25711
							],
							[
								25950,
								25975
							],
							[
								26066,
								26070
							],
							[
								26205,
								26211
							],
							[
								26356,
								26398
							],
							[
								26991,
								27027
							],
							[
								27538,
								27561
							],
							[
								28079,
								28109
							],
							[
								29596,
								29622
							],
							[
								29742,
								29754
							],
							[
								30416,
								30439
							],
							[
								30616,
								30627
							],
							[
								30749,
								30755
							],
							[
								30813,
								30822
							],
							[
								30831,
								30843
							],
							[
								30867,
								30887
							],
							[
								30948,
								30965
							],
							[
								31148,
								31168
							],
							[
								31225,
								31250
							],
							[
								31401,
								31425
							]
						],
						"symlist":
						[
							".accumulateClasses = () =>",
							" (e, acc) =>",
							"e =>",
							"i =>",
							" function()",
							" function(value)",
							" function()",
							" function(value)",
							" function stylesheets()",
							" (s, i) =>",
							"r =>",
							"() =>",
							" function colors(map, opts)",
							"arg =>",
							"async function getStars()",
							"s =>",
							"gr =>",
							" function getRect(e)",
							"e =>",
							"e =>",
							"e =>",
							"e =>",
							".putStars = function()",
							"name =>",
							"name =>",
							"e =>",
							"c =>",
							" function gradient(element)",
							"e =>",
							"toString()",
							"toString()",
							"s =>",
							" () =>",
							"GradientIterator",
							"next()",
							"getColors()",
							" (acc, step) =>",
							" function starAnim()",
							"MakePointList = r =>",
							" function stores(stores)",
							" function gettext(elem, done)",
							"elem =>",
							"getNodeText = node =>",
							"(resolve, reject) =>",
							" (node, root) =>",
							"tag =>",
							" function select()",
							"(resolve, reject) =>",
							"abortsel = () =>",
							"click = event =>",
							"onkey = event =>",
							" function maxZindex(root = 'body')",
							"(accu, e) =>",
							" function boxes(state)",
							" function res(width, height)",
							"b64toText = async (b64Data, contentType = 'application/octet-stream') =>",
							" function arrayBuffer2String(b)",
							" function ws(cmd = 'send', filename, data)",
							"(resolve, reject) =>",
							" function decodeBase64(b)",
							".onclose = function(event)",
							".onerror = function(event)",
							".onopen = function(event)",
							".onmessage = msg =>",
							" function settext(en, fa)",
							"x =>",
							"async function img(name, arg = {})",
							" obj =>",
							" function(arg)",
							"async (resolve, reject) =>",
							"getID = () =>",
							" () =>",
							" () =>",
							" function createsvg(wh, fixed = false)",
							" function setpos(element)",
							".onmousemove = function(event)",
							".onclick = function(event)",
							" function dump(element)",
							" function walk(element)",
							"e =>",
							" obj =>",
							" obj =>",
							"element =>",
							" e =>",
							"txt =>",
							"txt =>",
							"key =>",
							"(a, b) =>",
							"text =>",
							"text =>",
							"(acc, it) =>",
							"async function measure(element)",
							" function trackElements()",
							"e =>",
							" () =>",
							" function polyline(points, closed = false)",
							" function circle(point, radius = 10)",
							" function rect(...args)",
							" function __rect({ r, args })",
							" function borders(element)",
							"(o, name) =>",
							" function storage(name)",
							"newValue =>",
							" () =>",
							" () =>",
							" value =>",
							".get = function(key)",
							".set = function()",
							".has = function(key)",
							".assign = function(props)",
							" function assign_to(obj)"
						]
					},
					"AQAAAAAAAAAAAAAA7QYAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					11,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADtBgAAICAuYWNjdW11bGF0ZUNsYXNzZXMgPSAoKSA9PgogIChlLCBhY2MpID0+CiAgZSA9PgogIGkgPT4KICBmdW5jdGlvbigpCiAgZnVuY3Rpb24odmFsdWUpCiAgZnVuY3Rpb24oKQogIGZ1bmN0aW9uKHZhbHVlKQogIHN0eWxlc2hlZXRzKCkKICAocywgaSkgPT4KICByID0+CigpID0+CiAgY29sb3JzKG1hcCwgb3B0cykKICBhcmcgPT4KICBnZXRTdGFycygpCiAgcyA9PgogIGdyID0+CiAgZ2V0UmVjdChlKQogIGUgPT4KICBlID0+CiAgZSA9PgogIGUgPT4KICAucHV0U3RhcnMgPSBmdW5jdGlvbigpCiAgbmFtZSA9PgogIG5hbWUgPT4KICBlID0+CiAgYyA9PgogIGdyYWRpZW50KGVsZW1lbnQpCiAgZSA9PgogIHRvU3RyaW5nKCkKICB0b1N0cmluZygpCiAgcyA9PgogICgpID0+CkdyYWRpZW50SXRlcmF0b3IKICBuZXh0KCkKICBnZXRDb2xvcnMoKQogIChhY2MsIHN0ZXApID0+CiAgc3RhckFuaW0oKQpNYWtlUG9pbnRMaXN0ID0gciA9PgogIHN0b3JlcyhzdG9yZXMpCiAgZ2V0dGV4dChlbGVtLCBkb25lKQogIGVsZW0gPT4KICBnZXROb2RlVGV4dCA9IG5vZGUgPT4KKHJlc29sdmUsIHJlamVjdCkgPT4KICAobm9kZSwgcm9vdCkgPT4KICB0YWcgPT4KICBzZWxlY3QoKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIGFib3J0c2VsID0gKCkgPT4KICBjbGljayA9IGV2ZW50ID0+CiAgb25rZXkgPSBldmVudCA9PgogIG1heFppbmRleChyb290ID0gJ2JvZHknKQooYWNjdSwgZSkgPT4KICBib3hlcyhzdGF0ZSkKICByZXMod2lkdGgsIGhlaWdodCkKICBiNjR0b1RleHQgPSAoYjY0RGF0YSwgY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykgPT4KICBhcnJheUJ1ZmZlcjJTdHJpbmcoYikKICB3cyhjbWQgPSAnc2VuZCcsIGZpbGVuYW1lLCBkYXRhKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIGRlY29kZUJhc2U2NChiKQogIC5vbmNsb3NlID0gZnVuY3Rpb24oZXZlbnQpCiAgLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkKICAub25vcGVuID0gZnVuY3Rpb24oZXZlbnQpCiAgLm9ubWVzc2FnZSA9IG1zZyA9PgogIHNldHRleHQoZW4sIGZhKQogIHggPT4KICBpbWcobmFtZSwgYXJnID0ge30pCiAgb2JqID0+CiAgZnVuY3Rpb24oYXJnKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIGdldElEID0gKCkgPT4KICAoKSA9PgogICgpID0+CiAgY3JlYXRlc3ZnKHdoLCBmaXhlZCA9IGZhbHNlKQogIHNldHBvcyhlbGVtZW50KQogIC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50KQogIC5vbmNsaWNrID0gZnVuY3Rpb24oZXZlbnQpCiAgZHVtcChlbGVtZW50KQogIHdhbGsoZWxlbWVudCkKICBlID0+CiAgb2JqID0+CiAgb2JqID0+CiAgZWxlbWVudCA9PgogIGUgPT4KICB0eHQgPT4KICB0eHQgPT4KICBrZXkgPT4KKGEsIGIpID0+CiAgdGV4dCA9PgogIHRleHQgPT4KKGFjYywgaXQpID0+CiAgbWVhc3VyZShlbGVtZW50KQogIHRyYWNrRWxlbWVudHMoKQogIGUgPT4KICAoKSA9PgogIHBvbHlsaW5lKHBvaW50cywgY2xvc2VkID0gZmFsc2UpCiAgY2lyY2xlKHBvaW50LCByYWRpdXMgPSAxMCkKICByZWN0KC4uLmFyZ3MpCiAgX19yZWN0KHsgciwgYXJncyB9KQogIGJvcmRlcnMoZWxlbWVudCkKKG8sIG5hbWUpID0+CiAgc3RvcmFnZShuYW1lKQogIG5ld1ZhbHVlID0+CiAgKCkgPT4KICAoKSA9PgogIHZhbHVlID0+CiAgLmdldCA9IGZ1bmN0aW9uKGtleSkKICAuc2V0ID0gZnVuY3Rpb24oKQogIC5oYXMgPSBmdW5jdGlvbihrZXkpCiAgLmFzc2lnbiA9IGZ1bmN0aW9uKHByb3BzKQogIGFzc2lnbl90byhvYmopAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					12,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/lib/devtools.js",
						"symkeys":
						[
							[
								772,
								798
							],
							[
								933,
								950
							],
							[
								1164,
								1168
							],
							[
								1253,
								1257
							],
							[
								1745,
								1761
							],
							[
								1841,
								1862
							],
							[
								2131,
								2147
							],
							[
								2213,
								2234
							],
							[
								2405,
								2428
							],
							[
								2471,
								2481
							],
							[
								2547,
								2551
							],
							[
								2649,
								2654
							],
							[
								2704,
								2731
							],
							[
								2784,
								2790
							],
							[
								4603,
								4628
							],
							[
								4822,
								4826
							],
							[
								4890,
								4895
							],
							[
								4960,
								4981
							],
							[
								5275,
								5279
							],
							[
								5330,
								5334
							],
							[
								5450,
								5454
							],
							[
								5500,
								5504
							],
							[
								5531,
								5553
							],
							[
								5637,
								5644
							],
							[
								5674,
								5681
							],
							[
								5732,
								5736
							],
							[
								5813,
								5817
							],
							[
								6709,
								6736
							],
							[
								6994,
								6998
							],
							[
								7213,
								7223
							],
							[
								7330,
								7340
							],
							[
								7412,
								7416
							],
							[
								7479,
								7485
							],
							[
								7503,
								7519
							],
							[
								7549,
								7555
							],
							[
								7768,
								7779
							],
							[
								7818,
								7833
							],
							[
								8031,
								8051
							],
							[
								8591,
								8611
							],
							[
								9660,
								9684
							],
							[
								10185,
								10214
							],
							[
								10256,
								10263
							],
							[
								10308,
								10329
							],
							[
								10648,
								10668
							],
							[
								10783,
								10799
							],
							[
								11063,
								11069
							],
							[
								11661,
								11679
							],
							[
								11737,
								11757
							],
							[
								11875,
								11891
							],
							[
								12084,
								12100
							],
							[
								12302,
								12318
							],
							[
								12503,
								12537
							],
							[
								12599,
								12611
							],
							[
								12754,
								12776
							],
							[
								13676,
								13704
							],
							[
								14003,
								14075
							],
							[
								14258,
								14289
							],
							[
								14442,
								14484
							],
							[
								14508,
								14528
							],
							[
								15009,
								15037
							],
							[
								15109,
								15135
							],
							[
								15215,
								15241
							],
							[
								15463,
								15488
							],
							[
								15839,
								15858
							],
							[
								16343,
								16368
							],
							[
								16646,
								16650
							],
							[
								16940,
								16974
							],
							[
								17142,
								17156
							],
							[
								17274,
								17295
							],
							[
								17983,
								18009
							],
							[
								18227,
								18240
							],
							[
								19658,
								19664
							],
							[
								19806,
								19812
							],
							[
								20328,
								20366
							],
							[
								21513,
								21538
							],
							[
								21635,
								21665
							],
							[
								21937,
								21963
							],
							[
								22064,
								22087
							],
							[
								22166,
								22189
							],
							[
								22249,
								22253
							],
							[
								22444,
								22454
							],
							[
								22867,
								22877
							],
							[
								23487,
								23497
							],
							[
								23523,
								23528
							],
							[
								24460,
								24466
							],
							[
								24515,
								24521
							],
							[
								24587,
								24593
							],
							[
								24637,
								24646
							],
							[
								24744,
								24751
							],
							[
								24798,
								24805
							],
							[
								24949,
								24961
							],
							[
								25680,
								25711
							],
							[
								25950,
								25975
							],
							[
								26066,
								26070
							],
							[
								26205,
								26211
							],
							[
								26356,
								26398
							],
							[
								26991,
								27027
							],
							[
								27538,
								27561
							],
							[
								28079,
								28109
							],
							[
								29596,
								29622
							],
							[
								29742,
								29754
							],
							[
								30416,
								30439
							],
							[
								30616,
								30627
							],
							[
								30749,
								30755
							],
							[
								30813,
								30822
							],
							[
								30831,
								30843
							],
							[
								30867,
								30887
							],
							[
								30948,
								30965
							],
							[
								31148,
								31168
							],
							[
								31225,
								31250
							],
							[
								31401,
								31425
							]
						],
						"symlist":
						[
							".accumulateClasses = () =>",
							" (e, acc) =>",
							"e =>",
							"i =>",
							" function()",
							" function(value)",
							" function()",
							" function(value)",
							" function stylesheets()",
							" (s, i) =>",
							"r =>",
							"() =>",
							" function colors(map, opts)",
							"arg =>",
							"async function getStars()",
							"s =>",
							"gr =>",
							" function getRect(e)",
							"e =>",
							"e =>",
							"e =>",
							"e =>",
							".putStars = function()",
							"name =>",
							"name =>",
							"e =>",
							"c =>",
							" function gradient(element)",
							"e =>",
							"toString()",
							"toString()",
							"s =>",
							" () =>",
							"GradientIterator",
							"next()",
							"getColors()",
							" (acc, step) =>",
							" function starAnim()",
							"MakePointList = r =>",
							" function stores(stores)",
							" function gettext(elem, done)",
							"elem =>",
							"getNodeText = node =>",
							"(resolve, reject) =>",
							" (node, root) =>",
							"tag =>",
							" function select()",
							"(resolve, reject) =>",
							"abortsel = () =>",
							"click = event =>",
							"onkey = event =>",
							" function maxZindex(root = 'body')",
							"(accu, e) =>",
							" function boxes(state)",
							" function res(width, height)",
							"b64toText = async (b64Data, contentType = 'application/octet-stream') =>",
							" function arrayBuffer2String(b)",
							" function ws(cmd = 'send', filename, data)",
							"(resolve, reject) =>",
							" function decodeBase64(b)",
							".onclose = function(event)",
							".onerror = function(event)",
							".onopen = function(event)",
							".onmessage = msg =>",
							" function settext(en, fa)",
							"x =>",
							"async function img(name, arg = {})",
							" obj =>",
							" function(arg)",
							"async (resolve, reject) =>",
							"getID = () =>",
							" () =>",
							" () =>",
							" function createsvg(wh, fixed = false)",
							" function setpos(element)",
							".onmousemove = function(event)",
							".onclick = function(event)",
							" function dump(element)",
							" function walk(element)",
							"e =>",
							" obj =>",
							" obj =>",
							"element =>",
							" e =>",
							"txt =>",
							"txt =>",
							"key =>",
							"(a, b) =>",
							"text =>",
							"text =>",
							"(acc, it) =>",
							"async function measure(element)",
							" function trackElements()",
							"e =>",
							" () =>",
							" function polyline(points, closed = false)",
							" function circle(point, radius = 10)",
							" function rect(...args)",
							" function __rect({ r, args })",
							" function borders(element)",
							"(o, name) =>",
							" function storage(name)",
							"newValue =>",
							" () =>",
							" () =>",
							" value =>",
							".get = function(key)",
							".set = function()",
							".has = function(key)",
							".assign = function(props)",
							" function assign_to(obj)"
						]
					},
					"AQAAAAAAAAAAAAAA7QYAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAAAAAA"
				],
				[
					1,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAADtBgAAICAuYWNjdW11bGF0ZUNsYXNzZXMgPSAoKSA9PgogIChlLCBhY2MpID0+CiAgZSA9PgogIGkgPT4KICBmdW5jdGlvbigpCiAgZnVuY3Rpb24odmFsdWUpCiAgZnVuY3Rpb24oKQogIGZ1bmN0aW9uKHZhbHVlKQogIHN0eWxlc2hlZXRzKCkKICAocywgaSkgPT4KICByID0+CigpID0+CiAgY29sb3JzKG1hcCwgb3B0cykKICBhcmcgPT4KICBnZXRTdGFycygpCiAgcyA9PgogIGdyID0+CiAgZ2V0UmVjdChlKQogIGUgPT4KICBlID0+CiAgZSA9PgogIGUgPT4KICAucHV0U3RhcnMgPSBmdW5jdGlvbigpCiAgbmFtZSA9PgogIG5hbWUgPT4KICBlID0+CiAgYyA9PgogIGdyYWRpZW50KGVsZW1lbnQpCiAgZSA9PgogIHRvU3RyaW5nKCkKICB0b1N0cmluZygpCiAgcyA9PgogICgpID0+CkdyYWRpZW50SXRlcmF0b3IKICBuZXh0KCkKICBnZXRDb2xvcnMoKQogIChhY2MsIHN0ZXApID0+CiAgc3RhckFuaW0oKQpNYWtlUG9pbnRMaXN0ID0gciA9PgogIHN0b3JlcyhzdG9yZXMpCiAgZ2V0dGV4dChlbGVtLCBkb25lKQogIGVsZW0gPT4KICBnZXROb2RlVGV4dCA9IG5vZGUgPT4KKHJlc29sdmUsIHJlamVjdCkgPT4KICAobm9kZSwgcm9vdCkgPT4KICB0YWcgPT4KICBzZWxlY3QoKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIGFib3J0c2VsID0gKCkgPT4KICBjbGljayA9IGV2ZW50ID0+CiAgb25rZXkgPSBldmVudCA9PgogIG1heFppbmRleChyb290ID0gJ2JvZHknKQooYWNjdSwgZSkgPT4KICBib3hlcyhzdGF0ZSkKICByZXMod2lkdGgsIGhlaWdodCkKICBiNjR0b1RleHQgPSAoYjY0RGF0YSwgY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykgPT4KICBhcnJheUJ1ZmZlcjJTdHJpbmcoYikKICB3cyhjbWQgPSAnc2VuZCcsIGZpbGVuYW1lLCBkYXRhKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIGRlY29kZUJhc2U2NChiKQogIC5vbmNsb3NlID0gZnVuY3Rpb24oZXZlbnQpCiAgLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkKICAub25vcGVuID0gZnVuY3Rpb24oZXZlbnQpCiAgLm9ubWVzc2FnZSA9IG1zZyA9PgogIHNldHRleHQoZW4sIGZhKQogIHggPT4KICBpbWcobmFtZSwgYXJnID0ge30pCiAgb2JqID0+CiAgZnVuY3Rpb24oYXJnKQoocmVzb2x2ZSwgcmVqZWN0KSA9PgogIGdldElEID0gKCkgPT4KICAoKSA9PgogICgpID0+CiAgY3JlYXRlc3ZnKHdoLCBmaXhlZCA9IGZhbHNlKQogIHNldHBvcyhlbGVtZW50KQogIC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50KQogIC5vbmNsaWNrID0gZnVuY3Rpb24oZXZlbnQpCiAgZHVtcChlbGVtZW50KQogIHdhbGsoZWxlbWVudCkKICBlID0+CiAgb2JqID0+CiAgb2JqID0+CiAgZWxlbWVudCA9PgogIGUgPT4KICB0eHQgPT4KICB0eHQgPT4KICBrZXkgPT4KKGEsIGIpID0+CiAgdGV4dCA9PgogIHRleHQgPT4KKGFjYywgaXQpID0+CiAgbWVhc3VyZShlbGVtZW50KQogIHRyYWNrRWxlbWVudHMoKQogIGUgPT4KICAoKSA9PgogIHBvbHlsaW5lKHBvaW50cywgY2xvc2VkID0gZmFsc2UpCiAgY2lyY2xlKHBvaW50LCByYWRpdXMgPSAxMCkKICByZWN0KC4uLmFyZ3MpCiAgX19yZWN0KHsgciwgYXJncyB9KQogIGJvcmRlcnMoZWxlbWVudCkKKG8sIG5hbWUpID0+CiAgc3RvcmFnZShuYW1lKQogIG5ld1ZhbHVlID0+CiAgKCkgPT4KICAoKSA9PgogIHZhbHVlID0+CiAgLmdldCA9IGZ1bmN0aW9uKGtleSkKICAuc2V0ID0gZnVuY3Rpb24oKQogIC5oYXMgPSBmdW5jdGlvbihrZXkpCiAgLmFzc2lnbiA9IGZ1bmN0aW9uKHByb3BzKQogIGFzc2lnbl90byhvYmopAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/"
				],
				[
					2,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/quickjs-libc.c",
						"symkeys":
						[
							[
								1595,
								1599
							],
							[
								1778,
								1790
							],
							[
								1847,
								1854
							],
							[
								2112,
								2122
							],
							[
								2377,
								2390
							],
							[
								2468,
								2485
							],
							[
								2586,
								2595
							],
							[
								2787,
								2802
							],
							[
								2987,
								3006
							],
							[
								3114,
								3136
							],
							[
								3622,
								3635
							],
							[
								3731,
								3747
							],
							[
								3864,
								3874
							],
							[
								3935,
								3953
							],
							[
								9579,
								9591
							],
							[
								10456,
								10469
							],
							[
								11091,
								11106
							],
							[
								11677,
								11696
							],
							[
								11862,
								11881
							],
							[
								13029,
								13054
							],
							[
								14500,
								14516
							],
							[
								15417,
								15428
							],
							[
								15628,
								15641
							],
							[
								15977,
								15983
							],
							[
								16369,
								16377
							],
							[
								16462,
								16475
							],
							[
								16891,
								16906
							],
							[
								17246,
								17263
							],
							[
								18054,
								18063
							],
							[
								18204,
								18221
							],
							[
								18312,
								18327
							],
							[
								18621,
								18634
							],
							[
								20039,
								20048
							],
							[
								20063,
								20084
							],
							[
								20375,
								20387
							],
							[
								20469,
								20484
							],
							[
								20690,
								20709
							],
							[
								21039,
								21054
							],
							[
								21489,
								21508
							],
							[
								21665,
								21676
							],
							[
								22457,
								22469
							],
							[
								23236,
								23249
							],
							[
								23916,
								23930
							],
							[
								24194,
								24208
							],
							[
								24350,
								24363
							],
							[
								24505,
								24520
							],
							[
								24766,
								24782
							],
							[
								25268,
								25285
							],
							[
								25731,
								25749
							],
							[
								25966,
								25983
							],
							[
								26187,
								26203
							],
							[
								26568,
								26584
							],
							[
								27079,
								27094
							],
							[
								27297,
								27314
							],
							[
								27519,
								27539
							],
							[
								27745,
								27763
							],
							[
								27969,
								27991
							],
							[
								28708,
								28727
							],
							[
								29435,
								29459
							],
							[
								30338,
								30357
							],
							[
								30562,
								30581
							],
							[
								30874,
								30889
							],
							[
								30911,
								30927
							],
							[
								30945,
								30965
							],
							[
								31274,
								31289
							],
							[
								31477,
								31490
							],
							[
								35075,
								35078
							],
							[
								37698,
								37709
							],
							[
								38506,
								38524
							],
							[
								38955,
								38965
							],
							[
								39667,
								39678
							],
							[
								39909,
								39919
							],
							[
								40458,
								40474
							],
							[
								41169,
								41181
							],
							[
								41424,
								41443
							],
							[
								42084,
								42120
							],
							[
								42136,
								42167
							],
							[
								42191,
								42206
							],
							[
								42767,
								42786
							],
							[
								43395,
								43404
							],
							[
								43546,
								43561
							],
							[
								44218,
								44230
							],
							[
								44753,
								44765
							],
							[
								45241,
								45255
							],
							[
								45370,
								45377
							],
							[
								45614,
								45629
							],
							[
								45803,
								45823
							],
							[
								46942,
								46949
							],
							[
								47212,
								47219
							],
							[
								47352,
								47369
							],
							[
								47541,
								47553
							],
							[
								48918,
								48929
							],
							[
								49146,
								49157
							],
							[
								49294,
								49306
							],
							[
								49447,
								49457
							],
							[
								49599,
								49620
							],
							[
								49817,
								49833
							],
							[
								50028,
								50044
							],
							[
								50843,
								50861
							],
							[
								51247,
								51259
							],
							[
								51658,
								51668
							],
							[
								53599,
								53614
							],
							[
								53707,
								53728
							],
							[
								55356,
								55377
							],
							[
								55474,
								55484
							],
							[
								58654,
								58668
							],
							[
								59023,
								59040
							],
							[
								59192,
								59204
							],
							[
								59469,
								59480
							],
							[
								59782,
								59793
							],
							[
								60328,
								60341
							],
							[
								61123,
								61137
							],
							[
								61283,
								61293
							],
							[
								64241,
								64254
							],
							[
								64391,
								64403
							],
							[
								65178,
								65189
							],
							[
								65728,
								65736
							],
							[
								65949,
								65963
							],
							[
								66393,
								66406
							],
							[
								66916,
								66930
							],
							[
								67381,
								67391
							],
							[
								68819,
								68829
							],
							[
								70019,
								70029
							],
							[
								74727,
								74740
							],
							[
								75407,
								75417
							],
							[
								75890,
								75900
							],
							[
								76227,
								76236
							],
							[
								76481,
								76491
							],
							[
								76960,
								76972
							],
							[
								77193,
								77207
							],
							[
								77265,
								77276
							],
							[
								77392,
								77406
							],
							[
								77537,
								77549
							],
							[
								77727,
								77738
							],
							[
								77998,
								78008
							],
							[
								78186,
								78205
							],
							[
								78611,
								78630
							],
							[
								78723,
								78738
							],
							[
								78945,
								78965
							],
							[
								79443,
								79455
							],
							[
								79678,
								79697
							],
							[
								80082,
								80093
							],
							[
								81121,
								81144
							],
							[
								82027,
								82049
							],
							[
								82072,
								82096
							],
							[
								82129,
								82143
							],
							[
								84487,
								84508
							],
							[
								86260,
								86283
							],
							[
								87258,
								87281
							],
							[
								87840,
								87874
							],
							[
								88005,
								88016
							],
							[
								88058,
								88069
							],
							[
								88113,
								88124
							],
							[
								88162,
								88173
							],
							[
								88195,
								88206
							],
							[
								88231,
								88238
							],
							[
								91021,
								91031
							],
							[
								92235,
								92252
							],
							[
								92617,
								92625
							],
							[
								93007,
								93025
							],
							[
								93887,
								93907
							],
							[
								94582,
								94602
							],
							[
								95414,
								95425
							],
							[
								95657,
								95675
							],
							[
								96032,
								96049
							],
							[
								96220,
								96252
							],
							[
								96527,
								96538
							],
							[
								96896,
								96914
							]
						],
						"symlist":
						[
							"â€”â“‚â€“â€ƒpipeâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€ƒâ“‰â€‚â€ƒsighandler_tâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‚â€‚â€ƒenvironâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒUSE_WORKERâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‰â€‚â€ƒJSOSRWHandlerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSOSSignalHandlerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSOSTimerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSWorkerMessageâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSWorkerMessagePipeâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSWorkerMessageHandlerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSThreadStateâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒjs_std_dbuf_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmy_isdigitâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_printf_internalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_load_fileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_loadScriptâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_loadFileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_loader_soâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_loader_soâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_set_import_metaâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_loaderâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_exitâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_getenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsetenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒunsetenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_setenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_unsetenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_getenvironâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_gcâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒinterrupt_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒget_bool_optionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_evalScriptâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‰â€‚â€ƒJSSTDFileâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒjs_std_file_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_get_errnoâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_strerrorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_parseExtJSONâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_new_std_fileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_set_error_objectâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_openâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_popenâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_fdopenâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_tmpfileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_sprintfâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_printfâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_putsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_closeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_printfâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_flushâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_tellâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_seekâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_eofâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_clearerrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_filenoâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_read_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_getlineâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_readAsStringâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_getByteâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_putByteâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‚â€‚â€ƒURL_GET_PROGRAMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒURL_GET_BUF_SIZEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒhttp_get_header_lineâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_get_statusâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_urlGetâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â“‚â€“â€ƒDEFâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€”â’»â€“â€ƒjs_std_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_init_module_stdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_openâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_closeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_seekâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_read_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_isattyâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_ttyGetWinSizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‚â€‚â€ƒ__ENABLE_VIRTUAL_TERMINAL_PROCESSINGâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒ__ENABLE_VIRTUAL_TERMINAL_INPUTâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒjs_os_ttySetRawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_ttyGetWinSizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒterm_exitâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_ttySetRawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_removeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_renameâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒis_main_threadâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfind_rhâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfree_rw_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_setReadHandlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfind_shâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfree_shâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒos_signal_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_signalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒget_time_msâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒget_time_msâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒunlink_timerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfree_timerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_timer_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_timer_markâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_setTimeoutâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_clearTimeoutâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcall_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_pollâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhandle_posted_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhandle_posted_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_pollâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmake_obj_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmake_string_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_getcwdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_chdirâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_mkdirâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_readdirâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒtimespec_to_msâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_statâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒms_to_timevalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_utimesâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_sleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒrealpathâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_realpathâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_symlinkâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_readlinkâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒbuild_envpâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmy_execvpeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_execâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_waitpidâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_killâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_dupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_dup2â€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‰â€‚â€ƒJSWorkerDataâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒWorkerFuncArgsâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSSABHeaderâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒatomic_add_intâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_sab_allocâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_sab_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_sab_dupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_new_message_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_dup_message_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_message_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_portâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒworker_funcâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_ctor_internalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒJS_GetModuleLoaderFuncâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒJS_GetModuleLoaderOpaqueâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_ctorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_postMessageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_set_onmessageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_get_onmessageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_set_worker_new_context_funcâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â“‚â€“â€ƒOS_FLAGâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€”â’»â€“â€ƒjs_os_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_init_module_osâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_printâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_add_helpersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_init_handlersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_free_handlersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_dump_objâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_dump_error1â€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_dump_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_promise_rejection_trackerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_loopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_eval_binaryâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAOxoAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					3,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AgAAAAAAAAAAAAAAAAAAAAAAAABXIAAA4oCU4pOC4oCTIHBpcGUgKCApIOKApiDigJQgbWFjcm8gZnVuY3Rpb24KICDik4kgIHNpZ2hhbmRsZXJfdCA7IOKAlCB0eXBlZGVmCiAg4pOCICBlbnZpcm9uIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBVU0VfV09SS0VSIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOJICBKU09TUldIYW5kbGVyIDsg4oCUIHR5cGVkZWYKICDik4kgIEpTT1NTaWduYWxIYW5kbGVyIDsg4oCUIHR5cGVkZWYKICDik4kgIEpTT1NUaW1lciA7IOKAlCB0eXBlZGVmCiAg4pOJICBKU1dvcmtlck1lc3NhZ2UgOyDigJQgdHlwZWRlZgogIOKTiSAgSlNXb3JrZXJNZXNzYWdlUGlwZSA7IOKAlCB0eXBlZGVmCiAg4pOJICBKU1dvcmtlck1lc3NhZ2VIYW5kbGVyIDsg4oCUIHR5cGVkZWYKICDik4kgIEpTVGhyZWFkU3RhdGUgOyDigJQgdHlwZWRlZgrigJTikrvigJMganNfc3RkX2RidWZfaW5pdCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIG15X2lzZGlnaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19wcmludGZfaW50ZXJuYWwgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19sb2FkX2ZpbGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19sb2FkU2NyaXB0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2xvYWRGaWxlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbW9kdWxlX2xvYWRlcl9zbyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX21vZHVsZV9sb2FkZXJfc28gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19tb2R1bGVfc2V0X2ltcG9ydF9tZXRhICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfbW9kdWxlX2xvYWRlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9leGl0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2dldGVudiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHNldGVudiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIHVuc2V0ZW52ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX3NldGVudiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF91bnNldGVudiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9nZXRlbnZpcm9uICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2djICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaW50ZXJydXB0X2hhbmRsZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBnZXRfYm9vbF9vcHRpb24gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19ldmFsU2NyaXB0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTiSAgSlNTVERGaWxlIDsg4oCUIHR5cGVkZWYK4oCU4pK74oCTIGpzX3N0ZF9maWxlX2ZpbmFsaXplciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2dldF9lcnJubyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9zdHJlcnJvciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9wYXJzZUV4dEpTT04gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19uZXdfc3RkX2ZpbGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zZXRfZXJyb3Jfb2JqZWN0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX29wZW4gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfcG9wZW4gKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmRvcGVuICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX3RtcGZpbGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfc3ByaW50ZiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmlsZV9nZXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmlsZV9wdXRzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2ZpbGVfY2xvc2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmlsZV9wcmludGYgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmlsZV9mbHVzaCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9maWxlX3RlbGwgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmlsZV9zZWVrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2ZpbGVfZW9mICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2ZpbGVfZXJyb3IgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmlsZV9jbGVhcmVyciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9maWxlX2ZpbGVubyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9maWxlX3JlYWRfd3JpdGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfZmlsZV9nZXRsaW5lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2ZpbGVfcmVhZEFzU3RyaW5nICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2ZpbGVfZ2V0Qnl0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9maWxlX3B1dEJ5dGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCiAg4pOCICBVUkxfR0VUX1BST0dSQU0g4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIFVSTF9HRVRfQlVGX1NJWkUg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK74oCTIGh0dHBfZ2V0X2hlYWRlcl9saW5lICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgaHR0cF9nZXRfc3RhdHVzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX3VybEdldCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pOC4oCTIERFRiAoICkg4oCmIOKAlCBtYWNybyBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2luaXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19pbml0X21vZHVsZV9zdGQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19vcGVuICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfY2xvc2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19zZWVrICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfcmVhZF93cml0ZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX2lzYXR0eSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3R0eUdldFdpblNpemUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCiAg4pOCICBfX0VOQUJMRV9WSVJUVUFMX1RFUk1JTkFMX1BST0NFU1NJTkcg4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIF9fRU5BQkxFX1ZJUlRVQUxfVEVSTUlOQUxfSU5QVVQg4oCmIOKAlCBtYWNybyBvYmplY3QK4oCU4pK74oCTIGpzX29zX3R0eVNldFJhdyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3R0eUdldFdpblNpemUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB0ZXJtX2V4aXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc190dHlTZXRSYXcgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19yZW1vdmUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19yZW5hbWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBpc19tYWluX3RocmVhZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGZpbmRfcmggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBmcmVlX3J3X2hhbmRsZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19zZXRSZWFkSGFuZGxlciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGZpbmRfc2ggKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBmcmVlX3NoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgb3Nfc2lnbmFsX2hhbmRsZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19zaWduYWwgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBnZXRfdGltZV9tcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGdldF90aW1lX21zICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgdW5saW5rX3RpbWVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgZnJlZV90aW1lciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3RpbWVyX2ZpbmFsaXplciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3RpbWVyX21hcmsgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19zZXRUaW1lb3V0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfY2xlYXJUaW1lb3V0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgY2FsbF9oYW5kbGVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfcG9sbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX2ZyZWVfbWVzc2FnZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGhhbmRsZV9wb3N0ZWRfbWVzc2FnZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGhhbmRsZV9wb3N0ZWRfbWVzc2FnZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3BvbGwgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBtYWtlX29ial9lcnJvciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIG1ha2Vfc3RyaW5nX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfZ2V0Y3dkICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfY2hkaXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19ta2RpciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3JlYWRkaXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyB0aW1lc3BlY190b19tcyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3N0YXQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBtc190b190aW1ldmFsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfdXRpbWVzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3Nfc2xlZXAgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyByZWFscGF0aCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3JlYWxwYXRoICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3Nfc3ltbGluayAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3JlYWRsaW5rICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgYnVpbGRfZW52cCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIG15X2V4ZWN2cGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19leGVjICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3Nfd2FpdHBpZCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX29zX3BpcGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19raWxsICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfZHVwICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfb3NfZHVwMiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24KICDik4kgIEpTV29ya2VyRGF0YSA7IOKAlCB0eXBlZGVmCiAg4pOJICBXb3JrZXJGdW5jQXJncyA7IOKAlCB0eXBlZGVmCiAg4pOJICBKU1NBQkhlYWRlciA7IOKAlCB0eXBlZGVmCuKAlOKSu+KAkyBhdG9taWNfYWRkX2ludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3NhYl9hbGxvYyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3NhYl9mcmVlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc2FiX2R1cCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX25ld19tZXNzYWdlX3BpcGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19kdXBfbWVzc2FnZV9waXBlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfZnJlZV9tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfZnJlZV9tZXNzYWdlX3BpcGUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19mcmVlX3BvcnQgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc193b3JrZXJfZmluYWxpemVyICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMgd29ya2VyX2Z1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc193b3JrZXJfY3Rvcl9pbnRlcm5hbCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIEpTX0dldE1vZHVsZUxvYWRlckZ1bmMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBKU19HZXRNb2R1bGVMb2FkZXJPcGFxdWUgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc193b3JrZXJfY3RvciAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3dvcmtlcl9wb3N0TWVzc2FnZSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3dvcmtlcl9zZXRfb25tZXNzYWdlICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfd29ya2VyX2dldF9vbm1lc3NhZ2UgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfc2V0X3dvcmtlcl9uZXdfY29udGV4dF9mdW5jICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgogIOKTgiAgT1NfUExBVEZPUk0g4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIE9TX1BMQVRGT1JNIOKApiDigJQgbWFjcm8gb2JqZWN0CiAg4pOCICBPU19QTEFURk9STSDigKYg4oCUIG1hY3JvIG9iamVjdAogIOKTgiAgT1NfUExBVEZPUk0g4oCmIOKAlCBtYWNybyBvYmplY3QKICDik4IgIE9TX1BMQVRGT1JNIOKApiDigJQgbWFjcm8gb2JqZWN0CuKAlOKTguKAkyBPU19GTEFHICggKSDigKYg4oCUIG1hY3JvIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19vc19pbml0ICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfaW5pdF9tb2R1bGVfb3MgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19wcmludCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9hZGRfaGVscGVycyAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9pbml0X2hhbmRsZXJzICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX2ZyZWVfaGFuZGxlcnMgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19kdW1wX29iaiAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9kdW1wX2Vycm9yMSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9kdW1wX2Vycm9yICggKSB7IOKApiB9IOKAlCBmdW5jdGlvbgrigJTikrvigJMganNfc3RkX3Byb21pc2VfcmVqZWN0aW9uX3RyYWNrZXIgKCApIHsg4oCmIH0g4oCUIGZ1bmN0aW9uCuKAlOKSu+KAkyBqc19zdGRfbG9vcCAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24K4oCU4pK74oCTIGpzX3N0ZF9ldmFsX2JpbmFyeSAoICkgeyDigKYgfSDigJQgZnVuY3Rpb24AAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					4,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					5,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					6,
					1,
					"outline_refresh",
					{
						"path": null,
						"symkeys":
						[
						],
						"symlist":
						[
						]
					},
					"AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
					"BAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAAAAAAA"
				],
				[
					1,
					1,
					"outline_refresh",
					{
						"path": "/home/roman/Projects/plot-cv/quickjs/quickjs-libc.c",
						"symkeys":
						[
							[
								1595,
								1599
							],
							[
								1778,
								1790
							],
							[
								1847,
								1854
							],
							[
								2112,
								2122
							],
							[
								2377,
								2390
							],
							[
								2468,
								2485
							],
							[
								2586,
								2595
							],
							[
								2787,
								2802
							],
							[
								2987,
								3006
							],
							[
								3114,
								3136
							],
							[
								3622,
								3635
							],
							[
								3731,
								3747
							],
							[
								3864,
								3874
							],
							[
								3935,
								3953
							],
							[
								9579,
								9591
							],
							[
								10456,
								10469
							],
							[
								11091,
								11106
							],
							[
								11677,
								11696
							],
							[
								11862,
								11881
							],
							[
								13029,
								13054
							],
							[
								14500,
								14516
							],
							[
								15417,
								15428
							],
							[
								15628,
								15641
							],
							[
								15977,
								15983
							],
							[
								16369,
								16377
							],
							[
								16462,
								16475
							],
							[
								16891,
								16906
							],
							[
								17246,
								17263
							],
							[
								18054,
								18063
							],
							[
								18204,
								18221
							],
							[
								18312,
								18327
							],
							[
								18621,
								18634
							],
							[
								20039,
								20048
							],
							[
								20063,
								20084
							],
							[
								20375,
								20387
							],
							[
								20469,
								20484
							],
							[
								20690,
								20709
							],
							[
								21039,
								21054
							],
							[
								21489,
								21508
							],
							[
								21665,
								21676
							],
							[
								22457,
								22469
							],
							[
								23236,
								23249
							],
							[
								23916,
								23930
							],
							[
								24194,
								24208
							],
							[
								24350,
								24363
							],
							[
								24505,
								24520
							],
							[
								24766,
								24782
							],
							[
								25268,
								25285
							],
							[
								25731,
								25749
							],
							[
								25966,
								25983
							],
							[
								26187,
								26203
							],
							[
								26568,
								26584
							],
							[
								27079,
								27094
							],
							[
								27297,
								27314
							],
							[
								27519,
								27539
							],
							[
								27745,
								27763
							],
							[
								27969,
								27991
							],
							[
								28708,
								28727
							],
							[
								29435,
								29459
							],
							[
								30338,
								30357
							],
							[
								30562,
								30581
							],
							[
								30874,
								30889
							],
							[
								30911,
								30927
							],
							[
								30945,
								30965
							],
							[
								31274,
								31289
							],
							[
								31477,
								31490
							],
							[
								35075,
								35078
							],
							[
								37698,
								37709
							],
							[
								38506,
								38524
							],
							[
								38955,
								38965
							],
							[
								39667,
								39678
							],
							[
								39909,
								39919
							],
							[
								40458,
								40474
							],
							[
								41169,
								41181
							],
							[
								41424,
								41443
							],
							[
								42084,
								42120
							],
							[
								42136,
								42167
							],
							[
								42191,
								42206
							],
							[
								42767,
								42786
							],
							[
								43395,
								43404
							],
							[
								43546,
								43561
							],
							[
								44218,
								44230
							],
							[
								44753,
								44765
							],
							[
								45241,
								45255
							],
							[
								45370,
								45377
							],
							[
								45614,
								45629
							],
							[
								45803,
								45823
							],
							[
								46942,
								46949
							],
							[
								47212,
								47219
							],
							[
								47352,
								47369
							],
							[
								47541,
								47553
							],
							[
								48918,
								48929
							],
							[
								49146,
								49157
							],
							[
								49294,
								49306
							],
							[
								49447,
								49457
							],
							[
								49599,
								49620
							],
							[
								49817,
								49833
							],
							[
								50028,
								50044
							],
							[
								50843,
								50861
							],
							[
								51247,
								51259
							],
							[
								51658,
								51668
							],
							[
								53599,
								53614
							],
							[
								53707,
								53728
							],
							[
								55356,
								55377
							],
							[
								55474,
								55484
							],
							[
								58654,
								58668
							],
							[
								59023,
								59040
							],
							[
								59192,
								59204
							],
							[
								59469,
								59480
							],
							[
								59782,
								59793
							],
							[
								60328,
								60341
							],
							[
								61123,
								61137
							],
							[
								61283,
								61293
							],
							[
								64241,
								64254
							],
							[
								64391,
								64403
							],
							[
								65178,
								65189
							],
							[
								65728,
								65736
							],
							[
								65949,
								65963
							],
							[
								66393,
								66406
							],
							[
								66916,
								66930
							],
							[
								67381,
								67391
							],
							[
								68819,
								68829
							],
							[
								70019,
								70029
							],
							[
								74727,
								74740
							],
							[
								75407,
								75417
							],
							[
								75890,
								75900
							],
							[
								76227,
								76236
							],
							[
								76481,
								76491
							],
							[
								76960,
								76972
							],
							[
								77193,
								77207
							],
							[
								77265,
								77276
							],
							[
								77392,
								77406
							],
							[
								77537,
								77549
							],
							[
								77727,
								77738
							],
							[
								77998,
								78008
							],
							[
								78186,
								78205
							],
							[
								78611,
								78630
							],
							[
								78723,
								78738
							],
							[
								78945,
								78965
							],
							[
								79443,
								79455
							],
							[
								79678,
								79697
							],
							[
								80082,
								80093
							],
							[
								81121,
								81144
							],
							[
								82027,
								82049
							],
							[
								82072,
								82096
							],
							[
								82129,
								82143
							],
							[
								84487,
								84508
							],
							[
								86260,
								86283
							],
							[
								87258,
								87281
							],
							[
								87840,
								87874
							],
							[
								88005,
								88016
							],
							[
								88058,
								88069
							],
							[
								88113,
								88124
							],
							[
								88162,
								88173
							],
							[
								88195,
								88206
							],
							[
								88231,
								88238
							],
							[
								91021,
								91031
							],
							[
								92235,
								92252
							],
							[
								92617,
								92625
							],
							[
								93007,
								93025
							],
							[
								93887,
								93907
							],
							[
								94582,
								94602
							],
							[
								95414,
								95425
							],
							[
								95657,
								95675
							],
							[
								96032,
								96049
							],
							[
								96220,
								96252
							],
							[
								96527,
								96538
							],
							[
								96896,
								96914
							]
						],
						"symlist":
						[
							"â€”â“‚â€“â€ƒpipeâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€ƒâ“‰â€‚â€ƒsighandler_tâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‚â€‚â€ƒenvironâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒUSE_WORKERâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‰â€‚â€ƒJSOSRWHandlerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSOSSignalHandlerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSOSTimerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSWorkerMessageâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSWorkerMessagePipeâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSWorkerMessageHandlerâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSThreadStateâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒjs_std_dbuf_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmy_isdigitâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_printf_internalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_load_fileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_loadScriptâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_loadFileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_loader_soâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_loader_soâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_set_import_metaâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_module_loaderâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_exitâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_getenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒsetenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒunsetenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_setenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_unsetenvâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_getenvironâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_gcâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒinterrupt_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒget_bool_optionâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_evalScriptâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‰â€‚â€ƒJSSTDFileâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒjs_std_file_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_get_errnoâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_strerrorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_parseExtJSONâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_new_std_fileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_set_error_objectâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_openâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_popenâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_fdopenâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_tmpfileâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_sprintfâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_printfâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_getâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_putsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_closeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_printfâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_flushâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_tellâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_seekâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_eofâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_clearerrâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_filenoâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_read_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_getlineâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_readAsStringâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_getByteâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_file_putByteâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‚â€‚â€ƒURL_GET_PROGRAMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒURL_GET_BUF_SIZEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒhttp_get_header_lineâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhttp_get_statusâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_urlGetâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â“‚â€“â€ƒDEFâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€”â’»â€“â€ƒjs_std_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_init_module_stdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_openâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_closeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_seekâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_read_writeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_isattyâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_ttyGetWinSizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‚â€‚â€ƒ__ENABLE_VIRTUAL_TERMINAL_PROCESSINGâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒ__ENABLE_VIRTUAL_TERMINAL_INPUTâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â’»â€“â€ƒjs_os_ttySetRawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_ttyGetWinSizeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒterm_exitâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_ttySetRawâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_removeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_renameâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒis_main_threadâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfind_rhâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfree_rw_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_setReadHandlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfind_shâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfree_shâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒos_signal_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_signalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒget_time_msâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒget_time_msâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒunlink_timerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒfree_timerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_timer_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_timer_markâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_setTimeoutâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_clearTimeoutâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒcall_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_pollâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhandle_posted_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒhandle_posted_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_pollâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmake_obj_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmake_string_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_getcwdâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_chdirâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_mkdirâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_readdirâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒtimespec_to_msâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_statâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒms_to_timevalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_utimesâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_sleepâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒrealpathâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_realpathâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_symlinkâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_readlinkâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒbuild_envpâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒmy_execvpeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_execâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_waitpidâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_killâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_dupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_os_dup2â€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‰â€‚â€ƒJSWorkerDataâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒWorkerFuncArgsâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€ƒâ“‰â€‚â€ƒJSSABHeaderâ€‰;â€ƒâ€”â€ƒtypedef",
							"â€”â’»â€“â€ƒatomic_add_intâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_sab_allocâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_sab_freeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_sab_dupâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_new_message_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_dup_message_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_messageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_message_pipeâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_free_portâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_finalizerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒworker_funcâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_ctor_internalâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒJS_GetModuleLoaderFuncâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒJS_GetModuleLoaderOpaqueâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_ctorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_postMessageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_set_onmessageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_worker_get_onmessageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_set_worker_new_context_funcâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€ƒâ“‚â€‚â€ƒOS_PLATFORMâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
							"â€”â“‚â€“â€ƒOS_FLAGâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
							"â€”â’»â€“â€ƒjs_os_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_init_module_osâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_printâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_add_helpersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_init_handlersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_free_handlersâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_dump_objâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_dump_error1â€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_dump_errorâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_promise_rejection_trackerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_loopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
							"â€”â’»â€“â€ƒjs_std_eval_binaryâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
						]
					},
					"AQAAAAAAAAAAAAAAOxoAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "test-opencv.js",
			"settings":
			{
				"buffer_size": 20449,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					18,
					1,
					"cut",
					null,
					"AQAAAD8DAAAAAAAAPwMAAAAAAAAbAAAAICBjb25zdCB7IFdpbmRvdyB9ID0gZ2xmdzsK",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAD8DAAAAAAAAWgMAAAAAAAAAAAAAAADwvw"
				],
				[
					21,
					1,
					"paste",
					null,
					"AQAAAPICAAAAAAAADQMAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPICAAAAAAAA8gIAAAAAAAAAAAAAAADwvw"
				],
				[
					24,
					1,
					"insert",
					{
						"characters": "m"
					},
					"AQAAAAIDAAAAAAAAAwMAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAIDAAAAAAAAAgMAAAAAAAAAAAAAAADwvw"
				],
				[
					25,
					1,
					"insert",
					{
						"characters": " Sui"
					},
					"BAAAAAMDAAAAAAAABAMAAAAAAAAAAAAABAMAAAAAAAAFAwAAAAAAAAAAAAAFAwAAAAAAAAYDAAAAAAAAAAAAAAYDAAAAAAAABwMAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAMDAAAAAAAAAwMAAAAAAAAAAAAAAADwvw"
				],
				[
					28,
					1,
					"paste",
					null,
					"AgAAAPsCAAAAAAAAPAMAAAAAAAAAAAAAPAMAAAAAAAA8AwAAAAAAAA0AAAAgV2luZG93bSBTdWkg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPsCAAAAAAAACAMAAAAAAAAAAAAAAADwvw"
				],
				[
					31,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAABSUAAAaW1wb3J0IHsgUG9pbnQsIFNpemUsIFJlY3QsIE1hdCwgVU1hdCwgTGluZSwgQ0xBSEUsIFRpY2tNZXRlciwgRHJhdywgQ29udG91ciB9IGZyb20gJ29wZW5jdic7CmltcG9ydCAqIGFzIGN2IGZyb20gJ29wZW5jdic7CmltcG9ydCBmcyBmcm9tICdmcyc7CmltcG9ydCBDb25zb2xlIGZyb20gJ2NvbnNvbGUnOwppbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnOwppbXBvcnQgeyBSR0JBLCBIU0xBIH0gZnJvbSAnLi9saWIvY29sb3IuanMnOwppbXBvcnQgVXRpbCBmcm9tICcuL2xpYi91dGlsLmpzJzsKaW1wb3J0IHsgTnVtZXJpY1BhcmFtLCBFbnVtUGFyYW0sIFBhcmFtTmF2aWdhdG9yIH0gZnJvbSAnLi9wYXJhbS5qcyc7CmltcG9ydCB7IG1lbW9pemUsIHJhbmdlIH0gZnJvbSAnLi9saWIvbWlzYy5qcyc7CmltcG9ydCB7IFBpcGVsaW5lLCBQcm9jZXNzb3IgfSBmcm9tICcuL3Fqcy1vcGVuY3YvanMvY3ZQaXBlbGluZS5qcyc7CmltcG9ydCB7IFdpbmRvdywgTW91c2VGbGFncywgTW91c2VFdmVudHMsIE1vdXNlLCBUZXh0U3R5bGUsIERyYXdUZXh0IH0gZnJvbSAnLi9xanMtb3BlbmN2L2pzL2N2SGlnaEdVSS5qcyc7CmltcG9ydCAqIGFzIG52ZyBmcm9tICduYW5vdmcnOwppbXBvcnQgKiBhcyBnbGZ3IGZyb20gJ2dsZncnOwoKbGV0IGJhc2VuYW1lID0gVXRpbC5nZXRBcmd2KClbMV0ucmVwbGFjZSgvXC5qcyQvLCAnJyk7CmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJOwoKZnVuY3Rpb24gR0xGVyguLi5hcmdzKSB7CiAgY29uc3Qge0dhbW1hUmFtcCwgTW9uaXRvciwgUG9zaXRpb24sIFNjYWxlLCBWaWRlb01vZGUsIFdpbmRvdywgV29ya0FyZWEKfSA9IGdsZnc7CiAgbGV0IHJlc29sdXRpb24sIHdpbmRvdywgc2l6ZSwgcG9zaXRpb247CgogIHJlc29sdXRpb24gPSBuZXcgU2l6ZSguLi5hcmdzKTsKICBjb25zdCBoaW50cyA9IFsKICAgIFtnbGZ3LkNPTlRFWFRfVkVSU0lPTl9NQUpPUiwgM10sCiAgICBbZ2xmdy5DT05URVhUX1ZFUlNJT05fTUlOT1IsIDJdLAogICAgW2dsZncuT1BFTkdMX1BST0ZJTEUsIGdsZncuT1BFTkdMX0NPUkVfUFJPRklMRV0sCiAgICBbZ2xmdy5PUEVOR0xfRk9SV0FSRF9DT01QQVQsIHRydWVdLAogICAgW2dsZncuUkVTSVpBQkxFLCBmYWxzZV0sCiAgICBbZ2xmdy5TQU1QTEVTLCA0XQogIF07CgogIGZvcihsZXQgW3Byb3AsIHZhbHVlXSBvZiBoaW50cykgV2luZG93LmhpbnQocHJvcCwgdmFsdWUpOwoKICB3aW5kb3cgPSBuZXcgV2luZG93KHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0LCAnT3BlbkdMJyk7CiAgZ2xmdy5jb250ZXh0LmN1cnJlbnQgPSB3aW5kb3c7CiAgdGhpcy5jb250ZXh0ID0gZ2xmdy5jb250ZXh0OwoKICBzaXplID0gbmV3IFNpemUod2luZG93LnNpemUpOwogIHBvc2l0aW9uID0gbmV3IFBvaW50KHdpbmRvdy5wb3NpdGlvbik7CiAgY29uc3QgcmVjdCA9IG5ldyBSZWN0KC4uLnBvc2l0aW9uLCAuLi5zaXplKTsKICBjb25zb2xlLmxvZyhgR0xGV2AsIHJlY3QpOwogIG52Zy5DcmVhdGVHTDMobnZnLlNURU5DSUxfU1RST0tFUyB8IG52Zy5BTlRJQUxJQVMgfCBudmcuREVCVUcpOwogIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMsIHsgcmVzb2x1dGlvbiwgd2luZG93LCBzaXplLCBwb3NpdGlvbiB9KTsKfQoKZnVuY3Rpb24gV3JpdGVJbWFnZShuYW1lLCBtYXQpIHsKICBjdi5pbXdyaXRlKG5hbWUsIG1hdCk7CiAgY29uc29sZS5sb2coIldyb3RlICciICsgbmFtZSArICInICgiICsgbWF0LnNpemUgKyAnKS4nKTsKfQoKZnVuY3Rpb24gU2F2ZUNvbmZpZyhjb25maWdPYmopIHsKICBjb25maWdPYmogPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoY29uZmlnT2JqKS5tYXAoKFtrLCB2XSkgPT4gW2ssICt2XSkpOwogIGxldCBmaWxlID0gc3RkLm9wZW4oYmFzZW5hbWUgKyAnLmNvbmZpZy5qc29uJywgJ3crYicpOwogIGZpbGUucHV0cyhKU09OLnN0cmluZ2lmeShjb25maWdPYmosIG51bGwsIDIpICsgJ1xuJyk7CiAgZmlsZS5jbG9zZSgpOwogIGNvbnNvbGUubG9nKCJTYXZlZCBjb25maWcgdG8gJyIgKyBiYXNlbmFtZSArICcuY29uZmlnLmpzb24nICsgIiciLCBpbnNwZWN0KGNvbmZpZ09iaiwgeyBjb21wYWN0OiBmYWxzZSB9KSk7Cn0KCmZ1bmN0aW9uIExvYWRDb25maWcoKSB7CiAgbGV0IHN0ciA9IHN0ZC5sb2FkRmlsZShiYXNlbmFtZSArICcuY29uZmlnLmpzb24nKTsKICBsZXQgY29uZmlnT2JqID0gSlNPTi5wYXJzZShzdHIgfHwgJ3t9Jyk7CiAgY29uZmlnT2JqID0gT2JqZWN0LmZyb21FbnRyaWVzKAogICAgT2JqZWN0LmVudHJpZXMoY29uZmlnT2JqKQogICAgICAubWFwKChbaywgdl0pID0+IFtrLCArdl0pCiAgICAgIC5maWx0ZXIoKFtrLCB2XSkgPT4gIWlzTmFOKHYpKQogICk7CiAgY29uc29sZS5sb2coJ0xvYWRDb25maWc6JywgaW5zcGVjdChjb25maWdPYmosIHsgY29tcGFjdDogZmFsc2UgfSkpOwogIHJldHVybiBjb25maWdPYmo7Cn0KCmZ1bmN0aW9uIEluc3BlY3RNYXQobWF0KSB7CiAgY29uc3QgeyBjaGFubmVscywgZGVwdGgsIHR5cGUsIGNvbHMsIHJvd3MgfSA9IG1hdDsKICByZXR1cm4gaW5zcGVjdCh7IGNoYW5uZWxzLCBkZXB0aCwgdHlwZSwgY29scywgcm93cyB9KTsKfQoKZnVuY3Rpb24gVG9IZXgobnVtYmVyKSB7CiAgaWYobnVtYmVyIDwgMCkgbnVtYmVyID0gMHhmZmZmZmZmZiArIG51bWJlciArIDE7CiAgcmV0dXJuICcweCcgKyBudW1iZXIudG9TdHJpbmcoMTYpOwp9CgpmdW5jdGlvbiBBY2N1bXVsYXRvcihjYWxsYmFjaykgewogIGxldCBzZWxmOwogIGxldCBhY2N1ID0ge307CiAgc2VsZiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7CiAgICBpZihuYW1lIGluIGFjY3UpIHJldHVybjsKICAgIGFjY3VbbmFtZV0gPSB2YWx1ZTsKICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhuYW1lLCB2YWx1ZSk7CiAgfTsKICBPYmplY3QuYXNzaWduKHNlbGYsIHsKICAgIGFjY3UsCiAgICBlbnRyaWVzKCkgewogICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYWNjdSk7CiAgICB9LAogICAgdmFsdWVzKCkgewogICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhY2N1KTsKICAgIH0sCiAgICBrZXlzKCkgewogICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWNjdSk7CiAgICB9LAogICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICBmb3IobGV0IGtleSBpbiBhY2N1KSB5aWVsZCBba2V5LCBhY2N1W2tleV1dOwogICAgfSwKICAgIGNsZWFyKCkgewogICAgICBmb3IobGV0IGtleSBpbiBhY2N1KSBkZWxldGUgYWNjdVtrZXldOwogICAgfQogIH0pOwogIHJldHVybiBzZWxmOwp9CgpmdW5jdGlvbiBtYWluKC4uLmFyZ3MpIHsKICBnbG9iYWxUaGlzLmNvbnNvbGUgPSBuZXcgQ29uc29sZSh7CiAgICBpbnNwZWN0T3B0aW9uczogewogICAgICBtYXhTdHJpbmdMZW5ndGg6IDIwMCwKCiAgICAgIGJyZWFrTGVuZ3RoOiAxMDAsCiAgICAgIGNvbXBhY3Q6IDAsCiAgICAgIGRlcHRoOiBJbmZpbml0eQogICAgfQogIH0pOwogIGxldCBydW5uaW5nID0gdHJ1ZTsKCiAgY29uc29sZS5sb2coJ1V0aWwuZ2V0TWV0aG9kTmFtZXMoY3YpJywgVXRpbC5nZXRNZXRob2ROYW1lcyhjdiwgSW5maW5pdHksIDApKTsKICBjb25zb2xlLmxvZygnY3YuSG91Z2hMaW5lcycsIGN2LkhvdWdoTGluZXMpOwoKICBsZXQgbGluZSA9IG5ldyBMaW5lKDAsIDAsIDUwLCA1MCk7CiAgY29uc29sZS5sb2coJ2xpbmUnLCBsaW5lKTsKICBsZXQgY2xhaGUgPSBuZXcgQ0xBSEUoKTsKICBjb25zb2xlLmxvZygnY2xhaGUnLCBjbGFoZSk7CiAgY3YubmFtZWRXaW5kb3coJ291dHB1dCcsIGN2LldJTkRPV19OT1JNQUwgfCBjdi5XSU5ET1dfS0VFUFJBVElPKTsKICBsZXQgdHJhY2tiYXIgPSAnJzsKICBsZXQgZmlsZSA9IGFyZ3NbMF0gfHwgJy4uL2FuLXRyb25pY3MvaW1hZ2VzL2ZtLzR0ci5qcGcnOwogIGxldCBpbWFnZSA9IGN2LmltcmVhZChmaWxlKTsKICBsZXQgcmVzb2x1dGlvbiA9IGltYWdlLnNpemU7CiAgbGV0IHNjYWxlZDsKICBjb25zb2xlLmxvZygnU3ltYm9sLmluc3BlY3QnLCBTeW1ib2wuaW5zcGVjdCk7CiAgY29uc29sZS5sb2coJ3Jlc29sdXRpb24nLCByZXNvbHV0aW9uKTsKICBpZihyZXNvbHV0aW9uLndpZHRoID4gMTIwMCkgewogICAgbGV0IGYgPSAxMDI0IC8gcmVzb2x1dGlvbi53aWR0aDsKICAgIHNjYWxlZCA9IG5ldyBTaXplKHJlc29sdXRpb24ud2lkdGggKiBmLCByZXNvbHV0aW9uLmhlaWdodCAqIGYpOwogIH0gZWxzZSB7CiAgICBzY2FsZWQgPSBuZXcgU2l6ZShyZXNvbHV0aW9uKTsKICB9CgogIGxldCBvdXRwdXRSZWN0ID0gbmV3IFJlY3QoMCwgMCwgcmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQpOwogIGxldCBvdXRwdXRNYXQgPSBuZXcgTWF0KG91dHB1dFJlY3Quc2l6ZSwgY3YuQ1ZfOFVDMyk7CiAgbGV0IHN0YXR1c1JlY3QgPSBuZXcgUmVjdCgwLCByZXNvbHV0aW9uLmhlaWdodCwgcmVzb2x1dGlvbi53aWR0aCwgMjAwKTsKICBsZXQgc3RhdHVzTWF0ID0gbmV3IE1hdChzdGF0dXNSZWN0LnNpemUsIGN2LkNWXzhVQzMpOwogIGNvbnNvbGUubG9nKCdzdGF0dXNSZWN0OicsIHN0YXR1c1JlY3QpOwogIGxldCBbdGV4dFJlY3QsIGhlbHBSZWN0XSA9IG5ldyBSZWN0KHN0YXR1c1JlY3Quc2l6ZSkuaW5zZXQoNSkudnNwbGl0KC0yMCk7CiAgbGV0IHNjcmVlblNpemUgPSBuZXcgU2l6ZShyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCArIDIwMCk7CiAgY29uc29sZS5sb2coJ3N0YXR1c1JlY3QnLCBzdGF0dXNSZWN0KTsKICBjb25zb2xlLmxvZygndGV4dFJlY3QnLCB0ZXh0UmVjdCk7CiAgY29uc29sZS5sb2coJ2hlbHBSZWN0OicsIGhlbHBSZWN0KTsKICBsZXQgc2NyZWVuID0gbmV3IE1hdChzY3JlZW5TaXplLCBjdi5DVl84VUMzKTsKCiAgbGV0IGdmeCA9IG5ldyBHTEZXKC4uLnNjcmVlblNpemUpOwogIGNvbnNvbGUubG9nKCdnZng6JywgZ2Z4KTsKCiAgY3YuaW1zaG93KCdvdXRwdXQnLCBzY3JlZW4pOwogIGN2Lm1vdmVXaW5kb3coJ291dHB1dCcsIDAsIDApOwogIGN2LnJlc2l6ZVdpbmRvdygnb3V0cHV0Jywgc2NyZWVuU2l6ZS53aWR0aCk7CgogIGN2LnNldE1vdXNlQ2FsbGJhY2soJ291dHB1dCcsIChldmVudCwgeCwgeSwgZmxhZ3MpID0+IHsKICAgIGlmKGZsYWdzID09IGN2LkVWRU5UX0ZMQUdfTEJVVFRPTiB8fCBldmVudCA9PSBjdi5FVkVOVF9MQlVUVE9ORE9XTikgY29uc29sZS5sb2coYGNsaWNrICR7eH0sJHt5fWApOwogICAgZWxzZSBpZihldmVudCkgY29uc29sZS5sb2coJ01vdXNlQ2FsbGJhY2snLCB7IGV2ZW50LCB4LCB5LCBmbGFncyB9KTsKICB9KTsKCiAgbGV0IGJhY2tncm91bmRDb2xvciA9IDB4ZDBkMGQwOwogIGxldCBzaGFkb3dDb2xvciA9IDB4NDA0MDQwOwogIGxldCB0ZXh0Q29sb3IgPSAweGQzZDdjZjsKICBsZXQgZm9udHMgPSBbJy9ob21lL3JvbWFuLy5mb250cy9nb3RoaWMudHRmJywgJy9ob21lL3JvbWFuLy5mb250cy9nb3RoaWNiLnR0ZicsICcvdXNyL3NoYXJlL2ZvbnRzL3RydWV0eXBlL3VidW50dS9VYnVudHVNb25vLVIudHRmJ107CiAgbGV0IGZvbnRGYWNlID0gZm9udHNbMl07CiAgbGV0IGZvbnRTaXplID0gMTQ7CiAgZm9udHMuZm9yRWFjaChmaWxlID0+IERyYXcubG9hZEZvbnQoZmlsZSkpOwogIGxldCBjb25maWcgPSBMb2FkQ29uZmlnKCk7CiAgbGV0IHsgZnJhbWVTaG93ID0gMSwgcGFyYW1JbmRleCA9IDAgfSA9IGNvbmZpZzsKICBsZXQgcGFyYW1zID0gewogICAgdGhyZXM6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLnRocmVzIHx8IDIyOSwgMCwgMjU1KSwKICAgIHR5cGU6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLnR5cGUgfHwgY3YuVEhSRVNIX0JJTkFSWV9JTlYsIDAsIDQpLAogICAgYmx1cjogbmV3IE51bWVyaWNQYXJhbShjb25maWcuYmx1ciB8fCAxLCAxLCAxMCwgMiksCiAgICBrZXJuZWxfc2l6ZTogbmV3IE51bWVyaWNQYXJhbShjb25maWcua2VybmVsX3NpemUgfHwgMCwgMCwgOSksCiAgICByaG86IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLnJobyB8fCAxLCAxLCAzMCwgMC4yNSksCiAgICB0aGV0YTogbmV3IE51bWVyaWNQYXJhbShjb25maWcudGhldGEgfHwgMSwgMCwgOTApLAogICAgdGhyZXNob2xkOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy50aHJlc2hvbGQgfHwgMjUsIDAsIDUwKSwKICAgIG1pbkxpbmVMZW5ndGg6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLm1pbkxpbmVMZW5ndGggfHwgMywgMCwgMzApLAogICAgbWF4TGluZUdhcDogbmV3IE51bWVyaWNQYXJhbShjb25maWcubWF4TGluZUdhcCB8fCA0LCAwLCAyMCksCiAgICBkcDogbmV3IE51bWVyaWNQYXJhbShjb25maWcuZHAgfHwgMiwgMCwgMTAsIDAuMSksCiAgICBtaW5EaXN0OiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5taW5EaXN0IHx8IDEwLCAxLCAxMDAwKSwKICAgIHBhcmFtMTogbmV3IE51bWVyaWNQYXJhbShjb25maWcucGFyYW0xIHx8IDIwMCwgMSwgMTAwMCksCiAgICBwYXJhbTI6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLnBhcmFtMiB8fCAxMDAsIDEsIDEwMCksCiAgICBtaW5SYWRpdXM6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLm1pblJhZGl1cyB8fCAwLCAxLCAyNTApLAogICAgbWF4UmFkaXVzOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5tYXhSYWRpdXMgfHwgMjAwLCAxLCAxMDAwKQogIH07CiAgbGV0IGNvbnRvdXJzID0gW107CiAgbGV0IGxpbmVXaWR0aCA9IDE7CiAgbGV0IGxpbmVzID0gW107CiAgbGV0IGNpcmNsZXMgPSBbXTsKICBsZXQgcGFyYW1OYXYgPSBuZXcgUGFyYW1OYXZpZ2F0b3IocGFyYW1zLCBwYXJhbUluZGV4KTsKICBsZXQgcGFyYW1JbmRleGVzID0gWy0xLCAtMV07CiAgbGV0IHBhbGV0dGUgPSBuZXcgQXJyYXkoKTsKICBjb25zdCBibGFjayA9IFsweDAwLCAweDAwLCAweDAwLCAweGZmXTsKICBmb3IobGV0IGkgPSAwOyBpIDwgODsgaSsrKSBwYWxldHRlW2ldID0gW2kgJiAweDA0ID8gMHhmZiA6IDB4MDAsIGkgJiAweDAyID8gMHhmZiA6IDB4MDAsIGkgJiAweDAxID8gMHhmZiA6IDB4MDAsIDB4ZmZdOwogIHBhbGV0dGVbMl0gPSBbMHg2MCwgMHg2MCwgMHg2MCwgMHhmZl07CiAgcGFsZXR0ZVszXSA9IFsweGZmLCAweGZmLCAweDAsIDB4ZmZdOwogIGZvcihsZXQgaSA9IDg7IGkgPCAxNjsgaSsrKSBwYWxldHRlW2ldID0gYmxhY2s7CiAgbGV0IHBpcGVsaW5lID0gbmV3IFBpcGVsaW5lKAogICAgWwogICAgICBmdW5jdGlvbiBBY3F1aXJlRnJhbWUoc3JjLCBkc3QpIHsKICAgICAgICBpbWFnZSA9IGN2LmltcmVhZChmaWxlKTsKICAgICAgICBpbWFnZS5jb3B5VG8oZHN0KTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gR3JheXNjYWxlKHNyYywgZHN0KSB7CiAgICAgICAgbGV0IGNoYW5uZWxzID0gW107CiAgICAgICAgY3YuY3Z0Q29sb3Ioc3JjLCBkc3QsIGN2LkNPTE9SX0JHUjJMYWIpOwogICAgICAgIGN2LnNwbGl0KGRzdCwgY2hhbm5lbHMpOwogICAgICAgIGNoYW5uZWxzWzBdLmNvcHlUbyhkc3QpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBCbHVyKHNyYywgZHN0KSB7CiAgICAgICAgY3YuR2F1c3NpYW5CbHVyKHNyYywgZHN0LCBbK3BhcmFtcy5ibHVyLCArcGFyYW1zLmJsdXJdLCAwLCAwLCBjdi5CT1JERVJfUkVQTElDQVRFKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gVGhyZXNob2xkKHNyYywgZHN0KSB7CiAgICAgICAgY3YudGhyZXNob2xkKHNyYywgZHN0LCArcGFyYW1zLnRocmVzLCAyNTUsICtwYXJhbXMudHlwZSk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIE1vcnBob2xvZ3koc3JjLCBkc3QpIHsKICAgICAgICBsZXQgc3RydWN0dXJpbmdFbGVtZW50ID0gY3YuZ2V0U3RydWN0dXJpbmdFbGVtZW50KGN2Lk1PUlBIX0NST1NTLCBuZXcgU2l6ZSgrcGFyYW1zLmtlcm5lbF9zaXplICogMiArIDEsICtwYXJhbXMua2VybmVsX3NpemUgKiAyICsgMSkpOwogICAgICAgIHNyYy5jb3B5VG8oZHN0KTsKICAgICAgICBjdi5tb3JwaG9sb2d5RXgoZHN0LCBkc3QsIGN2Lk1PUlBIX0VST0RFLCBzdHJ1Y3R1cmluZ0VsZW1lbnQpOwogICAgICAgIGRzdC54b3IoWzI1NSwgMjU1LCAyNTUsIDBdLCBkc3QpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBTa2VsZXRvbml6YXRpb24oc3JjLCBkc3QpIHsKICAgICAgICBjdi5za2VsZXRvbml6YXRpb24oc3JjLCBkc3QpOwoKICAgICAgICAvL2N2LnRyYWNlU2tlbGV0b24oZHN0LCBjb250b3Vycyk7CiAgICAgICAgY29udG91cnMgPSBjdi50cmFjZVNrZWxldG9uKGRzdCk7CgogICAgICAgIC8vIGNvbnRvdXJzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpOwogICAgICAgIC8vLyogcHJldHRpZXItaWdub3JlICovIGNvbnNvbGUubG9nKCdTa2VsZXRvbml6YXRpb24nLCBjb25zb2xlLmNvbmZpZyh7IGNvbXBhY3Q6IDEsIG1heEFycmF5TGVuZ3RoOiBJbmZpbml0eSB9KSwgY29udG91cnMubWFwKGMgPT4gYy50b1N0cmluZygpKSk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIFNob3dUcmFjZShzcmMsIGRzdCkgewogICAgICAgIGN2LmN2dENvbG9yKHNyYywgZHN0LCBjdi5DT0xPUl9HUkFZMkJHUik7CiAgICAgICAgZHN0LmNsZWFyKCk7CgogICAgICAgIC8vbGV0IHBhbGV0dGU9IHJhbmdlKDAsMzU5LCAzNjAvY29udG91cnMubGVuZ3RoKS5tYXAoaHVlID0+IG5ldyBIU0xBKGh1ZSwgMTAwLDUwLDEuMCkpOwogICAgICAgIGxldCBwYWxldHRlID0gcmFuZ2UoMCwgY29udG91cnMubGVuZ3RoIC0gMSkKICAgICAgICAgIC5tYXAobiA9PiBbTWF0aC5mbG9vcihuIC8gMyksICgobiAlIDMpIC0gMSkgKiAyNSArIDUwXSkKICAgICAgICAgIC5tYXAoKFtuLCBtXSkgPT4gWyhNYXRoLmZsb29yKG4gLyAzKSAqIDM1OSAqIDkpIC8gKGNvbnRvdXJzLmxlbmd0aCAtIDEpLCAoKG4gJSAzKSAtIDEpICogMjUgKyA1MCwgbV0pCiAgICAgICAgICAubWFwKChbaCwgcywgbF0pID0+IG5ldyBIU0xBKGgsIHMsIGwsIDEuMCkpOwoKICAgICAgICBwYWxldHRlID0gcGFsZXR0ZS5tYXAoYyA9PiBjLnRvQkdSQSgpKTsKCiAgICAgICAvLyBjb25zb2xlLmxvZygnU2hvd1RyYWNlJywgY29uc29sZS5jb25maWcoeyBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksIGRlcHRoOiA0IH0pLCB7IHBhbGV0dGUgfSk7CiAgICAgICAvLyBjb25zb2xlLmxvZygnRHJhdy5jb250b3VycycsIERyYXcuY29udG91cnMpOwoKICAgICAgLy8gIGNvbnRvdXJzID0gY29udG91cnMuZmlsdGVyKGMgPT4gYy5sZW5ndGg8PSAyKTsKCiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbnRvdXJzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBjb2xvciA9IHBhbGV0dGVbaV07CiAgICAgICAgICAvL0RyYXcuY29udG91cnMoZHN0LCBjb250b3VycywgaSwgY29sb3IsIDEpOwogICAgICAgICAgRHJhdy5wb2x5bGluZXMoZHN0LCBbY29udG91cnNbaV1dLCBmYWxzZSwgY29sb3IsIDEpOwogICAgICAgICB9CgogICAgICAgIGNvbnNvbGUubG9nKCdTaG93VHJhY2UnLCBjb25zb2xlLmNvbmZpZyh7IG1heEFycmF5TGVuZ3RoOiBJbmZpbml0eSB9KSwgeyBzcmMsIGRzdCB9KTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gTGluZVNlZ21lbnREZXRlY3RvcihzcmMsIGRzdCkgewogICAgICAgIGxldCBsaW5lcyA9IFtdOwogICAgICAgIGxldCB3aWR0aCA9IFtdLAogICAgICAgICAgcHJlYyA9IFtdLAogICAgICAgICAgbmZhID0gW107CiAgICAgICAgY3YubGluZVNlZ21lbnREZXRlY3Rvcih0aGlzLm91dHB1dE9mKCdTa2VsZXRvbml6YXRpb24nKSwgbGluZXMsIHdpZHRoLCBwcmVjLCBuZmEpOwogICAgICAgIC8qIGxldCBpbnRlcnNlY3Rpb25NYXRyaXggPSBbXTsKICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGludGVyc2VjdGlvbk1hdHJpeFtpXSA9IFtdOwogICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgIGxldCBwdCA9IFtdOwogICAgICAgICAgICBsZXQgYiA9IGkgPT0gaiA/IG51bGwgOiBsaW5lc1tpXS5pbnRlcnNlY3QobGluZXNbal0sIHB0KTsKICAgICAgICAgICAgaW50ZXJzZWN0aW9uTWF0cml4W2ldW2pdID0gYiAmJiBwdDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgY29uc29sZS5sb2coJ0xpbmVTZWdtZW50RGV0ZWN0b3InLCB7IGludGVyc2VjdGlvbk1hdHJpeCB9KTsKICAgICAgICBsZXQgbGluZU1hcCA9IG5ldyBNYXAoKTsKICAgICAgICBsZXQgbGluZU1hcHBlciA9IG1lbW9pemUoKCkgPT4gW10sIGxpbmVNYXApOwogICAgICAgIGZvcihsZXQgbGluZSBvZiBsaW5lcykgewogICAgICAgICAgbGV0IHsgYSwgYiB9ID0gbGluZTsKICAgICAgICAgIGxpbmVNYXBwZXIoYSArICcnKS5wdXNoKGxpbmUpOwogICAgICAgICAgbGluZU1hcHBlcihiICsgJycpLnB1c2gobGluZSk7CiAgICAgICAgfQogICAgICAgIGNvbnNvbGUubG9nKCdMaW5lU2VnbWVudERldGVjdG9yJywgY29uc29sZS5jb25maWcoeyBjb21wYWN0OiAzIH0pLCBbLi4ubGluZU1hcF0ubWFwKChbbmFtZSwgYXJyXSkgPT4gW25hbWUsIGFyci5sZW5ndGgsIGFyci5tYXAobGluZSA9PiBbbGluZSArICcnLCBsaW5lLmxlbmd0aF0pXSkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pICk7CiAgICAgICAgKi8KICAgICAgICBzcmMuY29weVRvKGRzdCk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIFBpeGVsTmVpZ2hib3Job29kKHNyYywgZHN0KSB7CiAgICAgICAgbGV0IG5laWdoYm9yaG9vZCA9IG5ldyBNYXQoc3JjLnNpemUsIGN2LkNWXzhVQzEpOwogICAgICAgIGN2LnBpeGVsTmVpZ2hib3Job29kKHNyYywgbmVpZ2hib3Job29kKTsKICAgICAgICBsZXQgZW5kcG9pbnRzID0gY3YucGl4ZWxGaW5kVmFsdWUoc3JjLCAxKTsKICAgICAgICBjb25zb2xlLmxvZygnZW5kcG9pbnRzJywgZW5kcG9pbnRzKTsKICAgICAgICBsZXQgbGluZXBvaW50cyA9IGN2LnBpeGVsRmluZFZhbHVlKHNyYywgMik7CiAgICAgICAgY29uc29sZS5sb2coJ2xpbmVwb2ludHMnLCBsaW5lcG9pbnRzKTsKICAgICAgICBjdi5pbXdyaXRlKCduZWlnaGJvcmhvb2QucG5nJywgbmVpZ2hib3Job29kLCBwYWxldHRlKTsKICAgICAgICBsZXQgaW0gPSBjdi5pbXJlYWQoJ25laWdoYm9yaG9vZC5wbmcnKTsKICAgICAgICBpbS5jb3B5VG8oZHN0KTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gSG91Z2hMaW5lc1Aoc3JjLCBkc3QpIHsKICAgICAgICBjb25zdCBza2VsID0gdGhpcy5vdXRwdXRPZignU2tlbGV0b25pemF0aW9uJyk7CiAgICAgICAgY29uc3QgbW9ycGhvID0gdGhpcy5vdXRwdXRPZignTW9ycGhvbG9neScpOwogICAgICAgIGxldCBvdXRwdXQgPSBuZXcgTWF0KCk7CiAgICAgICAgaWYoc2tlbC5jaGFubmVscyA+IDEpIGN2LmN2dENvbG9yKHNrZWwsIHNrZWwsIGN2LkNPTE9SX0JHUjJHUkFZKTsKICAgICAgICBpZihtb3JwaG8uY2hhbm5lbHMgPiAxKSBjdi5jdnRDb2xvcihtb3JwaG8sIG1vcnBobywgY3YuQ09MT1JfQkdSMkdSQVkpOwogICAgICAgIGN2LkhvdWdoTGluZXNQKHNrZWwsIG91dHB1dCwgK3BhcmFtcy5yaG8sIChNYXRoLlBJICogKCtwYXJhbXMudGhldGEgfHwgMSkpIC8gMTgwLCArcGFyYW1zLnRocmVzaG9sZCwgK3BhcmFtcy5taW5MaW5lTGVuZ3RoLCArcGFyYW1zLm1heExpbmVHYXApOwogICAgICAgIGN2LmN2dENvbG9yKHNrZWwsIGRzdCwgY3YuQ09MT1JfR1JBWTJCR1IpOwogICAgICAgIGxldCBpID0gMDsKICAgICAgICBsaW5lcy5zcGxpY2UoMCwgbGluZXMubGVuZ3RoKTsKICAgICAgICBmb3IobGV0IGVsZW0gb2Ygb3V0cHV0LnZhbHVlcygpKSB7CiAgICAgICAgICBjb25zdCBsaW5lID0gbmV3IExpbmUoZWxlbSk7CiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpOwogICAgICAgICAgRHJhdy5saW5lKGRzdCwgLi4ubGluZS50b1BvaW50cygpLCBbMjU1LCAxMjgsIDBdLCBsaW5lV2lkdGgsIGN2LkxJTkVfQUEpOwogICAgICAgICAgRHJhdy5saW5lKG1vcnBobywgLi4ubGluZS50b1BvaW50cygpLCBbMCwgMCwgMF0sIDIsIGN2LkxJTkVfOCk7CiAgICAgICAgICBEcmF3LmxpbmUoc2tlbCwgLi4ubGluZS50b1BvaW50cygpLCBbMCwgMCwgMF0sIGxpbmVXaWR0aCwgY3YuTElORV84KTsKICAgICAgICAgICsraTsKICAgICAgICB9CiAgICAgICAgbGluZXMgPSBsaW5lcy5tYXAobCA9PiAobC5zbG9wZS55IDwgMCA/IGwuc3dhcCgpIDogbCkpOwoKICAgICAgICBjb25zdCBHZXRBbmdsZSA9IGwgPT4gTWF0aC5yb3VuZCgobC5hbmdsZSAqIFJBRDJERUcpIC8gMTUpICogMTU7CgogICAgICAgIGxpbmVzID0gbGluZXMuZmlsdGVyKGwgPT4gbC5sZW5ndGggPj0gNDAgJiYgTWF0aC5hYnMoR2V0QW5nbGUobCkpICE9IDQ1KTsKCiAgICAgICAgbGluZXMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7CiAgICAgICAgLy8gICAgbGluZXMgPSBsaW5lcy5zbGljZSgwLCA1MCk7CiAgICAgICAgLy9jb25zb2xlLmxvZyhgbGluZXNgLCBsaW5lcy5tYXAobCA9PiBbbCwgbC5zbG9wZSwgR2V0QW5nbGUobCldKSk7CgogICAgICAgIGxldCBpc0hvcml6b250YWwgPSBsID0+IE1hdGguYWJzKGwueDIgLSBsLngxKSA+IE1hdGguYWJzKGwueTIgLSBsLnkxKTsKCiAgICAgICAgbGV0IGZpcnN0TGFzdCA9IGEgPT4gW2FbMF0sIGFbYS5sZW5ndGggLSAxXV07CgogICAgICAgIGxldCB2ID0gbGluZXMKICAgICAgICAgIC5maWx0ZXIobCA9PiAhaXNIb3Jpem9udGFsKGwpKQogICAgICAgICAgLm1hcChsID0+IFtsLCBsLmF0KDAuNSldKQogICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGFbMV0ueCAtIGJbMV0ueCkKICAgICAgICAgIC5tYXAoKFtsXSkgPT4gbCk7CgogICAgICAgIGxldCBoID0gbGluZXMKICAgICAgICAgIC5maWx0ZXIobCA9PiBpc0hvcml6b250YWwobCkpCiAgICAgICAgICAubWFwKGwgPT4gW2wsIGwuYXQoMC41KV0pCiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYVsxXS55IC0gYlsxXS55KQogICAgICAgICAgLm1hcCgoW2xdKSA9PiBsKTsKCiAgICAgICAgLyogICB2ID0gZmlyc3RMYXN0KHYpOwogICAgICAgIGggPSBmaXJzdExhc3QoaCk7Ki8KICAgICAgICAvL2NvbnNvbGUubG9nKCdsaW5lczonLCB7IHYsIGggfSk7CgogICAgICAgIGNvbnN0IGFuZ2xlMkNvbG9yID0gYSA9PiB7CiAgICAgICAgICBsZXQgY29sb3IgPSBuZXcgSFNMQShNYXRoLnJvdW5kKGEpLCAxMDAsIDUwKS50b1JHQkEoKTsKICAgICAgICAgIHJldHVybiBbY29sb3IuYiwgY29sb3IuZywgY29sb3Iucl07CiAgICAgICAgfTsKCiAgICAgICAgY29uc29sZS5sb2coJ2FuZ2xlMkNvbG9yKDEwMCk6JywgYW5nbGUyQ29sb3IoMTAwKSk7CiAgICAgICAgY29uc29sZS5sb2coJ2FuZ2xlMkNvbG9yKDM2MCk6JywgYW5nbGUyQ29sb3IoMCkpOwogICAgICAgIC8qCiAgICAgICAgY29uc29sZS5sb2coJ3YnLAogICAgICAgICAgWy4uLnYuc2xpY2UoMCwgNCksIC4uLmguc2xpY2UoMCwgNCldLm1hcChsID0+IFsKICAgICAgICAgICAgLi4ubC50b1BvaW50cygpLAogICAgICAgICAgICBgeUludGVyY2VwdCgpID0gJHtsLnlJbnRlcmNlcHQoKX1gLAogICAgICAgICAgICBgeEludGVyY2VwdCgpID0gJHtsLnhJbnRlcmNlcHQoKX1gCiAgICAgICAgICBdKQogICAgICAgICk7Ki8KICAgICAgICBmb3IobGV0IGxpbmUgb2YgdikgewogICAgICAgICAgbGV0IGNvbG9yID0gYW5nbGUyQ29sb3IoKGxpbmUuYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkpICUgMTgwKTsKCiAgICAgICAgICBEcmF3LmxpbmUoZHN0LCAuLi5saW5lLnRvUG9pbnRzKCksIGNvbG9yLCAxLCBjdi5MSU5FX0FBKTsKICAgICAgICB9CiAgICAgICAgZm9yKGxldCBsaW5lIG9mIGgpIHsKICAgICAgICAgIGxldCBjb2xvciA9IGFuZ2xlMkNvbG9yKChsaW5lLmFuZ2xlICogKDE4MCAvIE1hdGguUEkpKSAlIDE4MCk7CgogICAgICAgICAgRHJhdy5saW5lKGRzdCwgLi4ubGluZS50b1BvaW50cygpLCBjb2xvciwgMSwgY3YuTElORV9BQSk7CiAgICAgICAgfQoKICAgICAgICBsZXQga2VybiA9IGN2LmdldFN0cnVjdHVyaW5nRWxlbWVudChjdi5NT1JQSF9DUk9TUywgbmV3IFNpemUoMywgMykpOwogICAgICAgIGN2LmRpbGF0ZShza2VsLCBza2VsLCBrZXJuKTsKICAgICAgICBjdi5lcm9kZShza2VsLCBza2VsLCBrZXJuKTsKICAgICAgICBjdi5kaWxhdGUobW9ycGhvLCBtb3JwaG8sIGtlcm4pOwogICAgICB9LAogICAgICBmdW5jdGlvbiBIb3VnaENpcmNsZXMoc3JjLCBkc3QpIHsKICAgICAgICBjb25zdCBtb3JwaG8gPSB0aGlzLm91dHB1dE9mKCdNb3JwaG9sb2d5Jyk7CiAgICAgICAgY29uc3Qgc2tlbCA9IHRoaXMub3V0cHV0T2YoJ1NrZWxldG9uaXphdGlvbicpOwogICAgICAgIGNvbnN0IHBhcmFtQXJyYXkgPSBbK3BhcmFtcy5kcCB8fCAxLCArcGFyYW1zLm1pbkRpc3QsICtwYXJhbXMucGFyYW0xLCArcGFyYW1zLnBhcmFtMiwgK3BhcmFtcy5taW5SYWRpdXMsICtwYXJhbXMubWF4UmFkaU1hdGh1c107CiAgICAgICAgbGV0IGNpcmNsZXMxID0gW10gfHwgbmV3IE1hdCgpOwogICAgICAgIGxldCBjaXJjbGVzMiA9IFtdIHx8IG5ldyBNYXQoKTsKICAgICAgICBjdi5Ib3VnaENpcmNsZXMobW9ycGhvLCBjaXJjbGVzMSwgY3YuSE9VR0hfR1JBRElFTlQsIC4uLnBhcmFtQXJyYXkpOwogICAgICAgIGN2LkhvdWdoQ2lyY2xlcyhza2VsLCBjaXJjbGVzMiwgY3YuSE9VR0hfR1JBRElFTlQsIC4uLnBhcmFtQXJyYXkpOwogICAgICAgIHRoaXMub3V0cHV0T2YoJ0hvdWdoTGluZXNQJykuY29weVRvKGRzdCk7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGZvcihsZXQgW3gsIHksIHJdIG9mIGNpcmNsZXMxKSB7CiAgICAgICAgICBsZXQgcCA9IG5ldyBQb2ludCh4LCB5KTsKICAgICAgICAgIERyYXcuY2lyY2xlKGRzdCwgcCwgciwgWzAsIDI1NSwgMF0sIGxpbmVXaWR0aCwgY3YuTElORV9BQSk7CiAgICAgICAgICBjaXJjbGVzLnB1c2goW3gsIHksIHJdKTsKICAgICAgICB9CiAgICAgICAgZm9yKGxldCBbeCwgeSwgcl0gb2YgY2lyY2xlczIpIHsKICAgICAgICAgIGxldCBwID0gbmV3IFBvaW50KHgsIHkpOwogICAgICAgICAgRHJhdy5jaXJjbGUoZHN0LCBwLCByICsgMiwgWzI1NSwgMCwgMF0sIGxpbmVXaWR0aCwgY3YuTElORV9BQSk7CiAgICAgICAgICBjaXJjbGVzLnB1c2goW3gsIHksIHJdKTsKICAgICAgICB9CiAgICAgIH0KICAgIF0sCiAgICBpID0+IHsKICAgICAgaWYoZnJhbWVTaG93ID09IGkpIHsKICAgICAgICBsZXQgcHJvY2Vzc29yID0gcGlwZWxpbmUuZ2V0UHJvY2Vzc29yKGkpOwogICAgICAgIGxldCBwYXJhbXMgPSBwcm9jZXNzb3JQYXJhbXMuZ2V0KHByb2Nlc3Nvcik7CiAgICAgICAgcGFyYW1JbmRleGVzWzBdID0gcGFyYW1OYXYuaW5kZXhPZihwYXJhbXNbMF0pOwogICAgICAgIHBhcmFtSW5kZXhlc1sxXSA9IHBhcmFtTmF2LmluZGV4T2YocGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXSk7CiAgICAgICAgaWYocGFyYW1OYXYuaW5kZXggPCBwYXJhbUluZGV4ZXNbMF0gfHwgcGFyYW1OYXYuaW5kZXggPiBwYXJhbUluZGV4ZXNbMV0pIHBhcmFtTmF2LmN1cnJlbnQgPSBwYXJhbXNbMF07CiAgICAgICAgbGV0IG1hdCA9IHBpcGVsaW5lLmdldEltYWdlKGkpOwogICAgICAgIGlmKG1hdC5jaGFubmVscyA9PSAxKSBjdi5jdnRDb2xvcihtYXQsIG91dHB1dE1hdCwgY3YuQ09MT1JfR1JBWTJCR1IpOwogICAgICAgIGVsc2UgaWYobWF0LmNoYW5uZWxzID09IDQpIGN2LmN2dENvbG9yKG1hdCwgb3V0cHV0TWF0LCBjdi5DT0xPUl9CR1JBMkJHUik7CiAgICAgICAgZWxzZSBtYXQuY29weVRvKG91dHB1dE1hdCk7CiAgICAgICAgUmVkcmF3U3RhdHVzKCk7CiAgICAgICAgUmVkcmF3V2luZG93KCk7CiAgICAgIH0KICAgIH0KICApOwogIGZ1bmN0aW9uIFJlZHJhd1N0YXR1cygpIHsKICAgIC8vY29uc29sZS5sb2coYHBpcGVsaW5lLmltYWdlcyA9YCwgbmV3IE1hcChwaXBlbGluZS5pbWFnZUVudHJpZXMoKSkpOwogICAgbGV0IGkgPSBwaXBlbGluZS5jdXJyZW50UHJvY2Vzc29yOwogICAgbGV0IHByb2Nlc3NvciA9IHBpcGVsaW5lLmdldFByb2Nlc3NvcihpKTsKICAgIGxldCBwYXJhbXMgPSBwcm9jZXNzb3JQYXJhbXMuZ2V0KHByb2Nlc3Nvcik7CiAgICBsZXQgc3JlY3QgPSBuZXcgUmVjdChzdGF0dXNSZWN0LnNpemUpOwoKICAgIERyYXcucmVjdGFuZ2xlKHN0YXR1c01hdCwgc3JlY3QsIGJhY2tncm91bmRDb2xvciwgY3YuRklMTEVELCB0cnVlKTsKICAgIERyYXcucmVjdGFuZ2xlKHN0YXR1c01hdCwgc3JlY3QuaW5zZXQoMywgMCksIDAsIGN2LkZJTExFRCwgdHJ1ZSk7CiAgICBjb25zdCBpbnNwZWN0T3B0aW9ucyA9IHsKICAgICAgY29sb3JzOiB0cnVlLAogICAgICBoaWRlS2V5czogWydjYWxsYmFjayddCiAgICB9OwogICAgbGV0IHRleHQgPQogICAgICBgIyR7aX06IGAgKwogICAgICBwaXBlbGluZS5uYW1lc1tpXSArCiAgICAgIGBcblxuYCArCiAgICAgIGBwYXJhbXM6XG5gICsKICAgICAgcGFyYW1zCiAgICAgICAgLm1hcCgobmFtZSwgaWR4KSA9PiB7CiAgICAgICAgICByZXR1cm4gYCAgJHtpZHggKyBwYXJhbUluZGV4ZXNbMF0gPT0gcGFyYW1OYXYuaW5kZXggPyAnXHgxYlsxOzMxbScgOiAnJ30ke25hbWUucGFkRW5kKDEzKX1ceDFiWzBtICAgXHgxYlsxOzM2bSR7K3BhcmFtTmF2LmdldChuYW1lKX1ceDFiWzBtXG5gOwogICAgICAgIH0pCiAgICAgICAgLmpvaW4oJycpOwogICAgRHJhd1RleHQoc3RhdHVzTWF0KHRleHRSZWN0KSwgdGV4dCwgdGV4dENvbG9yLCBmb250RmFjZSwgZm9udFNpemUpOwogICAgRHJhd1RleHQoc3RhdHVzTWF0KGhlbHBSZWN0KSwgJzwgcHJldiwgPiBuZXh0LCArIGluY3JlbWVudCwgLSBkZWNyZW1lbnQsIERFTCByZXNldCcsIHRleHRDb2xvciwgZm9udEZhY2UsIGZvbnRTaXplKTsKICB9CiAgZnVuY3Rpb24gUmVkcmF3V2luZG93KCkgewogICAgbGV0IGkgPSBwaXBlbGluZS5jdXJyZW50UHJvY2Vzc29yOwogICAgY3YudmNvbmNhdChbb3V0cHV0TWF0LCBzdGF0dXNNYXRdLCBzY3JlZW4pOwogICAgY3YuaW1zaG93KCdvdXRwdXQnLCBzY3JlZW4pOwogICAgY3YucmVzaXplV2luZG93KCdvdXRwdXQnLCBzY3JlZW5TaXplLndpZHRoLCBzY3JlZW5TaXplLmhlaWdodCk7CiAgICBjdi5zZXRXaW5kb3dUaXRsZSgnb3V0cHV0JywgYCMke2l9OiBgICsgcGlwZWxpbmUubmFtZXNbaV0pOwogIH0KICBsZXQga2V5OwogIGxldCBwYXJhbUFjY3VtdWxhdG9yID0gcGFyYW1OYXYuc2V0Q2FsbGJhY2soCiAgICBuZXcgQWNjdW11bGF0b3IoKG5hbWUsIHBhcmFtKSA9PiB7CiAgICAgIC8vIGNvbnNvbGUubG9nKGBwYXJhbSAnJHtuYW1lfScgY2FsbGJhY2tgLCBwYXJhbSk7CiAgICB9KQogICk7CiAgbGV0IHByb2Nlc3NvclBhcmFtcyA9IFV0aWwud2Vha01hcHBlcihwcm9jZXNzb3IgPT4gW10pOwogIHBpcGVsaW5lLmJlZm9yZSA9ICgpID0+IHBhcmFtQWNjdW11bGF0b3IuY2xlYXIoKTsKICBwaXBlbGluZS5hZnRlciA9ICgpID0+IHByb2Nlc3NvclBhcmFtcy5zZXQocGlwZWxpbmUuZ2V0UHJvY2Vzc29yKCksIHBhcmFtQWNjdW11bGF0b3Iua2V5cygpKTsKICBwaXBlbGluZSgpOwogIGRlbGV0ZSBwaXBlbGluZS5iZWZvcmU7CiAgZGVsZXRlIHBpcGVsaW5lLmFmdGVyOwogIGNvbnNvbGUubG9nKGBwaXBlbGluZS5yZWNhbGMoJHtmcmFtZVNob3d9KWAsIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpKTsKICB3aGlsZSh0cnVlKSB7CiAgICBrZXkgPSBjdi53YWl0S2V5RXgoLTEpOwogICAgaWYoa2V5ID09PSAncScgfHwga2V5ID09PSAxMTMgfHwga2V5ID09PSAnXHgxYicgfHwga2V5ID09PSAweDEwMDA3MSB8fCBrZXkgPT09IC0xKSBicmVhazsKICAgIHN3aXRjaCAoa2V5ICYgMHhmZmYpIHsKICAgICAgY2FzZSAweGYwOCAvKiBiYWNrc3BhY2UgKi86CiAgICAgIGNhc2UgMHgwOCAvKiBiYWNrc3BhY2UgKi86CiAgICAgICAgaWYoZnJhbWVTaG93ID4gMCkgewogICAgICAgICAgZnJhbWVTaG93LS07CiAgICAgICAgICBwaXBlbGluZS5zdGVwKC0xKTsKICAgICAgICB9CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhmNTIgLyogdXAgKi86CiAgICAgIGNhc2UgMHgzYyAvKiA8ICovOgogICAgICAgIHBhcmFtTmF2LnByZXYoKTsKICAgICAgICBpZihwYXJhbUluZGV4ZXNbMF0gIT0gLTEgJiYgcGFyYW1OYXYuaW5kZXggPCBwYXJhbUluZGV4ZXNbMF0pIHBhcmFtTmF2LmluZGV4ID0gcGFyYW1JbmRleGVzWzFdOwogICAgICAgIGNvbnNvbGUubG9nKGBQYXJhbSAjJHtwYXJhbU5hdi5pbmRleH0gJyR7cGFyYW1OYXYubmFtZX0nIHNlbGVjdGVkICgkeytwYXJhbU5hdi5wYXJhbX0pYCk7CiAgICAgICAgUmVkcmF3U3RhdHVzKCk7CiAgICAgICAgUmVkcmF3V2luZG93KCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhmNTQgLypkb3duICAqLzoKICAgICAgY2FzZSAweDNlIC8qID4gKi86CiAgICAgICAgcGFyYW1OYXYubmV4dCgpOwogICAgICAgIGlmKHBhcmFtSW5kZXhlc1sxXSAhPSAtMSAmJiBwYXJhbU5hdi5pbmRleCA+IHBhcmFtSW5kZXhlc1sxXSkgcGFyYW1OYXYuaW5kZXggPSBwYXJhbUluZGV4ZXNbMF07CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICMke3BhcmFtTmF2LmluZGV4fSAnJHtwYXJhbU5hdi5uYW1lfScgc2VsZWN0ZWQgKCR7K3BhcmFtTmF2LnBhcmFtfSlgKTsKICAgICAgICBSZWRyYXdTdGF0dXMoKTsKICAgICAgICBSZWRyYXdXaW5kb3coKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAweGY1MyAvKiByaWdodCAqLzoKICAgICAgY2FzZSAweDJiIC8qICsgKi86CiAgICAgICAgcGFyYW1OYXYucGFyYW0uaW5jcmVtZW50KCk7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7K3BhcmFtTmF2LnBhcmFtfWApOwogICAgICAgIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4ZmZmIC8qIERFTEVURSAqLzoKICAgICAgY2FzZSAweDlmIC8qIG51bXBhZCBERUwgKi86CiAgICAgIGNhc2UgMHhmOWYgLyogbnVtcGFkIERFTCAqLzoKICAgICAgICBwYXJhbU5hdi5wYXJhbS5yZXNldCgpOwogICAgICAgIGNvbnNvbGUubG9nKGBQYXJhbSAke3BhcmFtTmF2Lm5hbWV9OiAke2luc3BlY3QocGFyYW1OYXYucGFyYW0pfWApOwogICAgICAgIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4ZjUxIC8qIGxlZnQgKi86CiAgICAgIGNhc2UgMHgyZCAvKiAtICovOgogICAgICBjYXNlIDB4YWQgLyogbnVtcGFkIC0gKi86CiAgICAgIGNhc2UgMHhmYWQgLyogbnVtcGFkIC0gKi86CiAgICAgIGNhc2UgMHgyZmFkIC8qIG51bXBhZCAtICovOgogICAgICAgIHBhcmFtTmF2LnBhcmFtLmRlY3JlbWVudCgpOwogICAgICAgIGNvbnNvbGUubG9nKGBQYXJhbSAke3BhcmFtTmF2Lm5hbWV9OiAkeytwYXJhbU5hdi5wYXJhbX1gKTsKICAgICAgICBwaXBlbGluZS5yZWNhbGMoZnJhbWVTaG93KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAweDMxOiAvKiAxICovCiAgICAgIGNhc2UgMHgzMjogLyogMiAqLwogICAgICBjYXNlIDB4MzM6IC8qIDMgKi8KICAgICAgY2FzZSAweDM0OiAvKiA0ICovCiAgICAgIGNhc2UgMHgzNTogLyogNSAqLwogICAgICBjYXNlIDB4MzY6IC8qIDYgKi8KICAgICAgY2FzZSAweDM3OiAvKiA3ICovCiAgICAgIGNhc2UgMHgzODogLyogOCAqLwogICAgICBjYXNlIDB4Mzk6IC8qIDkgKi8KICAgICAgY2FzZSAweDMwIC8qIDAgKi86CiAgICAgICAgbGV0IHYgPSBrZXkgJiAweGYgfHwgMTA7CiAgICAgICAgcGFyYW1OYXYucGFyYW0uYWxwaGEgPSB2IC8gMTA7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7K3BhcmFtTmF2LnBhcmFtfWApOwogICAgICAgIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4YTcgLyogwqcgKi86CiAgICAgICAgcGFyYW1OYXYucGFyYW0uYWxwaGEgPSAwOwogICAgICAgIGNvbnNvbGUubG9nKGBQYXJhbSAke3BhcmFtTmF2Lm5hbWV9OiAkeytwYXJhbU5hdi5wYXJhbX1gKTsKICAgICAgICBwaXBlbGluZS5yZWNhbGMoZnJhbWVTaG93KTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAweDIwOgogICAgICAgIGZyYW1lU2hvdyA9IFV0aWwubW9kKGZyYW1lU2hvdyArIDEsIHBpcGVsaW5lLnNpemUpOwogICAgICAgIHBpcGVsaW5lLnN0ZXAoKTsKICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDogewogICAgICAgIGlmKGtleSAhPT0gLTEpIGNvbnNvbGUubG9nKCdrZXk6JywgVG9IZXgoa2V5KSk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICB9CiAgU2F2ZUNvbmZpZyh7IGZyYW1lU2hvdywgcGFyYW1JbmRleDogcGFyYW1OYXYuaW5kZXgsIC4uLnBhcmFtcyB9KTsKICBjb25zb2xlLmxvZygnRVhJVCcpOwp9CnRyeSB7CiAgbWFpbiguLi5zY3JpcHRBcmdzLnNsaWNlKDEpKTsKfSBjYXRjaChlcnJvcikgewogIGNvbnNvbGUubG9nKGBGQUlMOiAke2Vycm9yLm1lc3NhZ2V9XG4ke2Vycm9yLnN0YWNrfWApOwogIHN0ZC5leGl0KDEpOwp9IGZpbmFsbHkgewogIGNvbnNvbGUubG9nKCdTVUNDRVNTJyk7Cn0KAAAAAAAAAABVUAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAADwDAAAAAAAAPAMAAAAAAAAAAAAAAADwvw"
				],
				[
					67,
					1,
					"cut",
					null,
					"AQAAAF8DAAAAAAAAXwMAAAAAAAAQAAAALCBzaXplLCBwb3NpdGlvbg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAF8DAAAAAAAAbwMAAAAAAAAAAAAAAADwvw"
				],
				[
					74,
					1,
					"insert",
					{
						"characters": "const"
					},
					"BQAAADsFAAAAAAAAPAUAAAAAAAAAAAAAPAUAAAAAAAA9BQAAAAAAAAAAAAA9BQAAAAAAAD4FAAAAAAAAAAAAAD4FAAAAAAAAPwUAAAAAAAAAAAAAPwUAAAAAAABABQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAADsFAAAAAAAAOwUAAAAAAAAAAAAAAADwvw"
				],
				[
					75,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAEAFAAAAAAAAQQUAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAEAFAAAAAAAAQAUAAAAAAAAAAAAAAADwvw"
				],
				[
					76,
					1,
					"insert_snippet",
					{
						"contents": "{$0}"
					},
					"AQAAAEEFAAAAAAAAQwUAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAEEFAAAAAAAAQQUAAAAAAAAAAAAAAADwvw"
				],
				[
					77,
					1,
					"insert",
					{
						"characters": " size,"
					},
					"BgAAAEIFAAAAAAAAQwUAAAAAAAAAAAAAQwUAAAAAAABEBQAAAAAAAAAAAABEBQAAAAAAAEUFAAAAAAAAAAAAAEUFAAAAAAAARgUAAAAAAAAAAAAARgUAAAAAAABHBQAAAAAAAAAAAABHBQAAAAAAAEgFAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAEIFAAAAAAAAQgUAAAAAAAAAAAAAAADwvw"
				],
				[
					78,
					1,
					"insert",
					{
						"characters": " positoin"
					},
					"CQAAAEgFAAAAAAAASQUAAAAAAAAAAAAASQUAAAAAAABKBQAAAAAAAAAAAABKBQAAAAAAAEsFAAAAAAAAAAAAAEsFAAAAAAAATAUAAAAAAAAAAAAATAUAAAAAAABNBQAAAAAAAAAAAABNBQAAAAAAAE4FAAAAAAAAAAAAAE4FAAAAAAAATwUAAAAAAAAAAAAATwUAAAAAAABQBQAAAAAAAAAAAABQBQAAAAAAAFEFAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAEgFAAAAAAAASAUAAAAAAAAAAAAAAADwvw"
				],
				[
					79,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAFEFAAAAAAAAUgUAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFEFAAAAAAAAUQUAAAAAAAAAAAAAAADwvw"
				],
				[
					81,
					5,
					"left_delete",
					null,
					"BQAAAFIFAAAAAAAAUgUAAAAAAAABAAAAfVEFAAAAAAAAUQUAAAAAAAABAAAAIFAFAAAAAAAAUAUAAAAAAAABAAAAbk8FAAAAAAAATwUAAAAAAAABAAAAaU4FAAAAAAAATgUAAAAAAAABAAAAbw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFMFAAAAAAAAUwUAAAAAAAAAAAAAAADwvw"
				],
				[
					82,
					1,
					"insert",
					{
						"characters": "ion}"
					},
					"BAAAAE4FAAAAAAAATwUAAAAAAAAAAAAATwUAAAAAAABQBQAAAAAAAAAAAABQBQAAAAAAAFEFAAAAAAAAAAAAAFEFAAAAAAAAUgUAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAE4FAAAAAAAATgUAAAAAAAAAAAAAAADwvw"
				],
				[
					83,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAFIFAAAAAAAAUwUAAAAAAAAAAAAAUwUAAAAAAABUBQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFIFAAAAAAAAUgUAAAAAAAAAAAAAAADwvw"
				],
				[
					84,
					1,
					"insert",
					{
						"characters": " window;"
					},
					"CAAAAFQFAAAAAAAAVQUAAAAAAAAAAAAAVQUAAAAAAABWBQAAAAAAAAAAAABWBQAAAAAAAFcFAAAAAAAAAAAAAFcFAAAAAAAAWAUAAAAAAAAAAAAAWAUAAAAAAABZBQAAAAAAAAAAAABZBQAAAAAAAFoFAAAAAAAAAAAAAFoFAAAAAAAAWwUAAAAAAAAAAAAAWwUAAAAAAABcBQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFQFAAAAAAAAVAUAAAAAAAAAAAAAAADwvw"
				],
				[
					85,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAFwFAAAAAAAAXQUAAAAAAAAAAAAAXQUAAAAAAABeBQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFwFAAAAAAAAXAUAAAAAAAAAAAAAAADwvw"
				],
				[
					90,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAAKUFAAAAAAAApwUAAAAAAAAAAAAAXgUAAAAAAABgBQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAF4FAAAAAAAApQUAAAAAAAD////////vfw"
				],
				[
					98,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAAPUFAAAAAAAA9wUAAAAAAAAAAAAAqwUAAAAAAACtBQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKsFAAAAAAAA9QUAAAAAAAD////////vfw"
				],
				[
					107,
					1,
					"paste",
					null,
					"AgAAAPwCAAAAAAAAQwMAAAAAAAAAAAAAQwMAAAAAAABDAwAAAAAAAEAAAABHYW1tYVJhbXAsIE1vbml0b3IsIFBvc2l0aW9uLCBTY2FsZSwgVmlkZW9Nb2RlLCBXaW5kb3csIFdvcmtBcmVh",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPwCAAAAAAAAPAMAAAAAAAAAAAAAAADwvw"
				],
				[
					148,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAAB4UAAAaW1wb3J0IHsgUG9pbnQsIFNpemUsIFJlY3QsIE1hdCwgVU1hdCwgTGluZSwgQ0xBSEUsIFRpY2tNZXRlciwgRHJhdywgQ29udG91ciB9IGZyb20gJ29wZW5jdic7CmltcG9ydCAqIGFzIGN2IGZyb20gJ29wZW5jdic7CmltcG9ydCBmcyBmcm9tICdmcyc7CmltcG9ydCBDb25zb2xlIGZyb20gJ2NvbnNvbGUnOwppbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnOwppbXBvcnQgeyBSR0JBLCBIU0xBIH0gZnJvbSAnLi9saWIvY29sb3IuanMnOwppbXBvcnQgVXRpbCBmcm9tICcuL2xpYi91dGlsLmpzJzsKaW1wb3J0IHsgTnVtZXJpY1BhcmFtLCBFbnVtUGFyYW0sIFBhcmFtTmF2aWdhdG9yIH0gZnJvbSAnLi9wYXJhbS5qcyc7CmltcG9ydCB7IG1lbW9pemUsIHJhbmdlIH0gZnJvbSAnLi9saWIvbWlzYy5qcyc7CmltcG9ydCB7IFBpcGVsaW5lLCBQcm9jZXNzb3IgfSBmcm9tICcuL3Fqcy1vcGVuY3YvanMvY3ZQaXBlbGluZS5qcyc7CmltcG9ydCB7IFdpbmRvdywgTW91c2VGbGFncywgTW91c2VFdmVudHMsIE1vdXNlLCBUZXh0U3R5bGUsIERyYXdUZXh0IH0gZnJvbSAnLi9xanMtb3BlbmN2L2pzL2N2SGlnaEdVSS5qcyc7CmltcG9ydCAqIGFzIG52ZyBmcm9tICduYW5vdmcnOwppbXBvcnQgKiBhcyBnbGZ3IGZyb20gJ2dsZncnOwoKbGV0IGJhc2VuYW1lID0gVXRpbC5nZXRBcmd2KClbMV0ucmVwbGFjZSgvXC5qcyQvLCAnJyk7CmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJOwoKZnVuY3Rpb24gR0xGVyguLi5hcmdzKSB7CiAgY29uc3QgeyBHYW1tYVJhbXAsIE1vbml0b3IsIFBvc2l0aW9uLCBTY2FsZSwgU2l6ZSwgVmlkZW9Nb2RlLCBXaW5kb3csIFdvcmtBcmVhCiB9ID0gZ2xmdzsKICBsZXQgcmVzb2x1dGlvbiwgd2luZG93OwoKICByZXNvbHV0aW9uID0gbmV3IFNpemUoLi4uYXJncyk7CiAgY29uc3QgaGludHMgPSBbCiAgICBbZ2xmdy5DT05URVhUX1ZFUlNJT05fTUFKT1IsIDNdLAogICAgW2dsZncuQ09OVEVYVF9WRVJTSU9OX01JTk9SLCAyXSwKICAgIFtnbGZ3Lk9QRU5HTF9QUk9GSUxFLCBnbGZ3Lk9QRU5HTF9DT1JFX1BST0ZJTEVdLAogICAgW2dsZncuT1BFTkdMX0ZPUldBUkRfQ09NUEFULCB0cnVlXSwKICAgIFtnbGZ3LlJFU0laQUJMRSwgZmFsc2VdLAogICAgW2dsZncuU0FNUExFUywgNF0KICBdOwoKICBmb3IobGV0IFtwcm9wLCB2YWx1ZV0gb2YgaGludHMpIFdpbmRvdy5oaW50KHByb3AsIHZhbHVlKTsKCiAgd2luZG93ID0gbmV3IFdpbmRvdyhyZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCwgJ09wZW5HTCcpOwogIGdsZncuY29udGV4dC5jdXJyZW50ID0gd2luZG93OwogIHRoaXMuY29udGV4dCA9IGdsZncuY29udGV4dDsKCiBjb25zdCB7IHNpemUsIHBvc2l0aW9ufSA9IHdpbmRvdzsKIC8qIHNpemUgPSBuZXcgU2l6ZSh3aW5kb3cuc2l6ZSk7CiAgcG9zaXRpb24gPSBuZXcgUG9pbnQod2luZG93LnBvc2l0aW9uKTsqLwogLyogY29uc3QgcmVjdCA9IG5ldyBSZWN0KC4uLnBvc2l0aW9uLCAuLi5zaXplKTsKICBjb25zb2xlLmxvZyhgR0xGV2AsIHJlY3QpOyovCiAgbnZnLkNyZWF0ZUdMMyhudmcuU1RFTkNJTF9TVFJPS0VTIHwgbnZnLkFOVElBTElBUyB8IG52Zy5ERUJVRyk7CiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcywgeyByZXNvbHV0aW9uLCB3aW5kb3csIHNpemUsIHBvc2l0aW9uIH0pOwp9CgpmdW5jdGlvbiBXcml0ZUltYWdlKG5hbWUsIG1hdCkgewogIGN2Lmltd3JpdGUobmFtZSwgbWF0KTsKICBjb25zb2xlLmxvZygiV3JvdGUgJyIgKyBuYW1lICsgIicgKCIgKyBtYXQuc2l6ZSArICcpLicpOwp9CgpmdW5jdGlvbiBTYXZlQ29uZmlnKGNvbmZpZ09iaikgewogIGNvbmZpZ09iaiA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjb25maWdPYmopLm1hcCgoW2ssIHZdKSA9PiBbaywgK3ZdKSk7CiAgbGV0IGZpbGUgPSBzdGQub3BlbihiYXNlbmFtZSArICcuY29uZmlnLmpzb24nLCAndytiJyk7CiAgZmlsZS5wdXRzKEpTT04uc3RyaW5naWZ5KGNvbmZpZ09iaiwgbnVsbCwgMikgKyAnXG4nKTsKICBmaWxlLmNsb3NlKCk7CiAgY29uc29sZS5sb2coIlNhdmVkIGNvbmZpZyB0byAnIiArIGJhc2VuYW1lICsgJy5jb25maWcuanNvbicgKyAiJyIsIGluc3BlY3QoY29uZmlnT2JqLCB7IGNvbXBhY3Q6IGZhbHNlIH0pKTsKfQoKZnVuY3Rpb24gTG9hZENvbmZpZygpIHsKICBsZXQgc3RyID0gc3RkLmxvYWRGaWxlKGJhc2VuYW1lICsgJy5jb25maWcuanNvbicpOwogIGxldCBjb25maWdPYmogPSBKU09OLnBhcnNlKHN0ciB8fCAne30nKTsKICBjb25maWdPYmogPSBPYmplY3QuZnJvbUVudHJpZXMoCiAgICBPYmplY3QuZW50cmllcyhjb25maWdPYmopCiAgICAgIC5tYXAoKFtrLCB2XSkgPT4gW2ssICt2XSkKICAgICAgLmZpbHRlcigoW2ssIHZdKSA9PiAhaXNOYU4odikpCiAgKTsKICBjb25zb2xlLmxvZygnTG9hZENvbmZpZzonLCBpbnNwZWN0KGNvbmZpZ09iaiwgeyBjb21wYWN0OiBmYWxzZSB9KSk7CiAgcmV0dXJuIGNvbmZpZ09iajsKfQoKZnVuY3Rpb24gSW5zcGVjdE1hdChtYXQpIHsKICBjb25zdCB7IGNoYW5uZWxzLCBkZXB0aCwgdHlwZSwgY29scywgcm93cyB9ID0gbWF0OwogIHJldHVybiBpbnNwZWN0KHsgY2hhbm5lbHMsIGRlcHRoLCB0eXBlLCBjb2xzLCByb3dzIH0pOwp9CgpmdW5jdGlvbiBUb0hleChudW1iZXIpIHsKICBpZihudW1iZXIgPCAwKSBudW1iZXIgPSAweGZmZmZmZmZmICsgbnVtYmVyICsgMTsKICByZXR1cm4gJzB4JyArIG51bWJlci50b1N0cmluZygxNik7Cn0KCmZ1bmN0aW9uIEFjY3VtdWxhdG9yKGNhbGxiYWNrKSB7CiAgbGV0IHNlbGY7CiAgbGV0IGFjY3UgPSB7fTsKICBzZWxmID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHsKICAgIGlmKG5hbWUgaW4gYWNjdSkgcmV0dXJuOwogICAgYWNjdVtuYW1lXSA9IHZhbHVlOwogICAgaWYodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKG5hbWUsIHZhbHVlKTsKICB9OwogIE9iamVjdC5hc3NpZ24oc2VsZiwgewogICAgYWNjdSwKICAgIGVudHJpZXMoKSB7CiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhhY2N1KTsKICAgIH0sCiAgICB2YWx1ZXMoKSB7CiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFjY3UpOwogICAgfSwKICAgIGtleXMoKSB7CiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhY2N1KTsKICAgIH0sCiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICAgIGZvcihsZXQga2V5IGluIGFjY3UpIHlpZWxkIFtrZXksIGFjY3Vba2V5XV07CiAgICB9LAogICAgY2xlYXIoKSB7CiAgICAgIGZvcihsZXQga2V5IGluIGFjY3UpIGRlbGV0ZSBhY2N1W2tleV07CiAgICB9CiAgfSk7CiAgcmV0dXJuIHNlbGY7Cn0KCmZ1bmN0aW9uIG1haW4oLi4uYXJncykgewogIGdsb2JhbFRoaXMuY29uc29sZSA9IG5ldyBDb25zb2xlKHsKICAgIGluc3BlY3RPcHRpb25zOiB7CiAgICAgIG1heFN0cmluZ0xlbmd0aDogMjAwLAoKICAgICAgYnJlYWtMZW5ndGg6IDEwMCwKICAgICAgY29tcGFjdDogMCwKICAgICAgZGVwdGg6IEluZmluaXR5CiAgICB9CiAgfSk7CiAgbGV0IHJ1bm5pbmcgPSB0cnVlOwoKICBjb25zb2xlLmxvZygnVXRpbC5nZXRNZXRob2ROYW1lcyhjdiknLCBVdGlsLmdldE1ldGhvZE5hbWVzKGN2LCBJbmZpbml0eSwgMCkpOwogIGNvbnNvbGUubG9nKCdjdi5Ib3VnaExpbmVzJywgY3YuSG91Z2hMaW5lcyk7CgogIGxldCBsaW5lID0gbmV3IExpbmUoMCwgMCwgNTAsIDUwKTsKICBjb25zb2xlLmxvZygnbGluZScsIGxpbmUpOwogIGxldCBjbGFoZSA9IG5ldyBDTEFIRSgpOwogIGNvbnNvbGUubG9nKCdjbGFoZScsIGNsYWhlKTsKICBjdi5uYW1lZFdpbmRvdygnb3V0cHV0JywgY3YuV0lORE9XX05PUk1BTCB8IGN2LldJTkRPV19LRUVQUkFUSU8pOwogIGxldCB0cmFja2JhciA9ICcnOwogIGxldCBmaWxlID0gYXJnc1swXSB8fCAnLi4vYW4tdHJvbmljcy9pbWFnZXMvZm0vNHRyLmpwZyc7CiAgbGV0IGltYWdlID0gY3YuaW1yZWFkKGZpbGUpOwogIGxldCByZXNvbHV0aW9uID0gaW1hZ2Uuc2l6ZTsKICBsZXQgc2NhbGVkOwogIGNvbnNvbGUubG9nKCdTeW1ib2wuaW5zcGVjdCcsIFN5bWJvbC5pbnNwZWN0KTsKICBjb25zb2xlLmxvZygncmVzb2x1dGlvbicsIHJlc29sdXRpb24pOwogIGlmKHJlc29sdXRpb24ud2lkdGggPiAxMjAwKSB7CiAgICBsZXQgZiA9IDEwMjQgLyByZXNvbHV0aW9uLndpZHRoOwogICAgc2NhbGVkID0gbmV3IFNpemUocmVzb2x1dGlvbi53aWR0aCAqIGYsIHJlc29sdXRpb24uaGVpZ2h0ICogZik7CiAgfSBlbHNlIHsKICAgIHNjYWxlZCA9IG5ldyBTaXplKHJlc29sdXRpb24pOwogIH0KCiAgbGV0IG91dHB1dFJlY3QgPSBuZXcgUmVjdCgwLCAwLCByZXNvbHV0aW9uLndpZHRoLCByZXNvbHV0aW9uLmhlaWdodCk7CiAgbGV0IG91dHB1dE1hdCA9IG5ldyBNYXQob3V0cHV0UmVjdC5zaXplLCBjdi5DVl84VUMzKTsKICBsZXQgc3RhdHVzUmVjdCA9IG5ldyBSZWN0KDAsIHJlc29sdXRpb24uaGVpZ2h0LCByZXNvbHV0aW9uLndpZHRoLCAyMDApOwogIGxldCBzdGF0dXNNYXQgPSBuZXcgTWF0KHN0YXR1c1JlY3Quc2l6ZSwgY3YuQ1ZfOFVDMyk7CiAgY29uc29sZS5sb2coJ3N0YXR1c1JlY3Q6Jywgc3RhdHVzUmVjdCk7CiAgbGV0IFt0ZXh0UmVjdCwgaGVscFJlY3RdID0gbmV3IFJlY3Qoc3RhdHVzUmVjdC5zaXplKS5pbnNldCg1KS52c3BsaXQoLTIwKTsKICBsZXQgc2NyZWVuU2l6ZSA9IG5ldyBTaXplKHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0ICsgMjAwKTsKICBjb25zb2xlLmxvZygnc3RhdHVzUmVjdCcsIHN0YXR1c1JlY3QpOwogIGNvbnNvbGUubG9nKCd0ZXh0UmVjdCcsIHRleHRSZWN0KTsKICBjb25zb2xlLmxvZygnaGVscFJlY3Q6JywgaGVscFJlY3QpOwogIGxldCBzY3JlZW4gPSBuZXcgTWF0KHNjcmVlblNpemUsIGN2LkNWXzhVQzMpOwoKICBsZXQgZ2Z4ID0gbmV3IEdMRlcoLi4uc2NyZWVuU2l6ZSk7CiAgY29uc29sZS5sb2coJ2dmeDonLCBnZngpOwoKICBjdi5pbXNob3coJ291dHB1dCcsIHNjcmVlbik7CiAgY3YubW92ZVdpbmRvdygnb3V0cHV0JywgMCwgMCk7CiAgY3YucmVzaXplV2luZG93KCdvdXRwdXQnLCBzY3JlZW5TaXplLndpZHRoKTsKCiAgY3Yuc2V0TW91c2VDYWxsYmFjaygnb3V0cHV0JywgKGV2ZW50LCB4LCB5LCBmbGFncykgPT4gewogICAgaWYoZmxhZ3MgPT0gY3YuRVZFTlRfRkxBR19MQlVUVE9OIHx8IGV2ZW50ID09IGN2LkVWRU5UX0xCVVRUT05ET1dOKSBjb25zb2xlLmxvZyhgY2xpY2sgJHt4fSwke3l9YCk7CiAgICBlbHNlIGlmKGV2ZW50KSBjb25zb2xlLmxvZygnTW91c2VDYWxsYmFjaycsIHsgZXZlbnQsIHgsIHksIGZsYWdzIH0pOwogIH0pOwoKICBsZXQgYmFja2dyb3VuZENvbG9yID0gMHhkMGQwZDA7CiAgbGV0IHNoYWRvd0NvbG9yID0gMHg0MDQwNDA7CiAgbGV0IHRleHRDb2xvciA9IDB4ZDNkN2NmOwogIGxldCBmb250cyA9IFsnL2hvbWUvcm9tYW4vLmZvbnRzL2dvdGhpYy50dGYnLCAnL2hvbWUvcm9tYW4vLmZvbnRzL2dvdGhpY2IudHRmJywgJy91c3Ivc2hhcmUvZm9udHMvdHJ1ZXR5cGUvdWJ1bnR1L1VidW50dU1vbm8tUi50dGYnXTsKICBsZXQgZm9udEZhY2UgPSBmb250c1syXTsKICBsZXQgZm9udFNpemUgPSAxNDsKICBmb250cy5mb3JFYWNoKGZpbGUgPT4gRHJhdy5sb2FkRm9udChmaWxlKSk7CiAgbGV0IGNvbmZpZyA9IExvYWRDb25maWcoKTsKICBsZXQgeyBmcmFtZVNob3cgPSAxLCBwYXJhbUluZGV4ID0gMCB9ID0gY29uZmlnOwogIGxldCBwYXJhbXMgPSB7CiAgICB0aHJlczogbmV3IE51bWVyaWNQYXJhbShjb25maWcudGhyZXMgfHwgMjI5LCAwLCAyNTUpLAogICAgdHlwZTogbmV3IE51bWVyaWNQYXJhbShjb25maWcudHlwZSB8fCBjdi5USFJFU0hfQklOQVJZX0lOViwgMCwgNCksCiAgICBibHVyOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5ibHVyIHx8IDEsIDEsIDEwLCAyKSwKICAgIGtlcm5lbF9zaXplOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5rZXJuZWxfc2l6ZSB8fCAwLCAwLCA5KSwKICAgIHJobzogbmV3IE51bWVyaWNQYXJhbShjb25maWcucmhvIHx8IDEsIDEsIDMwLCAwLjI1KSwKICAgIHRoZXRhOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy50aGV0YSB8fCAxLCAwLCA5MCksCiAgICB0aHJlc2hvbGQ6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLnRocmVzaG9sZCB8fCAyNSwgMCwgNTApLAogICAgbWluTGluZUxlbmd0aDogbmV3IE51bWVyaWNQYXJhbShjb25maWcubWluTGluZUxlbmd0aCB8fCAzLCAwLCAzMCksCiAgICBtYXhMaW5lR2FwOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5tYXhMaW5lR2FwIHx8IDQsIDAsIDIwKSwKICAgIGRwOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5kcCB8fCAyLCAwLCAxMCwgMC4xKSwKICAgIG1pbkRpc3Q6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLm1pbkRpc3QgfHwgMTAsIDEsIDEwMDApLAogICAgcGFyYW0xOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5wYXJhbTEgfHwgMjAwLCAxLCAxMDAwKSwKICAgIHBhcmFtMjogbmV3IE51bWVyaWNQYXJhbShjb25maWcucGFyYW0yIHx8IDEwMCwgMSwgMTAwKSwKICAgIG1pblJhZGl1czogbmV3IE51bWVyaWNQYXJhbShjb25maWcubWluUmFkaXVzIHx8IDAsIDEsIDI1MCksCiAgICBtYXhSYWRpdXM6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLm1heFJhZGl1cyB8fCAyMDAsIDEsIDEwMDApCiAgfTsKICBsZXQgY29udG91cnMgPSBbXTsKICBsZXQgbGluZVdpZHRoID0gMTsKICBsZXQgbGluZXMgPSBbXTsKICBsZXQgY2lyY2xlcyA9IFtdOwogIGxldCBwYXJhbU5hdiA9IG5ldyBQYXJhbU5hdmlnYXRvcihwYXJhbXMsIHBhcmFtSW5kZXgpOwogIGxldCBwYXJhbUluZGV4ZXMgPSBbLTEsIC0xXTsKICBsZXQgcGFsZXR0ZSA9IG5ldyBBcnJheSgpOwogIGNvbnN0IGJsYWNrID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4ZmZdOwogIGZvcihsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHBhbGV0dGVbaV0gPSBbaSAmIDB4MDQgPyAweGZmIDogMHgwMCwgaSAmIDB4MDIgPyAweGZmIDogMHgwMCwgaSAmIDB4MDEgPyAweGZmIDogMHgwMCwgMHhmZl07CiAgcGFsZXR0ZVsyXSA9IFsweDYwLCAweDYwLCAweDYwLCAweGZmXTsKICBwYWxldHRlWzNdID0gWzB4ZmYsIDB4ZmYsIDB4MCwgMHhmZl07CiAgZm9yKGxldCBpID0gODsgaSA8IDE2OyBpKyspIHBhbGV0dGVbaV0gPSBibGFjazsKICBsZXQgcGlwZWxpbmUgPSBuZXcgUGlwZWxpbmUoCiAgICBbCiAgICAgIGZ1bmN0aW9uIEFjcXVpcmVGcmFtZShzcmMsIGRzdCkgewogICAgICAgIGltYWdlID0gY3YuaW1yZWFkKGZpbGUpOwogICAgICAgIGltYWdlLmNvcHlUbyhkc3QpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBHcmF5c2NhbGUoc3JjLCBkc3QpIHsKICAgICAgICBsZXQgY2hhbm5lbHMgPSBbXTsKICAgICAgICBjdi5jdnRDb2xvcihzcmMsIGRzdCwgY3YuQ09MT1JfQkdSMkxhYik7CiAgICAgICAgY3Yuc3BsaXQoZHN0LCBjaGFubmVscyk7CiAgICAgICAgY2hhbm5lbHNbMF0uY29weVRvKGRzdCk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIEJsdXIoc3JjLCBkc3QpIHsKICAgICAgICBjdi5HYXVzc2lhbkJsdXIoc3JjLCBkc3QsIFsrcGFyYW1zLmJsdXIsICtwYXJhbXMuYmx1cl0sIDAsIDAsIGN2LkJPUkRFUl9SRVBMSUNBVEUpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBUaHJlc2hvbGQoc3JjLCBkc3QpIHsKICAgICAgICBjdi50aHJlc2hvbGQoc3JjLCBkc3QsICtwYXJhbXMudGhyZXMsIDI1NSwgK3BhcmFtcy50eXBlKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gTW9ycGhvbG9neShzcmMsIGRzdCkgewogICAgICAgIGxldCBzdHJ1Y3R1cmluZ0VsZW1lbnQgPSBjdi5nZXRTdHJ1Y3R1cmluZ0VsZW1lbnQoY3YuTU9SUEhfQ1JPU1MsIG5ldyBTaXplKCtwYXJhbXMua2VybmVsX3NpemUgKiAyICsgMSwgK3BhcmFtcy5rZXJuZWxfc2l6ZSAqIDIgKyAxKSk7CiAgICAgICAgc3JjLmNvcHlUbyhkc3QpOwogICAgICAgIGN2Lm1vcnBob2xvZ3lFeChkc3QsIGRzdCwgY3YuTU9SUEhfRVJPREUsIHN0cnVjdHVyaW5nRWxlbWVudCk7CiAgICAgICAgZHN0LnhvcihbMjU1LCAyNTUsIDI1NSwgMF0sIGRzdCk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIFNrZWxldG9uaXphdGlvbihzcmMsIGRzdCkgewogICAgICAgIGN2LnNrZWxldG9uaXphdGlvbihzcmMsIGRzdCk7CgogICAgICAgIC8vY3YudHJhY2VTa2VsZXRvbihkc3QsIGNvbnRvdXJzKTsKICAgICAgICBjb250b3VycyA9IGN2LnRyYWNlU2tlbGV0b24oZHN0KTsKCiAgICAgICAgLy8gY29udG91cnMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7CiAgICAgICAgLy8vKiBwcmV0dGllci1pZ25vcmUgKi8gY29uc29sZS5sb2coJ1NrZWxldG9uaXphdGlvbicsIGNvbnNvbGUuY29uZmlnKHsgY29tcGFjdDogMSwgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5IH0pLCBjb250b3Vycy5tYXAoYyA9PiBjLnRvU3RyaW5nKCkpKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gU2hvd1RyYWNlKHNyYywgZHN0KSB7CiAgICAgICAgY3YuY3Z0Q29sb3Ioc3JjLCBkc3QsIGN2LkNPTE9SX0dSQVkyQkdSKTsKICAgICAgICBkc3QuY2xlYXIoKTsKCiAgICAgICAgLy9sZXQgcGFsZXR0ZT0gcmFuZ2UoMCwzNTksIDM2MC9jb250b3Vycy5sZW5ndGgpLm1hcChodWUgPT4gbmV3IEhTTEEoaHVlLCAxMDAsNTAsMS4wKSk7CiAgICAgICAgbGV0IHBhbGV0dGUgPSByYW5nZSgwLCBjb250b3Vycy5sZW5ndGggLSAxKQogICAgICAgICAgLm1hcChuID0+IFtNYXRoLmZsb29yKG4gLyAzKSwgKChuICUgMykgLSAxKSAqIDI1ICsgNTBdKQogICAgICAgICAgLm1hcCgoW24sIG1dKSA9PiBbKE1hdGguZmxvb3IobiAvIDMpICogMzU5ICogOSkgLyAoY29udG91cnMubGVuZ3RoIC0gMSksICgobiAlIDMpIC0gMSkgKiAyNSArIDUwLCBtXSkKICAgICAgICAgIC5tYXAoKFtoLCBzLCBsXSkgPT4gbmV3IEhTTEEoaCwgcywgbCwgMS4wKSk7CgogICAgICAgIHBhbGV0dGUgPSBwYWxldHRlLm1hcChjID0+IGMudG9CR1JBKCkpOwoKICAgICAgICAvLyBjb25zb2xlLmxvZygnU2hvd1RyYWNlJywgY29uc29sZS5jb25maWcoeyBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksIGRlcHRoOiA0IH0pLCB7IHBhbGV0dGUgfSk7CiAgICAgICAgLy8gY29uc29sZS5sb2coJ0RyYXcuY29udG91cnMnLCBEcmF3LmNvbnRvdXJzKTsKCiAgICAgICAgLy8gIGNvbnRvdXJzID0gY29udG91cnMuZmlsdGVyKGMgPT4gYy5sZW5ndGg8PSAyKTsKCiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbnRvdXJzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBjb2xvciA9IHBhbGV0dGVbaV07CiAgICAgICAgICAvL0RyYXcuY29udG91cnMoZHN0LCBjb250b3VycywgaSwgY29sb3IsIDEpOwogICAgICAgICAgRHJhdy5wb2x5bGluZXMoZHN0LCBbY29udG91cnNbaV1dLCBmYWxzZSwgY29sb3IsIDEpOwogICAgICAgIH0KCiAgICAgICAgY29uc29sZS5sb2coJ1Nob3dUcmFjZScsIGNvbnNvbGUuY29uZmlnKHsgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5IH0pLCB7IHNyYywgZHN0IH0pOwogICAgICB9LAogICAgICBmdW5jdGlvbiBMaW5lU2VnbWVudERldGVjdG9yKHNyYywgZHN0KSB7CiAgICAgICAgbGV0IGxpbmVzID0gW107CiAgICAgICAgbGV0IHdpZHRoID0gW10sCiAgICAgICAgICBwcmVjID0gW10sCiAgICAgICAgICBuZmEgPSBbXTsKICAgICAgICBjdi5saW5lU2VnbWVudERldGVjdG9yKHRoaXMub3V0cHV0T2YoJ1NrZWxldG9uaXphdGlvbicpLCBsaW5lcywgd2lkdGgsIHByZWMsIG5mYSk7CiAgICAgICAgLyogbGV0IGludGVyc2VjdGlvbk1hdHJpeCA9IFtdOwogICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgaW50ZXJzZWN0aW9uTWF0cml4W2ldID0gW107CiAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgbGV0IHB0ID0gW107CiAgICAgICAgICAgIGxldCBiID0gaSA9PSBqID8gbnVsbCA6IGxpbmVzW2ldLmludGVyc2VjdChsaW5lc1tqXSwgcHQpOwogICAgICAgICAgICBpbnRlcnNlY3Rpb25NYXRyaXhbaV1bal0gPSBiICYmIHB0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zb2xlLmxvZygnTGluZVNlZ21lbnREZXRlY3RvcicsIHsgaW50ZXJzZWN0aW9uTWF0cml4IH0pOwogICAgICAgIGxldCBsaW5lTWFwID0gbmV3IE1hcCgpOwogICAgICAgIGxldCBsaW5lTWFwcGVyID0gbWVtb2l6ZSgoKSA9PiBbXSwgbGluZU1hcCk7CiAgICAgICAgZm9yKGxldCBsaW5lIG9mIGxpbmVzKSB7CiAgICAgICAgICBsZXQgeyBhLCBiIH0gPSBsaW5lOwogICAgICAgICAgbGluZU1hcHBlcihhICsgJycpLnB1c2gobGluZSk7CiAgICAgICAgICBsaW5lTWFwcGVyKGIgKyAnJykucHVzaChsaW5lKTsKICAgICAgICB9CiAgICAgICAgY29uc29sZS5sb2coJ0xpbmVTZWdtZW50RGV0ZWN0b3InLCBjb25zb2xlLmNvbmZpZyh7IGNvbXBhY3Q6IDMgfSksIFsuLi5saW5lTWFwXS5tYXAoKFtuYW1lLCBhcnJdKSA9PiBbbmFtZSwgYXJyLmxlbmd0aCwgYXJyLm1hcChsaW5lID0+IFtsaW5lICsgJycsIGxpbmUubGVuZ3RoXSldKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSkgKTsKICAgICAgICAqLwogICAgICAgIHNyYy5jb3B5VG8oZHN0KTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gUGl4ZWxOZWlnaGJvcmhvb2Qoc3JjLCBkc3QpIHsKICAgICAgICBsZXQgbmVpZ2hib3Job29kID0gbmV3IE1hdChzcmMuc2l6ZSwgY3YuQ1ZfOFVDMSk7CiAgICAgICAgY3YucGl4ZWxOZWlnaGJvcmhvb2Qoc3JjLCBuZWlnaGJvcmhvb2QpOwogICAgICAgIGxldCBlbmRwb2ludHMgPSBjdi5waXhlbEZpbmRWYWx1ZShzcmMsIDEpOwogICAgICAgIGNvbnNvbGUubG9nKCdlbmRwb2ludHMnLCBlbmRwb2ludHMpOwogICAgICAgIGxldCBsaW5lcG9pbnRzID0gY3YucGl4ZWxGaW5kVmFsdWUoc3JjLCAyKTsKICAgICAgICBjb25zb2xlLmxvZygnbGluZXBvaW50cycsIGxpbmVwb2ludHMpOwogICAgICAgIGN2Lmltd3JpdGUoJ25laWdoYm9yaG9vZC5wbmcnLCBuZWlnaGJvcmhvb2QsIHBhbGV0dGUpOwogICAgICAgIGxldCBpbSA9IGN2LmltcmVhZCgnbmVpZ2hib3Job29kLnBuZycpOwogICAgICAgIGltLmNvcHlUbyhkc3QpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBIb3VnaExpbmVzUChzcmMsIGRzdCkgewogICAgICAgIGNvbnN0IHNrZWwgPSB0aGlzLm91dHB1dE9mKCdTa2VsZXRvbml6YXRpb24nKTsKICAgICAgICBjb25zdCBtb3JwaG8gPSB0aGlzLm91dHB1dE9mKCdNb3JwaG9sb2d5Jyk7CiAgICAgICAgbGV0IG91dHB1dCA9IG5ldyBNYXQoKTsKICAgICAgICBpZihza2VsLmNoYW5uZWxzID4gMSkgY3YuY3Z0Q29sb3Ioc2tlbCwgc2tlbCwgY3YuQ09MT1JfQkdSMkdSQVkpOwogICAgICAgIGlmKG1vcnBoby5jaGFubmVscyA+IDEpIGN2LmN2dENvbG9yKG1vcnBobywgbW9ycGhvLCBjdi5DT0xPUl9CR1IyR1JBWSk7CiAgICAgICAgY3YuSG91Z2hMaW5lc1Aoc2tlbCwgb3V0cHV0LCArcGFyYW1zLnJobywgKE1hdGguUEkgKiAoK3BhcmFtcy50aGV0YSB8fCAxKSkgLyAxODAsICtwYXJhbXMudGhyZXNob2xkLCArcGFyYW1zLm1pbkxpbmVMZW5ndGgsICtwYXJhbXMubWF4TGluZUdhcCk7CiAgICAgICAgY3YuY3Z0Q29sb3Ioc2tlbCwgZHN0LCBjdi5DT0xPUl9HUkFZMkJHUik7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGxpbmVzLnNwbGljZSgwLCBsaW5lcy5sZW5ndGgpOwogICAgICAgIGZvcihsZXQgZWxlbSBvZiBvdXRwdXQudmFsdWVzKCkpIHsKICAgICAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZShlbGVtKTsKICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7CiAgICAgICAgICBEcmF3LmxpbmUoZHN0LCAuLi5saW5lLnRvUG9pbnRzKCksIFsyNTUsIDEyOCwgMF0sIGxpbmVXaWR0aCwgY3YuTElORV9BQSk7CiAgICAgICAgICBEcmF3LmxpbmUobW9ycGhvLCAuLi5saW5lLnRvUG9pbnRzKCksIFswLCAwLCAwXSwgMiwgY3YuTElORV84KTsKICAgICAgICAgIERyYXcubGluZShza2VsLCAuLi5saW5lLnRvUG9pbnRzKCksIFswLCAwLCAwXSwgbGluZVdpZHRoLCBjdi5MSU5FXzgpOwogICAgICAgICAgKytpOwogICAgICAgIH0KICAgICAgICBsaW5lcyA9IGxpbmVzLm1hcChsID0+IChsLnNsb3BlLnkgPCAwID8gbC5zd2FwKCkgOiBsKSk7CgogICAgICAgIGNvbnN0IEdldEFuZ2xlID0gbCA9PiBNYXRoLnJvdW5kKChsLmFuZ2xlICogUkFEMkRFRykgLyAxNSkgKiAxNTsKCiAgICAgICAgbGluZXMgPSBsaW5lcy5maWx0ZXIobCA9PiBsLmxlbmd0aCA+PSA0MCAmJiBNYXRoLmFicyhHZXRBbmdsZShsKSkgIT0gNDUpOwoKICAgICAgICBsaW5lcy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTsKICAgICAgICAvLyAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIDUwKTsKICAgICAgICAvL2NvbnNvbGUubG9nKGBsaW5lc2AsIGxpbmVzLm1hcChsID0+IFtsLCBsLnNsb3BlLCBHZXRBbmdsZShsKV0pKTsKCiAgICAgICAgbGV0IGlzSG9yaXpvbnRhbCA9IGwgPT4gTWF0aC5hYnMobC54MiAtIGwueDEpID4gTWF0aC5hYnMobC55MiAtIGwueTEpOwoKICAgICAgICBsZXQgZmlyc3RMYXN0ID0gYSA9PiBbYVswXSwgYVthLmxlbmd0aCAtIDFdXTsKCiAgICAgICAgbGV0IHYgPSBsaW5lcwogICAgICAgICAgLmZpbHRlcihsID0+ICFpc0hvcml6b250YWwobCkpCiAgICAgICAgICAubWFwKGwgPT4gW2wsIGwuYXQoMC41KV0pCiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYVsxXS54IC0gYlsxXS54KQogICAgICAgICAgLm1hcCgoW2xdKSA9PiBsKTsKCiAgICAgICAgbGV0IGggPSBsaW5lcwogICAgICAgICAgLmZpbHRlcihsID0+IGlzSG9yaXpvbnRhbChsKSkKICAgICAgICAgIC5tYXAobCA9PiBbbCwgbC5hdCgwLjUpXSkKICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzFdLnkgLSBiWzFdLnkpCiAgICAgICAgICAubWFwKChbbF0pID0+IGwpOwoKICAgICAgICAvKiAgIHYgPSBmaXJzdExhc3Qodik7CiAgICAgICAgaCA9IGZpcnN0TGFzdChoKTsqLwogICAgICAgIC8vY29uc29sZS5sb2coJ2xpbmVzOicsIHsgdiwgaCB9KTsKCiAgICAgICAgY29uc3QgYW5nbGUyQ29sb3IgPSBhID0+IHsKICAgICAgICAgIGxldCBjb2xvciA9IG5ldyBIU0xBKE1hdGgucm91bmQoYSksIDEwMCwgNTApLnRvUkdCQSgpOwogICAgICAgICAgcmV0dXJuIFtjb2xvci5iLCBjb2xvci5nLCBjb2xvci5yXTsKICAgICAgICB9OwoKICAgICAgICBjb25zb2xlLmxvZygnYW5nbGUyQ29sb3IoMTAwKTonLCBhbmdsZTJDb2xvcigxMDApKTsKICAgICAgICBjb25zb2xlLmxvZygnYW5nbGUyQ29sb3IoMzYwKTonLCBhbmdsZTJDb2xvcigwKSk7CiAgICAgICAgLyoKICAgICAgICBjb25zb2xlLmxvZygndicsCiAgICAgICAgICBbLi4udi5zbGljZSgwLCA0KSwgLi4uaC5zbGljZSgwLCA0KV0ubWFwKGwgPT4gWwogICAgICAgICAgICAuLi5sLnRvUG9pbnRzKCksCiAgICAgICAgICAgIGB5SW50ZXJjZXB0KCkgPSAke2wueUludGVyY2VwdCgpfWAsCiAgICAgICAgICAgIGB4SW50ZXJjZXB0KCkgPSAke2wueEludGVyY2VwdCgpfWAKICAgICAgICAgIF0pCiAgICAgICAgKTsqLwogICAgICAgIGZvcihsZXQgbGluZSBvZiB2KSB7CiAgICAgICAgICBsZXQgY29sb3IgPSBhbmdsZTJDb2xvcigobGluZS5hbmdsZSAqICgxODAgLyBNYXRoLlBJKSkgJSAxODApOwoKICAgICAgICAgIERyYXcubGluZShkc3QsIC4uLmxpbmUudG9Qb2ludHMoKSwgY29sb3IsIDEsIGN2LkxJTkVfQUEpOwogICAgICAgIH0KICAgICAgICBmb3IobGV0IGxpbmUgb2YgaCkgewogICAgICAgICAgbGV0IGNvbG9yID0gYW5nbGUyQ29sb3IoKGxpbmUuYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkpICUgMTgwKTsKCiAgICAgICAgICBEcmF3LmxpbmUoZHN0LCAuLi5saW5lLnRvUG9pbnRzKCksIGNvbG9yLCAxLCBjdi5MSU5FX0FBKTsKICAgICAgICB9CgogICAgICAgIGxldCBrZXJuID0gY3YuZ2V0U3RydWN0dXJpbmdFbGVtZW50KGN2Lk1PUlBIX0NST1NTLCBuZXcgU2l6ZSgzLCAzKSk7CiAgICAgICAgY3YuZGlsYXRlKHNrZWwsIHNrZWwsIGtlcm4pOwogICAgICAgIGN2LmVyb2RlKHNrZWwsIHNrZWwsIGtlcm4pOwogICAgICAgIGN2LmRpbGF0ZShtb3JwaG8sIG1vcnBobywga2Vybik7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIEhvdWdoQ2lyY2xlcyhzcmMsIGRzdCkgewogICAgICAgIGNvbnN0IG1vcnBobyA9IHRoaXMub3V0cHV0T2YoJ01vcnBob2xvZ3knKTsKICAgICAgICBjb25zdCBza2VsID0gdGhpcy5vdXRwdXRPZignU2tlbGV0b25pemF0aW9uJyk7CiAgICAgICAgY29uc3QgcGFyYW1BcnJheSA9IFsrcGFyYW1zLmRwIHx8IDEsICtwYXJhbXMubWluRGlzdCwgK3BhcmFtcy5wYXJhbTEsICtwYXJhbXMucGFyYW0yLCArcGFyYW1zLm1pblJhZGl1cywgK3BhcmFtcy5tYXhSYWRpTWF0aHVzXTsKICAgICAgICBsZXQgY2lyY2xlczEgPSBbXSB8fCBuZXcgTWF0KCk7CiAgICAgICAgbGV0IGNpcmNsZXMyID0gW10gfHwgbmV3IE1hdCgpOwogICAgICAgIGN2LkhvdWdoQ2lyY2xlcyhtb3JwaG8sIGNpcmNsZXMxLCBjdi5IT1VHSF9HUkFESUVOVCwgLi4ucGFyYW1BcnJheSk7CiAgICAgICAgY3YuSG91Z2hDaXJjbGVzKHNrZWwsIGNpcmNsZXMyLCBjdi5IT1VHSF9HUkFESUVOVCwgLi4ucGFyYW1BcnJheSk7CiAgICAgICAgdGhpcy5vdXRwdXRPZignSG91Z2hMaW5lc1AnKS5jb3B5VG8oZHN0KTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgZm9yKGxldCBbeCwgeSwgcl0gb2YgY2lyY2xlczEpIHsKICAgICAgICAgIGxldCBwID0gbmV3IFBvaW50KHgsIHkpOwogICAgICAgICAgRHJhdy5jaXJjbGUoZHN0LCBwLCByLCBbMCwgMjU1LCAwXSwgbGluZVdpZHRoLCBjdi5MSU5FX0FBKTsKICAgICAgICAgIGNpcmNsZXMucHVzaChbeCwgeSwgcl0pOwogICAgICAgIH0KICAgICAgICBmb3IobGV0IFt4LCB5LCByXSBvZiBjaXJjbGVzMikgewogICAgICAgICAgbGV0IHAgPSBuZXcgUG9pbnQoeCwgeSk7CiAgICAgICAgICBEcmF3LmNpcmNsZShkc3QsIHAsIHIgKyAyLCBbMjU1LCAwLCAwXSwgbGluZVdpZHRoLCBjdi5MSU5FX0FBKTsKICAgICAgICAgIGNpcmNsZXMucHVzaChbeCwgeSwgcl0pOwogICAgICAgIH0KICAgICAgfQogICAgXSwKICAgIGkgPT4gewogICAgICBpZihmcmFtZVNob3cgPT0gaSkgewogICAgICAgIGxldCBwcm9jZXNzb3IgPSBwaXBlbGluZS5nZXRQcm9jZXNzb3IoaSk7CiAgICAgICAgbGV0IHBhcmFtcyA9IHByb2Nlc3NvclBhcmFtcy5nZXQocHJvY2Vzc29yKTsKICAgICAgICBwYXJhbUluZGV4ZXNbMF0gPSBwYXJhbU5hdi5pbmRleE9mKHBhcmFtc1swXSk7CiAgICAgICAgcGFyYW1JbmRleGVzWzFdID0gcGFyYW1OYXYuaW5kZXhPZihwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKTsKICAgICAgICBpZihwYXJhbU5hdi5pbmRleCA8IHBhcmFtSW5kZXhlc1swXSB8fCBwYXJhbU5hdi5pbmRleCA+IHBhcmFtSW5kZXhlc1sxXSkgcGFyYW1OYXYuY3VycmVudCA9IHBhcmFtc1swXTsKICAgICAgICBsZXQgbWF0ID0gcGlwZWxpbmUuZ2V0SW1hZ2UoaSk7CiAgICAgICAgaWYobWF0LmNoYW5uZWxzID09IDEpIGN2LmN2dENvbG9yKG1hdCwgb3V0cHV0TWF0LCBjdi5DT0xPUl9HUkFZMkJHUik7CiAgICAgICAgZWxzZSBpZihtYXQuY2hhbm5lbHMgPT0gNCkgY3YuY3Z0Q29sb3IobWF0LCBvdXRwdXRNYXQsIGN2LkNPTE9SX0JHUkEyQkdSKTsKICAgICAgICBlbHNlIG1hdC5jb3B5VG8ob3V0cHV0TWF0KTsKICAgICAgICBSZWRyYXdTdGF0dXMoKTsKICAgICAgICBSZWRyYXdXaW5kb3coKTsKICAgICAgfQogICAgfQogICk7CiAgZnVuY3Rpb24gUmVkcmF3U3RhdHVzKCkgewogICAgLy9jb25zb2xlLmxvZyhgcGlwZWxpbmUuaW1hZ2VzID1gLCBuZXcgTWFwKHBpcGVsaW5lLmltYWdlRW50cmllcygpKSk7CiAgICBsZXQgaSA9IHBpcGVsaW5lLmN1cnJlbnRQcm9jZXNzb3I7CiAgICBsZXQgcHJvY2Vzc29yID0gcGlwZWxpbmUuZ2V0UHJvY2Vzc29yKGkpOwogICAgbGV0IHBhcmFtcyA9IHByb2Nlc3NvclBhcmFtcy5nZXQocHJvY2Vzc29yKTsKICAgIGxldCBzcmVjdCA9IG5ldyBSZWN0KHN0YXR1c1JlY3Quc2l6ZSk7CgogICAgRHJhdy5yZWN0YW5nbGUoc3RhdHVzTWF0LCBzcmVjdCwgYmFja2dyb3VuZENvbG9yLCBjdi5GSUxMRUQsIHRydWUpOwogICAgRHJhdy5yZWN0YW5nbGUoc3RhdHVzTWF0LCBzcmVjdC5pbnNldCgzLCAwKSwgMCwgY3YuRklMTEVELCB0cnVlKTsKICAgIGNvbnN0IGluc3BlY3RPcHRpb25zID0gewogICAgICBjb2xvcnM6IHRydWUsCiAgICAgIGhpZGVLZXlzOiBbJ2NhbGxiYWNrJ10KICAgIH07CiAgICBsZXQgdGV4dCA9CiAgICAgIGAjJHtpfTogYCArCiAgICAgIHBpcGVsaW5lLm5hbWVzW2ldICsKICAgICAgYFxuXG5gICsKICAgICAgYHBhcmFtczpcbmAgKwogICAgICBwYXJhbXMKICAgICAgICAubWFwKChuYW1lLCBpZHgpID0+IHsKICAgICAgICAgIHJldHVybiBgICAke2lkeCArIHBhcmFtSW5kZXhlc1swXSA9PSBwYXJhbU5hdi5pbmRleCA/ICdceDFiWzE7MzFtJyA6ICcnfSR7bmFtZS5wYWRFbmQoMTMpfVx4MWJbMG0gICBceDFiWzE7MzZtJHsrcGFyYW1OYXYuZ2V0KG5hbWUpfVx4MWJbMG1cbmA7CiAgICAgICAgfSkKICAgICAgICAuam9pbignJyk7CiAgICBEcmF3VGV4dChzdGF0dXNNYXQodGV4dFJlY3QpLCB0ZXh0LCB0ZXh0Q29sb3IsIGZvbnRGYWNlLCBmb250U2l6ZSk7CiAgICBEcmF3VGV4dChzdGF0dXNNYXQoaGVscFJlY3QpLCAnPCBwcmV2LCA+IG5leHQsICsgaW5jcmVtZW50LCAtIGRlY3JlbWVudCwgREVMIHJlc2V0JywgdGV4dENvbG9yLCBmb250RmFjZSwgZm9udFNpemUpOwogIH0KICBmdW5jdGlvbiBSZWRyYXdXaW5kb3coKSB7CiAgICBsZXQgaSA9IHBpcGVsaW5lLmN1cnJlbnRQcm9jZXNzb3I7CiAgICBjdi52Y29uY2F0KFtvdXRwdXRNYXQsIHN0YXR1c01hdF0sIHNjcmVlbik7CiAgICBjdi5pbXNob3coJ291dHB1dCcsIHNjcmVlbik7CiAgICBjdi5yZXNpemVXaW5kb3coJ291dHB1dCcsIHNjcmVlblNpemUud2lkdGgsIHNjcmVlblNpemUuaGVpZ2h0KTsKICAgIGN2LnNldFdpbmRvd1RpdGxlKCdvdXRwdXQnLCBgIyR7aX06IGAgKyBwaXBlbGluZS5uYW1lc1tpXSk7CiAgfQogIGxldCBrZXk7CiAgbGV0IHBhcmFtQWNjdW11bGF0b3IgPSBwYXJhbU5hdi5zZXRDYWxsYmFjaygKICAgIG5ldyBBY2N1bXVsYXRvcigobmFtZSwgcGFyYW0pID0+IHsKICAgICAgLy8gY29uc29sZS5sb2coYHBhcmFtICcke25hbWV9JyBjYWxsYmFja2AsIHBhcmFtKTsKICAgIH0pCiAgKTsKICBsZXQgcHJvY2Vzc29yUGFyYW1zID0gVXRpbC53ZWFrTWFwcGVyKHByb2Nlc3NvciA9PiBbXSk7CiAgcGlwZWxpbmUuYmVmb3JlID0gKCkgPT4gcGFyYW1BY2N1bXVsYXRvci5jbGVhcigpOwogIHBpcGVsaW5lLmFmdGVyID0gKCkgPT4gcHJvY2Vzc29yUGFyYW1zLnNldChwaXBlbGluZS5nZXRQcm9jZXNzb3IoKSwgcGFyYW1BY2N1bXVsYXRvci5rZXlzKCkpOwogIHBpcGVsaW5lKCk7CiAgZGVsZXRlIHBpcGVsaW5lLmJlZm9yZTsKICBkZWxldGUgcGlwZWxpbmUuYWZ0ZXI7CiAgY29uc29sZS5sb2coYHBpcGVsaW5lLnJlY2FsYygke2ZyYW1lU2hvd30pYCwgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdykpOwogIHdoaWxlKHRydWUpIHsKICAgIGtleSA9IGN2LndhaXRLZXlFeCgtMSk7CiAgICBpZihrZXkgPT09ICdxJyB8fCBrZXkgPT09IDExMyB8fCBrZXkgPT09ICdceDFiJyB8fCBrZXkgPT09IDB4MTAwMDcxIHx8IGtleSA9PT0gLTEpIGJyZWFrOwogICAgc3dpdGNoIChrZXkgJiAweGZmZikgewogICAgICBjYXNlIDB4ZjA4IC8qIGJhY2tzcGFjZSAqLzoKICAgICAgY2FzZSAweDA4IC8qIGJhY2tzcGFjZSAqLzoKICAgICAgICBpZihmcmFtZVNob3cgPiAwKSB7CiAgICAgICAgICBmcmFtZVNob3ctLTsKICAgICAgICAgIHBpcGVsaW5lLnN0ZXAoLTEpOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgY2FzZSAweGY1MiAvKiB1cCAqLzoKICAgICAgY2FzZSAweDNjIC8qIDwgKi86CiAgICAgICAgcGFyYW1OYXYucHJldigpOwogICAgICAgIGlmKHBhcmFtSW5kZXhlc1swXSAhPSAtMSAmJiBwYXJhbU5hdi5pbmRleCA8IHBhcmFtSW5kZXhlc1swXSkgcGFyYW1OYXYuaW5kZXggPSBwYXJhbUluZGV4ZXNbMV07CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICMke3BhcmFtTmF2LmluZGV4fSAnJHtwYXJhbU5hdi5uYW1lfScgc2VsZWN0ZWQgKCR7K3BhcmFtTmF2LnBhcmFtfSlgKTsKICAgICAgICBSZWRyYXdTdGF0dXMoKTsKICAgICAgICBSZWRyYXdXaW5kb3coKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAweGY1NCAvKmRvd24gICovOgogICAgICBjYXNlIDB4M2UgLyogPiAqLzoKICAgICAgICBwYXJhbU5hdi5uZXh0KCk7CiAgICAgICAgaWYocGFyYW1JbmRleGVzWzFdICE9IC0xICYmIHBhcmFtTmF2LmluZGV4ID4gcGFyYW1JbmRleGVzWzFdKSBwYXJhbU5hdi5pbmRleCA9IHBhcmFtSW5kZXhlc1swXTsKICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW0gIyR7cGFyYW1OYXYuaW5kZXh9ICcke3BhcmFtTmF2Lm5hbWV9JyBzZWxlY3RlZCAoJHsrcGFyYW1OYXYucGFyYW19KWApOwogICAgICAgIFJlZHJhd1N0YXR1cygpOwogICAgICAgIFJlZHJhd1dpbmRvdygpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4ZjUzIC8qIHJpZ2h0ICovOgogICAgICBjYXNlIDB4MmIgLyogKyAqLzoKICAgICAgICBwYXJhbU5hdi5wYXJhbS5pbmNyZW1lbnQoKTsKICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW0gJHtwYXJhbU5hdi5uYW1lfTogJHsrcGFyYW1OYXYucGFyYW19YCk7CiAgICAgICAgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdyk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhmZmYgLyogREVMRVRFICovOgogICAgICBjYXNlIDB4OWYgLyogbnVtcGFkIERFTCAqLzoKICAgICAgY2FzZSAweGY5ZiAvKiBudW1wYWQgREVMICovOgogICAgICAgIHBhcmFtTmF2LnBhcmFtLnJlc2V0KCk7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7aW5zcGVjdChwYXJhbU5hdi5wYXJhbSl9YCk7CiAgICAgICAgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdyk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhmNTEgLyogbGVmdCAqLzoKICAgICAgY2FzZSAweDJkIC8qIC0gKi86CiAgICAgIGNhc2UgMHhhZCAvKiBudW1wYWQgLSAqLzoKICAgICAgY2FzZSAweGZhZCAvKiBudW1wYWQgLSAqLzoKICAgICAgY2FzZSAweDJmYWQgLyogbnVtcGFkIC0gKi86CiAgICAgICAgcGFyYW1OYXYucGFyYW0uZGVjcmVtZW50KCk7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7K3BhcmFtTmF2LnBhcmFtfWApOwogICAgICAgIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4MzE6IC8qIDEgKi8KICAgICAgY2FzZSAweDMyOiAvKiAyICovCiAgICAgIGNhc2UgMHgzMzogLyogMyAqLwogICAgICBjYXNlIDB4MzQ6IC8qIDQgKi8KICAgICAgY2FzZSAweDM1OiAvKiA1ICovCiAgICAgIGNhc2UgMHgzNjogLyogNiAqLwogICAgICBjYXNlIDB4Mzc6IC8qIDcgKi8KICAgICAgY2FzZSAweDM4OiAvKiA4ICovCiAgICAgIGNhc2UgMHgzOTogLyogOSAqLwogICAgICBjYXNlIDB4MzAgLyogMCAqLzoKICAgICAgICBsZXQgdiA9IGtleSAmIDB4ZiB8fCAxMDsKICAgICAgICBwYXJhbU5hdi5wYXJhbS5hbHBoYSA9IHYgLyAxMDsKICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW0gJHtwYXJhbU5hdi5uYW1lfTogJHsrcGFyYW1OYXYucGFyYW19YCk7CiAgICAgICAgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdyk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhhNyAvKiDCpyAqLzoKICAgICAgICBwYXJhbU5hdi5wYXJhbS5hbHBoYSA9IDA7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7K3BhcmFtTmF2LnBhcmFtfWApOwogICAgICAgIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4MjA6CiAgICAgICAgZnJhbWVTaG93ID0gVXRpbC5tb2QoZnJhbWVTaG93ICsgMSwgcGlwZWxpbmUuc2l6ZSk7CiAgICAgICAgcGlwZWxpbmUuc3RlcCgpOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OiB7CiAgICAgICAgaWYoa2V5ICE9PSAtMSkgY29uc29sZS5sb2coJ2tleTonLCBUb0hleChrZXkpKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogIH0KICBTYXZlQ29uZmlnKHsgZnJhbWVTaG93LCBwYXJhbUluZGV4OiBwYXJhbU5hdi5pbmRleCwgLi4ucGFyYW1zIH0pOwogIGNvbnNvbGUubG9nKCdFWElUJyk7Cn0KdHJ5IHsKICBtYWluKC4uLnNjcmlwdEFyZ3Muc2xpY2UoMSkpOwp9IGNhdGNoKGVycm9yKSB7CiAgY29uc29sZS5sb2coYEZBSUw6ICR7ZXJyb3IubWVzc2FnZX1cbiR7ZXJyb3Iuc3RhY2t9YCk7CiAgc3RkLmV4aXQoMSk7Cn0gZmluYWxseSB7CiAgY29uc29sZS5sb2coJ1NVQ0NFU1MnKTsKfQoAAAAAAAAAAHpQAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOIFAAAAAAAAAQYAAAAAAAAAAAAAAADwvw"
				],
				[
					162,
					1,
					"insert",
					{
						"characters": " "
					},
					"AgAAAGUFAAAAAAAAZgUAAAAAAAAAAAAAZgUAAAAAAABmBQAAAAAAAJ4AAAAgIC8qIHNpemUgPSBuZXcgU2l6ZSh3aW5kb3cuc2l6ZSk7CiAgcG9zaXRpb24gPSBuZXcgUG9pbnQod2luZG93LnBvc2l0aW9uKTsqLwogIC8qIGNvbnN0IHJlY3QgPSBuZXcgUmVjdCguLi5wb3NpdGlvbiwgLi4uc2l6ZSk7CiAgY29uc29sZS5sb2coYEdMRldgLCByZWN0KTsqLw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAGUFAAAAAAAAAwYAAAAAAAAAAAAAAADwvw"
				],
				[
					177,
					1,
					"toggle_comment",
					{
						"block": true
					},
					"AgAAAOoSAAAAAAAA7BIAAAAAAAAAAAAAqxIAAAAAAACtEgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKsSAAAAAAAA6hIAAAAAAAAAAAAAAADwvw"
				],
				[
					191,
					1,
					"revert",
					null,
					"CgAAAAAAAAAAAAAAAAAAAAAAAADiTwAAaW1wb3J0IHsgUG9pbnQsIFNpemUsIFJlY3QsIE1hdCwgVU1hdCwgTGluZSwgQ0xBSEUsIFRpY2tNZXRlciwgRHJhdywgQ29udG91ciB9IGZyb20gJ29wZW5jdic7CmltcG9ydCAqIGFzIGN2IGZyb20gJ29wZW5jdic7CmltcG9ydCBmcyBmcm9tICdmcyc7CmltcG9ydCBDb25zb2xlIGZyb20gJ2NvbnNvbGUnOwppbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnOwppbXBvcnQgeyBSR0JBLCBIU0xBIH0gZnJvbSAnLi9saWIvY29sb3IuanMnOwppbXBvcnQgVXRpbCBmcm9tICcuL2xpYi91dGlsLmpzJzsKaW1wb3J0IHsgTnVtZXJpY1BhcmFtLCBFbnVtUGFyYW0sIFBhcmFtTmF2aWdhdG9yIH0gZnJvbSAnLi9wYXJhbS5qcyc7CmltcG9ydCB7IG1lbW9pemUsIHJhbmdlIH0gZnJvbSAnLi9saWIvbWlzYy5qcyc7CmltcG9ydCB7IFBpcGVsaW5lLCBQcm9jZXNzb3IgfSBmcm9tICcuL3Fqcy1vcGVuY3YvanMvY3ZQaXBlbGluZS5qcyc7CmltcG9ydCB7IFdpbmRvdywgTW91c2VGbGFncywgTW91c2VFdmVudHMsIE1vdXNlLCBUZXh0U3R5bGUsIERyYXdUZXh0IH0gZnJvbSAnLi9xanMtb3BlbmN2L2pzL2N2SGlnaEdVSS5qcyc7CmltcG9ydCAqIGFzIG52ZyBmcm9tICduYW5vdmcnOwppbXBvcnQgKiBhcyBnbGZ3IGZyb20gJ2dsZncnOwoKbGV0IGJhc2VuYW1lID0gVXRpbC5nZXRBcmd2KClbMV0ucmVwbGFjZSgvXC5qcyQvLCAnJyk7CmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJOwoKZnVuY3Rpb24gR0xGVyguLi5hcmdzKSB7CiAgY29uc3QgeyBHYW1tYVJhbXAsIE1vbml0b3IsIFBvc2l0aW9uLCBTY2FsZSwgU2l6ZSwgVmlkZW9Nb2RlLCBXaW5kb3csIFdvcmtBcmVhIH0gPSBnbGZ3OwogIGxldCByZXNvbHV0aW9uLCB3aW5kb3c7CgogIHJlc29sdXRpb24gPSBuZXcgU2l6ZSguLi5hcmdzKTsKICBjb25zdCBoaW50cyA9IFsKICAgIFtnbGZ3LkNPTlRFWFRfVkVSU0lPTl9NQUpPUiwgM10sCiAgICBbZ2xmdy5DT05URVhUX1ZFUlNJT05fTUlOT1IsIDJdLAogICAgW2dsZncuT1BFTkdMX1BST0ZJTEUsIGdsZncuT1BFTkdMX0NPUkVfUFJPRklMRV0sCiAgICBbZ2xmdy5PUEVOR0xfRk9SV0FSRF9DT01QQVQsIHRydWVdLAogICAgW2dsZncuUkVTSVpBQkxFLCBmYWxzZV0sCiAgICBbZ2xmdy5TQU1QTEVTLCA0XQogIF07CgogIGZvcihsZXQgW3Byb3AsIHZhbHVlXSBvZiBoaW50cykgV2luZG93LmhpbnQocHJvcCwgdmFsdWUpOwoKICB3aW5kb3cgPSBuZXcgV2luZG93KHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0LCAnT3BlbkdMJyk7CiAgZ2xmdy5jb250ZXh0LmN1cnJlbnQgPSB3aW5kb3c7CiAgdGhpcy5jb250ZXh0ID0gZ2xmdy5jb250ZXh0OwoKICBjb25zdCB7IHNpemUsIHBvc2l0aW9uIH0gPSB3aW5kb3c7CiAKICBudmcuQ3JlYXRlR0wzKG52Zy5TVEVOQ0lMX1NUUk9LRVMgfCBudmcuQU5USUFMSUFTIHwgbnZnLkRFQlVHKTsKICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLCB7IHJlc29sdXRpb24sIHdpbmRvdywgc2l6ZSwgcG9zaXRpb24gfSk7Cn0KCmZ1bmN0aW9uIFdyaXRlSW1hZ2UobmFtZSwgbWF0KSB7CiAgY3YuaW13cml0ZShuYW1lLCBtYXQpOwogIGNvbnNvbGUubG9nKCJXcm90ZSAnIiArIG5hbWUgKyAiJyAoIiArIG1hdC5zaXplICsgJykuJyk7Cn0KCmZ1bmN0aW9uIFNhdmVDb25maWcoY29uZmlnT2JqKSB7CiAgY29uZmlnT2JqID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNvbmZpZ09iaikubWFwKChbaywgdl0pID0+IFtrLCArdl0pKTsKICBsZXQgZmlsZSA9IHN0ZC5vcGVuKGJhc2VuYW1lICsgJy5jb25maWcuanNvbicsICd3K2InKTsKICBmaWxlLnB1dHMoSlNPTi5zdHJpbmdpZnkoY29uZmlnT2JqLCBudWxsLCAyKSArICdcbicpOwogIGZpbGUuY2xvc2UoKTsKICBjb25zb2xlLmxvZygiU2F2ZWQgY29uZmlnIHRvICciICsgYmFzZW5hbWUgKyAnLmNvbmZpZy5qc29uJyArICInIiwgaW5zcGVjdChjb25maWdPYmosIHsgY29tcGFjdDogZmFsc2UgfSkpOwp9CgpmdW5jdGlvbiBMb2FkQ29uZmlnKCkgewogIGxldCBzdHIgPSBzdGQubG9hZEZpbGUoYmFzZW5hbWUgKyAnLmNvbmZpZy5qc29uJyk7CiAgbGV0IGNvbmZpZ09iaiA9IEpTT04ucGFyc2Uoc3RyIHx8ICd7fScpOwogIGNvbmZpZ09iaiA9IE9iamVjdC5mcm9tRW50cmllcygKICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZ09iaikKICAgICAgLm1hcCgoW2ssIHZdKSA9PiBbaywgK3ZdKQogICAgICAuZmlsdGVyKChbaywgdl0pID0+ICFpc05hTih2KSkKICApOwogIGNvbnNvbGUubG9nKCdMb2FkQ29uZmlnOicsIGluc3BlY3QoY29uZmlnT2JqLCB7IGNvbXBhY3Q6IGZhbHNlIH0pKTsKICByZXR1cm4gY29uZmlnT2JqOwp9CgpmdW5jdGlvbiBJbnNwZWN0TWF0KG1hdCkgewogIGNvbnN0IHsgY2hhbm5lbHMsIGRlcHRoLCB0eXBlLCBjb2xzLCByb3dzIH0gPSBtYXQ7CiAgcmV0dXJuIGluc3BlY3QoeyBjaGFubmVscywgZGVwdGgsIHR5cGUsIGNvbHMsIHJvd3MgfSk7Cn0KCmZ1bmN0aW9uIFRvSGV4KG51bWJlcikgewogIGlmKG51bWJlciA8IDApIG51bWJlciA9IDB4ZmZmZmZmZmYgKyBudW1iZXIgKyAxOwogIHJldHVybiAnMHgnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTsKfQoKZnVuY3Rpb24gQWNjdW11bGF0b3IoY2FsbGJhY2spIHsKICBsZXQgc2VsZjsKICBsZXQgYWNjdSA9IHt9OwogIHNlbGYgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkgewogICAgaWYobmFtZSBpbiBhY2N1KSByZXR1cm47CiAgICBhY2N1W25hbWVdID0gdmFsdWU7CiAgICBpZih0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sobmFtZSwgdmFsdWUpOwogIH07CiAgT2JqZWN0LmFzc2lnbihzZWxmLCB7CiAgICBhY2N1LAogICAgZW50cmllcygpIHsKICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGFjY3UpOwogICAgfSwKICAgIHZhbHVlcygpIHsKICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYWNjdSk7CiAgICB9LAogICAga2V5cygpIHsKICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFjY3UpOwogICAgfSwKICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgICAgZm9yKGxldCBrZXkgaW4gYWNjdSkgeWllbGQgW2tleSwgYWNjdVtrZXldXTsKICAgIH0sCiAgICBjbGVhcigpIHsKICAgICAgZm9yKGxldCBrZXkgaW4gYWNjdSkgZGVsZXRlIGFjY3Vba2V5XTsKICAgIH0KICB9KTsKICByZXR1cm4gc2VsZjsKfQoKZnVuY3Rpb24gbWFpbiguLi5hcmdzKSB7CiAgZ2xvYmFsVGhpcy5jb25zb2xlID0gbmV3IENvbnNvbGUoewogICAgaW5zcGVjdE9wdGlvbnM6IHsKICAgICAgbWF4U3RyaW5nTGVuZ3RoOiAyMDAsCgogICAgICBicmVha0xlbmd0aDogMTAwLAogICAgICBjb21wYWN0OiAwLAogICAgICBkZXB0aDogSW5maW5pdHkKICAgIH0KICB9KTsKICBsZXQgcnVubmluZyA9IHRydWU7CgogIGNvbnNvbGUubG9nKCdVdGlsLmdldE1ldGhvZE5hbWVzKGN2KScsIFV0aWwuZ2V0TWV0aG9kTmFtZXMoY3YsIEluZmluaXR5LCAwKSk7CiAgY29uc29sZS5sb2coJ2N2LkhvdWdoTGluZXMnLCBjdi5Ib3VnaExpbmVzKTsKCiAgbGV0IGxpbmUgPSBuZXcgTGluZSgwLCAwLCA1MCwgNTApOwogIGNvbnNvbGUubG9nKCdsaW5lJywgbGluZSk7CiAgbGV0IGNsYWhlID0gbmV3IENMQUhFKCk7CiAgY29uc29sZS5sb2coJ2NsYWhlJywgY2xhaGUpOwogIGN2Lm5hbWVkV2luZG93KCdvdXRwdXQnLCBjdi5XSU5ET1dfTk9STUFMIHwgY3YuV0lORE9XX0tFRVBSQVRJTyk7CiAgbGV0IHRyYWNrYmFyID0gJyc7CiAgbGV0IGZpbGUgPSBhcmdzWzBdIHx8ICcuLi9hbi10cm9uaWNzL2ltYWdlcy9mbS80dHIuanBnJzsKICBsZXQgaW1hZ2UgPSBjdi5pbXJlYWQoZmlsZSk7CiAgbGV0IHJlc29sdXRpb24gPSBpbWFnZS5zaXplOwogIGxldCBzY2FsZWQ7CiAgY29uc29sZS5sb2coJ1N5bWJvbC5pbnNwZWN0JywgU3ltYm9sLmluc3BlY3QpOwogIGNvbnNvbGUubG9nKCdyZXNvbHV0aW9uJywgcmVzb2x1dGlvbik7CiAgaWYocmVzb2x1dGlvbi53aWR0aCA+IDEyMDApIHsKICAgIGxldCBmID0gMTAyNCAvIHJlc29sdXRpb24ud2lkdGg7CiAgICBzY2FsZWQgPSBuZXcgU2l6ZShyZXNvbHV0aW9uLndpZHRoICogZiwgcmVzb2x1dGlvbi5oZWlnaHQgKiBmKTsKICB9IGVsc2UgewogICAgc2NhbGVkID0gbmV3IFNpemUocmVzb2x1dGlvbik7CiAgfQoKICBsZXQgb3V0cHV0UmVjdCA9IG5ldyBSZWN0KDAsIDAsIHJlc29sdXRpb24ud2lkdGgsIHJlc29sdXRpb24uaGVpZ2h0KTsKICBsZXQgb3V0cHV0TWF0ID0gbmV3IE1hdChvdXRwdXRSZWN0LnNpemUsIGN2LkNWXzhVQzMpOwogIGxldCBzdGF0dXNSZWN0ID0gbmV3IFJlY3QoMCwgcmVzb2x1dGlvbi5oZWlnaHQsIHJlc29sdXRpb24ud2lkdGgsIDIwMCk7CiAgbGV0IHN0YXR1c01hdCA9IG5ldyBNYXQoc3RhdHVzUmVjdC5zaXplLCBjdi5DVl84VUMzKTsKICBjb25zb2xlLmxvZygnc3RhdHVzUmVjdDonLCBzdGF0dXNSZWN0KTsKICBsZXQgW3RleHRSZWN0LCBoZWxwUmVjdF0gPSBuZXcgUmVjdChzdGF0dXNSZWN0LnNpemUpLmluc2V0KDUpLnZzcGxpdCgtMjApOwogIGxldCBzY3JlZW5TaXplID0gbmV3IFNpemUocmVzb2x1dGlvbi53aWR0aCwgcmVzb2x1dGlvbi5oZWlnaHQgKyAyMDApOwogIGNvbnNvbGUubG9nKCdzdGF0dXNSZWN0Jywgc3RhdHVzUmVjdCk7CiAgY29uc29sZS5sb2coJ3RleHRSZWN0JywgdGV4dFJlY3QpOwogIGNvbnNvbGUubG9nKCdoZWxwUmVjdDonLCBoZWxwUmVjdCk7CiAgbGV0IHNjcmVlbiA9IG5ldyBNYXQoc2NyZWVuU2l6ZSwgY3YuQ1ZfOFVDMyk7CgogLyogbGV0IGdmeCA9IG5ldyBHTEZXKC4uLnNjcmVlblNpemUpOwogIGNvbnNvbGUubG9nKCdnZng6JywgZ2Z4KTsqLwoKICBjdi5pbXNob3coJ291dHB1dCcsIHNjcmVlbik7CiAgY3YubW92ZVdpbmRvdygnb3V0cHV0JywgMCwgMCk7CiAgY3YucmVzaXplV2luZG93KCdvdXRwdXQnLCBzY3JlZW5TaXplLndpZHRoKTsKCiAgY3Yuc2V0TW91c2VDYWxsYmFjaygnb3V0cHV0JywgKGV2ZW50LCB4LCB5LCBmbGFncykgPT4gewogICAgaWYoZmxhZ3MgPT0gY3YuRVZFTlRfRkxBR19MQlVUVE9OIHx8IGV2ZW50ID09IGN2LkVWRU5UX0xCVVRUT05ET1dOKSBjb25zb2xlLmxvZyhgY2xpY2sgJHt4fSwke3l9YCk7CiAgICBlbHNlIGlmKGV2ZW50KSBjb25zb2xlLmxvZygnTW91c2VDYWxsYmFjaycsIHsgZXZlbnQsIHgsIHksIGZsYWdzIH0pOwogIH0pOwoKICBsZXQgYmFja2dyb3VuZENvbG9yID0gMHhkMGQwZDA7CiAgbGV0IHNoYWRvd0NvbG9yID0gMHg0MDQwNDA7CiAgbGV0IHRleHRDb2xvciA9IDB4ZDNkN2NmOwogIGxldCBmb250cyA9IFsnL2hvbWUvcm9tYW4vLmZvbnRzL2dvdGhpYy50dGYnLCAnL2hvbWUvcm9tYW4vLmZvbnRzL2dvdGhpY2IudHRmJywgJy91c3Ivc2hhcmUvZm9udHMvdHJ1ZXR5cGUvdWJ1bnR1L1VidW50dU1vbm8tUi50dGYnXTsKICBsZXQgZm9udEZhY2UgPSBmb250c1syXTsKICBsZXQgZm9udFNpemUgPSAxNDsKICBmb250cy5mb3JFYWNoKGZpbGUgPT4gRHJhdy5sb2FkRm9udChmaWxlKSk7CiAgbGV0IGNvbmZpZyA9IExvYWRDb25maWcoKTsKICBsZXQgeyBmcmFtZVNob3cgPSAxLCBwYXJhbUluZGV4ID0gMCB9ID0gY29uZmlnOwogIGxldCBwYXJhbXMgPSB7CiAgICB0aHJlczogbmV3IE51bWVyaWNQYXJhbShjb25maWcudGhyZXMgfHwgMjI5LCAwLCAyNTUpLAogICAgdHlwZTogbmV3IE51bWVyaWNQYXJhbShjb25maWcudHlwZSB8fCBjdi5USFJFU0hfQklOQVJZX0lOViwgMCwgNCksCiAgICBibHVyOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5ibHVyIHx8IDEsIDEsIDEwLCAyKSwKICAgIGtlcm5lbF9zaXplOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5rZXJuZWxfc2l6ZSB8fCAwLCAwLCA5KSwKICAgIHJobzogbmV3IE51bWVyaWNQYXJhbShjb25maWcucmhvIHx8IDEsIDEsIDMwLCAwLjI1KSwKICAgIHRoZXRhOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy50aGV0YSB8fCAxLCAwLCA5MCksCiAgICB0aHJlc2hvbGQ6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLnRocmVzaG9sZCB8fCAyNSwgMCwgNTApLAogICAgbWluTGluZUxlbmd0aDogbmV3IE51bWVyaWNQYXJhbShjb25maWcubWluTGluZUxlbmd0aCB8fCAzLCAwLCAzMCksCiAgICBtYXhMaW5lR2FwOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5tYXhMaW5lR2FwIHx8IDQsIDAsIDIwKSwKICAgIGRwOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5kcCB8fCAyLCAwLCAxMCwgMC4xKSwKICAgIG1pbkRpc3Q6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLm1pbkRpc3QgfHwgMTAsIDEsIDEwMDApLAogICAgcGFyYW0xOiBuZXcgTnVtZXJpY1BhcmFtKGNvbmZpZy5wYXJhbTEgfHwgMjAwLCAxLCAxMDAwKSwKICAgIHBhcmFtMjogbmV3IE51bWVyaWNQYXJhbShjb25maWcucGFyYW0yIHx8IDEwMCwgMSwgMTAwKSwKICAgIG1pblJhZGl1czogbmV3IE51bWVyaWNQYXJhbShjb25maWcubWluUmFkaXVzIHx8IDAsIDEsIDI1MCksCiAgICBtYXhSYWRpdXM6IG5ldyBOdW1lcmljUGFyYW0oY29uZmlnLm1heFJhZGl1cyB8fCAyMDAsIDEsIDEwMDApCiAgfTsKICBsZXQgY29udG91cnMgPSBbXTsKICBsZXQgbGluZVdpZHRoID0gMTsKICBsZXQgbGluZXMgPSBbXTsKICBsZXQgY2lyY2xlcyA9IFtdOwogIGxldCBwYXJhbU5hdiA9IG5ldyBQYXJhbU5hdmlnYXRvcihwYXJhbXMsIHBhcmFtSW5kZXgpOwogIGxldCBwYXJhbUluZGV4ZXMgPSBbLTEsIC0xXTsKICBsZXQgcGFsZXR0ZSA9IG5ldyBBcnJheSgpOwogIGNvbnN0IGJsYWNrID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4ZmZdOwogIGZvcihsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHBhbGV0dGVbaV0gPSBbaSAmIDB4MDQgPyAweGZmIDogMHgwMCwgaSAmIDB4MDIgPyAweGZmIDogMHgwMCwgaSAmIDB4MDEgPyAweGZmIDogMHgwMCwgMHhmZl07CiAgcGFsZXR0ZVsyXSA9IFsweDYwLCAweDYwLCAweDYwLCAweGZmXTsKICBwYWxldHRlWzNdID0gWzB4ZmYsIDB4ZmYsIDB4MCwgMHhmZl07CiAgZm9yKGxldCBpID0gODsgaSA8IDE2OyBpKyspIHBhbGV0dGVbaV0gPSBibGFjazsKICBsZXQgcGlwZWxpbmUgPSBuZXcgUGlwZWxpbmUoCiAgICBbCiAgICAgIGZ1bmN0aW9uIEFjcXVpcmVGcmFtZShzcmMsIGRzdCkgewogICAgICAgIGltYWdlID0gY3YuaW1yZWFkKGZpbGUpOwogICAgICAgIGltYWdlLmNvcHlUbyhkc3QpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBHcmF5c2NhbGUoc3JjLCBkc3QpIHsKICAgICAgICBsZXQgY2hhbm5lbHMgPSBbXTsKICAgICAgICBjdi5jdnRDb2xvcihzcmMsIGRzdCwgY3YuQ09MT1JfQkdSMkxhYik7CiAgICAgICAgY3Yuc3BsaXQoZHN0LCBjaGFubmVscyk7CiAgICAgICAgY2hhbm5lbHNbMF0uY29weVRvKGRzdCk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIEJsdXIoc3JjLCBkc3QpIHsKICAgICAgICBjdi5HYXVzc2lhbkJsdXIoc3JjLCBkc3QsIFsrcGFyYW1zLmJsdXIsICtwYXJhbXMuYmx1cl0sIDAsIDAsIGN2LkJPUkRFUl9SRVBMSUNBVEUpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBUaHJlc2hvbGQoc3JjLCBkc3QpIHsKICAgICAgICBjdi50aHJlc2hvbGQoc3JjLCBkc3QsICtwYXJhbXMudGhyZXMsIDI1NSwgK3BhcmFtcy50eXBlKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gTW9ycGhvbG9neShzcmMsIGRzdCkgewogICAgICAgIGxldCBzdHJ1Y3R1cmluZ0VsZW1lbnQgPSBjdi5nZXRTdHJ1Y3R1cmluZ0VsZW1lbnQoY3YuTU9SUEhfQ1JPU1MsIG5ldyBTaXplKCtwYXJhbXMua2VybmVsX3NpemUgKiAyICsgMSwgK3BhcmFtcy5rZXJuZWxfc2l6ZSAqIDIgKyAxKSk7CiAgICAgICAgc3JjLmNvcHlUbyhkc3QpOwogICAgICAgIGN2Lm1vcnBob2xvZ3lFeChkc3QsIGRzdCwgY3YuTU9SUEhfRVJPREUsIHN0cnVjdHVyaW5nRWxlbWVudCk7CiAgICAgICAgZHN0LnhvcihbMjU1LCAyNTUsIDI1NSwgMF0sIGRzdCk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIFNrZWxldG9uaXphdGlvbihzcmMsIGRzdCkgewogICAgICAgIGN2LnNrZWxldG9uaXphdGlvbihzcmMsIGRzdCk7CgogICAgICAgIC8vY3YudHJhY2VTa2VsZXRvbihkc3QsIGNvbnRvdXJzKTsKICAgICAgICBjb250b3VycyA9IGN2LnRyYWNlU2tlbGV0b24oZHN0KTsKCiAgICAgICAgLy8gY29udG91cnMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7CiAgICAgICAgLy8vKiBwcmV0dGllci1pZ25vcmUgKi8gY29uc29sZS5sb2coJ1NrZWxldG9uaXphdGlvbicsIGNvbnNvbGUuY29uZmlnKHsgY29tcGFjdDogMSwgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5IH0pLCBjb250b3Vycy5tYXAoYyA9PiBjLnRvU3RyaW5nKCkpKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gU2hvd1RyYWNlKHNyYywgZHN0KSB7CiAgICAgICAgY3YuY3Z0Q29sb3Ioc3JjLCBkc3QsIGN2LkNPTE9SX0dSQVkyQkdSKTsKICAgICAgICBkc3QuY2xlYXIoKTsKCiAgICAgICAgLy9sZXQgcGFsZXR0ZT0gcmFuZ2UoMCwzNTksIDM2MC9jb250b3Vycy5sZW5ndGgpLm1hcChodWUgPT4gbmV3IEhTTEEoaHVlLCAxMDAsNTAsMS4wKSk7CiAgICAgICAgbGV0IHBhbGV0dGUgPSByYW5nZSgwLCBjb250b3Vycy5sZW5ndGggLSAxKQogICAgICAgICAgLm1hcChuID0+IFtNYXRoLmZsb29yKG4gLyAzKSwgKChuICUgMykgLSAxKSAqIDI1ICsgNTBdKQogICAgICAgICAgLm1hcCgoW24sIG1dKSA9PiBbKE1hdGguZmxvb3IobiAvIDMpICogMzU5ICogOSkgLyAoY29udG91cnMubGVuZ3RoIC0gMSksICgobiAlIDMpIC0gMSkgKiAyNSArIDUwLCBtXSkKICAgICAgICAgIC5tYXAoKFtoLCBzLCBsXSkgPT4gbmV3IEhTTEEoaCwgcywgbCwgMS4wKSk7CgogICAgICAgIHBhbGV0dGUgPSBwYWxldHRlLm1hcChjID0+IGMudG9CR1JBKCkpOwoKICAgICAgICAvLyBjb25zb2xlLmxvZygnU2hvd1RyYWNlJywgY29uc29sZS5jb25maWcoeyBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksIGRlcHRoOiA0IH0pLCB7IHBhbGV0dGUgfSk7CiAgICAgICAgLy8gY29uc29sZS5sb2coJ0RyYXcuY29udG91cnMnLCBEcmF3LmNvbnRvdXJzKTsKCiAgICAgICAgLy8gIGNvbnRvdXJzID0gY29udG91cnMuZmlsdGVyKGMgPT4gYy5sZW5ndGg8PSAyKTsKCiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGNvbnRvdXJzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBjb2xvciA9IHBhbGV0dGVbaV07CiAgICAgICAgICAvL0RyYXcuY29udG91cnMoZHN0LCBjb250b3VycywgaSwgY29sb3IsIDEpOwogICAgICAgICAgRHJhdy5wb2x5bGluZXMoZHN0LCBbY29udG91cnNbaV1dLCBmYWxzZSwgY29sb3IsIDEpOwogICAgICAgIH0KCiAgICAgICAgY29uc29sZS5sb2coJ1Nob3dUcmFjZScsIGNvbnNvbGUuY29uZmlnKHsgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5IH0pLCB7IHNyYywgZHN0IH0pOwogICAgICB9LAogICAgICBmdW5jdGlvbiBMaW5lU2VnbWVudERldGVjdG9yKHNyYywgZHN0KSB7CiAgICAgICAgbGV0IGxpbmVzID0gW107CiAgICAgICAgbGV0IHdpZHRoID0gW10sCiAgICAgICAgICBwcmVjID0gW10sCiAgICAgICAgICBuZmEgPSBbXTsKICAgICAgICBjdi5saW5lU2VnbWVudERldGVjdG9yKHRoaXMub3V0cHV0T2YoJ1NrZWxldG9uaXphdGlvbicpLCBsaW5lcywgd2lkdGgsIHByZWMsIG5mYSk7CiAgICAgICAgLyogbGV0IGludGVyc2VjdGlvbk1hdHJpeCA9IFtdOwogICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgaW50ZXJzZWN0aW9uTWF0cml4W2ldID0gW107CiAgICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgbGV0IHB0ID0gW107CiAgICAgICAgICAgIGxldCBiID0gaSA9PSBqID8gbnVsbCA6IGxpbmVzW2ldLmludGVyc2VjdChsaW5lc1tqXSwgcHQpOwogICAgICAgICAgICBpbnRlcnNlY3Rpb25NYXRyaXhbaV1bal0gPSBiICYmIHB0OwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBjb25zb2xlLmxvZygnTGluZVNlZ21lbnREZXRlY3RvcicsIHsgaW50ZXJzZWN0aW9uTWF0cml4IH0pOwogICAgICAgIGxldCBsaW5lTWFwID0gbmV3IE1hcCgpOwogICAgICAgIGxldCBsaW5lTWFwcGVyID0gbWVtb2l6ZSgoKSA9PiBbXSwgbGluZU1hcCk7CiAgICAgICAgZm9yKGxldCBsaW5lIG9mIGxpbmVzKSB7CiAgICAgICAgICBsZXQgeyBhLCBiIH0gPSBsaW5lOwogICAgICAgICAgbGluZU1hcHBlcihhICsgJycpLnB1c2gobGluZSk7CiAgICAgICAgICBsaW5lTWFwcGVyKGIgKyAnJykucHVzaChsaW5lKTsKICAgICAgICB9CiAgICAgICAgY29uc29sZS5sb2coJ0xpbmVTZWdtZW50RGV0ZWN0b3InLCBjb25zb2xlLmNvbmZpZyh7IGNvbXBhY3Q6IDMgfSksIFsuLi5saW5lTWFwXS5tYXAoKFtuYW1lLCBhcnJdKSA9PiBbbmFtZSwgYXJyLmxlbmd0aCwgYXJyLm1hcChsaW5lID0+IFtsaW5lICsgJycsIGxpbmUubGVuZ3RoXSldKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSkgKTsKICAgICAgICAqLwogICAgICAgIHNyYy5jb3B5VG8oZHN0KTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gUGl4ZWxOZWlnaGJvcmhvb2Qoc3JjLCBkc3QpIHsKICAgICAgICBsZXQgbmVpZ2hib3Job29kID0gbmV3IE1hdChzcmMuc2l6ZSwgY3YuQ1ZfOFVDMSk7CiAgICAgICAgY3YucGl4ZWxOZWlnaGJvcmhvb2Qoc3JjLCBuZWlnaGJvcmhvb2QpOwogICAgICAgIGxldCBlbmRwb2ludHMgPSBjdi5waXhlbEZpbmRWYWx1ZShzcmMsIDEpOwogICAgICAgIGNvbnNvbGUubG9nKCdlbmRwb2ludHMnLCBlbmRwb2ludHMpOwogICAgICAgIGxldCBsaW5lcG9pbnRzID0gY3YucGl4ZWxGaW5kVmFsdWUoc3JjLCAyKTsKICAgICAgICBjb25zb2xlLmxvZygnbGluZXBvaW50cycsIGxpbmVwb2ludHMpOwogICAgICAgIGN2Lmltd3JpdGUoJ25laWdoYm9yaG9vZC5wbmcnLCBuZWlnaGJvcmhvb2QsIHBhbGV0dGUpOwogICAgICAgIGxldCBpbSA9IGN2LmltcmVhZCgnbmVpZ2hib3Job29kLnBuZycpOwogICAgICAgIGltLmNvcHlUbyhkc3QpOwogICAgICB9LAogICAgICBmdW5jdGlvbiBIb3VnaExpbmVzUChzcmMsIGRzdCkgewogICAgICAgIGNvbnN0IHNrZWwgPSB0aGlzLm91dHB1dE9mKCdTa2VsZXRvbml6YXRpb24nKTsKICAgICAgICBjb25zdCBtb3JwaG8gPSB0aGlzLm91dHB1dE9mKCdNb3JwaG9sb2d5Jyk7CiAgICAgICAgbGV0IG91dHB1dCA9IG5ldyBNYXQoKTsKICAgICAgICBpZihza2VsLmNoYW5uZWxzID4gMSkgY3YuY3Z0Q29sb3Ioc2tlbCwgc2tlbCwgY3YuQ09MT1JfQkdSMkdSQVkpOwogICAgICAgIGlmKG1vcnBoby5jaGFubmVscyA+IDEpIGN2LmN2dENvbG9yKG1vcnBobywgbW9ycGhvLCBjdi5DT0xPUl9CR1IyR1JBWSk7CiAgICAgICAgY3YuSG91Z2hMaW5lc1Aoc2tlbCwgb3V0cHV0LCArcGFyYW1zLnJobywgKE1hdGguUEkgKiAoK3BhcmFtcy50aGV0YSB8fCAxKSkgLyAxODAsICtwYXJhbXMudGhyZXNob2xkLCArcGFyYW1zLm1pbkxpbmVMZW5ndGgsICtwYXJhbXMubWF4TGluZUdhcCk7CiAgICAgICAgY3YuY3Z0Q29sb3Ioc2tlbCwgZHN0LCBjdi5DT0xPUl9HUkFZMkJHUik7CiAgICAgICAgbGV0IGkgPSAwOwogICAgICAgIGxpbmVzLnNwbGljZSgwLCBsaW5lcy5sZW5ndGgpOwogICAgICAgIGZvcihsZXQgZWxlbSBvZiBvdXRwdXQudmFsdWVzKCkpIHsKICAgICAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZShlbGVtKTsKICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7CiAgICAgICAgICBEcmF3LmxpbmUoZHN0LCAuLi5saW5lLnRvUG9pbnRzKCksIFsyNTUsIDEyOCwgMF0sIGxpbmVXaWR0aCwgY3YuTElORV9BQSk7CiAgICAgICAgICBEcmF3LmxpbmUobW9ycGhvLCAuLi5saW5lLnRvUG9pbnRzKCksIFswLCAwLCAwXSwgMiwgY3YuTElORV84KTsKICAgICAgICAgIERyYXcubGluZShza2VsLCAuLi5saW5lLnRvUG9pbnRzKCksIFswLCAwLCAwXSwgbGluZVdpZHRoLCBjdi5MSU5FXzgpOwogICAgICAgICAgKytpOwogICAgICAgIH0KICAgICAgICBsaW5lcyA9IGxpbmVzLm1hcChsID0+IChsLnNsb3BlLnkgPCAwID8gbC5zd2FwKCkgOiBsKSk7CgogICAgICAgIGNvbnN0IEdldEFuZ2xlID0gbCA9PiBNYXRoLnJvdW5kKChsLmFuZ2xlICogUkFEMkRFRykgLyAxNSkgKiAxNTsKCiAgICAgICAgbGluZXMgPSBsaW5lcy5maWx0ZXIobCA9PiBsLmxlbmd0aCA+PSA0MCAmJiBNYXRoLmFicyhHZXRBbmdsZShsKSkgIT0gNDUpOwoKICAgICAgICBsaW5lcy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTsKICAgICAgICAvLyAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIDUwKTsKICAgICAgICAvL2NvbnNvbGUubG9nKGBsaW5lc2AsIGxpbmVzLm1hcChsID0+IFtsLCBsLnNsb3BlLCBHZXRBbmdsZShsKV0pKTsKCiAgICAgICAgbGV0IGlzSG9yaXpvbnRhbCA9IGwgPT4gTWF0aC5hYnMobC54MiAtIGwueDEpID4gTWF0aC5hYnMobC55MiAtIGwueTEpOwoKICAgICAgICBsZXQgZmlyc3RMYXN0ID0gYSA9PiBbYVswXSwgYVthLmxlbmd0aCAtIDFdXTsKCiAgICAgICAgbGV0IHYgPSBsaW5lcwogICAgICAgICAgLmZpbHRlcihsID0+ICFpc0hvcml6b250YWwobCkpCiAgICAgICAgICAubWFwKGwgPT4gW2wsIGwuYXQoMC41KV0pCiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYVsxXS54IC0gYlsxXS54KQogICAgICAgICAgLm1hcCgoW2xdKSA9PiBsKTsKCiAgICAgICAgbGV0IGggPSBsaW5lcwogICAgICAgICAgLmZpbHRlcihsID0+IGlzSG9yaXpvbnRhbChsKSkKICAgICAgICAgIC5tYXAobCA9PiBbbCwgbC5hdCgwLjUpXSkKICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzFdLnkgLSBiWzFdLnkpCiAgICAgICAgICAubWFwKChbbF0pID0+IGwpOwoKICAgICAgICAvKiAgIHYgPSBmaXJzdExhc3Qodik7CiAgICAgICAgaCA9IGZpcnN0TGFzdChoKTsqLwogICAgICAgIC8vY29uc29sZS5sb2coJ2xpbmVzOicsIHsgdiwgaCB9KTsKCiAgICAgICAgY29uc3QgYW5nbGUyQ29sb3IgPSBhID0+IHsKICAgICAgICAgIGxldCBjb2xvciA9IG5ldyBIU0xBKE1hdGgucm91bmQoYSksIDEwMCwgNTApLnRvUkdCQSgpOwogICAgICAgICAgcmV0dXJuIFtjb2xvci5iLCBjb2xvci5nLCBjb2xvci5yXTsKICAgICAgICB9OwoKICAgICAgICBjb25zb2xlLmxvZygnYW5nbGUyQ29sb3IoMTAwKTonLCBhbmdsZTJDb2xvcigxMDApKTsKICAgICAgICBjb25zb2xlLmxvZygnYW5nbGUyQ29sb3IoMzYwKTonLCBhbmdsZTJDb2xvcigwKSk7CiAgICAgICAgLyoKICAgICAgICBjb25zb2xlLmxvZygndicsCiAgICAgICAgICBbLi4udi5zbGljZSgwLCA0KSwgLi4uaC5zbGljZSgwLCA0KV0ubWFwKGwgPT4gWwogICAgICAgICAgICAuLi5sLnRvUG9pbnRzKCksCiAgICAgICAgICAgIGB5SW50ZXJjZXB0KCkgPSAke2wueUludGVyY2VwdCgpfWAsCiAgICAgICAgICAgIGB4SW50ZXJjZXB0KCkgPSAke2wueEludGVyY2VwdCgpfWAKICAgICAgICAgIF0pCiAgICAgICAgKTsqLwogICAgICAgIGZvcihsZXQgbGluZSBvZiB2KSB7CiAgICAgICAgICBsZXQgY29sb3IgPSBhbmdsZTJDb2xvcigobGluZS5hbmdsZSAqICgxODAgLyBNYXRoLlBJKSkgJSAxODApOwoKICAgICAgICAgIERyYXcubGluZShkc3QsIC4uLmxpbmUudG9Qb2ludHMoKSwgY29sb3IsIDEsIGN2LkxJTkVfQUEpOwogICAgICAgIH0KICAgICAgICBmb3IobGV0IGxpbmUgb2YgaCkgewogICAgICAgICAgbGV0IGNvbG9yID0gYW5nbGUyQ29sb3IoKGxpbmUuYW5nbGUgKiAoMTgwIC8gTWF0aC5QSSkpICUgMTgwKTsKCiAgICAgICAgICBEcmF3LmxpbmUoZHN0LCAuLi5saW5lLnRvUG9pbnRzKCksIGNvbG9yLCAxLCBjdi5MSU5FX0FBKTsKICAgICAgICB9CgogICAgICAgIGxldCBrZXJuID0gY3YuZ2V0U3RydWN0dXJpbmdFbGVtZW50KGN2Lk1PUlBIX0NST1NTLCBuZXcgU2l6ZSgzLCAzKSk7CiAgICAgICAgY3YuZGlsYXRlKHNrZWwsIHNrZWwsIGtlcm4pOwogICAgICAgIGN2LmVyb2RlKHNrZWwsIHNrZWwsIGtlcm4pOwogICAgICAgIGN2LmRpbGF0ZShtb3JwaG8sIG1vcnBobywga2Vybik7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uIEhvdWdoQ2lyY2xlcyhzcmMsIGRzdCkgewogICAgICAgIGNvbnN0IG1vcnBobyA9IHRoaXMub3V0cHV0T2YoJ01vcnBob2xvZ3knKTsKICAgICAgICBjb25zdCBza2VsID0gdGhpcy5vdXRwdXRPZignU2tlbGV0b25pemF0aW9uJyk7CiAgICAgICAgY29uc3QgcGFyYW1BcnJheSA9IFsrcGFyYW1zLmRwIHx8IDEsICtwYXJhbXMubWluRGlzdCwgK3BhcmFtcy5wYXJhbTEsICtwYXJhbXMucGFyYW0yLCArcGFyYW1zLm1pblJhZGl1cywgK3BhcmFtcy5tYXhSYWRpTWF0aHVzXTsKICAgICAgICBsZXQgY2lyY2xlczEgPSBbXSB8fCBuZXcgTWF0KCk7CiAgICAgICAgbGV0IGNpcmNsZXMyID0gW10gfHwgbmV3IE1hdCgpOwogICAgICAgIGN2LkhvdWdoQ2lyY2xlcyhtb3JwaG8sIGNpcmNsZXMxLCBjdi5IT1VHSF9HUkFESUVOVCwgLi4ucGFyYW1BcnJheSk7CiAgICAgICAgY3YuSG91Z2hDaXJjbGVzKHNrZWwsIGNpcmNsZXMyLCBjdi5IT1VHSF9HUkFESUVOVCwgLi4ucGFyYW1BcnJheSk7CiAgICAgICAgdGhpcy5vdXRwdXRPZignSG91Z2hMaW5lc1AnKS5jb3B5VG8oZHN0KTsKICAgICAgICBsZXQgaSA9IDA7CiAgICAgICAgZm9yKGxldCBbeCwgeSwgcl0gb2YgY2lyY2xlczEpIHsKICAgICAgICAgIGxldCBwID0gbmV3IFBvaW50KHgsIHkpOwogICAgICAgICAgRHJhdy5jaXJjbGUoZHN0LCBwLCByLCBbMCwgMjU1LCAwXSwgbGluZVdpZHRoLCBjdi5MSU5FX0FBKTsKICAgICAgICAgIGNpcmNsZXMucHVzaChbeCwgeSwgcl0pOwogICAgICAgIH0KICAgICAgICBmb3IobGV0IFt4LCB5LCByXSBvZiBjaXJjbGVzMikgewogICAgICAgICAgbGV0IHAgPSBuZXcgUG9pbnQoeCwgeSk7CiAgICAgICAgICBEcmF3LmNpcmNsZShkc3QsIHAsIHIgKyAyLCBbMjU1LCAwLCAwXSwgbGluZVdpZHRoLCBjdi5MSU5FX0FBKTsKICAgICAgICAgIGNpcmNsZXMucHVzaChbeCwgeSwgcl0pOwogICAgICAgIH0KICAgICAgfQogICAgXSwKICAgIGkgPT4gewogICAgICBpZihmcmFtZVNob3cgPT0gaSkgewogICAgICAgIGxldCBwcm9jZXNzb3IgPSBwaXBlbGluZS5nZXRQcm9jZXNzb3IoaSk7CiAgICAgICAgbGV0IHBhcmFtcyA9IHByb2Nlc3NvclBhcmFtcy5nZXQocHJvY2Vzc29yKTsKICAgICAgICBwYXJhbUluZGV4ZXNbMF0gPSBwYXJhbU5hdi5pbmRleE9mKHBhcmFtc1swXSk7CiAgICAgICAgcGFyYW1JbmRleGVzWzFdID0gcGFyYW1OYXYuaW5kZXhPZihwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKTsKICAgICAgICBpZihwYXJhbU5hdi5pbmRleCA8IHBhcmFtSW5kZXhlc1swXSB8fCBwYXJhbU5hdi5pbmRleCA+IHBhcmFtSW5kZXhlc1sxXSkgcGFyYW1OYXYuY3VycmVudCA9IHBhcmFtc1swXTsKICAgICAgICBsZXQgbWF0ID0gcGlwZWxpbmUuZ2V0SW1hZ2UoaSk7CiAgICAgICAgaWYobWF0LmNoYW5uZWxzID09IDEpIGN2LmN2dENvbG9yKG1hdCwgb3V0cHV0TWF0LCBjdi5DT0xPUl9HUkFZMkJHUik7CiAgICAgICAgZWxzZSBpZihtYXQuY2hhbm5lbHMgPT0gNCkgY3YuY3Z0Q29sb3IobWF0LCBvdXRwdXRNYXQsIGN2LkNPTE9SX0JHUkEyQkdSKTsKICAgICAgICBlbHNlIG1hdC5jb3B5VG8ob3V0cHV0TWF0KTsKICAgICAgICBSZWRyYXdTdGF0dXMoKTsKICAgICAgICBSZWRyYXdXaW5kb3coKTsKICAgICAgfQogICAgfQogICk7CiAgZnVuY3Rpb24gUmVkcmF3U3RhdHVzKCkgewogICAgLy9jb25zb2xlLmxvZyhgcGlwZWxpbmUuaW1hZ2VzID1gLCBuZXcgTWFwKHBpcGVsaW5lLmltYWdlRW50cmllcygpKSk7CiAgICBsZXQgaSA9IHBpcGVsaW5lLmN1cnJlbnRQcm9jZXNzb3I7CiAgICBsZXQgcHJvY2Vzc29yID0gcGlwZWxpbmUuZ2V0UHJvY2Vzc29yKGkpOwogICAgbGV0IHBhcmFtcyA9IHByb2Nlc3NvclBhcmFtcy5nZXQocHJvY2Vzc29yKTsKICAgIGxldCBzcmVjdCA9IG5ldyBSZWN0KHN0YXR1c1JlY3Quc2l6ZSk7CgogICAgRHJhdy5yZWN0YW5nbGUoc3RhdHVzTWF0LCBzcmVjdCwgYmFja2dyb3VuZENvbG9yLCBjdi5GSUxMRUQsIHRydWUpOwogICAgRHJhdy5yZWN0YW5nbGUoc3RhdHVzTWF0LCBzcmVjdC5pbnNldCgzLCAwKSwgMCwgY3YuRklMTEVELCB0cnVlKTsKICAgIGNvbnN0IGluc3BlY3RPcHRpb25zID0gewogICAgICBjb2xvcnM6IHRydWUsCiAgICAgIGhpZGVLZXlzOiBbJ2NhbGxiYWNrJ10KICAgIH07CiAgICBsZXQgdGV4dCA9CiAgICAgIGAjJHtpfTogYCArCiAgICAgIHBpcGVsaW5lLm5hbWVzW2ldICsKICAgICAgYFxuXG5gICsKICAgICAgYHBhcmFtczpcbmAgKwogICAgICBwYXJhbXMKICAgICAgICAubWFwKChuYW1lLCBpZHgpID0+IHsKICAgICAgICAgIHJldHVybiBgICAke2lkeCArIHBhcmFtSW5kZXhlc1swXSA9PSBwYXJhbU5hdi5pbmRleCA/ICdceDFiWzE7MzFtJyA6ICcnfSR7bmFtZS5wYWRFbmQoMTMpfVx4MWJbMG0gICBceDFiWzE7MzZtJHsrcGFyYW1OYXYuZ2V0KG5hbWUpfVx4MWJbMG1cbmA7CiAgICAgICAgfSkKICAgICAgICAuam9pbignJyk7CiAgICBEcmF3VGV4dChzdGF0dXNNYXQodGV4dFJlY3QpLCB0ZXh0LCB0ZXh0Q29sb3IsIGZvbnRGYWNlLCBmb250U2l6ZSk7CiAgICBEcmF3VGV4dChzdGF0dXNNYXQoaGVscFJlY3QpLCAnPCBwcmV2LCA+IG5leHQsICsgaW5jcmVtZW50LCAtIGRlY3JlbWVudCwgREVMIHJlc2V0JywgdGV4dENvbG9yLCBmb250RmFjZSwgZm9udFNpemUpOwogIH0KICBmdW5jdGlvbiBSZWRyYXdXaW5kb3coKSB7CiAgICBsZXQgaSA9IHBpcGVsaW5lLmN1cnJlbnRQcm9jZXNzb3I7CiAgICBjdi52Y29uY2F0KFtvdXRwdXRNYXQsIHN0YXR1c01hdF0sIHNjcmVlbik7CiAgICBjdi5pbXNob3coJ291dHB1dCcsIHNjcmVlbik7CiAgICBjdi5yZXNpemVXaW5kb3coJ291dHB1dCcsIHNjcmVlblNpemUud2lkdGgsIHNjcmVlblNpemUuaGVpZ2h0KTsKICAgIGN2LnNldFdpbmRvd1RpdGxlKCdvdXRwdXQnLCBgIyR7aX06IGAgKyBwaXBlbGluZS5uYW1lc1tpXSk7CiAgfQogIGxldCBrZXk7CiAgbGV0IHBhcmFtQWNjdW11bGF0b3IgPSBwYXJhbU5hdi5zZXRDYWxsYmFjaygKICAgIG5ldyBBY2N1bXVsYXRvcigobmFtZSwgcGFyYW0pID0+IHsKICAgICAgLy8gY29uc29sZS5sb2coYHBhcmFtICcke25hbWV9JyBjYWxsYmFja2AsIHBhcmFtKTsKICAgIH0pCiAgKTsKICBsZXQgcHJvY2Vzc29yUGFyYW1zID0gVXRpbC53ZWFrTWFwcGVyKHByb2Nlc3NvciA9PiBbXSk7CiAgcGlwZWxpbmUuYmVmb3JlID0gKCkgPT4gcGFyYW1BY2N1bXVsYXRvci5jbGVhcigpOwogIHBpcGVsaW5lLmFmdGVyID0gKCkgPT4gcHJvY2Vzc29yUGFyYW1zLnNldChwaXBlbGluZS5nZXRQcm9jZXNzb3IoKSwgcGFyYW1BY2N1bXVsYXRvci5rZXlzKCkpOwogIHBpcGVsaW5lKCk7CiAgZGVsZXRlIHBpcGVsaW5lLmJlZm9yZTsKICBkZWxldGUgcGlwZWxpbmUuYWZ0ZXI7CiAgY29uc29sZS5sb2coYHBpcGVsaW5lLnJlY2FsYygke2ZyYW1lU2hvd30pYCwgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdykpOwogIHdoaWxlKHRydWUpIHsKICAgIGtleSA9IGN2LndhaXRLZXlFeCgtMSk7CiAgICBpZihrZXkgPT09ICdxJyB8fCBrZXkgPT09IDExMyB8fCBrZXkgPT09ICdceDFiJyB8fCBrZXkgPT09IDB4MTAwMDcxIHx8IGtleSA9PT0gLTEpIGJyZWFrOwogICAgc3dpdGNoIChrZXkgJiAweGZmZikgewogICAgICBjYXNlIDB4ZjA4IC8qIGJhY2tzcGFjZSAqLzoKICAgICAgY2FzZSAweDA4IC8qIGJhY2tzcGFjZSAqLzoKICAgICAgICBpZihmcmFtZVNob3cgPiAwKSB7CiAgICAgICAgICBmcmFtZVNob3ctLTsKICAgICAgICAgIHBpcGVsaW5lLnN0ZXAoLTEpOwogICAgICAgIH0KICAgICAgICBicmVhazsKICAgICAgY2FzZSAweGY1MiAvKiB1cCAqLzoKICAgICAgY2FzZSAweDNjIC8qIDwgKi86CiAgICAgICAgcGFyYW1OYXYucHJldigpOwogICAgICAgIGlmKHBhcmFtSW5kZXhlc1swXSAhPSAtMSAmJiBwYXJhbU5hdi5pbmRleCA8IHBhcmFtSW5kZXhlc1swXSkgcGFyYW1OYXYuaW5kZXggPSBwYXJhbUluZGV4ZXNbMV07CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICMke3BhcmFtTmF2LmluZGV4fSAnJHtwYXJhbU5hdi5uYW1lfScgc2VsZWN0ZWQgKCR7K3BhcmFtTmF2LnBhcmFtfSlgKTsKICAgICAgICBSZWRyYXdTdGF0dXMoKTsKICAgICAgICBSZWRyYXdXaW5kb3coKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAweGY1NCAvKmRvd24gICovOgogICAgICBjYXNlIDB4M2UgLyogPiAqLzoKICAgICAgICBwYXJhbU5hdi5uZXh0KCk7CiAgICAgICAgaWYocGFyYW1JbmRleGVzWzFdICE9IC0xICYmIHBhcmFtTmF2LmluZGV4ID4gcGFyYW1JbmRleGVzWzFdKSBwYXJhbU5hdi5pbmRleCA9IHBhcmFtSW5kZXhlc1swXTsKICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW0gIyR7cGFyYW1OYXYuaW5kZXh9ICcke3BhcmFtTmF2Lm5hbWV9JyBzZWxlY3RlZCAoJHsrcGFyYW1OYXYucGFyYW19KWApOwogICAgICAgIFJlZHJhd1N0YXR1cygpOwogICAgICAgIFJlZHJhd1dpbmRvdygpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4ZjUzIC8qIHJpZ2h0ICovOgogICAgICBjYXNlIDB4MmIgLyogKyAqLzoKICAgICAgICBwYXJhbU5hdi5wYXJhbS5pbmNyZW1lbnQoKTsKICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW0gJHtwYXJhbU5hdi5uYW1lfTogJHsrcGFyYW1OYXYucGFyYW19YCk7CiAgICAgICAgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdyk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhmZmYgLyogREVMRVRFICovOgogICAgICBjYXNlIDB4OWYgLyogbnVtcGFkIERFTCAqLzoKICAgICAgY2FzZSAweGY5ZiAvKiBudW1wYWQgREVMICovOgogICAgICAgIHBhcmFtTmF2LnBhcmFtLnJlc2V0KCk7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7aW5zcGVjdChwYXJhbU5hdi5wYXJhbSl9YCk7CiAgICAgICAgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdyk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhmNTEgLyogbGVmdCAqLzoKICAgICAgY2FzZSAweDJkIC8qIC0gKi86CiAgICAgIGNhc2UgMHhhZCAvKiBudW1wYWQgLSAqLzoKICAgICAgY2FzZSAweGZhZCAvKiBudW1wYWQgLSAqLzoKICAgICAgY2FzZSAweDJmYWQgLyogbnVtcGFkIC0gKi86CiAgICAgICAgcGFyYW1OYXYucGFyYW0uZGVjcmVtZW50KCk7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7K3BhcmFtTmF2LnBhcmFtfWApOwogICAgICAgIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4MzE6IC8qIDEgKi8KICAgICAgY2FzZSAweDMyOiAvKiAyICovCiAgICAgIGNhc2UgMHgzMzogLyogMyAqLwogICAgICBjYXNlIDB4MzQ6IC8qIDQgKi8KICAgICAgY2FzZSAweDM1OiAvKiA1ICovCiAgICAgIGNhc2UgMHgzNjogLyogNiAqLwogICAgICBjYXNlIDB4Mzc6IC8qIDcgKi8KICAgICAgY2FzZSAweDM4OiAvKiA4ICovCiAgICAgIGNhc2UgMHgzOTogLyogOSAqLwogICAgICBjYXNlIDB4MzAgLyogMCAqLzoKICAgICAgICBsZXQgdiA9IGtleSAmIDB4ZiB8fCAxMDsKICAgICAgICBwYXJhbU5hdi5wYXJhbS5hbHBoYSA9IHYgLyAxMDsKICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW0gJHtwYXJhbU5hdi5uYW1lfTogJHsrcGFyYW1OYXYucGFyYW19YCk7CiAgICAgICAgcGlwZWxpbmUucmVjYWxjKGZyYW1lU2hvdyk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMHhhNyAvKiDCpyAqLzoKICAgICAgICBwYXJhbU5hdi5wYXJhbS5hbHBoYSA9IDA7CiAgICAgICAgY29uc29sZS5sb2coYFBhcmFtICR7cGFyYW1OYXYubmFtZX06ICR7K3BhcmFtTmF2LnBhcmFtfWApOwogICAgICAgIHBpcGVsaW5lLnJlY2FsYyhmcmFtZVNob3cpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDB4MjA6CiAgICAgICAgZnJhbWVTaG93ID0gVXRpbC5tb2QoZnJhbWVTaG93ICsgMSwgcGlwZWxpbmUuc2l6ZSk7CiAgICAgICAgcGlwZWxpbmUuc3RlcCgpOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OiB7CiAgICAgICAgaWYoa2V5ICE9PSAtMSkgY29uc29sZS5sb2coJ2tleTonLCBUb0hleChrZXkpKTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQogIH0KICBTYXZlQ29uZmlnKHsgZnJhbWVTaG93LCBwYXJhbUluZGV4OiBwYXJhbU5hdi5pbmRleCwgLi4ucGFyYW1zIH0pOwogIGNvbnNvbGUubG9nKCdFWElUJyk7Cn0KdHJ5IHsKICBtYWluKC4uLnNjcmlwdEFyZ3Muc2xpY2UoMSkpOwp9IGNhdGNoKGVycm9yKSB7CiAgY29uc29sZS5sb2coYEZBSUw6ICR7ZXJyb3IubWVzc2FnZX1cbiR7ZXJyb3Iuc3RhY2t9YCk7CiAgc3RkLmV4aXQoMSk7Cn0gZmluYWxseSB7CiAgY29uc29sZS5sb2coJ1NVQ0NFU1MnKTsKfQoAAAAAAAAAAOFPAAAAAAAAAAAAAAAAAAAAAAAA4U8AAAAAAAAAAAAAAAAAAAAAAADhTwAAAAAAAAAAAAAAAAAAAAAAAOFPAAAAAAAAAAAAAAAAAAAAAAAA4U8AAAAAAAAAAAAAAAAAAAAAAADhTwAAAAAAAAAAAAAAAAAAAAAAAOFPAAAAAAAAAAAAAAAAAAAAAAAA4U8AAAAAAAAAAAAAAAAAAAAAAADhTwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPICAAAAAAAATQMAAAAAAAAAAAAAAADwvw"
				]
			]
		},
		{
			"file": "qjs-opencv/js/cvHighGUI.js",
			"settings":
			{
				"buffer_size": 5001,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					2,
					1,
					"revert",
					null,
					"CgAAAAAAAAAAAAAAAAAAAAAAAACJEwAAaW1wb3J0IHsgc2VsZWN0Uk9JLCBTaXplLCBQb2ludCwgRHJhdywgRklMTEVELCBGT05UX0hFUlNIRVlfUExBSU4sIGdldFNjcmVlblJlc29sdXRpb24sIGdldFdpbmRvd0ltYWdlUmVjdCwgZ2V0V2luZG93UHJvcGVydHksIGltc2hvdywgTElORV9BQSwgbW92ZVdpbmRvdywgbmFtZWRXaW5kb3csIHJlc2l6ZVdpbmRvdywgc2V0TW91c2VDYWxsYmFjaywgc2V0V2luZG93UHJvcGVydHksIHNldFdpbmRvd1RpdGxlLCBXSU5ET1dfTk9STUFMLCBFVkVOVF9NT1VTRU1PVkUsIEVWRU5UX0xCVVRUT05ET1dOLCBFVkVOVF9SQlVUVE9ORE9XTiwgRVZFTlRfTUJVVFRPTkRPV04sIEVWRU5UX0xCVVRUT05VUCwgRVZFTlRfUkJVVFRPTlVQLCBFVkVOVF9NQlVUVE9OVVAsIEVWRU5UX0xCVVRUT05EQkxDTEssIEVWRU5UX1JCVVRUT05EQkxDTEssIEVWRU5UX01CVVRUT05EQkxDTEssIEVWRU5UX01PVVNFV0hFRUwsIEVWRU5UX01PVVNFSFdIRUVMLCBFVkVOVF9GTEFHX0xCVVRUT04sIEVWRU5UX0ZMQUdfUkJVVFRPTiwgRVZFTlRfRkxBR19NQlVUVE9OLCBFVkVOVF9GTEFHX0NUUkxLRVksIEVWRU5UX0ZMQUdfU0hJRlRLRVksIEVWRU5UX0ZMQUdfQUxUS0VZIH0gZnJvbSAnb3BlbmN2JzsKaW1wb3J0IHsgQml0c1RvTmFtZXMgfSBmcm9tICcuL2N2VXRpbHMuanMnOwoKZXhwb3J0IGNvbnN0IE1vdXNlRXZlbnRzID0gewogIEVWRU5UX01PVVNFTU9WRSwKICBFVkVOVF9MQlVUVE9ORE9XTiwKICBFVkVOVF9SQlVUVE9ORE9XTiwKICBFVkVOVF9NQlVUVE9ORE9XTiwKICBFVkVOVF9MQlVUVE9OVVAsCiAgRVZFTlRfUkJVVFRPTlVQLAogIEVWRU5UX01CVVRUT05VUCwKICBFVkVOVF9MQlVUVE9OREJMQ0xLLAogIEVWRU5UX1JCVVRUT05EQkxDTEssCiAgRVZFTlRfTUJVVFRPTkRCTENMSywKICBFVkVOVF9NT1VTRVdIRUVMLAogIEVWRU5UX01PVVNFSFdIRUVMCn07CmV4cG9ydCBjb25zdCBNb3VzZUZsYWdzID0gewogIEVWRU5UX0ZMQUdfTEJVVFRPTiwKICBFVkVOVF9GTEFHX1JCVVRUT04sCiAgRVZFTlRfRkxBR19NQlVUVE9OLAogIEVWRU5UX0ZMQUdfQ1RSTEtFWSwKICBFVkVOVF9GTEFHX1NISUZUS0VZLAogIEVWRU5UX0ZMQUdfQUxUS0VZCn07CgpleHBvcnQgY29uc3QgTW91c2UgPSB7CiAgcHJpbnRFdmVudDogKCgpID0+IHsKICAgIHJldHVybiBldmVudCA9PiBNb3VzZUV2ZW50c1tldmVudF0ucmVwbGFjZSgvRVZFTlRfLywgJycpOwogIH0pKCksCiAgcHJpbnRGbGFnczogKCgpID0+IHsKICAgIGNvbnN0IHRva3MgPSBCaXRzVG9OYW1lcyhNb3VzZUZsYWdzLCBuYW1lID0+IG5hbWUucmVwbGFjZSgvRVZFTlRfRkxBR18vLCAnJykpOwoKICAgIHJldHVybiBmbGFncyA9PiBbLi4udG9rcyhmbGFncyldOwogIH0pKCkKfTsKCmV4cG9ydCBjbGFzcyBTY3JlZW4gewogIHN0YXRpYyBzaXplKCkgewogICAgcmV0dXJuIGdldFNjcmVlblJlc29sdXRpb24oKTsKICB9Cn0KCmV4cG9ydCBjbGFzcyBXaW5kb3cgewogIGNvbnN0cnVjdG9yKG5hbWUsIGZsYWdzID0gV0lORE9XX05PUk1BTCkgewogICAgdGhpcy5uYW1lID0gbmFtZTsKICAgIHRoaXMuZmxhZ3MgPSBmbGFnczsKCiAgICBuYW1lZFdpbmRvdyh0aGlzLm5hbWUsIHRoaXMuZmxhZ3MpOwogIH0KCiAgbW92ZSguLi5hcmdzKSB7CiAgICBsZXQgcG9zID0gbmV3IFBvaW50KC4uLmFyZ3MpOwogICAgbW92ZVdpbmRvdyh0aGlzLm5hbWUsIHBvcy54LCBwb3MueSk7CiAgfQoKICByZXNpemUoLi4uYXJncykgewogICAgLy9jb25zb2xlLmxvZygiV2luZG93LnJlc2l6ZSIsIC4uLmFyZ3MpOwogICAgbGV0IHNpemUgPSBuZXcgU2l6ZSguLi5hcmdzKTsKICAgIHJlc2l6ZVdpbmRvdyh0aGlzLm5hbWUsIC4uLnNpemUpOwogICAgcmV0dXJuIHNpemU7CiAgfQoKICBhbGlnbihuID0gMCkgewogICAgbGV0IHMgPSBTY3JlZW4uc2l6ZSgpOwogICAgbGV0IHJlY3QgPSB0aGlzLmltYWdlUmVjdDsKICAgIGxldCBkaW0gPSBuZXcgU2l6ZShyZWN0KTsKICAgIGxldCB7IHgsIHkgfSA9IGRpbS5hbGlnbihzLCBuKTsKICAgIGNvbnNvbGUubG9nKCdwb3MnLCB7IHgsIHkgfSk7CiAgICByZXR1cm4gdGhpcy5tb3ZlKHgsIHkpOwogIH0KCiAgLyogcHJldHRpZXItaWdub3JlICovIGdldCBpbWFnZVJlY3QoKSB7CiAgICByZXR1cm4gZ2V0V2luZG93SW1hZ2VSZWN0KHRoaXMubmFtZSk7CiAgfQoKICBnZXQocHJvcElkKSB7CiAgICByZXR1cm4gZ2V0V2luZG93UHJvcGVydHkodGhpcy5uYW1lLCBwcm9wSWQpOwogIH0KICBzZXQocHJvcElkLCB2YWx1ZSkgewogICAgc2V0V2luZG93UHJvcGVydHkodGhpcy5uYW1lLCBwcm9wSWQsIHZhbHVlKTsKICB9CgogIHNldFRpdGxlKHRpdGxlKSB7CiAgICB0aGlzLnRpdGxlID0gdGl0bGU7CiAgICBzZXRXaW5kb3dUaXRsZSh0aGlzLm5hbWUsIHRpdGxlKTsKICB9CgogIHNldE1vdXNlQ2FsbGJhY2soZm4pIHsKICAgIGNvbnNvbGUubG9nKCdXaW5kb3cuc2V0TW91c2VDYWxsYmFjaycsIGZuKTsKICAgIHNldE1vdXNlQ2FsbGJhY2sodGhpcy5uYW1lLCAoZXZlbnQsIHgsIHksIGZsYWdzKSA9PiB7CiAgICAgIC8vY29uc29sZS5sb2coIk1vdXNlQ2FsbGJhY2siLCB7ZXZlbnQseCx5LGZsYWdzfSk7CiAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQsIHgsIHksIGZsYWdzKTsKICAgIH0pOwogIH0KCiAgc2hvdyhtYXQpIHsKICAgIHRoaXMubWF0ID0gbWF0OwogICAgaW1zaG93KHRoaXMubmFtZSwgbWF0KTsKICB9CgogIHZhbHVlT2YoKSB7CiAgICByZXR1cm4gdGhpcy5uYW1lOwogIH0KCiAgc2VsZWN0Uk9JKG1hdCwgc2hvd0Nyb3NzaGFpciA9IHRydWUsIGZyb21DZW50ZXIgPSBmYWxzZSkgewogICAgcmV0dXJuIHNlbGVjdFJPSSh0aGlzLm5hbWUsIG1hdCA/PyB0aGlzLm1hdCwgc2hvd0Nyb3NzaGFpciwgZnJvbUNlbnRlcik7CiAgfQp9CgpleHBvcnQgZnVuY3Rpb24gVGV4dFN0eWxlKGZvbnRGYWNlID0gRk9OVF9IRVJTSEVZX1BMQUlOLCBmb250U2NhbGUgPSAxLjAsIHRoaWNrbmVzcyA9IC0xKSB7CiAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IGZvbnRGYWNlLCBmb250U2NhbGUsIHRoaWNrbmVzcyB9KTsKfQoKT2JqZWN0LmFzc2lnbihUZXh0U3R5bGUucHJvdG90eXBlLCB7CiAgc2l6ZSh0ZXh0LCBmbiA9IHkgPT4ge30pIHsKICAgIGNvbnN0IHsgZm9udEZhY2UsIGZvbnRTY2FsZSwgdGhpY2tuZXNzIH0gPSB0aGlzOwogICAgbGV0IGJhc2VZOwogICAgbGV0IHNpemUgPSBuZXcgU2l6ZSguLi5EcmF3LnRleHRTaXplKHRleHQsIGZvbnRGYWNlLCBmb250U2NhbGUsIHRoaWNrbmVzcywgeSA9PiAoYmFzZVkgPSB5KSkpOwoKICAgIGZuKGJhc2VZKTsKCiAgICBzaXplLnkgPSBiYXNlWTsKICAgIHJldHVybiBzaXplOwogIH0sCgogIGRyYXcobWF0LCB0ZXh0LCBwb3MsIGNvbG9yID0gWzI1NSwgMjU1LCAyNTUsIDI1NV0sIGxpbmVUaGlja25lc3MgPSBGSUxMRUQsIGxpbmVUeXBlID0gTElORV9BQSkgewogICAgY29uc3QgeyBmb250RmFjZSwgZm9udFNjYWxlLCB0aGlja25lc3MgfSA9IHRoaXM7CiAgICBEcmF3LnRleHQobWF0LCB0ZXh0LCBwb3MsIGZvbnRGYWNlLCBmb250U2NhbGUsIGNvbG9yLCBsaW5lVGhpY2tuZXNzLCBsaW5lVHlwZSk7CiAgfQp9KTsKCmNvbnN0IHBhbGV0dGUxNiA9IFsKICAweDAwMDAwMCwgMHhhMDAwMDAsIDB4MDBhMDAwLCAweGEwYTAwMCwgMHgwMDAwYTAsIDB4YTAwMGEwLCAweDAwYTBhMCwgMHhjMGMwYzAsIDB4YTBhMGEwLCAweGZmMDAwMCwgMHgwMGZmMDAsCiAgMHhmZmZmMDAsIDB4MDAwMGZmLCAweGZmMDBmZiwgMHgwMGZmZmYsIDB4ZmZmZmZmCl07CgpleHBvcnQgZnVuY3Rpb24gRHJhd1RleHQoZHN0LCB0ZXh0LCBjb2xvciwgZm9udEZhY2UsIGZvbnRTaXplID0gMTMpIHsKICBsZXQgYyA9IGNvbG9yOwogIGxldCBmb250ID0KICAgIHR5cGVvZiBmb250RmFjZSA9PSAnb2JqZWN0JyAmJiBmb250RmFjZSAhPSBudWxsICYmIGZvbnRGYWNlIGluc3RhbmNlb2YgVGV4dFN0eWxlCiAgICAgID8gZm9udEZhY2UKICAgICAgOiBuZXcgVGV4dFN0eWxlKGZvbnRGYWNlLCBmb250U2l6ZSwgLTEpOwogIGxldCBsaW5lcyA9IFsuLi50ZXh0Lm1hdGNoQWxsKC8oXHgxYlteYS16XSpbYS16XXxcbnxbXlx4MWJcbl0qKS9nKV0ubWFwKG0gPT4gbVswXSk7CiAgbGV0IGJhc2VZOwogIGxldCBzaXplID0gZm9udC5zaXplKCd5UCcsIHkgPT4gKGJhc2VZID0geSkpOwogIGxldCBzdGFydCA9IG5ldyBQb2ludChzaXplLndpZHRoIC8gdGV4dC5sZW5ndGgsIGJhc2VZIC0gMyk7CiAgbGV0IHBvcyA9IG5ldyBQb2ludChzdGFydCk7CiAgbGV0IGluY1kgPSAoYmFzZVkgfHwgMikgKyBzaXplLmhlaWdodCArIDM7CgogIGZvcihsZXQgbGluZSBvZiBsaW5lcykgewogICAgaWYobGluZSA9PSAnXG4nKSB7CiAgICAgIHBvcy55ICs9IGluY1k7CiAgICAgIHBvcy54ID0gc3RhcnQueDsKICAgICAgY29udGludWU7CiAgICB9IGVsc2UgaWYobGluZS5zdGFydHNXaXRoKCdceDFiJykpIHsKICAgICAgbGV0IGFuc2kgPSBbLi4ubGluZS5tYXRjaEFsbCgvKFswLTldK3xbYS16XSkvZyldLm1hcChtID0+IChpc05hTigrbVswXSkgPyBtWzBdIDogK21bMF0pKTsKICAgICAgaWYoYW5zaVthbnNpLmxlbmd0aCAtIDFdID09ICdtJykgewogICAgICAgIGxldCBuOwogICAgICAgIGZvcihsZXQgY29kZSBvZiBhbnNpLnNsaWNlKDAsIC0xKSkgewogICAgICAgICAgaWYoY29kZSA9PSAwKSBjb250aW51ZTsKICAgICAgICAgIGlmKGNvZGUgPT0gMSkgbiA9IChuIHwgMCkgKyA4OwogICAgICAgICAgZWxzZSBpZihjb2RlID49IDMwKSBuID0gbiB8IDAgfCAoY29kZSAtIDMwKTsKICAgICAgICB9CiAgICAgICAgaWYobiA9PT0gdW5kZWZpbmVkKSBjID0gY29sb3I7CiAgICAgICAgZWxzZSBjID0gcGFsZXR0ZTE2W25dOwogICAgICB9CiAgICAgIGNvbnRpbnVlOwogICAgfQogICAgc2l6ZSA9IGZvbnQuc2l6ZShsaW5lKTsKICAgIGZvbnQuZHJhdyhkc3QsIGxpbmUsIHBvcywgYywgLTEsIExJTkVfQUEpOwogICAgcG9zLnggKz0gc2l6ZS53aWR0aDsKICB9Cn0KAAAAAAAAAACJEwAAAAAAAAAAAAAAAAAAAAAAAIkTAAAAAAAAAAAAAAAAAAAAAAAAiRMAAAAAAAAAAAAAAAAAAAAAAACJEwAAAAAAAAAAAAAAAAAAAAAAAIkTAAAAAAAAAAAAAAAAAAAAAAAAiRMAAAAAAAAAAAAAAAAAAAAAAACJEwAAAAAAAAAAAAAAAAAAAAAAAIkTAAAAAAAAAAAAAAAAAAAAAAAAiRMAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvw"
				]
			]
		},
		{
			"file": "lib/util.js",
			"settings":
			{
				"buffer_size": 184762,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "test-glfw.js",
			"settings":
			{
				"buffer_size": 4498,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					369,
					1,
					"insert",
					{
						"characters": "sine="
					},
					"BQAAACgMAAAAAAAAKQwAAAAAAAAAAAAAKQwAAAAAAAAqDAAAAAAAAAAAAAAqDAAAAAAAACsMAAAAAAAAAAAAACsMAAAAAAAALAwAAAAAAAAAAAAALAwAAAAAAAAtDAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACgMAAAAAAAAKAwAAAAAAAAAAAAAAADwvw"
				],
				[
					371,
					1,
					"insert",
					{
						"characters": "M"
					},
					"AQAAAEoMAAAAAAAASwwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAEoMAAAAAAAASgwAAAAAAAD////////vfw"
				],
				[
					372,
					1,
					"left_delete",
					null,
					"AQAAAEoMAAAAAAAASgwAAAAAAAABAAAATQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAEsMAAAAAAAASwwAAAAAAAAAAAAAAADwvw"
				],
				[
					373,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAEoMAAAAAAAASwwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAEoMAAAAAAAASgwAAAAAAAAAAAAAAADwvw"
				],
				[
					377,
					1,
					"cut",
					null,
					"AQAAAG8MAAAAAAAAbwwAAAAAAAAQAAAALm1hcCh2ID0+IHYgKiApOw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAG8MAAAAAAAAfwwAAAAAAAD////////vfw"
				],
				[
					378,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAG8MAAAAAAAAcAwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAG8MAAAAAAAAbwwAAAAAAAAAAAAAAADwvw"
				],
				[
					382,
					1,
					"cut",
					null,
					"AQAAAKIMAAAAAAAAogwAAAAAAAApAAAAY29uc29sZS5sb2coImluZGV4ICUgMzYwIiwgaW5kZXggJSAzNjApOwo",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKIMAAAAAAAAywwAAAAAAAAAAAAAAAAAAA"
				],
				[
					383,
					1,
					"paste",
					null,
					"AQAAAKIMAAAAAAAAywwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKIMAAAAAAAAogwAAAAAAAAAAAAAAADwvw"
				],
				[
					386,
					1,
					"paste",
					null,
					"AQAAAE4MAAAAAAAAdwwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAE4MAAAAAAAATgwAAAAAAAAAAAAAAADwvw"
				],
				[
					393,
					1,
					"insert",
					{
						"characters": "sine"
					},
					"BQAAAFsMAAAAAAAAXAwAAAAAAAAAAAAAXAwAAAAAAABcDAAAAAAAAAsAAABpbmRleCAlIDM2MFwMAAAAAAAAXQwAAAAAAAAAAAAAXQwAAAAAAABeDAAAAAAAAAAAAABeDAAAAAAAAF8MAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFsMAAAAAAAAZgwAAAAAAAAAAAAAAADwvw"
				],
				[
					397,
					1,
					"insert",
					{
						"characters": "sine"
					},
					"BQAAAGIMAAAAAAAAYwwAAAAAAAAAAAAAYwwAAAAAAABjDAAAAAAAAAsAAABpbmRleCAlIDM2MGMMAAAAAAAAZAwAAAAAAAAAAAAAZAwAAAAAAABlDAAAAAAAAAAAAABlDAAAAAAAAGYMAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAGIMAAAAAAAAbQwAAAAAAAAAAAAAAADwvw"
				],
				[
					419,
					1,
					"insert",
					{
						"characters": " "
					},
					"AgAAAHYMAAAAAAAAdwwAAAAAAAAAAAAAdwwAAAAAAAB3DAAAAAAAAAQAAABbLi4u",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAHYMAAAAAAAAegwAAAAAAAAAAAAAAADwvw"
				],
				[
					422,
					1,
					"left_delete",
					null,
					"AQAAAIYMAAAAAAAAhgwAAAAAAAABAAAAXQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIcMAAAAAAAAhwwAAAAAAAAAAAAAAADwvw"
				],
				[
					423,
					1,
					"insert",
					{
						"characters": ".normalize"
					},
					"CgAAAIYMAAAAAAAAhwwAAAAAAAAAAAAAhwwAAAAAAACIDAAAAAAAAAAAAACIDAAAAAAAAIkMAAAAAAAAAAAAAIkMAAAAAAAAigwAAAAAAAAAAAAAigwAAAAAAACLDAAAAAAAAAAAAACLDAAAAAAAAIwMAAAAAAAAAAAAAIwMAAAAAAAAjQwAAAAAAAAAAAAAjQwAAAAAAACODAAAAAAAAAAAAACODAAAAAAAAI8MAAAAAAAAAAAAAI8MAAAAAAAAkAwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIYMAAAAAAAAhgwAAAAAAAAAAAAAAADwvw"
				],
				[
					424,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAJAMAAAAAAAAkgwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJAMAAAAAAAAkAwAAAAAAAAAAAAAAADwvw"
				],
				[
					460,
					1,
					"paste",
					null,
					"AQAAAIsKAAAAAAAAHAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIsKAAAAAAAAiwoAAAAAAAAAAAAAAADwvw"
				],
				[
					465,
					1,
					"insert",
					{
						"characters": "const"
					},
					"BgAAAIsKAAAAAAAAjAoAAAAAAAAAAAAAjAoAAAAAAACMCgAAAAAAAAUAAABQb2ludIwKAAAAAAAAjQoAAAAAAAAAAAAAjQoAAAAAAACOCgAAAAAAAAAAAACOCgAAAAAAAI8KAAAAAAAAAAAAAI8KAAAAAAAAkAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIsKAAAAAAAAkAoAAAAAAAAAAAAAAADwvw"
				],
				[
					466,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAJAKAAAAAAAAkQoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJAKAAAAAAAAkAoAAAAAAAAAAAAAAADwvw"
				],
				[
					467,
					1,
					"right_delete",
					null,
					"AQAAAJEKAAAAAAAAkQoAAAAAAAABAAAALg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJEKAAAAAAAAkQoAAAAAAAAAAAAAAADwvw"
				],
				[
					470,
					2,
					"left_delete",
					null,
					"AgAAAKEKAAAAAAAAoQoAAAAAAAABAAAAMaAKAAAAAAAAoAoAAAAAAAABAAAAcA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKIKAAAAAAAAogoAAAAAAAAAAAAAAADwvw"
				],
				[
					471,
					1,
					"insert",
					{
						"characters": "a,"
					},
					"AgAAAKAKAAAAAAAAoQoAAAAAAAAAAAAAoQoAAAAAAACiCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKAKAAAAAAAAoAoAAAAAAAAAAAAAAADwvw"
				],
				[
					472,
					1,
					"insert",
					{
						"characters": " b,"
					},
					"AwAAAKIKAAAAAAAAowoAAAAAAAAAAAAAowoAAAAAAACkCgAAAAAAAAAAAACkCgAAAAAAAKUKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKIKAAAAAAAAogoAAAAAAAAAAAAAAADwvw"
				],
				[
					473,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAKUKAAAAAAAApgoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKUKAAAAAAAApQoAAAAAAAAAAAAAAADwvw"
				],
				[
					474,
					7,
					"right_delete",
					null,
					"BwAAAKYKAAAAAAAApgoAAAAAAAABAAAALKYKAAAAAAAApgoAAAAAAAABAAAAIKYKAAAAAAAApgoAAAAAAAABAAAAcKYKAAAAAAAApgoAAAAAAAABAAAAMqYKAAAAAAAApgoAAAAAAAABAAAALKYKAAAAAAAApgoAAAAAAAABAAAAIKYKAAAAAAAApgoAAAAAAAABAAAAYQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKYKAAAAAAAApgoAAAAAAAAAAAAAAADwvw"
				],
				[
					475,
					1,
					"insert",
					{
						"characters": "alpha"
					},
					"BQAAAKYKAAAAAAAApwoAAAAAAAAAAAAApwoAAAAAAACoCgAAAAAAAAAAAACoCgAAAAAAAKkKAAAAAAAAAAAAAKkKAAAAAAAAqgoAAAAAAAAAAAAAqgoAAAAAAACrCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKYKAAAAAAAApgoAAAAAAAAAAAAAAADwvw"
				],
				[
					480,
					1,
					"cut",
					null,
					"AQAAALQKAAAAAAAAtAoAAAAAAAAbAAAAYSA9IFV0aWwuY2xhbXAoMCwgMSwgYSk7CiAg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALQKAAAAAAAAzwoAAAAAAAAAAAAAAAA0QA"
				],
				[
					483,
					1,
					"insert",
					{
						"characters": "(a"
					},
					"AgAAALsKAAAAAAAAvAoAAAAAAAAAAAAAvAoAAAAAAAC9CgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALsKAAAAAAAAuwoAAAAAAAAAAAAAAADwvw"
				],
				[
					484,
					1,
					"insert",
					{
						"characters": " *"
					},
					"AgAAAL0KAAAAAAAAvgoAAAAAAAAAAAAAvgoAAAAAAAC/CgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAL0KAAAAAAAAvQoAAAAAAAAAAAAAAADwvw"
				],
				[
					485,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAL8KAAAAAAAAwAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAL8KAAAAAAAAvwoAAAAAAAAAAAAAAADwvw"
				],
				[
					486,
					1,
					"insert",
					{
						"characters": "(1.0"
					},
					"BAAAAMAKAAAAAAAAwQoAAAAAAAAAAAAAwQoAAAAAAADCCgAAAAAAAAAAAADCCgAAAAAAAMMKAAAAAAAAAAAAAMMKAAAAAAAAxAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMAKAAAAAAAAwAoAAAAAAAAAAAAAAADwvw"
				],
				[
					487,
					1,
					"insert",
					{
						"characters": " -"
					},
					"AgAAAMQKAAAAAAAAxQoAAAAAAAAAAAAAxQoAAAAAAADGCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMQKAAAAAAAAxAoAAAAAAAAAAAAAAADwvw"
				],
				[
					488,
					1,
					"insert",
					{
						"characters": " alpha)"
					},
					"BwAAAMYKAAAAAAAAxwoAAAAAAAAAAAAAxwoAAAAAAADICgAAAAAAAAAAAADICgAAAAAAAMkKAAAAAAAAAAAAAMkKAAAAAAAAygoAAAAAAAAAAAAAygoAAAAAAADLCgAAAAAAAAAAAADLCgAAAAAAAMwKAAAAAAAAAAAAAMwKAAAAAAAAzQoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMYKAAAAAAAAxgoAAAAAAAAAAAAAAADwvw"
				],
				[
					489,
					1,
					"insert",
					{
						"characters": " +"
					},
					"AgAAAM0KAAAAAAAAzgoAAAAAAAAAAAAAzgoAAAAAAADPCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAM0KAAAAAAAAzQoAAAAAAAAAAAAAAADwvw"
				],
				[
					490,
					1,
					"insert",
					{
						"characters": " b"
					},
					"AgAAAM8KAAAAAAAA0AoAAAAAAAAAAAAA0AoAAAAAAADRCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAM8KAAAAAAAAzwoAAAAAAAAAAAAAAADwvw"
				],
				[
					491,
					1,
					"insert",
					{
						"characters": " *"
					},
					"AgAAANEKAAAAAAAA0goAAAAAAAAAAAAA0goAAAAAAADTCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANEKAAAAAAAA0QoAAAAAAAAAAAAAAADwvw"
				],
				[
					492,
					1,
					"insert",
					{
						"characters": " (alph"
					},
					"BgAAANMKAAAAAAAA1AoAAAAAAAAAAAAA1AoAAAAAAADVCgAAAAAAAAAAAADVCgAAAAAAANYKAAAAAAAAAAAAANYKAAAAAAAA1woAAAAAAAAAAAAA1woAAAAAAADYCgAAAAAAAAAAAADYCgAAAAAAANkKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANMKAAAAAAAA0woAAAAAAAAAAAAAAADwvw"
				],
				[
					493,
					1,
					"insert",
					{
						"characters": "a))"
					},
					"AwAAANkKAAAAAAAA2goAAAAAAAAAAAAA2goAAAAAAADbCgAAAAAAAAAAAADbCgAAAAAAANwKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANkKAAAAAAAA2QoAAAAAAAAAAAAAAADwvw"
				],
				[
					494,
					1,
					"left_delete",
					null,
					"AQAAANsKAAAAAAAA2woAAAAAAAABAAAAKQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANwKAAAAAAAA3AoAAAAAAAAAAAAAAADwvw"
				],
				[
					496,
					1,
					"cut",
					null,
					"AQAAANsKAAAAAAAA2woAAAAAAABEAAAAbmV3IFBvaW50KHAxLnggKiAoMS4wIC0gYSkgKyBwMi54ICogYSwgcDEueSAqICgxLjAgLSBhKSArIHAyLnkgKiBhKTs",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANsKAAAAAAAAHwsAAAAAAAD////////vfw"
				],
				[
					497,
					1,
					"left_delete",
					null,
					"AQAAANoKAAAAAAAA2goAAAAAAAABAAAAKQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANsKAAAAAAAA2woAAAAAAAAAAAAAAADwvw"
				],
				[
					498,
					1,
					"insert",
					{
						"characters": ");"
					},
					"AgAAANoKAAAAAAAA2woAAAAAAAAAAAAA2woAAAAAAADcCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANoKAAAAAAAA2goAAAAAAAAAAAAAAADwvw"
				],
				[
					501,
					1,
					"right_delete",
					null,
					"AQAAALsKAAAAAAAAuwoAAAAAAAABAAAAKA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALsKAAAAAAAAuwoAAAAAAAAAAAAAAADwvw"
				],
				[
					506,
					1,
					"left_delete",
					null,
					"AQAAALAKAAAAAAAAsAoAAAAAAAABAAAAew",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALEKAAAAAAAAsQoAAAAAAAD////////vfw"
				],
				[
					507,
					10,
					"right_delete",
					null,
					"CgAAALAKAAAAAAAAsAoAAAAAAAABAAAACrAKAAAAAAAAsAoAAAAAAAABAAAAILAKAAAAAAAAsAoAAAAAAAABAAAAILAKAAAAAAAAsAoAAAAAAAABAAAAcrAKAAAAAAAAsAoAAAAAAAABAAAAZbAKAAAAAAAAsAoAAAAAAAABAAAAdLAKAAAAAAAAsAoAAAAAAAABAAAAdbAKAAAAAAAAsAoAAAAAAAABAAAAcrAKAAAAAAAAsAoAAAAAAAABAAAAbrAKAAAAAAAAsAoAAAAAAAABAAAAIA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALAKAAAAAAAAsAoAAAAAAAAAAAAAAADwvw"
				],
				[
					511,
					1,
					"left_delete",
					null,
					"AQAAANEKAAAAAAAA0QoAAAAAAAADAAAAfTsK",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANEKAAAAAAAA1AoAAAAAAAAAAAAAAAAAAA"
				],
				[
					513,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AQAAAIsKAAAAAAAAjAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIsKAAAAAAAAiwoAAAAAAAAAAAAAAAAAAA"
				],
				[
					522,
					1,
					"insert",
					{
						"characters": "x"
					},
					"AgAAAKEKAAAAAAAAogoAAAAAAAAAAAAAogoAAAAAAACiCgAAAAAAAAEAAABh",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKEKAAAAAAAAogoAAAAAAAAAAAAAAADwvw"
				],
				[
					527,
					1,
					"insert",
					{
						"characters": "y"
					},
					"AgAAAKQKAAAAAAAApQoAAAAAAAAAAAAApQoAAAAAAAClCgAAAAAAAAEAAABi",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKQKAAAAAAAApQoAAAAAAAAAAAAAAADwvw"
				],
				[
					532,
					1,
					"insert",
					{
						"characters": "x"
					},
					"AgAAALEKAAAAAAAAsgoAAAAAAAAAAAAAsgoAAAAAAACyCgAAAAAAAAEAAABh",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALEKAAAAAAAAsgoAAAAAAAAAAAAAAADwvw"
				],
				[
					540,
					1,
					"insert",
					{
						"characters": "y"
					},
					"AgAAAMUKAAAAAAAAxgoAAAAAAAAAAAAAxgoAAAAAAADGCgAAAAAAAAEAAABi",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMUKAAAAAAAAxgoAAAAAAAAAAAAAAADwvw"
				],
				[
					563,
					1,
					"insert",
					{
						"characters": "sign"
					},
					"BQAAAKcKAAAAAAAAqAoAAAAAAAAAAAAAqAoAAAAAAACoCgAAAAAAAAUAAABhbHBoYagKAAAAAAAAqQoAAAAAAAAAAAAAqQoAAAAAAACqCgAAAAAAAAAAAACqCgAAAAAAAKsKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKcKAAAAAAAArAoAAAAAAAAAAAAAAADwvw"
				],
				[
					564,
					1,
					"left_delete",
					null,
					"AQAAAKoKAAAAAAAAqgoAAAAAAAABAAAAbg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKsKAAAAAAAAqwoAAAAAAAAAAAAAAADwvw"
				],
				[
					565,
					1,
					"insert",
					{
						"characters": "ma"
					},
					"AgAAAKoKAAAAAAAAqwoAAAAAAAAAAAAAqwoAAAAAAACsCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKoKAAAAAAAAqgoAAAAAAAAAAAAAAADwvw"
				],
				[
					575,
					1,
					"paste",
					null,
					"AgAAALwKAAAAAAAAwQoAAAAAAAAAAAAAwQoAAAAAAADBCgAAAAAAAAUAAABhbHBoYQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALwKAAAAAAAAwQoAAAAAAAAAAAAAAADwvw"
				],
				[
					580,
					1,
					"paste",
					null,
					"AgAAAMoKAAAAAAAAzwoAAAAAAAAAAAAAzwoAAAAAAADPCgAAAAAAAAUAAABhbHBoYQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMoKAAAAAAAAzwoAAAAAAAAAAAAAAADwvw"
				],
				[
					613,
					1,
					"cut",
					null,
					"AQAAAIwKAAAAAAAAjAoAAAAAAABGAAAAY29uc3QgaW50ZXJwb2xhdGUgPSAoeCwgeSwgc2lnbWEpID0+IHggKiAoMS4wIC0gc2lnbWEpICsgeSAqIChzaWdtYSk7Cg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIwKAAAAAAAA0goAAAAAAAAAAAAAAADwvw"
				],
				[
					614,
					2,
					"paste",
					null,
					"AgAAAIwKAAAAAAAA0goAAAAAAAAAAAAA0goAAAAAAAAYCwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIwKAAAAAAAAjAoAAAAAAAAAAAAAAADwvw"
				],
				[
					619,
					1,
					"insert",
					{
						"characters": "clamp"
					},
					"BgAAAJIKAAAAAAAAkwoAAAAAAAAAAAAAkwoAAAAAAACTCgAAAAAAAAsAAABpbnRlcnBvbGF0ZZMKAAAAAAAAlAoAAAAAAAAAAAAAlAoAAAAAAACVCgAAAAAAAAAAAACVCgAAAAAAAJYKAAAAAAAAAAAAAJYKAAAAAAAAlwoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJIKAAAAAAAAnQoAAAAAAAAAAAAAAADwvw"
				],
				[
					621,
					1,
					"insert",
					{
						"characters": "n,"
					},
					"AgAAAJsKAAAAAAAAnAoAAAAAAAAAAAAAnAoAAAAAAACdCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJsKAAAAAAAAmwoAAAAAAAAAAAAAAADwvw"
				],
				[
					622,
					1,
					"insert",
					{
						"characters": " min,"
					},
					"BQAAAJ0KAAAAAAAAngoAAAAAAAAAAAAAngoAAAAAAACfCgAAAAAAAAAAAACfCgAAAAAAAKAKAAAAAAAAAAAAAKAKAAAAAAAAoQoAAAAAAAAAAAAAoQoAAAAAAACiCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ0KAAAAAAAAnQoAAAAAAAAAAAAAAADwvw"
				],
				[
					623,
					1,
					"insert",
					{
						"characters": " max"
					},
					"BAAAAKIKAAAAAAAAowoAAAAAAAAAAAAAowoAAAAAAACkCgAAAAAAAAAAAACkCgAAAAAAAKUKAAAAAAAAAAAAAKUKAAAAAAAApgoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKIKAAAAAAAAogoAAAAAAAAAAAAAAADwvw"
				],
				[
					624,
					11,
					"right_delete",
					null,
					"CwAAAKYKAAAAAAAApgoAAAAAAAABAAAAeKYKAAAAAAAApgoAAAAAAAABAAAALKYKAAAAAAAApgoAAAAAAAABAAAAIKYKAAAAAAAApgoAAAAAAAABAAAAeaYKAAAAAAAApgoAAAAAAAABAAAALKYKAAAAAAAApgoAAAAAAAABAAAAIKYKAAAAAAAApgoAAAAAAAABAAAAc6YKAAAAAAAApgoAAAAAAAABAAAAaaYKAAAAAAAApgoAAAAAAAABAAAAZ6YKAAAAAAAApgoAAAAAAAABAAAAbaYKAAAAAAAApgoAAAAAAAABAAAAYQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKYKAAAAAAAApgoAAAAAAAAAAAAAAADwvw"
				],
				[
					626,
					1,
					"insert",
					{
						"characters": "r"
					},
					"AQAAAKsKAAAAAAAArAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKsKAAAAAAAAqwoAAAAAAAAAAAAAAADwvw"
				],
				[
					627,
					1,
					"left_delete",
					null,
					"AQAAAKsKAAAAAAAAqwoAAAAAAAABAAAAcg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKwKAAAAAAAArAoAAAAAAAAAAAAAAADwvw"
				],
				[
					628,
					1,
					"insert",
					{
						"characters": "Math."
					},
					"BQAAAKsKAAAAAAAArAoAAAAAAAAAAAAArAoAAAAAAACtCgAAAAAAAAAAAACtCgAAAAAAAK4KAAAAAAAAAAAAAK4KAAAAAAAArwoAAAAAAAAAAAAArwoAAAAAAACwCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKsKAAAAAAAAqwoAAAAAAAAAAAAAAADwvw"
				],
				[
					629,
					1,
					"insert",
					{
						"characters": "min"
					},
					"AwAAALAKAAAAAAAAsQoAAAAAAAAAAAAAsQoAAAAAAACyCgAAAAAAAAAAAACyCgAAAAAAALMKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALAKAAAAAAAAsAoAAAAAAAAAAAAAAADwvw"
				],
				[
					630,
					3,
					"left_delete",
					null,
					"AwAAALIKAAAAAAAAsgoAAAAAAAABAAAAbrEKAAAAAAAAsQoAAAAAAAABAAAAabAKAAAAAAAAsAoAAAAAAAABAAAAbQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALMKAAAAAAAAswoAAAAAAAAAAAAAAADwvw"
				],
				[
					631,
					1,
					"insert",
					{
						"characters": "max(m"
					},
					"BQAAALAKAAAAAAAAsQoAAAAAAAAAAAAAsQoAAAAAAACyCgAAAAAAAAAAAACyCgAAAAAAALMKAAAAAAAAAAAAALMKAAAAAAAAtAoAAAAAAAAAAAAAtAoAAAAAAAC1CgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALAKAAAAAAAAsAoAAAAAAAAAAAAAAADwvw"
				],
				[
					632,
					1,
					"insert",
					{
						"characters": "in,"
					},
					"AwAAALUKAAAAAAAAtgoAAAAAAAAAAAAAtgoAAAAAAAC3CgAAAAAAAAAAAAC3CgAAAAAAALgKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALUKAAAAAAAAtQoAAAAAAAAAAAAAAADwvw"
				],
				[
					633,
					1,
					"insert",
					{
						"characters": " n)"
					},
					"AwAAALgKAAAAAAAAuQoAAAAAAAAAAAAAuQoAAAAAAAC6CgAAAAAAAAAAAAC6CgAAAAAAALsKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALgKAAAAAAAAuAoAAAAAAAAAAAAAAADwvw"
				],
				[
					634,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAALsKAAAAAAAAvAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALsKAAAAAAAAuwoAAAAAAAAAAAAAAADwvw"
				],
				[
					636,
					1,
					"cut",
					null,
					"AQAAALwKAAAAAAAAvAoAAAAAAAAgAAAAeCAqICgxLjAgLSBzaWdtYSkgKyB5ICogKHNpZ21hKTs",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALwKAAAAAAAA3AoAAAAAAAD////////vfw"
				],
				[
					638,
					1,
					"insert",
					{
						"characters": "Math.min("
					},
					"CQAAAKsKAAAAAAAArAoAAAAAAAAAAAAArAoAAAAAAACtCgAAAAAAAAAAAACtCgAAAAAAAK4KAAAAAAAAAAAAAK4KAAAAAAAArwoAAAAAAAAAAAAArwoAAAAAAACwCgAAAAAAAAAAAACwCgAAAAAAALEKAAAAAAAAAAAAALEKAAAAAAAAsgoAAAAAAAAAAAAAsgoAAAAAAACzCgAAAAAAAAAAAACzCgAAAAAAALQKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKsKAAAAAAAAqwoAAAAAAAAAAAAAAADwvw"
				],
				[
					639,
					1,
					"insert",
					{
						"characters": "n"
					},
					"AQAAALQKAAAAAAAAtQoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALQKAAAAAAAAtAoAAAAAAAAAAAAAAADwvw"
				],
				[
					640,
					1,
					"left_delete",
					null,
					"AQAAALQKAAAAAAAAtAoAAAAAAAABAAAAbg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALUKAAAAAAAAtQoAAAAAAAAAAAAAAADwvw"
				],
				[
					642,
					1,
					"left_delete",
					null,
					"AQAAAMQKAAAAAAAAxAoAAAAAAAABAAAAIA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMUKAAAAAAAAxQoAAAAAAAD////////vfw"
				],
				[
					643,
					1,
					"insert",
					{
						"characters": "m"
					},
					"AQAAAMQKAAAAAAAAxQoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMQKAAAAAAAAxAoAAAAAAAAAAAAAAADwvw"
				],
				[
					644,
					1,
					"left_delete",
					null,
					"AQAAAMQKAAAAAAAAxAoAAAAAAAABAAAAbQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMUKAAAAAAAAxQoAAAAAAAAAAAAAAADwvw"
				],
				[
					645,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAAMQKAAAAAAAAxQoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMQKAAAAAAAAxAoAAAAAAAAAAAAAAADwvw"
				],
				[
					646,
					1,
					"insert",
					{
						"characters": " max);"
					},
					"BgAAAMUKAAAAAAAAxgoAAAAAAAAAAAAAxgoAAAAAAADHCgAAAAAAAAAAAADHCgAAAAAAAMgKAAAAAAAAAAAAAMgKAAAAAAAAyQoAAAAAAAAAAAAAyQoAAAAAAADKCgAAAAAAAAAAAADKCgAAAAAAAMsKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMUKAAAAAAAAxQoAAAAAAAAAAAAAAADwvw"
				],
				[
					647,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AQAAAMsKAAAAAAAAzAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMsKAAAAAAAAywoAAAAAAAAAAAAAAADwvw"
				],
				[
					678,
					1,
					"insert",
					{
						"characters": "Array.isArray(x"
					},
					"DwAAAPIKAAAAAAAA8woAAAAAAAAAAAAA8woAAAAAAAD0CgAAAAAAAAAAAAD0CgAAAAAAAPUKAAAAAAAAAAAAAPUKAAAAAAAA9goAAAAAAAAAAAAA9goAAAAAAAD3CgAAAAAAAAAAAAD3CgAAAAAAAPgKAAAAAAAAAAAAAPgKAAAAAAAA+QoAAAAAAAAAAAAA+QoAAAAAAAD6CgAAAAAAAAAAAAD6CgAAAAAAAPsKAAAAAAAAAAAAAPsKAAAAAAAA/AoAAAAAAAAAAAAA/AoAAAAAAAD9CgAAAAAAAAAAAAD9CgAAAAAAAP4KAAAAAAAAAAAAAP4KAAAAAAAA/woAAAAAAAAAAAAA/woAAAAAAAAACwAAAAAAAAAAAAAACwAAAAAAAAELAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPIKAAAAAAAA8goAAAAAAAAAAAAAAADwvw"
				],
				[
					679,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAAELAAAAAAAAAgsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAELAAAAAAAAAQsAAAAAAAAAAAAAAADwvw"
				],
				[
					680,
					1,
					"insert",
					{
						"characters": " ?"
					},
					"AgAAAAILAAAAAAAAAwsAAAAAAAAAAAAAAwsAAAAAAAAECwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAILAAAAAAAAAgsAAAAAAAAAAAAAAADwvw"
				],
				[
					681,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAAQLAAAAAAAABQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAQLAAAAAAAABAsAAAAAAAAAAAAAAADwvw"
				],
				[
					682,
					1,
					"insert",
					{
						"characters": ":"
					},
					"AQAAAAULAAAAAAAABgsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAULAAAAAAAABQsAAAAAAAAAAAAAAADwvw"
				],
				[
					683,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAAYLAAAAAAAABwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAYLAAAAAAAABgsAAAAAAAAAAAAAAADwvw"
				],
				[
					685,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAAULAAAAAAAABgsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAULAAAAAAAABQsAAAAAAAAAAAAAAADwvw"
				],
				[
					687,
					1,
					"insert",
					{
						"characters": "x.map"
					},
					"BQAAAAULAAAAAAAABgsAAAAAAAAAAAAABgsAAAAAAAAHCwAAAAAAAAAAAAAHCwAAAAAAAAgLAAAAAAAAAAAAAAgLAAAAAAAACQsAAAAAAAAAAAAACQsAAAAAAAAKCwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAULAAAAAAAABQsAAAAAAAAAAAAAAADwvw"
				],
				[
					688,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAAoLAAAAAAAADAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAoLAAAAAAAACgsAAAAAAAAAAAAAAADwvw"
				],
				[
					689,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAAsLAAAAAAAADAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAsLAAAAAAAACwsAAAAAAAAAAAAAAADwvw"
				],
				[
					691,
					1,
					"insert",
					{
						"characters": "x"
					},
					"AQAAAAsLAAAAAAAADAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAsLAAAAAAAACwsAAAAAAAAAAAAAAADwvw"
				],
				[
					692,
					1,
					"left_delete",
					null,
					"AQAAAAsLAAAAAAAACwsAAAAAAAABAAAAeA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAwLAAAAAAAADAsAAAAAAAAAAAAAAADwvw"
				],
				[
					693,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAAsLAAAAAAAADQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAsLAAAAAAAACwsAAAAAAAAAAAAAAADwvw"
				],
				[
					694,
					1,
					"insert",
					{
						"characters": "xx,i"
					},
					"BAAAAAwLAAAAAAAADQsAAAAAAAAAAAAADQsAAAAAAAAOCwAAAAAAAAAAAAAOCwAAAAAAAA8LAAAAAAAAAAAAAA8LAAAAAAAAEAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAwLAAAAAAAADAsAAAAAAAAAAAAAAADwvw"
				],
				[
					696,
					1,
					"insert",
					{
						"characters": " =>"
					},
					"AwAAABELAAAAAAAAEgsAAAAAAAAAAAAAEgsAAAAAAAATCwAAAAAAAAAAAAATCwAAAAAAABQLAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABELAAAAAAAAEQsAAAAAAAAAAAAAAADwvw"
				],
				[
					697,
					1,
					"insert",
					{
						"characters": "  "
					},
					"AgAAABQLAAAAAAAAFQsAAAAAAAAAAAAAFQsAAAAAAAAWCwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABQLAAAAAAAAFAsAAAAAAAAAAAAAAADwvw"
				],
				[
					699,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAABULAAAAAAAAFgsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABULAAAAAAAAFQsAAAAAAAAAAAAAAADwvw"
				],
				[
					700,
					1,
					"insert",
					{
						"characters": "xx"
					},
					"AgAAABYLAAAAAAAAFwsAAAAAAAAAAAAAFwsAAAAAAAAYCwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABYLAAAAAAAAFgsAAAAAAAAAAAAAAADwvw"
				],
				[
					701,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAABgLAAAAAAAAGQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABgLAAAAAAAAGAsAAAAAAAAAAAAAAADwvw"
				],
				[
					702,
					3,
					"left_delete",
					null,
					"AwAAABgLAAAAAAAAGAsAAAAAAAABAAAAIBcLAAAAAAAAFwsAAAAAAAABAAAAeBYLAAAAAAAAFgsAAAAAAAABAAAAeA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABkLAAAAAAAAGQsAAAAAAAAAAAAAAADwvw"
				],
				[
					703,
					1,
					"insert",
					{
						"characters": "interpolate"
					},
					"CwAAABYLAAAAAAAAFwsAAAAAAAAAAAAAFwsAAAAAAAAYCwAAAAAAAAAAAAAYCwAAAAAAABkLAAAAAAAAAAAAABkLAAAAAAAAGgsAAAAAAAAAAAAAGgsAAAAAAAAbCwAAAAAAAAAAAAAbCwAAAAAAABwLAAAAAAAAAAAAABwLAAAAAAAAHQsAAAAAAAAAAAAAHQsAAAAAAAAeCwAAAAAAAAAAAAAeCwAAAAAAAB8LAAAAAAAAAAAAAB8LAAAAAAAAIAsAAAAAAAAAAAAAIAsAAAAAAAAhCwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABYLAAAAAAAAFgsAAAAAAAAAAAAAAADwvw"
				],
				[
					704,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAACELAAAAAAAAIwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACELAAAAAAAAIQsAAAAAAAAAAAAAAADwvw"
				],
				[
					705,
					1,
					"insert",
					{
						"characters": "xx,"
					},
					"AwAAACILAAAAAAAAIwsAAAAAAAAAAAAAIwsAAAAAAAAkCwAAAAAAAAAAAAAkCwAAAAAAACULAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACILAAAAAAAAIgsAAAAAAAAAAAAAAADwvw"
				],
				[
					706,
					1,
					"insert",
					{
						"characters": " y"
					},
					"AgAAACULAAAAAAAAJgsAAAAAAAAAAAAAJgsAAAAAAAAnCwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACULAAAAAAAAJQsAAAAAAAAAAAAAAADwvw"
				],
				[
					707,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAACcLAAAAAAAAKQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACcLAAAAAAAAJwsAAAAAAAAAAAAAAADwvw"
				],
				[
					708,
					1,
					"insert",
					{
						"characters": "i"
					},
					"AQAAACgLAAAAAAAAKQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACgLAAAAAAAAKAsAAAAAAAAAAAAAAADwvw"
				],
				[
					710,
					1,
					"left_delete",
					null,
					"AQAAACoLAAAAAAAAKgsAAAAAAAABAAAAKQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACsLAAAAAAAAKwsAAAAAAAAAAAAAAADwvw"
				],
				[
					711,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAACoLAAAAAAAAKwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACoLAAAAAAAAKgsAAAAAAAAAAAAAAADwvw"
				],
				[
					712,
					1,
					"insert",
					{
						"characters": " isg"
					},
					"BAAAACsLAAAAAAAALAsAAAAAAAAAAAAALAsAAAAAAAAtCwAAAAAAAAAAAAAtCwAAAAAAAC4LAAAAAAAAAAAAAC4LAAAAAAAALwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACsLAAAAAAAAKwsAAAAAAAAAAAAAAADwvw"
				],
				[
					713,
					3,
					"left_delete",
					null,
					"AwAAAC4LAAAAAAAALgsAAAAAAAABAAAAZy0LAAAAAAAALQsAAAAAAAABAAAAcywLAAAAAAAALAsAAAAAAAABAAAAaQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAC8LAAAAAAAALwsAAAAAAAAAAAAAAADwvw"
				],
				[
					714,
					1,
					"insert",
					{
						"characters": "sign"
					},
					"BAAAACwLAAAAAAAALQsAAAAAAAAAAAAALQsAAAAAAAAuCwAAAAAAAAAAAAAuCwAAAAAAAC8LAAAAAAAAAAAAAC8LAAAAAAAAMAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACwLAAAAAAAALAsAAAAAAAAAAAAAAADwvw"
				],
				[
					715,
					1,
					"left_delete",
					null,
					"AQAAAC8LAAAAAAAALwsAAAAAAAABAAAAbg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAADALAAAAAAAAMAsAAAAAAAAAAAAAAADwvw"
				],
				[
					716,
					1,
					"insert",
					{
						"characters": "ma)"
					},
					"AwAAAC8LAAAAAAAAMAsAAAAAAAAAAAAAMAsAAAAAAAAxCwAAAAAAAAAAAAAxCwAAAAAAADILAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAC8LAAAAAAAALwsAAAAAAAAAAAAAAADwvw"
				],
				[
					717,
					4,
					"right_delete",
					null,
					"BAAAADILAAAAAAAAMgsAAAAAAAABAAAAIDILAAAAAAAAMgsAAAAAAAABAAAAIDILAAAAAAAAMgsAAAAAAAABAAAAKTILAAAAAAAAMgsAAAAAAAABAAAAIA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAADILAAAAAAAAMgsAAAAAAAAAAAAAAADwvw"
				],
				[
					737,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAADILAAAAAAAAMwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAADILAAAAAAAAMgsAAAAAAAAAAAAAAADwvw"
				],
				[
					749,
					1,
					"left_delete",
					null,
					"AQAAAMsKAAAAAAAAywoAAAAAAAABAAAACg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMwKAAAAAAAAzAoAAAAAAAAAAAAAAADwvw"
				],
				[
					755,
					1,
					"revert",
					null,
					"AgAAAAAAAAAAAAAAAAAAAAAAAABpEQAAaW1wb3J0IHsgcG9sbCwgY29udGV4dCwgQ09OVEVYVF9WRVJTSU9OX01BSk9SLCBDT05URVhUX1ZFUlNJT05fTUlOT1IsIE9QRU5HTF9QUk9GSUxFLCBPUEVOR0xfQ09SRV9QUk9GSUxFLCBPUEVOR0xfRk9SV0FSRF9DT01QQVQsIFJFU0laQUJMRSwgU0FNUExFUywgV2luZG93IH0gZnJvbSAnZ2xmdyc7CmltcG9ydCBVdGlsIGZyb20gJy4vbGliL3V0aWwuanMnOwppbXBvcnQgQ29uc29sZSBmcm9tICdjb25zb2xlJzsKaW1wb3J0IHsgZ2xGbHVzaCwgZ2xCZWdpbiwgZ2xCaW5kVGV4dHVyZSwgZ2xDbGVhciwgZ2xDbGVhckNvbG9yLCBnbEVuYWJsZSwgZ2xFbmQsIGdsR2VuVGV4dHVyZXMsIGdsVGV4Q29vcmQyZiwgZ2xUZXhQYXJhbWV0ZXJmLCBnbFRleEltYWdlMkQsIGdsVmVydGV4M2YsIGdsVmlld3BvcnQsIEdMX0NPTE9SX0JVRkZFUl9CSVQsIEdMX0xJTkVBUiwgR0xfUVVBRFMsIEdMX1JFUEVBVCwgR0xfUkdCLCBHTF9URVhUVVJFXzJELCBHTF9URVhUVVJFX01BR19GSUxURVIsIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiwgR0xfVEVYVFVSRV9XUkFQX1MsIEdMX1RFWFRVUkVfV1JBUF9ULCBHTF9VTlNJR05FRF9CWVRFLCBnbERpc2FibGUsIGdsTG9hZElkZW50aXR5LCBnbE1hdHJpeE1vZGUsIGdsT3J0aG8sIGdsUHVzaE1hdHJpeCwgZ2xQb3BNYXRyaXgsIEdMX0xJR0hUSU5HLCBHTF9NT0RFTFZJRVcsIEdMX1BST0pFQ1RJT04gfSBmcm9tICcuL2dsLmpzJzsKaW1wb3J0IHsgSFNMQSB9IGZyb20gJy4vbGliL2NvbG9yLmpzJzsKaW1wb3J0IHsgaW1yZWFkIH0gZnJvbSAnb3BlbmN2JzsKaW1wb3J0IHsgcmFuZ2UgfSBmcm9tICcuL2xpYi9taXNjLmpzJzsKCmZ1bmN0aW9uIE1hdDJUZXh0dXJlKHRleHR1cmVfY3YpIHsKICBjb25zb2xlLmxvZygndGV4dHVyZV9jdicsIHRleHR1cmVfY3YpOwogIGNvbnN0IHsgYnVmZmVyIH0gPSB0ZXh0dXJlX2N2OwogIGNvbnNvbGUubG9nKCd0ZXh0dXJlX2N2LmJ1ZmZlcicsIGJ1ZmZlcik7CiAgbGV0IHRleHR1cmUgPSBuZXcgVWludDMyQXJyYXkoMSk7CiAgY29uc29sZS5sb2coJ3RleHR1cmUnLCB0ZXh0dXJlKTsKICBnbEdlblRleHR1cmVzKDEsIHRleHR1cmUuYnVmZmVyKTsgLy8gQ3JlYXRlIFRoZSBUZXh0dXJlCgogIGdsQmluZFRleHR1cmUoR0xfVEVYVFVSRV8yRCwgdGV4dHVyZVswXSk7CiAgZ2xUZXhQYXJhbWV0ZXJmKEdMX1RFWFRVUkVfMkQsIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiwgR0xfTElORUFSKTsKICBnbFRleFBhcmFtZXRlcmYoR0xfVEVYVFVSRV8yRCwgR0xfVEVYVFVSRV9NQUdfRklMVEVSLCBHTF9MSU5FQVIpOwogIGdsVGV4UGFyYW1ldGVyZihHTF9URVhUVVJFXzJELCBHTF9URVhUVVJFX1dSQVBfUywgR0xfUkVQRUFUKTsKICBnbFRleFBhcmFtZXRlcmYoR0xfVEVYVFVSRV8yRCwgR0xfVEVYVFVSRV9XUkFQX1QsIEdMX1JFUEVBVCk7CgogIGdsVGV4SW1hZ2UyRChHTF9URVhUVVJFXzJELCAwLCAzLCB0ZXh0dXJlX2N2LmNvbHMsIHRleHR1cmVfY3Yucm93cywgMCwgR0xfUkdCLCBHTF9VTlNJR05FRF9CWVRFLCBidWZmZXIpOwogIHJldHVybiB0ZXh0dXJlWzBdOwp9CgpmdW5jdGlvbiBtYWluKC4uLmFyZ3MpIHsKICBnbG9iYWxUaGlzLmNvbnNvbGUgPSBuZXcgQ29uc29sZSh7CiAgICBpbnNwZWN0T3B0aW9uczogeyBjb2xvcnM6IHRydWUsIGRlcHRoOiAxLCBtYXhBcnJheUxlbmd0aDogSW5maW5pdHksIG1heFN0cmluZ0xlbmd0aDogMTAwIH0KICB9KTsKICBXaW5kb3cuaGludChDT05URVhUX1ZFUlNJT05fTUFKT1IsIDMpOwogIFdpbmRvdy5oaW50KENPTlRFWFRfVkVSU0lPTl9NSU5PUiwgMik7CiAgV2luZG93LmhpbnQoT1BFTkdMX1BST0ZJTEUsIE9QRU5HTF9DT1JFX1BST0ZJTEUpOwogIFdpbmRvdy5oaW50KE9QRU5HTF9GT1JXQVJEX0NPTVBBVCwgdHJ1ZSk7CiAgV2luZG93LmhpbnQoUkVTSVpBQkxFLCBmYWxzZSk7CiAgV2luZG93LmhpbnQoU0FNUExFUywgNCk7CgogIGNvbnN0IHdpbmRvdyA9IG5ldyBXaW5kb3coODAwLCA2MDAsICdPcGVuR0wnKTsKICBjb250ZXh0LmN1cnJlbnQgPSB3aW5kb3c7CgogIGNvbnN0IHsgcG9zaXRpb24sIHNpemUgfSA9IHdpbmRvdzsKICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNpemU7CiAgY29uc3QgeyB4LCB5IH0gPSBwb3NpdGlvbjsKICBsZXQgdGV4dHVyZXMgPSBbXTsKCiAgY29uc29sZS5sb2coYHdpZHRoOiAke3dpZHRofSwgaGVpZ2h0OiAke2hlaWdodH0sIHg6ICR7eH0sIHk6ICR7eX1gKTsKCiAgaWYoYXJncy5sZW5ndGggPT0gMCkgYXJncy5wdXNoKCdNdWVobGViZXJnLnBuZycpOwoKICB3aGlsZShhcmdzLmxlbmd0aCA+IDApIHsKICAgIGNvbnNvbGUubG9nKCdhcmdzWzBdOicsIGFyZ3NbMF0pOwoKICAgIGxldCBpbWFnZSA9IGltcmVhZChhcmdzWzBdKTsKICAgIGNvbnNvbGUubG9nKCdpbWFnZTonLCBpbWFnZSk7CiAgICBjb25zb2xlLmxvZygnaW1hZ2UuYnVmZmVyOicsIGltYWdlLmJ1ZmZlcik7CiAgICBsZXQgdGV4dHVyZSA9IE1hdDJUZXh0dXJlKGltYWdlKTsKCiAgICBhcmdzLnNoaWZ0KCk7CiAgICB0ZXh0dXJlcy5wdXNoKHRleHR1cmUpOwogIH0KICBVdGlsLnNodWZmbGUodGV4dHVyZXMpOwogIGNvbnNvbGUubG9nKCd0ZXh0dXJlcycsIHRleHR1cmVzKTsKCmxldCBodWVzICA9ICAgcmFuZ2UoMCwzNTkpLm1hcChoID0+IG5ldyBIU0xBKGgsIDEwMCw1MCkpLm1hcChoc2xhID0+IGhzbGEudG9SR0JBKCkpOwoKY29uc3QgY2xhbXAgPSAobiwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KG1pbiwgbiksIG1heCk7CmNvbnN0IGludGVycG9sYXRlID0gKHgsIHksIHNpZ21hKSA9PiBBcnJheS5pc0FycmF5KHgpID8geC5tYXAoKHh4LGkpID0+ICBpbnRlcnBvbGF0ZSh4eCwgeVtpXSwgc2lnbWEpKTogeCAqICgxLjAgLSBzaWdtYSkgKyB5ICogKHNpZ21hKTsKCmNvbnNvbGUubG9nKCJodWVzIixodWVzKTsKCiAgd2hpbGUoIXdpbmRvdy5zaG91bGRDbG9zZSkgewogICAgZ2xWaWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTsKCiAgICBnbE1hdHJpeE1vZGUoR0xfUFJPSkVDVElPTik7CiAgICBnbFB1c2hNYXRyaXgoKTsKICAgIGdsTG9hZElkZW50aXR5KCk7CiAgICBnbE9ydGhvKDAuMCwgd2lkdGgsIDAuMCwgaGVpZ2h0LCAtMS4wLCAxLjApOwogICAgZ2xNYXRyaXhNb2RlKEdMX01PREVMVklFVyk7CiAgICBnbFB1c2hNYXRyaXgoKTsKCiAgICBnbExvYWRJZGVudGl0eSgpOwogICAgZ2xEaXNhYmxlKEdMX0xJR0hUSU5HKTsKCiAgICBsZXQgdGltZSA9ICtuZXcgRGF0ZSgpIC8gMTAwMDsKICAgIGxldCBpbmRleCA9IE1hdGguZmxvb3IoKHRpbWUgKiAzNjApIC8gMzApOwoKCmxldCBzaW5lPSBNYXRoLnNpbih0aW1lICogMiAqIE1hdGguUEkpOwoKCmNvbnNvbGUubG9nKCJzaW5lIiwgc2luZSk7CgpsZXQgY29sb3IgPSAgaHVlc1tpbmRleCUzNjBdLm5vcm1hbGl6ZSgpOwoKLy8gY29uc29sZS5sb2coImNvbG9yIiwgLi4uY29sb3Iubm9ybWFsaXplKCkpOwoKY29uc29sZS5sb2coImluZGV4ICUgMzYwIiwgaW5kZXggJSAzNjApOwpjb25zb2xlLmxvZygiY29sb3IiLCBjb2xvcik7CgoKICAgIGdsQ2xlYXJDb2xvciguLi5jb2xvci5ub3JtYWxpemUoKSk7CiAgICBnbENsZWFyKEdMX0NPTE9SX0JVRkZFUl9CSVQpOyAvL2NsZWFycyB0aGUgd2luZG93IHRvIHRoZSBjb2xvciB5b3Ugd2FudC4KCiAgICBnbEVuYWJsZShHTF9URVhUVVJFXzJEKTsKICAgIC8vIGNvbnNvbGUubG9nKCd0ZXh0dXJlc1swXScsIHRleHR1cmVzWzBdKTsKICAgIGdsQmluZFRleHR1cmUoR0xfVEVYVFVSRV8yRCwgdGV4dHVyZXNbMF0pOwoKICAgIC8vIERyYXcgYSB0ZXh0dXJlZCBxdWFkCiAgICBnbEJlZ2luKEdMX1FVQURTKTsKICAgIGdsVGV4Q29vcmQyZigwLCAwKTsKICAgIGdsVmVydGV4M2YoMCwgMCwgMCk7CiAgICBnbFRleENvb3JkMmYoMCwgMSk7CiAgICBnbFZlcnRleDNmKDAsIDEwMCwgMCk7CiAgICBnbFRleENvb3JkMmYoMSwgMSk7CiAgICBnbFZlcnRleDNmKDEwMCwgMTAwLCAwKTsKICAgIGdsVGV4Q29vcmQyZigxLCAwKTsKICAgIGdsVmVydGV4M2YoMTAwLCAwLCAwKTsKICAgIGdsRW5kKCk7CgogICAgZ2xEaXNhYmxlKEdMX1RFWFRVUkVfMkQpOwogICAgZ2xCaW5kVGV4dHVyZShHTF9URVhUVVJFXzJELCAwKTsKCiAgICBnbFBvcE1hdHJpeCgpOwoKICAgIGdsTWF0cml4TW9kZShHTF9QUk9KRUNUSU9OKTsKICAgIGdsUG9wTWF0cml4KCk7CgogICAgZ2xNYXRyaXhNb2RlKEdMX01PREVMVklFVyk7CgogICAgZ2xGbHVzaCgpOwoKICAgIHdpbmRvdy5zd2FwQnVmZmVycygpOwogICAgcG9sbCgpOwogIH0KfQoKdHJ5IHsKICBtYWluKC4uLnNjcmlwdEFyZ3Muc2xpY2UoMSkpOwp9IGNhdGNoKGVycm9yKSB7CiAgY29uc29sZS5sb2coYEZBSUw6ICR7ZXJyb3IubWVzc2FnZX1cbiR7ZXJyb3Iuc3RhY2t9YCk7CiAgc3RkLmV4aXQoMSk7Cn0gZmluYWxseSB7CiAgY29uc29sZS5sb2coJ1NVQ0NFU1MnKTsKfQoAAAAAAAAAAJMRAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMwKAAAAAAAAzAoAAAAAAAAAAAAAAADwvw"
				],
				[
					758,
					1,
					"insert",
					{
						"characters": "[..."
					},
					"BAAAAF4NAAAAAAAAXw0AAAAAAAAAAAAAXw0AAAAAAABgDQAAAAAAAAAAAABgDQAAAAAAAGENAAAAAAAAAAAAAGENAAAAAAAAYg0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAF4NAAAAAAAAXg0AAAAAAAAAAAAAAADwvw"
				],
				[
					760,
					1,
					"insert",
					{
						"characters": "];"
					},
					"AgAAAHMNAAAAAAAAdA0AAAAAAAAAAAAAdA0AAAAAAAB1DQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAHMNAAAAAAAAcw0AAAAAAAAAAAAAAADwvw"
				],
				[
					761,
					1,
					"insert",
					{
						"characters": " //"
					},
					"AwAAAHUNAAAAAAAAdg0AAAAAAAAAAAAAdg0AAAAAAAB3DQAAAAAAAAAAAAB3DQAAAAAAAHgNAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAHUNAAAAAAAAdQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					766,
					4,
					"right_delete",
					null,
					"BAAAAIkNAAAAAAAAiQ0AAAAAAAACAAAAICCJDQAAAAAAAIkNAAAAAAAAAQAAAC+JDQAAAAAAAIkNAAAAAAAAAQAAAC+JDQAAAAAAAIkNAAAAAAAAAQAAACA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIkNAAAAAAAAiQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					769,
					1,
					"insert",
					{
						"characters": "color);"
					},
					"CAAAAJ4NAAAAAAAAnw0AAAAAAAAAAAAAnw0AAAAAAACfDQAAAAAAABYAAAAuLi5jb2xvci5ub3JtYWxpemUoKSk7nw0AAAAAAACgDQAAAAAAAAAAAACgDQAAAAAAAKENAAAAAAAAAAAAAKENAAAAAAAAog0AAAAAAAAAAAAAog0AAAAAAACjDQAAAAAAAAAAAACjDQAAAAAAAKQNAAAAAAAAAAAAAKQNAAAAAAAApQ0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ4NAAAAAAAAtA0AAAAAAAD////////vfw"
				],
				[
					778,
					1,
					"insert",
					{
						"characters": "mapN"
					},
					"BAAAABAOAAAAAAAAEQ4AAAAAAAAAAAAAEQ4AAAAAAAASDgAAAAAAAAAAAAASDgAAAAAAABMOAAAAAAAAAAAAABMOAAAAAAAAFA4AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABAOAAAAAAAAEA4AAAAAAAAAAAAAAADwvw"
				],
				[
					779,
					1,
					"left_delete",
					null,
					"AQAAABMOAAAAAAAAEw4AAAAAAAABAAAATg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABQOAAAAAAAAFA4AAAAAAAAAAAAAAADwvw"
				],
				[
					780,
					1,
					"insert",
					{
						"characters": "(n"
					},
					"AgAAABMOAAAAAAAAFA4AAAAAAAAAAAAAFA4AAAAAAAAVDgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABMOAAAAAAAAEw4AAAAAAAAAAAAAAADwvw"
				],
				[
					781,
					1,
					"insert",
					{
						"characters": " =>"
					},
					"AwAAABUOAAAAAAAAFg4AAAAAAAAAAAAAFg4AAAAAAAAXDgAAAAAAAAAAAAAXDgAAAAAAABgOAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABUOAAAAAAAAFQ4AAAAAAAAAAAAAAADwvw"
				],
				[
					782,
					1,
					"insert",
					{
						"characters": " n"
					},
					"AgAAABgOAAAAAAAAGQ4AAAAAAAAAAAAAGQ4AAAAAAAAaDgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABgOAAAAAAAAGA4AAAAAAAAAAAAAAADwvw"
				],
				[
					783,
					1,
					"insert",
					{
						"characters": "*"
					},
					"AQAAABoOAAAAAAAAGw4AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABoOAAAAAAAAGg4AAAAAAAAAAAAAAADwvw"
				],
				[
					784,
					1,
					"left_delete",
					null,
					"AQAAABoOAAAAAAAAGg4AAAAAAAABAAAAKg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABsOAAAAAAAAGw4AAAAAAAAAAAAAAADwvw"
				],
				[
					785,
					1,
					"insert",
					{
						"characters": "/255))"
					},
					"BgAAABoOAAAAAAAAGw4AAAAAAAAAAAAAGw4AAAAAAAAcDgAAAAAAAAAAAAAcDgAAAAAAAB0OAAAAAAAAAAAAAB0OAAAAAAAAHg4AAAAAAAAAAAAAHg4AAAAAAAAfDgAAAAAAAAAAAAAfDgAAAAAAACAOAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABoOAAAAAAAAGg4AAAAAAAAAAAAAAADwvw"
				],
				[
					787,
					1,
					"left_delete",
					null,
					"AQAAACAOAAAAAAAAIA4AAAAAAAANAAAAbm9ybWFsaXplKCkpOw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACAOAAAAAAAALQ4AAAAAAAD////////vfw"
				],
				[
					788,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAACAOAAAAAAAAIQ4AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACAOAAAAAAAAIA4AAAAAAAAAAAAAAADwvw"
				],
				[
					799,
					1,
					"doxy_enter",
					null,
					"AgAAAIUNAAAAAAAAhg0AAAAAAAAAAAAAhg0AAAAAAACKDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIUNAAAAAAAAhQ0AAAAAAAD////////vfw"
				],
				[
					800,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AwAAAIoNAAAAAAAAiw0AAAAAAAAAAAAAiw0AAAAAAACPDQAAAAAAAAAAAACGDQAAAAAAAIYNAAAAAAAABAAAACAgICA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIoNAAAAAAAAig0AAAAAAAAAAAAAAADwvw"
				],
				[
					803,
					1,
					"insert",
					{
						"characters": "color"
					},
					"BQAAAIsNAAAAAAAAjA0AAAAAAAAAAAAAjA0AAAAAAACNDQAAAAAAAAAAAACNDQAAAAAAAI4NAAAAAAAAAAAAAI4NAAAAAAAAjw0AAAAAAAAAAAAAjw0AAAAAAACQDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIsNAAAAAAAAiw0AAAAAAAAAAAAAAADwvw"
				],
				[
					804,
					1,
					"insert",
					{
						"characters": " ="
					},
					"AgAAAJANAAAAAAAAkQ0AAAAAAAAAAAAAkQ0AAAAAAACSDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJANAAAAAAAAkA0AAAAAAAAAAAAAAADwvw"
				],
				[
					805,
					1,
					"insert",
					{
						"characters": " interpolate"
					},
					"DAAAAJINAAAAAAAAkw0AAAAAAAAAAAAAkw0AAAAAAACUDQAAAAAAAAAAAACUDQAAAAAAAJUNAAAAAAAAAAAAAJUNAAAAAAAAlg0AAAAAAAAAAAAAlg0AAAAAAACXDQAAAAAAAAAAAACXDQAAAAAAAJgNAAAAAAAAAAAAAJgNAAAAAAAAmQ0AAAAAAAAAAAAAmQ0AAAAAAACaDQAAAAAAAAAAAACaDQAAAAAAAJsNAAAAAAAAAAAAAJsNAAAAAAAAnA0AAAAAAAAAAAAAnA0AAAAAAACdDQAAAAAAAAAAAACdDQAAAAAAAJ4NAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJINAAAAAAAAkg0AAAAAAAAAAAAAAADwvw"
				],
				[
					806,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAJ4NAAAAAAAAoA0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ4NAAAAAAAAng0AAAAAAAAAAAAAAADwvw"
				],
				[
					807,
					1,
					"insert",
					{
						"characters": "color,"
					},
					"BgAAAJ8NAAAAAAAAoA0AAAAAAAAAAAAAoA0AAAAAAAChDQAAAAAAAAAAAAChDQAAAAAAAKINAAAAAAAAAAAAAKINAAAAAAAAow0AAAAAAAAAAAAAow0AAAAAAACkDQAAAAAAAAAAAACkDQAAAAAAAKUNAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ8NAAAAAAAAnw0AAAAAAAAAAAAAAADwvw"
				],
				[
					808,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAKUNAAAAAAAApg0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKUNAAAAAAAApQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					809,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAKYNAAAAAAAAqA0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKYNAAAAAAAApg0AAAAAAAAAAAAAAADwvw"
				],
				[
					810,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAKYNAAAAAAAApg0AAAAAAAABAAAAW6YNAAAAAAAApg0AAAAAAAABAAAAXQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKcNAAAAAAAApw0AAAAAAAAAAAAAAADwvw"
				],
				[
					811,
					1,
					"insert",
					{
						"characters": "sine"
					},
					"BAAAAKYNAAAAAAAApw0AAAAAAAAAAAAApw0AAAAAAACoDQAAAAAAAAAAAACoDQAAAAAAAKkNAAAAAAAAAAAAAKkNAAAAAAAAqg0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKYNAAAAAAAApg0AAAAAAAAAAAAAAADwvw"
				],
				[
					812,
					1,
					"insert",
					{
						"characters": " >"
					},
					"AgAAAKoNAAAAAAAAqw0AAAAAAAAAAAAAqw0AAAAAAACsDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKoNAAAAAAAAqg0AAAAAAAAAAAAAAADwvw"
				],
				[
					813,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAKwNAAAAAAAArQ0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKwNAAAAAAAArA0AAAAAAAAAAAAAAADwvw"
				],
				[
					814,
					1,
					"left_delete",
					null,
					"AQAAAKwNAAAAAAAArA0AAAAAAAABAAAAIA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAK0NAAAAAAAArQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					815,
					1,
					"insert",
					{
						"characters": "="
					},
					"AQAAAKwNAAAAAAAArQ0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKwNAAAAAAAArA0AAAAAAAAAAAAAAADwvw"
				],
				[
					816,
					1,
					"insert",
					{
						"characters": " 0"
					},
					"AgAAAK0NAAAAAAAArg0AAAAAAAAAAAAArg0AAAAAAACvDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAK0NAAAAAAAArQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					817,
					1,
					"insert",
					{
						"characters": " ?"
					},
					"AgAAAK8NAAAAAAAAsA0AAAAAAAAAAAAAsA0AAAAAAACxDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAK8NAAAAAAAArw0AAAAAAAAAAAAAAADwvw"
				],
				[
					818,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAALENAAAAAAAAsg0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALENAAAAAAAAsQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					819,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAALINAAAAAAAAtA0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALINAAAAAAAAsg0AAAAAAAAAAAAAAADwvw"
				],
				[
					820,
					1,
					"insert",
					{
						"characters": "255,255,255,255"
					},
					"DwAAALMNAAAAAAAAtA0AAAAAAAAAAAAAtA0AAAAAAAC1DQAAAAAAAAAAAAC1DQAAAAAAALYNAAAAAAAAAAAAALYNAAAAAAAAtw0AAAAAAAAAAAAAtw0AAAAAAAC4DQAAAAAAAAAAAAC4DQAAAAAAALkNAAAAAAAAAAAAALkNAAAAAAAAug0AAAAAAAAAAAAAug0AAAAAAAC7DQAAAAAAAAAAAAC7DQAAAAAAALwNAAAAAAAAAAAAALwNAAAAAAAAvQ0AAAAAAAAAAAAAvQ0AAAAAAAC+DQAAAAAAAAAAAAC+DQAAAAAAAL8NAAAAAAAAAAAAAL8NAAAAAAAAwA0AAAAAAAAAAAAAwA0AAAAAAADBDQAAAAAAAAAAAADBDQAAAAAAAMINAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAALMNAAAAAAAAsw0AAAAAAAAAAAAAAADwvw"
				],
				[
					822,
					1,
					"insert",
					{
						"characters": " :"
					},
					"AgAAAMMNAAAAAAAAxA0AAAAAAAAAAAAAxA0AAAAAAADFDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMMNAAAAAAAAww0AAAAAAAAAAAAAAADwvw"
				],
				[
					823,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAMUNAAAAAAAAxg0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMUNAAAAAAAAxQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					824,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAMYNAAAAAAAAyA0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMYNAAAAAAAAxg0AAAAAAAAAAAAAAADwvw"
				],
				[
					825,
					1,
					"insert",
					{
						"characters": "25"
					},
					"AgAAAMcNAAAAAAAAyA0AAAAAAAAAAAAAyA0AAAAAAADJDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMcNAAAAAAAAxw0AAAAAAAAAAAAAAADwvw"
				],
				[
					826,
					2,
					"left_delete",
					null,
					"AgAAAMgNAAAAAAAAyA0AAAAAAAABAAAANccNAAAAAAAAxw0AAAAAAAABAAAAMg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMkNAAAAAAAAyQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					827,
					1,
					"insert",
					{
						"characters": "0,0,0,"
					},
					"BgAAAMcNAAAAAAAAyA0AAAAAAAAAAAAAyA0AAAAAAADJDQAAAAAAAAAAAADJDQAAAAAAAMoNAAAAAAAAAAAAAMoNAAAAAAAAyw0AAAAAAAAAAAAAyw0AAAAAAADMDQAAAAAAAAAAAADMDQAAAAAAAM0NAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMcNAAAAAAAAxw0AAAAAAAAAAAAAAADwvw"
				],
				[
					828,
					1,
					"left_delete",
					null,
					"AQAAAMwNAAAAAAAAzA0AAAAAAAABAAAALA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAM0NAAAAAAAAzQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					829,
					1,
					"insert",
					{
						"characters": ",255"
					},
					"BAAAAMwNAAAAAAAAzQ0AAAAAAAAAAAAAzQ0AAAAAAADODQAAAAAAAAAAAADODQAAAAAAAM8NAAAAAAAAAAAAAM8NAAAAAAAA0A0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAMwNAAAAAAAAzA0AAAAAAAAAAAAAAADwvw"
				],
				[
					831,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAANENAAAAAAAA0g0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANENAAAAAAAA0Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					837,
					1,
					"insert",
					{
						"characters": ","
					},
					"AQAAANENAAAAAAAA0g0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANENAAAAAAAA0Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					838,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAANINAAAAAAAA0w0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANINAAAAAAAA0g0AAAAAAAAAAAAAAADwvw"
				],
				[
					843,
					1,
					"insert",
					{
						"characters": "Math.abs"
					},
					"CAAAANMNAAAAAAAA1A0AAAAAAAAAAAAA1A0AAAAAAADVDQAAAAAAAAAAAADVDQAAAAAAANYNAAAAAAAAAAAAANYNAAAAAAAA1w0AAAAAAAAAAAAA1w0AAAAAAADYDQAAAAAAAAAAAADYDQAAAAAAANkNAAAAAAAAAAAAANkNAAAAAAAA2g0AAAAAAAAAAAAA2g0AAAAAAADbDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANMNAAAAAAAA0w0AAAAAAAAAAAAAAADwvw"
				],
				[
					844,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAANsNAAAAAAAA3Q0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANsNAAAAAAAA2w0AAAAAAAAAAAAAAADwvw"
				],
				[
					845,
					1,
					"insert",
					{
						"characters": "sine"
					},
					"BAAAANwNAAAAAAAA3Q0AAAAAAAAAAAAA3Q0AAAAAAADeDQAAAAAAAAAAAADeDQAAAAAAAN8NAAAAAAAAAAAAAN8NAAAAAAAA4A0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAANwNAAAAAAAA3A0AAAAAAAAAAAAAAADwvw"
				],
				[
					847,
					1,
					"insert",
					{
						"characters": ")"
					},
					"AQAAAOENAAAAAAAA4g0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOENAAAAAAAA4Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					849,
					1,
					"cut",
					null,
					"AQAAAOINAAAAAAAA4g0AAAAAAAACAAAAICk",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOINAAAAAAAA5A0AAAAAAAD////////vfw"
				],
				[
					850,
					1,
					"left_delete",
					null,
					"AQAAAOENAAAAAAAA4Q0AAAAAAAABAAAAKQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOINAAAAAAAA4g0AAAAAAAAAAAAAAADwvw"
				],
				[
					851,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAOENAAAAAAAA4w0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOENAAAAAAAA4Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					853,
					2,
					"left_delete",
					null,
					"AgAAAOINAAAAAAAA4g0AAAAAAAABAAAAKeENAAAAAAAA4Q0AAAAAAAABAAAAKA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOMNAAAAAAAA4w0AAAAAAAAAAAAAAADwvw"
				],
				[
					854,
					1,
					"insert",
					{
						"characters": ");"
					},
					"AgAAAOENAAAAAAAA4g0AAAAAAAAAAAAA4g0AAAAAAADjDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOENAAAAAAAA4Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					879,
					1,
					"insert",
					{
						"characters": ".map"
					},
					"BAAAAOINAAAAAAAA4w0AAAAAAAAAAAAA4w0AAAAAAADkDQAAAAAAAAAAAADkDQAAAAAAAOUNAAAAAAAAAAAAAOUNAAAAAAAA5g0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOINAAAAAAAA4g0AAAAAAAAAAAAAAADwvw"
				],
				[
					880,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAOYNAAAAAAAA6A0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOYNAAAAAAAA5g0AAAAAAAAAAAAAAADwvw"
				],
				[
					881,
					1,
					"insert",
					{
						"characters": "Math.ronud"
					},
					"CgAAAOcNAAAAAAAA6A0AAAAAAAAAAAAA6A0AAAAAAADpDQAAAAAAAAAAAADpDQAAAAAAAOoNAAAAAAAAAAAAAOoNAAAAAAAA6w0AAAAAAAAAAAAA6w0AAAAAAADsDQAAAAAAAAAAAADsDQAAAAAAAO0NAAAAAAAAAAAAAO0NAAAAAAAA7g0AAAAAAAAAAAAA7g0AAAAAAADvDQAAAAAAAAAAAADvDQAAAAAAAPANAAAAAAAAAAAAAPANAAAAAAAA8Q0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOcNAAAAAAAA5w0AAAAAAAAAAAAAAADwvw"
				],
				[
					883,
					4,
					"left_delete",
					null,
					"BAAAAPENAAAAAAAA8Q0AAAAAAAABAAAAKfANAAAAAAAA8A0AAAAAAAABAAAAZO8NAAAAAAAA7w0AAAAAAAABAAAAde4NAAAAAAAA7g0AAAAAAAABAAAAbg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPINAAAAAAAA8g0AAAAAAAAAAAAAAADwvw"
				],
				[
					884,
					1,
					"insert",
					{
						"characters": "und)"
					},
					"BAAAAO4NAAAAAAAA7w0AAAAAAAAAAAAA7w0AAAAAAADwDQAAAAAAAAAAAADwDQAAAAAAAPENAAAAAAAAAAAAAPENAAAAAAAA8g0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAO4NAAAAAAAA7g0AAAAAAAAAAAAAAADwvw"
				],
				[
					894,
					1,
					"insert",
					{
						"characters": "/2"
					},
					"AgAAAOENAAAAAAAA4g0AAAAAAAAAAAAA4g0AAAAAAADjDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOENAAAAAAAA4Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					903,
					1,
					"left_delete",
					null,
					"AQAAAOINAAAAAAAA4g0AAAAAAAABAAAAMg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOMNAAAAAAAA4w0AAAAAAAAAAAAAAMCMQA"
				],
				[
					904,
					1,
					"left_delete",
					null,
					"AQAAAOENAAAAAAAA4Q0AAAAAAAABAAAALw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOINAAAAAAAA4g0AAAAAAAAAAAAAAADwvw"
				],
				[
					905,
					1,
					"insert",
					{
						"characters": "*.08"
					},
					"BAAAAOENAAAAAAAA4g0AAAAAAAAAAAAA4g0AAAAAAADjDQAAAAAAAAAAAADjDQAAAAAAAOQNAAAAAAAAAAAAAOQNAAAAAAAA5Q0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOENAAAAAAAA4Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					906,
					1,
					"left_delete",
					null,
					"AQAAAOQNAAAAAAAA5A0AAAAAAAABAAAAOA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOUNAAAAAAAA5Q0AAAAAAAAAAAAAAADwvw"
				],
				[
					907,
					1,
					"insert",
					{
						"characters": "87"
					},
					"AgAAAOQNAAAAAAAA5Q0AAAAAAAAAAAAA5Q0AAAAAAADmDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOQNAAAAAAAA5A0AAAAAAAAAAAAAAADwvw"
				],
				[
					908,
					3,
					"left_delete",
					null,
					"AwAAAOUNAAAAAAAA5Q0AAAAAAAABAAAAN+QNAAAAAAAA5A0AAAAAAAABAAAAOOMNAAAAAAAA4w0AAAAAAAABAAAAMA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOYNAAAAAAAA5g0AAAAAAAAAAAAAAADwvw"
				],
				[
					909,
					1,
					"insert",
					{
						"characters": "875"
					},
					"AwAAAOMNAAAAAAAA5A0AAAAAAAAAAAAA5A0AAAAAAADlDQAAAAAAAAAAAADlDQAAAAAAAOYNAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOMNAAAAAAAA4w0AAAAAAAAAAAAAAADwvw"
				],
				[
					915,
					1,
					"insert",
					{
						"characters": "90"
					},
					"AgAAAOINAAAAAAAA4w0AAAAAAAAAAAAA4w0AAAAAAADkDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOINAAAAAAAA4g0AAAAAAAAAAAAAAADwvw"
				],
				[
					916,
					2,
					"left_delete",
					null,
					"AgAAAOMNAAAAAAAA4w0AAAAAAAABAAAAMOINAAAAAAAA4g0AAAAAAAABAAAAOQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOQNAAAAAAAA5A0AAAAAAAAAAAAAAADwvw"
				],
				[
					917,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AQAAAOINAAAAAAAA4w0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOINAAAAAAAA4g0AAAAAAAAAAAAAAADwvw"
				],
				[
					921,
					3,
					"right_delete",
					null,
					"AwAAAOQNAAAAAAAA5A0AAAAAAAABAAAAOOQNAAAAAAAA5A0AAAAAAAABAAAAN+QNAAAAAAAA5A0AAAAAAAABAAAANQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOQNAAAAAAAA5A0AAAAAAAAAAAAAAADwvw"
				],
				[
					922,
					1,
					"insert",
					{
						"characters": "3"
					},
					"AQAAAOQNAAAAAAAA5Q0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAOQNAAAAAAAA5A0AAAAAAAAAAAAAAADwvw"
				],
				[
					929,
					1,
					"left_delete",
					null,
					"AQAAAPkNAAAAAAAA+Q0AAAAAAABuAAAAICBjb25zb2xlLmxvZygiY29sb3IiLCBjb2xvcik7CgogICAgY29uc29sZS5sb2coJ2luZGV4ICUgMzYwJywgaW5kZXggJSAzNjApOwogICAgY29uc29sZS5sb2coJ2NvbG9yJywgY29sb3IpOwo",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPkNAAAAAAAAZw4AAAAAAAAAAAAAAAAAAA"
				],
				[
					935,
					1,
					"left_delete",
					null,
					"AQAAAPcNAAAAAAAA9w0AAAAAAAABAAAACg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAPgNAAAAAAAA+A0AAAAAAAAAAAAAAAAAAA"
				],
				[
					939,
					1,
					"left_delete",
					null,
					"AQAAAC4NAAAAAAAALg0AAAAAAAAgAAAAICAgIGNvbnNvbGUubG9nKCdzaW5lJywgc2luZSk7Cgo",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAC4NAAAAAAAATg0AAAAAAAAAAAAAAAAAAA"
				],
				[
					967,
					1,
					"insert",
					{
						"characters": ",37"
					},
					"AwAAAE8KAAAAAAAAUAoAAAAAAAAAAAAAUAoAAAAAAABRCgAAAAAAAAAAAABRCgAAAAAAAFIKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAE8KAAAAAAAATwoAAAAAAAAAAAAAAADwvw"
				],
				[
					968,
					1,
					"left_delete",
					null,
					"AQAAAFEKAAAAAAAAUQoAAAAAAAABAAAANw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFIKAAAAAAAAUgoAAAAAAAAAAAAAAADwvw"
				],
				[
					969,
					1,
					"insert",
					{
						"characters": "6"
					},
					"AQAAAFEKAAAAAAAAUgoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFEKAAAAAAAAUQoAAAAAAAAAAAAAAADwvw"
				],
				[
					972,
					1,
					"insert",
					{
						"characters": "*4"
					},
					"AgAAAFIKAAAAAAAAUwoAAAAAAAAAAAAAUwoAAAAAAABUCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFIKAAAAAAAAUgoAAAAAAAAAAAAAAADwvw"
				],
				[
					975,
					2,
					"left_delete",
					null,
					"AgAAAFMKAAAAAAAAUwoAAAAAAAABAAAANFIKAAAAAAAAUgoAAAAAAAABAAAAKg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFQKAAAAAAAAVAoAAAAAAAAAAAAAAADwvw"
				],
				[
					976,
					1,
					"insert",
					{
						"characters": "/3"
					},
					"AgAAAFIKAAAAAAAAUwoAAAAAAAAAAAAAUwoAAAAAAABUCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFIKAAAAAAAAUgoAAAAAAAAAAAAAAADwvw"
				],
				[
					979,
					4,
					"left_delete",
					null,
					"BAAAAFMKAAAAAAAAUwoAAAAAAAABAAAAM1IKAAAAAAAAUgoAAAAAAAABAAAAL1EKAAAAAAAAUQoAAAAAAAABAAAANlAKAAAAAAAAUAoAAAAAAAABAAAAMw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFQKAAAAAAAAVAoAAAAAAAAAAAAAAADwvw"
				],
				[
					980,
					1,
					"insert",
					{
						"characters": "16"
					},
					"AgAAAFAKAAAAAAAAUQoAAAAAAAAAAAAAUQoAAAAAAABSCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFAKAAAAAAAAUAoAAAAAAAAAAAAAAADwvw"
				],
				[
					987,
					1,
					"insert",
					{
						"characters": ".Ã¶e"
					},
					"AwAAAIMLAAAAAAAAhAsAAAAAAAAAAAAAhAsAAAAAAACFCwAAAAAAAAAAAACFCwAAAAAAAIYLAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIMLAAAAAAAAgwsAAAAAAAAAAAAAAADwvw"
				],
				[
					988,
					2,
					"left_delete",
					null,
					"AgAAAIULAAAAAAAAhQsAAAAAAAABAAAAZYQLAAAAAAAAhAsAAAAAAAACAAAAw7Y",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIYLAAAAAAAAhgsAAAAAAAAAAAAAAADwvw"
				],
				[
					989,
					1,
					"insert",
					{
						"characters": "length"
					},
					"BgAAAIQLAAAAAAAAhQsAAAAAAAAAAAAAhQsAAAAAAACGCwAAAAAAAAAAAACGCwAAAAAAAIcLAAAAAAAAAAAAAIcLAAAAAAAAiAsAAAAAAAAAAAAAiAsAAAAAAACJCwAAAAAAAAAAAACJCwAAAAAAAIoLAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIQLAAAAAAAAhAsAAAAAAAAAAAAAAADwvw"
				],
				[
					994,
					1,
					"left_delete",
					null,
					"AQAAAFAKAAAAAAAAUAoAAAAAAAABAAAAMQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFEKAAAAAAAAUQoAAAAAAAAAAAAAAADwvw"
				],
				[
					995,
					1,
					"insert",
					{
						"characters": "3"
					},
					"AQAAAFAKAAAAAAAAUQoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFAKAAAAAAAAUAoAAAAAAAAAAAAAAADwvw"
				],
				[
					996,
					2,
					"left_delete",
					null,
					"AgAAAFAKAAAAAAAAUAoAAAAAAAABAAAAM08KAAAAAAAATwoAAAAAAAABAAAALA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFEKAAAAAAAAUQoAAAAAAAAAAAAAAADwvw"
				],
				[
					997,
					1,
					"insert",
					{
						"characters": "369"
					},
					"AwAAAE8KAAAAAAAAUAoAAAAAAAAAAAAAUAoAAAAAAABRCgAAAAAAAAAAAABRCgAAAAAAAFIKAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAE8KAAAAAAAATwoAAAAAAAAAAAAAAADwvw"
				],
				[
					998,
					3,
					"left_delete",
					null,
					"AwAAAFEKAAAAAAAAUQoAAAAAAAABAAAAOVAKAAAAAAAAUAoAAAAAAAABAAAANk8KAAAAAAAATwoAAAAAAAABAAAAMw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFIKAAAAAAAAUgoAAAAAAAAAAAAAAADwvw"
				],
				[
					999,
					1,
					"insert",
					{
						"characters": ",369"
					},
					"BAAAAE8KAAAAAAAAUAoAAAAAAAAAAAAAUAoAAAAAAABRCgAAAAAAAAAAAABRCgAAAAAAAFIKAAAAAAAAAAAAAFIKAAAAAAAAUwoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAE8KAAAAAAAATwoAAAAAAAAAAAAAAADwvw"
				],
				[
					1000,
					2,
					"left_delete",
					null,
					"AgAAAFIKAAAAAAAAUgoAAAAAAAABAAAAOVEKAAAAAAAAUQoAAAAAAAABAAAANg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFMKAAAAAAAAUwoAAAAAAAAAAAAAAADwvw"
				],
				[
					1001,
					1,
					"insert",
					{
						"characters": "59/16"
					},
					"BQAAAFEKAAAAAAAAUgoAAAAAAAAAAAAAUgoAAAAAAABTCgAAAAAAAAAAAABTCgAAAAAAAFQKAAAAAAAAAAAAAFQKAAAAAAAAVQoAAAAAAAAAAAAAVQoAAAAAAABWCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFEKAAAAAAAAUQoAAAAAAAAAAAAAAADwvw"
				],
				[
					1002,
					1,
					"right_delete",
					null,
					"AQAAAFYKAAAAAAAAVgoAAAAAAAABAAAANg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFYKAAAAAAAAVgoAAAAAAAAAAAAAAADwvw"
				],
				[
					1009,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAAFcKAAAAAAAAWAoAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFcKAAAAAAAAVwoAAAAAAAD////////vfw"
				],
				[
					1011,
					1,
					"left_delete",
					null,
					"AgAAAFIKAAAAAAAAUgoAAAAAAAABAAAAOVEKAAAAAAAAUQoAAAAAAAABAAAANQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFMKAAAAAAAAUwoAAAAAAAAAAAAAAADwvw"
				],
				[
					1012,
					1,
					"insert",
					{
						"characters": "60"
					},
					"AgAAAFEKAAAAAAAAUgoAAAAAAAAAAAAAUgoAAAAAAABTCgAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFEKAAAAAAAAUQoAAAAAAAAAAAAAAADwvw"
				],
				[
					1028,
					1,
					"left_delete",
					null,
					"AQAAAFcKAAAAAAAAVwoAAAAAAAABAAAAOw",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAFgKAAAAAAAAWAoAAAAAAAD////////vfw"
				],
				[
					1039,
					3,
					"right_delete",
					null,
					"AwAAAF0NAAAAAAAAXQ0AAAAAAAABAAAAM10NAAAAAAAAXQ0AAAAAAAABAAAANl0NAAAAAAAAXQ0AAAAAAAABAAAAMA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAF0NAAAAAAAAXQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					1040,
					1,
					"insert",
					{
						"characters": "16"
					},
					"AgAAAF0NAAAAAAAAXg0AAAAAAAAAAAAAXg0AAAAAAABfDQAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAF0NAAAAAAAAXQ0AAAAAAAAAAAAAAADwvw"
				],
				[
					1050,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AQAAAAoNAAAAAAAACw0AAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAoNAAAAAAAACg0AAAAAAAAAAAAAAADwvw"
				],
				[
					1062,
					7,
					"left_delete",
					null,
					"BwAAAI0LAAAAAAAAjQsAAAAAAAABAAAAaIwLAAAAAAAAjAsAAAAAAAABAAAAdIsLAAAAAAAAiwsAAAAAAAABAAAAZ4oLAAAAAAAAigsAAAAAAAABAAAAbokLAAAAAAAAiQsAAAAAAAABAAAAZYgLAAAAAAAAiAsAAAAAAAABAAAAbIcLAAAAAAAAhwsAAAAAAAABAAAALg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAI4LAAAAAAAAjgsAAAAAAAAAAAAAAADwvw"
				],
				[
					1066,
					1,
					"insert",
					{
						"characters": "[..."
					},
					"BAAAAIMLAAAAAAAAhAsAAAAAAAAAAAAAhAsAAAAAAACFCwAAAAAAAAAAAACFCwAAAAAAAIYLAAAAAAAAAAAAAIYLAAAAAAAAhwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIMLAAAAAAAAgwsAAAAAAAAAAAAAAADwvw"
				],
				[
					1068,
					1,
					"insert",
					{
						"characters": "]"
					},
					"AQAAAIsLAAAAAAAAjAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIsLAAAAAAAAiwsAAAAAAAAAAAAAAADwvw"
				],
				[
					1072,
					4,
					"right_delete",
					null,
					"BAAAAIMLAAAAAAAAgwsAAAAAAAABAAAAW4MLAAAAAAAAgwsAAAAAAAABAAAALoMLAAAAAAAAgwsAAAAAAAABAAAALoMLAAAAAAAAgwsAAAAAAAABAAAALg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIMLAAAAAAAAgwsAAAAAAAAAAAAAAADwvw"
				],
				[
					1074,
					1,
					"insert",
					{
						"characters": ".map"
					},
					"BAAAAIcLAAAAAAAAiAsAAAAAAAAAAAAAiAsAAAAAAACJCwAAAAAAAAAAAACJCwAAAAAAAIoLAAAAAAAAAAAAAIoLAAAAAAAAiwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIcLAAAAAAAAhwsAAAAAAAAAAAAAAADwvw"
				],
				[
					1075,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAIsLAAAAAAAAjQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIsLAAAAAAAAiwsAAAAAAAAAAAAAAADwvw"
				],
				[
					1076,
					1,
					"insert",
					{
						"characters": "c"
					},
					"AQAAAIwLAAAAAAAAjQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAIwLAAAAAAAAjAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1077,
					1,
					"insert",
					{
						"characters": " =>"
					},
					"AwAAAI0LAAAAAAAAjgsAAAAAAAAAAAAAjgsAAAAAAACPCwAAAAAAAAAAAACPCwAAAAAAAJALAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAI0LAAAAAAAAjQsAAAAAAAAAAAAAAADwvw"
				],
				[
					1078,
					1,
					"insert",
					{
						"characters": " "
					},
					"AQAAAJALAAAAAAAAkQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJALAAAAAAAAkAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1079,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAJELAAAAAAAAkwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJELAAAAAAAAkQsAAAAAAAAAAAAAAADwvw"
				],
				[
					1080,
					1,
					"insert",
					{
						"characters": "...c"
					},
					"BAAAAJILAAAAAAAAkwsAAAAAAAAAAAAAkwsAAAAAAACUCwAAAAAAAAAAAACUCwAAAAAAAJULAAAAAAAAAAAAAJULAAAAAAAAlgsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJILAAAAAAAAkgsAAAAAAAAAAAAAAADwvw"
				],
				[
					1082,
					1,
					"right_delete",
					null,
					"AQAAAJgLAAAAAAAAmAsAAAAAAAABAAAAXQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJgLAAAAAAAAmAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1089,
					1,
					"insert",
					{
						"characters": ".map"
					},
					"BAAAAJgLAAAAAAAAmQsAAAAAAAAAAAAAmQsAAAAAAACaCwAAAAAAAAAAAACaCwAAAAAAAJsLAAAAAAAAAAAAAJsLAAAAAAAAnAsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJgLAAAAAAAAmAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1090,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAJwLAAAAAAAAngsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJwLAAAAAAAAnAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1091,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAJwLAAAAAAAAnAsAAAAAAAABAAAAKJwLAAAAAAAAnAsAAAAAAAABAAAAKQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ0LAAAAAAAAnQsAAAAAAAAAAAAAAADwvw"
				],
				[
					1092,
					4,
					"left_delete",
					null,
					"BAAAAJsLAAAAAAAAmwsAAAAAAAABAAAAcJoLAAAAAAAAmgsAAAAAAAABAAAAYZkLAAAAAAAAmQsAAAAAAAABAAAAbZgLAAAAAAAAmAsAAAAAAAABAAAALg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJwLAAAAAAAAnAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1106,
					1,
					"insert",
					{
						"characters": ".slic"
					},
					"BQAAAJcLAAAAAAAAmAsAAAAAAAAAAAAAmAsAAAAAAACZCwAAAAAAAAAAAACZCwAAAAAAAJoLAAAAAAAAAAAAAJoLAAAAAAAAmwsAAAAAAAAAAAAAmwsAAAAAAACcCwAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJcLAAAAAAAAlwsAAAAAAAAAAAAAAADwvw"
				],
				[
					1107,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAJwLAAAAAAAAngsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJwLAAAAAAAAnAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1108,
					1,
					"run_macro_file",
					{
						"file": "res://Packages/Default/Delete Left Right.sublime-macro"
					},
					"AgAAAJwLAAAAAAAAnAsAAAAAAAABAAAAKJwLAAAAAAAAnAsAAAAAAAABAAAAKQ",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ0LAAAAAAAAnQsAAAAAAAAAAAAAAADwvw"
				],
				[
					1109,
					1,
					"insert",
					{
						"characters": "e"
					},
					"AQAAAJwLAAAAAAAAnQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJwLAAAAAAAAnAsAAAAAAAAAAAAAAADwvw"
				],
				[
					1110,
					1,
					"insert_snippet",
					{
						"contents": "($0)"
					},
					"AQAAAJ0LAAAAAAAAnwsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ0LAAAAAAAAnQsAAAAAAAAAAAAAAADwvw"
				],
				[
					1111,
					1,
					"insert",
					{
						"characters": "0,2"
					},
					"AwAAAJ4LAAAAAAAAnwsAAAAAAAAAAAAAnwsAAAAAAACgCwAAAAAAAAAAAACgCwAAAAAAAKELAAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAJ4LAAAAAAAAngsAAAAAAAAAAAAAAADwvw"
				],
				[
					1116,
					1,
					"left_delete",
					null,
					"AQAAAKALAAAAAAAAoAsAAAAAAAABAAAAMg",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKELAAAAAAAAoQsAAAAAAAAAAAAAAADwvw"
				],
				[
					1117,
					1,
					"insert",
					{
						"characters": "3"
					},
					"AQAAAKALAAAAAAAAoQsAAAAAAAAAAAAA",
					"CQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAKALAAAAAAAAoAsAAAAAAAAAAAAAAADwvw"
				]
			]
		},
		{
			"file": "test-nanovg.js",
			"settings":
			{
				"buffer_size": 3656,
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					37,
					1,
					"insert",
					{
						"characters": "\n\n"
					},
					"BQAAAAUGAAAAAAAABgYAAAAAAAAAAAAABgYAAAAAAAAIBgAAAAAAAAAAAAAIBgAAAAAAAAkGAAAAAAAAAAAAAAkGAAAAAAAACwYAAAAAAAAAAAAABgYAAAAAAAAGBgAAAAAAAAIAAAAgIA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAABQYAAAAAAAAFBgAAAAAAAAAAAAAAAPC/"
				],
				[
					38,
					1,
					"paste",
					null,
					"AQAAAAkGAAAAAAAASwYAAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAACQYAAAAAAAAJBgAAAAAAAAAAAAAAAPC/"
				],
				[
					41,
					1,
					"left_delete",
					null,
					"AQAAAEoGAAAAAAAASgYAAAAAAAABAAAACg",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAASwYAAAAAAABLBgAAAAAAAAAAAAAAAPC/"
				],
				[
					46,
					1,
					"revert",
					null,
					"CAAAAAAAAAAAAAAAAAAAAAAAAABKDgAAaW1wb3J0ICogYXMgZ2xmdyBmcm9tICdnbGZ3JzsKaW1wb3J0IHsgZ2xDbGVhciwgZ2xDbGVhckNvbG9yLCBnbFZpZXdwb3J0LCBHTF9DT0xPUl9CVUZGRVJfQklULCBHTF9ERVBUSF9CVUZGRVJfQklULCBHTF9TVEVOQ0lMX0JVRkZFUl9CSVQgfSBmcm9tICcuL2dsLmpzJzsKaW1wb3J0IHsgSFNMQSB9IGZyb20gJy4vbGliL2NvbG9yLmpzJzsKaW1wb3J0IHsgTWF0LCBQb2ludCB9IGZyb20gJ29wZW5jdic7CmltcG9ydCAqIGFzIGN2IGZyb20gJ29wZW5jdic7CmltcG9ydCAqIGFzIG52ZyBmcm9tICduYW5vdmcnOwppbXBvcnQgQ29uc29sZSBmcm9tICdjb25zb2xlJzsKaW1wb3J0IHsgR0xGVywgTWF0MkltYWdlLCBEcmF3SW1hZ2UsIERyYXdDaXJjbGUsIFBvc2l0aW9uIH0gZnJvbSAnLi9kcmF3LXV0aWxzLmpzJzsKCmZ1bmN0aW9uIG1haW4oLi4uYXJncykgewogIGdsb2JhbFRoaXMuY29uc29sZSA9IG5ldyBDb25zb2xlKHsKICAgIGluc3BlY3RPcHRpb25zOiB7CiAgICAgIG1heFN0cmluZ0xlbmd0aDogMjAwLAogICAgICBtYXhBcnJheUxlbmd0aDogMTAsCiAgICAgIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSwKICAgICAgY29tcGFjdDogMiwKICAgICAgZGVwdGg6IDEwCiAgICB9CiAgfSk7CgogIGxldCBpID0gMDsKICBsZXQgcnVubmluZyA9IHRydWU7CgogIGxldCBjb250ZXh0OwogIGNvbnN0IHsgcG9zaXRpb24sIHNpemUsIHdpbmRvdyB9ID0gKGNvbnRleHQgPSBuZXcgR0xGVygxMjgwLCA5MDAsIHsKICAgIHRpdGxlOiBzY3JpcHRBcmdzWzBdLAogICAgcmVzaXphYmxlOiB0cnVlLAogICAgaGFuZGxlU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7CiAgICAgIGNvbnNvbGUubG9nKCdyZXNpemVkJywgeyB3aWR0aCwgaGVpZ2h0IH0pOwogICAgfSwKICAgIGhhbmRsZUtleShrZXlDb2RlKSB7CiAgICAgIGxldCBjaGFyQ29kZSA9IGtleUNvZGUgJiAweGZmOwogICAgICBjb25zb2xlLmxvZyhgaGFuZGxlS2V5YCwgeyBrZXlDb2RlOiAnMHgnICsga2V5Q29kZS50b1N0cmluZygxNiksIGNoYXJDb2RlLCBjaGFyOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSB9KTsKICAgICAgbGV0IGNoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjaGFyQ29kZSk7CgogICAgICBsZXQgaGFuZGxlciA9IHsgJ1x4MDAnOiAoKSA9PiAocnVubmluZyA9IGZhbHNlKSwgUTogKCkgPT4gKHJ1bm5pbmcgPSBmYWxzZSkgfVtjaGFyXTsKICAgICAgaWYoaGFuZGxlcikgaGFuZGxlcigpOwogICAgfSwKICAgIGhhbmRsZUNoYXJNb2RzKGNoYXIsIG1vZHMpIHsKICAgICAgY29uc29sZS5sb2coYGhhbmRsZUNoYXJNb2RzYCwgeyBjaGFyLCBtb2RzIH0pOwogICAgfSwKICAgIGhhbmRsZU1vdXNlQnV0dG9uKGJ1dHRvbiwgYWN0aW9uLCBtb2RzKSB7CiAgICAgIGNvbnNvbGUubG9nKGBoYW5kbGVNb3VzZUJ1dHRvbmAsIHsgYnV0dG9uLCBhY3Rpb24sIG1vZHMgfSk7CiAgICB9LAogICAgaGFuZGxlQ3Vyc29yUG9zKHgsIHkpIHsKICAgICAgLy9jb25zb2xlLmxvZyhgaGFuZGxlQ3Vyc29yUG9zYCwgeyB4LCB5IH0pOwogICAgfQogIH0pKTsKCiAgICBudmcuQ3JlYXRlR0wzKG52Zy5TVEVOQ0lMX1NUUk9LRVMgfCBudmcuQU5USUFMSUFTIHwgbnZnLkRFQlVHKTsKCiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzaXplOwogIGNvbnN0IHsgeCwgeSB9ID0gcG9zaXRpb247CgogIC8vY29uc29sZS5sb2coYHdpZHRoOiAke3dpZHRofSwgaGVpZ2h0OiAke2hlaWdodH0sIHg6ICR7eH0sIHk6ICR7eX1gKTsKCiAgbGV0IG1hdCA9IG5ldyBNYXQoc2l6ZSwgY3YuQ1ZfOFVDNCk7CgogIG1hdC5zZXRUbyhbMTEsIDIyLCAzMywgMjU1XSk7CgogIGN2LmxpbmUobWF0LCBuZXcgUG9pbnQoMTAsIDEwKSwgbmV3IFBvaW50KHNpemUud2lkdGggLSAxMCwgc2l6ZS5oZWlnaHQgLSAxMCksIFsyNTUsIDI1NSwgMCwgMjU1XSwgNCwgY3YuTElORV9BQSk7CiAgY3YubGluZShtYXQsIG5ldyBQb2ludChzaXplLndpZHRoIC0gMTAsIDEwKSwgbmV3IFBvaW50KDEwLCBzaXplLmhlaWdodCAtIDEwKSwgWzI1NSwgMCwgMCwgMjU1XSwgNCwgY3YuTElORV9BQSk7CgogIGxldCBpbWFnZTIgPSBjdi5pbXJlYWQoJ0FyY2hpdGVrdHVyLnBuZycpOwoKICBsZXQgeyBidWZmZXIgfSA9IG1hdDsKCiAgbGV0IHBpeGVsczsKICBsZXQgaW1nSWQgPSBNYXQySW1hZ2UobWF0KTsKICBsZXQgaW1nMklkID0gbnZnLkNyZWF0ZUltYWdlKCdNdWVobGViZXJnLnBuZycsIDApOwoKICBsZXQgaW1nMlN6ID0gbnZnLkltYWdlU2l6ZShpbWcySWQpOwogIGxldCBpbWdTeiA9IG52Zy5JbWFnZVNpemUoaW1nSWQpOwoKICB3aGlsZSgocnVubmluZyAmJj0gIXdpbmRvdy5zaG91bGRDbG9zZSkpIHsKICAgIGxldCB0aW1lID0gK25ldyBEYXRlKCkgLyAxMDAwOwogICAgbGV0IGluZGV4ID0gTWF0aC5mbG9vcigodGltZSAqIDM2MCkgLyAzMCk7CiAgICBsZXQgY29sb3IgPSBuZXcgSFNMQShpbmRleCAlIDM2MCwgMTAwLCA1MCArIDI1ICogTWF0aC5zaW4odGltZSAqIDAuMSAqIE1hdGguUEkpKS50b1JHQkEoKTsKCiAgICBjb250ZXh0LmJlZ2luKGNvbG9yKTsKCiAgICBudmcuQmVnaW5GcmFtZSh3aWR0aCwgaGVpZ2h0LCAxKTsKCiAgICBsZXQgbSA9IG52Zy5DdXJyZW50VHJhbnNmb3JtKCk7CiAgICBsZXQgdCA9IG52Zy5UcmFuc2Zvcm1UcmFuc2xhdGUoW10sIDEwLCAyMCk7CiAgICBsZXQgcyA9IG52Zy5UcmFuc2Zvcm1TY2FsZShbXSwgMywgMyk7CgogICAgbGV0IHAgPSBudmcuVHJhbnNmb3JtTXVsdGlwbHkobnZnLlRyYW5zZm9ybU11bHRpcGx5KG0sIHQpLCBzKTsKCiAgICAvLyBsZXQgcGF0dGVybiA9IG52Zy5JbWFnZVBhdHRlcm4oMCwgMCwgLi4uaW1nMlN6LCAwLCBpbWcySWQsIDEpOwoKICAgIGxldCBjZW50ZXIgPSBuZXcgUG9zaXRpb24oc2l6ZS53aWR0aCAvIDIsIHNpemUuaGVpZ2h0IC8gMik7CiAgICBsZXQgaW1nU3pfMiA9IG5ldyBQb3NpdGlvbihpbWcyU3oud2lkdGggKiAtMC41LCBpbWcyU3ouaGVpZ2h0ICogLTAuNSk7CgogICAgbnZnLlNhdmUoKTsKCiAgICBudmcuVHJhbnNsYXRlKC4uLmNlbnRlcik7CiAgICBudmcuU2NhbGUoMC41LCAwLjUpOwogICAgbnZnLlRyYW5zbGF0ZSguLi5pbWdTel8yKTsKCiAgICBsZXQgcGhpID0gKChpICUgMzYwKSAvIDE4MCkgKiBNYXRoLlBJOwogICAgbGV0IHZlYyA9IFtNYXRoLmNvcyhwaGkpLCBNYXRoLnNpbihwaGkpXS5tYXAobiA9PiBuICogMTAwKTsKCiAgICBEcmF3SW1hZ2UoaW1nMklkLCB2ZWMpOwogICAgbnZnLlRyYW5zbGF0ZShpbWdTel8yLndpZHRoICogLTEsIGltZ1N6XzIuaGVpZ2h0ICogLTEpOwogICAgRHJhd0NpcmNsZShuZXcgUG9zaXRpb24oMCwgMCksIDQwKTsKCiAgICBudmcuUmVzdG9yZSgpOwoKICAgIERyYXdDaXJjbGUoY2VudGVyLCAxMDApOwoKICAgIG52Zy5FbmRGcmFtZSgpOwoKICAgIGNvbnRleHQuZW5kKCk7CiAgICAvKndpbmRvdy5zd2FwQnVmZmVycygpOwogICAgZ2xmdy5wb2xsKCk7Ki8KICAgIGkrKzsKICB9Cn0KCnRyeSB7CiAgbWFpbiguLi5zY3JpcHRBcmdzLnNsaWNlKDEpKTsKfSBjYXRjaChlcnJvcikgewogIC8vY29uc29sZS5sb2coYEZBSUw6ICR7ZXJyb3IubWVzc2FnZX1cbiR7ZXJyb3Iuc3RhY2t9YCk7CiAgc3RkLmV4aXQoMSk7Cn0gZmluYWxseSB7CiAgLy9jb25zb2xlLmxvZygnU1VDQ0VTUycpOwp9CgAAAAAAAAAASA4AAAAAAAAAAAAAAAAAAAAAAABIDgAAAAAAAAAAAAAAAAAAAAAAAEgOAAAAAAAAAAAAAAAAAAAAAAAASA4AAAAAAAAAAAAAAAAAAAAAAABIDgAAAAAAAAAAAAAAAAAAAAAAAEgOAAAAAAAAAAAAAAAAAAAAAAAASA4AAAAAAAAAAAAA",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAASgYAAAAAAABKBgAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "draw-utils.js",
			"settings":
			{
				"buffer_size": 4941,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					36,
					1,
					"cut",
					null,
					"AQAAAG4FAAAAAAAAbgUAAAAAAABCAAAAICBudmcuQ3JlYXRlR0wzKG52Zy5TVEVOQ0lMX1NUUk9LRVMgfCBudmcuQU5USUFMSUFTIHwgbnZnLkRFQlVHKTsK",
					"BwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAbgUAAAAAAACwBQAAAAAAAAAAAAAAAPC/"
				]
			]
		},
		{
			"file": "qjs-opencv/point.js",
			"settings":
			{
				"buffer_size": 2553,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/geom/point.js",
			"settings":
			{
				"buffer_size": 11150,
				"line_ending": "Unix"
			}
		},
		{
			"file": "check-discogs.js",
			"settings":
			{
				"buffer_size": 5103,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					48,
					1,
					"paste",
					null,
					"AQAAAAADAAAAAAAAZQMAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAADwvw"
				],
				[
					53,
					1,
					"insert",
					{
						"characters": "fetching"
					},
					"CQAAABEDAAAAAAAAEgMAAAAAAAAAAAAAEgMAAAAAAAASAwAAAAAAAAUAAABPcmRlchIDAAAAAAAAEwMAAAAAAAAAAAAAEwMAAAAAAAAUAwAAAAAAAAAAAAAUAwAAAAAAABUDAAAAAAAAAAAAABUDAAAAAAAAFgMAAAAAAAAAAAAAFgMAAAAAAAAXAwAAAAAAAAAAAAAXAwAAAAAAABgDAAAAAAAAAAAAABgDAAAAAAAAGQMAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABEDAAAAAAAAFgMAAAAAAAAAAAAAAADwvw"
				],
				[
					54,
					1,
					"insert",
					{
						"characters": " order"
					},
					"BgAAABkDAAAAAAAAGgMAAAAAAAAAAAAAGgMAAAAAAAAbAwAAAAAAAAAAAAAbAwAAAAAAABwDAAAAAAAAAAAAABwDAAAAAAAAHQMAAAAAAAAAAAAAHQMAAAAAAAAeAwAAAAAAAAAAAAAeAwAAAAAAAB8DAAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAABkDAAAAAAAAGQMAAAAAAAAAAAAAAADwvw"
				],
				[
					56,
					3,
					"right_delete",
					null,
					"AwAAACEDAAAAAAAAIQMAAAAAAAABAAAAICEDAAAAAAAAIQMAAAAAAAABAAAAICEDAAAAAAAAIQMAAAAAAAABAAAAJw",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACEDAAAAAAAAIQMAAAAAAAAAAAAAAADwvw"
				],
				[
					57,
					1,
					"insert_snippet",
					{
						"contents": "'$0'"
					},
					"AQAAACEDAAAAAAAAIwMAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACEDAAAAAAAAIQMAAAAAAAAAAAAAAADwvw"
				],
				[
					58,
					1,
					"insert",
					{
						"characters": "+id);"
					},
					"BQAAACIDAAAAAAAAIwMAAAAAAAAAAAAAIwMAAAAAAAAkAwAAAAAAAAAAAAAkAwAAAAAAACUDAAAAAAAAAAAAACUDAAAAAAAAJgMAAAAAAAAAAAAAJgMAAAAAAAAnAwAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACIDAAAAAAAAIgMAAAAAAAAAAAAAAADwvw"
				],
				[
					62,
					1,
					"cut",
					null,
					"AQAAACcDAAAAAAAAJwMAAAAAAABKAAAAJyArIENvbG9yU3RyKFsyNCwgMTYwLCAyNTVdLCAnaHR0cHM6Ly93d3cuZGlzY29ncy5jb20vc2VsbC9vcmRlci8nICsgaWQpKTs",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACcDAAAAAAAAcQMAAAAAAAD////////vfw"
				],
				[
					73,
					1,
					"paste",
					null,
					"AQAAACoQAAAAAAAAdhMAAAAAAAAAAAAA",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAACoQAAAAAAAAKhAAAAAAAAAAAAAAAADwvw"
				],
				[
					75,
					1,
					"cut",
					null,
					"AQAAAHYTAAAAAAAAdhMAAAAAAADpAQAAJ3NpZD1kZWIxNDMzMGY4OTk5NTU5OGI0Y2QzN2VjZDhmMGMzZDsgbGFuZ3VhZ2UyPWVuOyBja191c2VybmFtZT1kaXNrb3Nlbm47IHNlc3Npb249ImdaN25URFI1anBRa3hYTzdxNkYyTXVHNkVqdz0/X2V4cGlyZXM9TVRZMU5qSTNOemd4T1E9PSZhdXRoX3Rva2VuPUlrdENaMHRXYVdkeFdrcDNjV2R1Ynpaa1kwUm9NWHBFYjA5RUlnPT0mY3JlYXRlZF9hdD1Jakl3TWpFdE1USXRNamhVTWpFNk1UQTZNVGt1TkRNeE5EUXpJZz09JmlkcCUzQXVzZXJfaWQ9T0RNMk9UQXlNZz09IjsgbXBfc2Vzc2lvbj1lZDU3MDBmMjVmYWMzYzY0M2I4NzIxOTE7IHBwY19vbmJvYXJkX3Byb21wdD1zZWVuOyBfX2NmX2JtPXJVN1dybDQ5emlkbm1OejFjZllaa3M1TUhIYmxGc2FVSFJxa2suM19laGctMTY0NDc4MzAyNi0wLUFlRWZWRnZJRE5XSEkrb29IaFR3U0pjNDRjd2wyVVpTLzVVVG5MM0NnZXc0emxTOU96QzNwNXJXbC9iWk1JRTM1Q3hueGJFMVU4RUFieXJSWGxwQzIrWT0n",
					"BgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwvwAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPC/AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8L8AAAAAAQAAAHYTAAAAAAAAXxUAAAAAAAD////////vfw"
				]
			]
		},
		{
			"file": "lib/devtools.js",
			"settings":
			{
				"buffer_size": 31892,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "quickjs/quickjs-libc.c",
			"settings":
			{
				"buffer_size": 97640,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/color/rgba.js",
			"settings":
			{
				"buffer_size": 22482,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 19285 files for \"alpha, \" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/sys-root:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/imgui/imgui_widgets.cpp:\n 5824    // lead HSV values to be out of range)\n 5825    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;\n 5826:   draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);\n 5827    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, IM_COL32(128, 128, 128, 255), 12);\n 5828    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);\n\n/home/roman/Projects/plot-cv/opencv/filterdemo.cpp:\n   89  \n   90      float t = (float)cv::getTickCount();\n   91:     cv::ximgproc::anisotropicDiffusion(src, dst, alpha, sigma, niters);\n   92      t = (float)cv::getTickCount() - t;\n   93      printf(\"time: %.1fms\\n\", t * 1000. / cv::getTickFrequency());\n\n/home/roman/Projects/plot-cv/opencv/scan.cpp:\n  280    // float alpha = 1.9;\n  281    // float beta = -80;\n  282:   // dst.convertTo(dst, -1, alpha, beta);\n  283    cv::cvtColor(mbgra, dst, cv::COLOR_BGR2GRAY);\n  284    cv::adaptiveThreshold(dst, dst, 255, cv::ADAPTIVE_THRESH_MEAN_C, cv::THRESH_BINARY, 5, 4);\n  ...\n  322    //    float alpha = 2.2;\n  323    //    float beta = 0;\n  324:   //    dst.convertTo(dst, -1, alpha, beta);\n  325  \n  326    cv::threshold(dst, dst, 0, 255, cv::THRESH_BINARY | THRESH_OTSU);\n\n/home/roman/Projects/plot-cv/opencv/scanopy.cpp:\n  278    float alpha = 1.9;\n  279    float beta = -80;\n  280:   dst.convertTo(dst, -1, alpha, beta);\n  281  \n  282    // get source bitmap's config\n  ...\n  318    //    float alpha = 2.2;\n  319    //    float beta = 0;\n  320:   //    dst.convertTo(dst, -1, alpha, beta);\n  321  \n  322    cv::threshold(dst, dst, 0, 255, cv::THRESH_BINARY | THRESH_OTSU);\n\n/home/roman/Projects/plot-cv/opencv/sedz6Im82:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/opencv/sedzzP7Ww:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/opencv/utils.cpp:\n  371    if(!all.empty()) {\n  372      double alpha = 0.7;\n  373:     addWeighted(all_img, alpha, src, 1.0 - alpha, 0.0, all_img);\n  374      cv::imshow(\"all\", all_img);\n  375    }\n\n/home/roman/Projects/plot-cv/opencv/disabled/sedOLi7bJ:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/opencv/disabled/train_HOG.cpp:\n   28    const int sv_total = sv.rows;\n   29    // get the decision function\n   30:   cv::Mat alpha, svidx;\n   31:   double rho = svm->getDecisionFunction(0, alpha, svidx);\n   32  \n   33    CV_Assert(alpha.total() == 1 && svidx.total() == 1 && sv_total == 1);\n\n/home/roman/Projects/plot-cv/opencv/disabled/wrappers_video.cpp:\n   51                 ivx::cv::Scalar::create<VX_TYPE_ENUM>(context, VX_NORM_L2),\n   52                 cannied);\n   53:   Node::create(graph, VX_KERNEL_ACCUMULATE_WEIGHTED, gray, alpha, halfImg);\n   54:   Node::create(graph, VX_KERNEL_ACCUMULATE_WEIGHTED, cannied, alpha, halfCanny);\n   55    Node::create(graph,\n   56                 VX_KERNEL_ADD,\n\n/home/roman/Projects/plot-cv/qjs-opencv/js_cv.cpp:\n  203  \n  204    if(argc >= 3)\n  205:     JS_ToFloat64(ctx, &alpha, argv[2]);\n  206    if(argc >= 4)\n  207      JS_ToFloat64(ctx, &beta, argv[3]);\n  ...\n  211      JS_ToInt32(ctx, &dtype, argv[5]);\n  212  \n  213:   cv::normalize(src, dst, alpha, beta, norm_type, dtype);\n  214    return JS_UNDEFINED;\n  215  }\n  ...\n  219    JSInputOutputArray a1, a2, dst;\n  220  \n  221:   double alpha, beta, gamma;\n  222    int32_t dtype = -1;\n  223  \n  ...\n  235  \n  236    if(argc >= 2)\n  237:     JS_ToFloat64(ctx, &alpha, argv[1]);\n  238    if(argc >= 4)\n  239      JS_ToFloat64(ctx, &beta, argv[3]);\n  ...\n  244      JS_ToInt32(ctx, &dtype, argv[6]);\n  245  \n  246:   cv::addWeighted(a1, alpha, a2, beta, gamma, dst, dtype);\n  247    return JS_UNDEFINED;\n  248  }\n  ...\n  552        double alpha = 1, beta = 0;\n  553        if(argc >= 3)\n  554:         JS_ToFloat64(ctx, &alpha, argv[2]);\n  555        if(argc >= 4)\n  556          JS_ToFloat64(ctx, &beta, argv[3]);\n  557:       cv::convertScaleAbs(src, dst, alpha, beta);\n  558        break;\n  559      }\n  ...\n 1078  \n 1079        if(argc >= 2)\n 1080:         JS_ToFloat64(ctx, &alpha, argv[1]);\n 1081        if(argc >= 3)\n 1082          src2 = js_umat_or_mat(ctx, argv[2]);\n ....\n 1085          dst = js_umat_or_mat(ctx, argv[3]);\n 1086  \n 1087:       cv::scaleAdd(src, alpha, src2, dst);\n 1088        break;\n 1089      }\n\n/home/roman/Projects/plot-cv/qjs-opencv/js_imgproc.cpp:\n 1020        double alpha;\n 1021        JSInputArray mask = cv::noArray();\n 1022:       JS_ToFloat64(ctx, &alpha, argv[2]);\n 1023        if(argc >= 4)\n 1024          mask = js_umat_or_mat(ctx, argv[3]);\n 1025:       cv::accumulateWeighted(src, dst, alpha, mask);\n 1026        break;\n 1027      }\n\n/home/roman/Projects/plot-cv/qjs-opencv/js_mat.cpp:\n 1051  \n 1052    if(argc >= 3)\n 1053:     JS_ToFloat64(ctx, &alpha, argv[2]);\n 1054  \n 1055    if(argc >= 4)\n 1056      JS_ToFloat64(ctx, &beta, argv[3]);\n 1057  \n 1058:   m->convertTo(*output, rtype, alpha, beta);\n 1059  \n 1060    return JS_UNDEFINED;\n\n/home/roman/Projects/plot-cv/qjs-opencv/js_umat.cpp:\n  772  \n  773    if(argc >= 3)\n  774:     JS_ToFloat64(ctx, &alpha, argv[2]);\n  775  \n  776    if(argc >= 4)\n  777      JS_ToFloat64(ctx, &beta, argv[3]);\n  778  \n  779:   um->convertTo(*output, rtype, alpha, beta);\n  780  \n  781    return JS_UNDEFINED;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/carotene/include/carotene/functions.hpp:\n  181                       const u8 * src1Base, ptrdiff_t src1Stride,\n  182                       u8 * dstBase, ptrdiff_t dstStride,\n  183:                      f32 alpha, f32 beta, f32 gamma);\n  184  \n  185      void addWeighted(const Size2D &size,\n  ...\n  187                       const s8 * src1Base, ptrdiff_t src1Stride,\n  188                       s8 * dstBase, ptrdiff_t dstStride,\n  189:                      f32 alpha, f32 beta, f32 gamma);\n  190  \n  191      void addWeighted(const Size2D &size,\n  ...\n  193                       const u16 * src1Base, ptrdiff_t src1Stride,\n  194                       u16 * dstBase, ptrdiff_t dstStride,\n  195:                      f32 alpha, f32 beta, f32 gamma);\n  196  \n  197      void addWeighted(const Size2D &size,\n  ...\n  199                       const s16 * src1Base, ptrdiff_t src1Stride,\n  200                       s16 * dstBase, ptrdiff_t dstStride,\n  201:                      f32 alpha, f32 beta, f32 gamma);\n  202  \n  203      void addWeighted(const Size2D &size,\n  ...\n  205                       const u32 * src1Base, ptrdiff_t src1Stride,\n  206                       u32 * dstBase, ptrdiff_t dstStride,\n  207:                      f32 alpha, f32 beta, f32 gamma);\n  208  \n  209      void addWeighted(const Size2D &size,\n  ...\n  211                       const s32 * src1Base, ptrdiff_t src1Stride,\n  212                       s32 * dstBase, ptrdiff_t dstStride,\n  213:                      f32 alpha, f32 beta, f32 gamma);\n  214  \n  215      void addWeighted(const Size2D &size,\n  ...\n  217                       const f32 * src1Base, ptrdiff_t src1Stride,\n  218                       f32 * dstBase, ptrdiff_t dstStride,\n  219:                      f32 alpha, f32 beta, f32 gamma);\n  220  \n  221      /*\n  ...\n 2108                        const u8 * srcBase, ptrdiff_t srcStride,\n 2109                        u8 * dstBase, ptrdiff_t dstStride,\n 2110:                       f64 alpha, f64 beta);\n 2111  \n 2112      void convertScale(const Size2D &_size,\n 2113                        const u8 * srcBase, ptrdiff_t srcStride,\n 2114                        s8 * dstBase, ptrdiff_t dstStride,\n 2115:                       f64 alpha, f64 beta);\n 2116  \n 2117      void convertScale(const Size2D &_size,\n 2118                        const u8 * srcBase, ptrdiff_t srcStride,\n 2119                        u16 * dstBase, ptrdiff_t dstStride,\n 2120:                       f64 alpha, f64 beta);\n 2121  \n 2122      void convertScale(const Size2D &_size,\n 2123                        const u8 * srcBase, ptrdiff_t srcStride,\n 2124                        s16 * dstBase, ptrdiff_t dstStride,\n 2125:                       f64 alpha, f64 beta);\n 2126  \n 2127      void convertScale(const Size2D &_size,\n 2128                        const u8 * srcBase, ptrdiff_t srcStride,\n 2129                        s32 * dstBase, ptrdiff_t dstStride,\n 2130:                       f64 alpha, f64 beta);\n 2131  \n 2132      void convertScale(const Size2D &_size,\n 2133                        const u8 * srcBase, ptrdiff_t srcStride,\n 2134                        f32 * dstBase, ptrdiff_t dstStride,\n 2135:                       f64 alpha, f64 beta);\n 2136  \n 2137      void convertScale(const Size2D &_size,\n 2138                        const s8 * srcBase, ptrdiff_t srcStride,\n 2139                        u8 * dstBase, ptrdiff_t dstStride,\n 2140:                       f64 alpha, f64 beta);\n 2141  \n 2142      void convertScale(const Size2D &_size,\n 2143                        const s8 * srcBase, ptrdiff_t srcStride,\n 2144                        s8 * dstBase, ptrdiff_t dstStride,\n 2145:                       f64 alpha, f64 beta);\n 2146  \n 2147      void convertScale(const Size2D &_size,\n 2148                        const s8 * srcBase, ptrdiff_t srcStride,\n 2149                        u16 * dstBase, ptrdiff_t dstStride,\n 2150:                       f64 alpha, f64 beta);\n 2151  \n 2152      void convertScale(const Size2D &_size,\n 2153                        const s8 * srcBase, ptrdiff_t srcStride,\n 2154                        s16 * dstBase, ptrdiff_t dstStride,\n 2155:                       f64 alpha, f64 beta);\n 2156  \n 2157      void convertScale(const Size2D &_size,\n 2158                        const s8 * srcBase, ptrdiff_t srcStride,\n 2159                        s32 * dstBase, ptrdiff_t dstStride,\n 2160:                       f64 alpha, f64 beta);\n 2161  \n 2162      void convertScale(const Size2D &_size,\n 2163                        const s8 * srcBase, ptrdiff_t srcStride,\n 2164                        f32 * dstBase, ptrdiff_t dstStride,\n 2165:                       f64 alpha, f64 beta);\n 2166  \n 2167      void convertScale(const Size2D &_size,\n 2168                        const u16 * srcBase, ptrdiff_t srcStride,\n 2169                        u8 * dstBase, ptrdiff_t dstStride,\n 2170:                       f64 alpha, f64 beta);\n 2171  \n 2172      void convertScale(const Size2D &_size,\n 2173                        const u16 * srcBase, ptrdiff_t srcStride,\n 2174                        s8 * dstBase, ptrdiff_t dstStride,\n 2175:                       f64 alpha, f64 beta);\n 2176  \n 2177      void convertScale(const Size2D &_size,\n 2178                        const u16 * srcBase, ptrdiff_t srcStride,\n 2179                        u16 * dstBase, ptrdiff_t dstStride,\n 2180:                       f64 alpha, f64 beta);\n 2181  \n 2182      void convertScale(const Size2D &_size,\n 2183                        const u16 * srcBase, ptrdiff_t srcStride,\n 2184                        s16 * dstBase, ptrdiff_t dstStride,\n 2185:                       f64 alpha, f64 beta);\n 2186  \n 2187      void convertScale(const Size2D &_size,\n 2188                        const u16 * srcBase, ptrdiff_t srcStride,\n 2189                        s32 * dstBase, ptrdiff_t dstStride,\n 2190:                       f64 alpha, f64 beta);\n 2191  \n 2192      void convertScale(const Size2D &_size,\n 2193                        const u16 * srcBase, ptrdiff_t srcStride,\n 2194                        f32 * dstBase, ptrdiff_t dstStride,\n 2195:                       f64 alpha, f64 beta);\n 2196  \n 2197      void convertScale(const Size2D &_size,\n 2198                        const s16 * srcBase, ptrdiff_t srcStride,\n 2199                        u8 * dstBase, ptrdiff_t dstStride,\n 2200:                       f64 alpha, f64 beta);\n 2201  \n 2202      void convertScale(const Size2D &_size,\n 2203                        const s16 * srcBase, ptrdiff_t srcStride,\n 2204                        s8 * dstBase, ptrdiff_t dstStride,\n 2205:                       f64 alpha, f64 beta);\n 2206  \n 2207      void convertScale(const Size2D &_size,\n 2208                        const s16 * srcBase, ptrdiff_t srcStride,\n 2209                        u16 * dstBase, ptrdiff_t dstStride,\n 2210:                       f64 alpha, f64 beta);\n 2211  \n 2212      void convertScale(const Size2D &_size,\n 2213                        const s16 * srcBase, ptrdiff_t srcStride,\n 2214                        s16 * dstBase, ptrdiff_t dstStride,\n 2215:                       f64 alpha, f64 beta);\n 2216  \n 2217      void convertScale(const Size2D &_size,\n 2218                        const s16 * srcBase, ptrdiff_t srcStride,\n 2219                        s32 * dstBase, ptrdiff_t dstStride,\n 2220:                       f64 alpha, f64 beta);\n 2221  \n 2222      void convertScale(const Size2D &_size,\n 2223                        const s16 * srcBase, ptrdiff_t srcStride,\n 2224                        f32 * dstBase, ptrdiff_t dstStride,\n 2225:                       f64 alpha, f64 beta);\n 2226  \n 2227      void convertScale(const Size2D &_size,\n 2228                        const s32 * srcBase, ptrdiff_t srcStride,\n 2229                        u8 * dstBase, ptrdiff_t dstStride,\n 2230:                       f64 alpha, f64 beta);\n 2231  \n 2232      void convertScale(const Size2D &_size,\n 2233                        const s32 * srcBase, ptrdiff_t srcStride,\n 2234                        s8 * dstBase, ptrdiff_t dstStride,\n 2235:                       f64 alpha, f64 beta);\n 2236  \n 2237      void convertScale(const Size2D &_size,\n 2238                        const s32 * srcBase, ptrdiff_t srcStride,\n 2239                        u16 * dstBase, ptrdiff_t dstStride,\n 2240:                       f64 alpha, f64 beta);\n 2241  \n 2242      void convertScale(const Size2D &_size,\n 2243                        const s32 * srcBase, ptrdiff_t srcStride,\n 2244                        s16 * dstBase, ptrdiff_t dstStride,\n 2245:                       f64 alpha, f64 beta);\n 2246  \n 2247      void convertScale(const Size2D &_size,\n 2248                        const s32 * srcBase, ptrdiff_t srcStride,\n 2249                        s32 * dstBase, ptrdiff_t dstStride,\n 2250:                       f64 alpha, f64 beta);\n 2251  \n 2252      void convertScale(const Size2D &_size,\n 2253                        const s32 * srcBase, ptrdiff_t srcStride,\n 2254                        f32 * dstBase, ptrdiff_t dstStride,\n 2255:                       f64 alpha, f64 beta);\n 2256  \n 2257      void convertScale(const Size2D &_size,\n 2258                        const f32 * srcBase, ptrdiff_t srcStride,\n 2259                        u8 * dstBase, ptrdiff_t dstStride,\n 2260:                       f64 alpha, f64 beta);\n 2261  \n 2262      void convertScale(const Size2D &_size,\n 2263                        const f32 * srcBase, ptrdiff_t srcStride,\n 2264                        s8 * dstBase, ptrdiff_t dstStride,\n 2265:                       f64 alpha, f64 beta);\n 2266  \n 2267      void convertScale(const Size2D &_size,\n 2268                        const f32 * srcBase, ptrdiff_t srcStride,\n 2269                        u16 * dstBase, ptrdiff_t dstStride,\n 2270:                       f64 alpha, f64 beta);\n 2271  \n 2272      void convertScale(const Size2D &_size,\n 2273                        const f32 * srcBase, ptrdiff_t srcStride,\n 2274                        s16 * dstBase, ptrdiff_t dstStride,\n 2275:                       f64 alpha, f64 beta);\n 2276  \n 2277      void convertScale(const Size2D &_size,\n 2278                        const f32 * srcBase, ptrdiff_t srcStride,\n 2279                        s32 * dstBase, ptrdiff_t dstStride,\n 2280:                       f64 alpha, f64 beta);\n 2281  \n 2282      void convertScale(const Size2D &_size,\n 2283                        const f32 * srcBase, ptrdiff_t srcStride,\n 2284                        f32 * dstBase, ptrdiff_t dstStride,\n 2285:                       f64 alpha, f64 beta);\n 2286  \n 2287      /*\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/carotene/src/accumulate.cpp:\n  297      typedef u8 type;\n  298  \n  299:     float alpha, beta;\n  300:     float32x4_t v_alpha, v_beta;\n  301  \n  302      explicit AccumulateWeighted(float _alpha) :\n  ...\n  313          uint16x8_t v_src1_p = vmovl_u8(vget_low_u8(v_src1));\n  314          float32x4_t v_dst0f = vmlaq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(vget_low_u16(v_src1_p))), v_beta),\n  315:                                         v_alpha, vcvtq_f32_u32(vmovl_u16(vget_low_u16(v_src0_p))));\n  316          float32x4_t v_dst1f = vmlaq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(vget_high_u16(v_src1_p))), v_beta),\n  317:                                         v_alpha, vcvtq_f32_u32(vmovl_u16(vget_high_u16(v_src0_p))));\n  318          uint16x8_t v_dst0 = vcombine_u16(vmovn_u32(vcvtq_u32_f32(v_dst0f)),\n  319                                           vmovn_u32(vcvtq_u32_f32(v_dst1f)));\n  ...\n  322          v_src1_p = vmovl_u8(vget_high_u8(v_src1));\n  323          v_dst0f = vmlaq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(vget_low_u16(v_src1_p))), v_beta),\n  324:                             v_alpha, vcvtq_f32_u32(vmovl_u16(vget_low_u16(v_src0_p))));\n  325          v_dst1f = vmlaq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(vget_high_u16(v_src1_p))), v_beta),\n  326:                             v_alpha, vcvtq_f32_u32(vmovl_u16(vget_high_u16(v_src0_p))));\n  327          uint16x8_t v_dst1 = vcombine_u16(vmovn_u32(vcvtq_u32_f32(v_dst0f)),\n  328                                           vmovn_u32(vcvtq_u32_f32(v_dst1f)));\n  ...\n  337  \n  338          float32x4_t v_dst0f = vmlaq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(vget_low_u16(v_src1))), v_beta),\n  339:                                         v_alpha, vcvtq_f32_u32(vmovl_u16(vget_low_u16(v_src0))));\n  340          float32x4_t v_dst1f = vmlaq_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(vget_high_u16(v_src1))), v_beta),\n  341:                                         v_alpha, vcvtq_f32_u32(vmovl_u16(vget_high_u16(v_src0))));\n  342          uint16x8_t _v_dst = vcombine_u16(vmovn_u32(vcvtq_u32_f32(v_dst0f)),\n  343                                          vmovn_u32(vcvtq_u32_f32(v_dst1f)));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/carotene/src/add_weighted.cpp:\n   62      typedef T type;\n   63  \n   64:     f32 alpha, beta, gamma;\n   65      typedef typename TypeTraits<T>::wide wtype;\n   66      wAdd<wtype> wideAdd;\n   67:     wAdd(f32 _alpha, f32 _beta, f32 _gamma):\n   68          alpha(_alpha), beta(_beta), gamma(_gamma),\n   69:         wideAdd(_alpha, _beta, _gamma) {}\n   70  \n   71      void operator() (const typename VecTraits<T>::vec128 & v_src0,\n   ..\n  100      typedef s32 type;\n  101  \n  102:     f32 alpha, beta, gamma;\n  103:     float32x4_t valpha, vbeta, vgamma;\n  104:     wAdd(f32 _alpha, f32 _beta, f32 _gamma):\n  105          alpha(_alpha), beta(_beta), gamma(_gamma)\n  106      {\n  ...\n  144      typedef u32 type;\n  145  \n  146:     f32 alpha, beta, gamma;\n  147:     float32x4_t valpha, vbeta, vgamma;\n  148:     wAdd(f32 _alpha, f32 _beta, f32 _gamma):\n  149          alpha(_alpha), beta(_beta), gamma(_gamma)\n  150      {\n  ...\n  188      typedef f32 type;\n  189  \n  190:     f32 alpha, beta, gamma;\n  191:     float32x4_t valpha, vbeta, vgamma;\n  192:     wAdd(f32 _alpha, f32 _beta, f32 _gamma):\n  193          alpha(_alpha), beta(_beta), gamma(_gamma)\n  194      {\n  ...\n  228                   const type * src1Base, ptrdiff_t src1Stride, \\\n  229                   type * dstBase, ptrdiff_t dstStride,         \\\n  230:                  f32 alpha, f32 beta, f32 gamma)              \\\n  231  {                                                             \\\n  232      internal::assertSupportedConfiguration();                 \\\n  233:     wAdd<type> wgtAdd(alpha,                                  \\\n  234                        beta,                                   \\\n  235                        gamma);                                 \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/carotene/src/convert_scale.cpp:\n   48                        const T1 * srcBase, ptrdiff_t srcStride,                   \\\n   49                        T2 * dstBase, ptrdiff_t dstStride,                         \\\n   50:                       f64 alpha, f64 beta)                                       \\\n   51      {                                                                            \\\n   52          internal::assertSupportedConfiguration();                                \\\n   ..\n   83                        const T1 * srcBase, ptrdiff_t srcStride,                   \\\n   84                        T1 * dstBase, ptrdiff_t dstStride,                         \\\n   85:                       f64 alpha, f64 beta)                                       \\\n   86      {                                                                            \\\n   87          internal::assertSupportedConfiguration();                                \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/CHANGES:\n 4821    Removed dependence on !PNG_READ_EXPAND_SUPPORTED for calling\n 4822      png_set_packing() in png_read_png().\n 4823:   Fixed combination of ~alpha with shift. On read invert alpha, processing\n 4824      occurred after shift processing, which causes the final values to be\n 4825      outside the range that should be produced by the shift. Reversing the\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.h:\n 1052  PNG_EXPORT(27, void, png_set_expand_gray_1_2_4_to_8, (png_structrp png_ptr));\n 1053  PNG_EXPORT(28, void, png_set_palette_to_rgb, (png_structrp png_ptr));\n 1054: PNG_EXPORT(29, void, png_set_tRNS_to_alpha, (png_structrp png_ptr));\n 1055  #endif\n 1056  \n ....\n 1228  \n 1229  #ifdef PNG_READ_STRIP_ALPHA_SUPPORTED\n 1230: PNG_EXPORT(36, void, png_set_strip_alpha, (png_structrp png_ptr));\n 1231  #endif\n 1232  \n 1233  #if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \\\n 1234      defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)\n 1235: PNG_EXPORT(37, void, png_set_swap_alpha, (png_structrp png_ptr));\n 1236  #endif\n 1237  \n 1238  #if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \\\n 1239      defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)\n 1240: PNG_EXPORT(38, void, png_set_invert_alpha, (png_structrp png_ptr));\n 1241  #endif\n 1242  \n ....\n 1249  #  define PNG_FILLER_AFTER 1\n 1250  /* Add an alpha byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. */\n 1251: PNG_EXPORT(40, void, png_set_add_alpha, (png_structrp png_ptr,\n 1252      png_uint_32 filler, int flags));\n 1253  #endif /* READ_FILLER || WRITE_FILLER */\n ....\n 2139  #ifdef PNG_tRNS_SUPPORTED\n 2140  PNG_EXPORT(166, png_uint_32, png_get_tRNS, (png_const_structrp png_ptr,\n 2141:     png_inforp info_ptr, png_bytep *trans_alpha, int *num_trans,\n 2142      png_color_16p *trans_color));\n 2143  #endif\n ....\n 2145  #ifdef PNG_tRNS_SUPPORTED\n 2146  PNG_EXPORT(167, void, png_set_tRNS, (png_structrp png_ptr,\n 2147:     png_inforp info_ptr, png_const_bytep trans_alpha, int num_trans,\n 2148      png_const_color_16p trans_color));\n 2149  #endif\n ....\n 2508   /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */\n 2509  \n 2510: #  define png_composite(composite, fg, alpha, bg)        \\\n 2511     {                                                     \\\n 2512        png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \\\n ....\n 2517     }\n 2518  \n 2519: #  define png_composite_16(composite, fg, alpha, bg)     \\\n 2520     {                                                     \\\n 2521        png_uint_32 temp = (png_uint_32)((png_uint_32)(fg) \\\n ....\n 2528  #else  /* Standard method using integer division */\n 2529  \n 2530: #  define png_composite(composite, fg, alpha, bg)                      \\\n 2531     (composite) =                                                       \\\n 2532         (png_byte)(0xff & (((png_uint_16)(fg) * (png_uint_16)(alpha) +  \\\n ....\n 2534         127) / 255))\n 2535  \n 2536: #  define png_composite_16(composite, fg, alpha, bg)                       \\\n 2537     (composite) =                                                           \\\n 2538         (png_uint_16)(0xffff & (((png_uint_32)(fg) * (png_uint_32)(alpha) + \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/pngget.c:\n 1092  png_uint_32 PNGAPI\n 1093  png_get_tRNS(png_const_structrp png_ptr, png_inforp info_ptr,\n 1094:     png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)\n 1095  {\n 1096     png_uint_32 retval = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/pngpriv.h:\n 1245      PNG_EMPTY);\n 1246  \n 1247: /* Combine a row of data, dealing with alpha, etc. if requested.  'row' is an\n 1248   * array of png_ptr->width pixels.  If the image is not interlaced or this\n 1249   * is the final pass this just does a memcpy, otherwise the \"display\" flag\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/pngread.c:\n 1762  png_create_colormap_entry(png_image_read_control *display,\n 1763      png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,\n 1764:     png_uint_32 alpha, int encoding)\n 1765  {\n 1766     png_imagep image = display->image;\n ....\n 2196  \n 2197              /* If there is a tRNS chunk then this either selects a transparent\n 2198:              * value or, if the output has no alpha, the background color.\n 2199               */\n 2200              if (png_ptr->num_trans > 0)\n ....\n 2233                 else\n 2234                    png_create_colormap_entry(display, i, back_r, back_g, back_b,\n 2235:                       back_alpha, output_encoding);\n 2236              }\n 2237  \n ....\n 2343                  */\n 2344                 png_create_colormap_entry(display, 254, back_r, back_g, back_b,\n 2345:                    back_alpha, output_encoding);\n 2346              }\n 2347  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/pngrtran.c:\n 4785  #endif\n 4786           png_do_expand_palette(png_ptr, row_info, png_ptr->row_buf + 1,\n 4787:              png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);\n 4788        }\n 4789  \n ....\n 4851   *                                   (3x compare/pixel compared to doing\n 4852   *                                   composite with gray bkgrnd)\n 4853:  *   - Gray + alpha -> convert to RGB + alpha, composite with background and\n 4854   *                                   remove alpha bytes (3x float\n 4855   *                                   operations/pixel compared with composite\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/pngset.c:\n  993  void PNGAPI\n  994  png_set_tRNS(png_structrp png_ptr, png_inforp info_ptr,\n  995:     png_const_bytep trans_alpha, int num_trans, png_const_color_16p trans_color)\n  996  {\n  997     png_debug1(1, \"in %s storage function\", \"tRNS\");\n  ...\n 1019            info_ptr->trans_alpha = png_voidcast(png_bytep,\n 1020                png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH));\n 1021:           memcpy(info_ptr->trans_alpha, trans_alpha, (size_t)num_trans);\n 1022         }\n 1023         png_ptr->trans_alpha = info_ptr->trans_alpha;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/pngwrite.c:\n  229        }\n  230  #endif\n  231:       png_write_tRNS(png_ptr, info_ptr->trans_alpha, &(info_ptr->trans_color),\n  232            info_ptr->num_trans, info_ptr->color_type);\n  233     }\n  ...\n 1603                 component = 65535;\n 1604  \n 1605:             /* component<alpha, so component/alpha is less than one and\n 1606               * component*reciprocal is less than 2^31.\n 1607               */\n ....\n 1656        return 255;\n 1657  \n 1658:    /* component<alpha, so component/alpha is less than one and\n 1659      * component*reciprocal is less than 2^31.\n 1660      */\n ....\n 1739              c = (int)channels;\n 1740              do /* always at least one channel */\n 1741:                *out_ptr++ = png_unpremultiply(*in_ptr++, alpha, reciprocal);\n 1742              while (--c > 0);\n 1743  \n ....\n 1862              {\n 1863                 palette[i].blue = png_unpremultiply(entry[afirst + (2 ^ bgr)],\n 1864:                    alpha, reciprocal);\n 1865                 palette[i].green = png_unpremultiply(entry[afirst + 1], alpha,\n 1866                     reciprocal);\n ....\n 1871              else /* gray */\n 1872                 palette[i].blue = palette[i].red = palette[i].green =\n 1873:                    png_unpremultiply(entry[afirst], alpha, reciprocal);\n 1874           }\n 1875        }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libtiff/ChangeLog:\n 7312  \n 7313  \t* libtiff/tif_getimage.c:\n 7314: \t- When there is no alpha, gtTileSeparate and gtStripSeparate allocated\n 7315  \t  buffer for alpha strile and filled it, only to never read it back.\n 7316  \t  Removed allocation and fill.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libtiff/tif_getimage.c:\n  130  \t\t\t/*\n  131  \t\t\t * We should likely validate that any extra samples are either\n  132: \t\t\t * to be ignored, or are alpha, and if alpha we should try to use\n  133  \t\t\t * them.  But for now we won't bother with this.\n  134  \t\t\t*/\n  ...\n 2837  \t\tif (img->bitspersample == 8 && img->samplesperpixel == 4)\n 2838  \t\t{\n 2839: \t\t\timg->alpha = 1; // Not alpha, but seems like the only way to get 4th band\n 2840  \t\t\timg->put.separate = putCMYKseparate8bittile;\n 2841  \t\t}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dec/io_dec.c:\n  135    if (alpha != NULL) {\n  136      for (j = 0; j < mb_h; ++j) {\n  137:       memcpy(dst, alpha, mb_w * sizeof(*dst));\n  138        alpha += io->width;\n  139        dst += buf->a_stride;\n  140      }\n  141    } else if (buf->a != NULL) {\n  142:     // the user requested alpha, but there is none, set it to opaque.\n  143      FillAlphaPlane(dst, mb_w, mb_h, buf->a_stride);\n  144    }\n  ...\n  147  \n  148  static int GetAlphaSourceRow(const VP8Io* const io,\n  149:                              const uint8_t** alpha, int* const num_rows) {\n  150    int start_y = io->mb_y;\n  151    *num_rows = io->mb_h;\n  ...\n  182      const WebPRGBABuffer* const buf = &p->output->u.RGBA;\n  183      int num_rows;\n  184:     const size_t start_y = GetAlphaSourceRow(io, &alpha, &num_rows);\n  185      uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;\n  186      uint8_t* const dst = base_rgba + (alpha_first ? 0 : 3);\n  187:     const int has_alpha = WebPDispatchAlpha(alpha, io->width, mb_w,\n  188                                              num_rows, dst, buf->stride);\n  189      (void)expected_num_lines_out;\n  ...\n  206      const WebPRGBABuffer* const buf = &p->output->u.RGBA;\n  207      int num_rows;\n  208:     const size_t start_y = GetAlphaSourceRow(io, &alpha, &num_rows);\n  209      uint8_t* const base_rgba = buf->rgba + start_y * buf->stride;\n  210  #if (WEBP_SWAP_16BIT_CSP == 1)\n  ...\n  282      }\n  283    } else if (buf->a != NULL) {\n  284:     // the user requested alpha, but there is none, set it to opaque.\n  285      assert(p->last_y + expected_num_lines_out <= io->scaled_height);\n  286      FillAlphaPlane(dst_a, io->scaled_width, expected_num_lines_out,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dec/vp8l_dec.c:\n   79  \n   80  // Memory needed for lookup tables of one Huffman tree group. Red, blue, alpha\n   81: // and distance alphabets are constant (256 for red, blue and alpha, 40 for\n   82  // distance) and lookup table sizes for them in worst case are 630 and 410\n   83  // respectively. Size of green alphabet depends on color cache size and is equal\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dec/webp_dec.c:\n  689    return ParseHeadersInternal(data, data_size,\n  690                                &features->width, &features->height,\n  691:                               &features->has_alpha, &features->has_animation,\n  692                                &features->format, NULL);\n  693  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/alpha_processing.c:\n  147        } else {\n  148          const uint32_t alpha = (argb >> 24) & 0xff;\n  149:         const uint32_t scale = GetScale(alpha, inverse);\n  150          uint32_t out = argb & 0xff000000u;\n  151          out |= Mult(argb >>  0, scale) <<  0;\n  ...\n  195  \n  196  void WebPMultRows(uint8_t* ptr, int stride,\n  197:                   const uint8_t* alpha, int alpha_stride,\n  198                    int width, int num_rows, int inverse) {\n  199    int n;\n  200    for (n = 0; n < num_rows; ++n) {\n  201:     WebPMultRow(ptr, alpha, width, inverse);\n  202      ptr += stride;\n  203      alpha += alpha_stride;\n  ...\n  291  \n  292  #if !WEBP_NEON_OMIT_C_CODE\n  293: static int DispatchAlpha_C(const uint8_t* alpha, int alpha_stride,\n  294                             int width, int height,\n  295                             uint8_t* dst, int dst_stride) {\n  ...\n  310  }\n  311  \n  312: static void DispatchAlphaToGreen_C(const uint8_t* alpha, int alpha_stride,\n  313                                     int width, int height,\n  314                                     uint32_t* dst, int dst_stride) {\n  ...\n  325  static int ExtractAlpha_C(const uint8_t* argb, int argb_stride,\n  326                            int width, int height,\n  327:                           uint8_t* alpha, int alpha_stride) {\n  328    uint8_t alpha_mask = 0xff;\n  329    int i, j;\n  ...\n  341  }\n  342  \n  343: static void ExtractGreen_C(const uint32_t* argb, uint8_t* alpha, int size) {\n  344    int i;\n  345    for (i = 0; i < size; ++i) alpha[i] = argb[i] >> 8;\n  ...\n  396  void (*WebPDispatchAlphaToGreen)(const uint8_t*, int, int, int, uint32_t*, int);\n  397  int (*WebPExtractAlpha)(const uint8_t*, int, int, int, uint8_t*, int);\n  398: void (*WebPExtractGreen)(const uint32_t* argb, uint8_t* alpha, int size);\n  399  #ifdef WORDS_BIGENDIAN\n  400  void (*WebPPackARGB)(const uint8_t* a, const uint8_t* r, const uint8_t* g,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/alpha_processing_mips_dsp_r2.c:\n   17  #if defined(WEBP_USE_MIPS_DSP_R2)\n   18  \n   19: static int DispatchAlpha_MIPSdspR2(const uint8_t* alpha, int alpha_stride,\n   20                                     int width, int height,\n   21                                     uint8_t* dst, int dst_stride) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/alpha_processing_neon.c:\n   81  //------------------------------------------------------------------------------\n   82  \n   83: static int DispatchAlpha_NEON(const uint8_t* alpha, int alpha_stride,\n   84                                int width, int height,\n   85                                uint8_t* dst, int dst_stride) {\n   ..\n  113  }\n  114  \n  115: static void DispatchAlphaToGreen_NEON(const uint8_t* alpha, int alpha_stride,\n  116                                        int width, int height,\n  117                                        uint32_t* dst, int dst_stride) {\n  ...\n  134  static int ExtractAlpha_NEON(const uint8_t* argb, int argb_stride,\n  135                               int width, int height,\n  136:                              uint8_t* alpha, int alpha_stride) {\n  137    uint32_t alpha_mask = 0xffffffffu;\n  138    uint8x8_t mask8 = vdup_n_u8(0xff);\n  ...\n  163  \n  164  static void ExtractGreen_NEON(const uint32_t* argb,\n  165:                               uint8_t* alpha, int size) {\n  166    int i;\n  167    for (i = 0; i + 16 <= size; i += 16) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/alpha_processing_sse2.c:\n   19  //------------------------------------------------------------------------------\n   20  \n   21: static int DispatchAlpha_SSE2(const uint8_t* alpha, int alpha_stride,\n   22                                int width, int height,\n   23                                uint8_t* dst, int dst_stride) {\n   ..\n   73  }\n   74  \n   75: static void DispatchAlphaToGreen_SSE2(const uint8_t* alpha, int alpha_stride,\n   76                                        int width, int height,\n   77                                        uint32_t* dst, int dst_stride) {\n   ..\n  101  static int ExtractAlpha_SSE2(const uint8_t* argb, int argb_stride,\n  102                               int width, int height,\n  103:                              uint8_t* alpha, int alpha_stride) {\n  104    // alpha_and stores an 'and' operation of all the alpha[] values. The final\n  105    // value is not 0xff if any of the alpha[] is not equal to 0xff.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/alpha_processing_sse41.c:\n   22  static int ExtractAlpha_SSE41(const uint8_t* argb, int argb_stride,\n   23                                int width, int height,\n   24:                               uint8_t* alpha, int alpha_stride) {\n   25    // alpha_and stores an 'and' operation of all the alpha[] values. The final\n   26    // value is not 0xff if any of the alpha[] is not equal to 0xff.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/dsp.h:\n  579  // Dispatch the values from alpha[] plane to the ARGB destination 'dst'.\n  580  // Returns true if alpha[] plane has non-trivial values different from 0xff.\n  581: extern int (*WebPDispatchAlpha)(const uint8_t* alpha, int alpha_stride,\n  582                                  int width, int height,\n  583                                  uint8_t* dst, int dst_stride);\n  ...\n  585  // Transfer packed 8b alpha[] values to green channel in dst[], zero'ing the\n  586  // A/R/B values. 'dst_stride' is the stride for dst[] in uint32_t units.\n  587: extern void (*WebPDispatchAlphaToGreen)(const uint8_t* alpha, int alpha_stride,\n  588                                          int width, int height,\n  589                                          uint32_t* dst, int dst_stride);\n  ...\n  594  extern int (*WebPExtractAlpha)(const uint8_t* argb, int argb_stride,\n  595                                 int width, int height,\n  596:                                uint8_t* alpha, int alpha_stride);\n  597  \n  598  // Extract the green values from 32b values in argb[] and pack them into alpha[]\n  599  // (this is the opposite of WebPDispatchAlphaToGreen).\n  600: extern void (*WebPExtractGreen)(const uint32_t* argb, uint8_t* alpha, int size);\n  601  \n  602  // Pre-Multiply operation transforms x into x * A / 255  (where x=Y,R,G or B).\n  ...\n  616  // Same a WebPMultRow(), but for several 'num_rows' rows.\n  617  void WebPMultRows(uint8_t* ptr, int stride,\n  618:                   const uint8_t* alpha, int alpha_stride,\n  619                    int width, int num_rows, int inverse);\n  620  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/alpha_enc.c:\n   68    WebPConfigInit(&config);\n   69    config.lossless = 1;\n   70:   // Enable exact, or it would alter RGB values of transparent alpha, which is\n   71    // normally OK but not here since we are not encoding the input image but  an\n   72    // internal encoding-related image containing necessary exact information in\n   ..\n  200  \n  201  // Given the input 'filter' option, return an OR'd bit-set of filters to try.\n  202: static uint32_t GetFilterMap(const uint8_t* alpha, int width, int height,\n  203                               int filter, int effort_level) {\n  204    uint32_t bit_map = 0U;\n  ...\n  208      const int kMinColorsForFilterNone = 16;\n  209      const int kMaxColorsForFilterNone = 192;\n  210:     const int num_colors = GetNumColors(alpha, width, height, width);\n  211      // For low number of colors, NONE yields better compression.\n  212      filter = (num_colors <= kMinColorsForFilterNone)\n  213          ? WEBP_FILTER_NONE\n  214:         : WebPEstimateBestFilter(alpha, width, height, width);\n  215      bit_map |= 1 << filter;\n  216      // For large number of colors, try FILTER_NONE in addition to the best\n  ...\n  232  }\n  233  \n  234: static int ApplyFiltersAndEncode(const uint8_t* alpha, int width, int height,\n  235                                   size_t data_size, int method, int filter,\n  236                                   int reduce_levels, int effort_level,\n  ...\n  241    FilterTrial best;\n  242    uint32_t try_map =\n  243:       GetFilterMap(alpha, width, height, filter, effort_level);\n  244    InitFilterTrial(&best);\n  245  \n  ...\n  251        if (try_map & 1) {\n  252          FilterTrial trial;\n  253:         ok = EncodeAlphaInternal(alpha, width, height, method, filter,\n  254                                   reduce_levels, effort_level, filtered_alpha,\n  255                                   &trial);\n  ...\n  264      WebPSafeFree(filtered_alpha);\n  265    } else {\n  266:     ok = EncodeAlphaInternal(alpha, width, height, method, WEBP_FILTER_NONE,\n  267                               reduce_levels, effort_level, NULL, &best);\n  268    }\n  ...\n  331  \n  332    // Extract alpha data (width x height) from raw_data (stride x height).\n  333:   WebPCopyPlane(pic->a, pic->a_stride, quant_alpha, width, width, height);\n  334  \n  335    if (reduce_levels) {  // No Quantization required for 'quality = 100'.\n  ...\n  339      const int alpha_levels = (quality <= 70) ? (2 + quality / 5)\n  340                                               : (16 + (quality - 70) * 8);\n  341:     ok = QuantizeLevels(quant_alpha, width, height, alpha_levels, &sse);\n  342    }\n  343  \n  344    if (ok) {\n  345      VP8FiltersInit();\n  346:     ok = ApplyFiltersAndEncode(quant_alpha, width, height, data_size, method,\n  347                                 filter, reduce_levels, effort_level, output,\n  348                                 output_size, pic->stats);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/analysis_enc.c:\n   92      const int alpha = 255 * (centers[n] - mid) / (max - min);\n   93      const int beta = 255 * (centers[n] - min) / (max - min);\n   94:     enc->dqm_[n].alpha_ = clip(alpha, -127, 127);\n   95      enc->dqm_[n].beta_ = clip(beta, 0, 255);\n   96    }\n   ..\n  104  #define ALPHA_SCALE (2 * MAX_ALPHA)  // scaling factor for alpha.\n  105  #define DEFAULT_ALPHA (-1)\n  106: #define IS_BETTER_ALPHA(alpha, best_alpha) ((alpha) > (best_alpha))\n  107  \n  108  static int FinalAlphaValue(int alpha) {\n  109    alpha = MAX_ALPHA - alpha;\n  110:   return clip(alpha, 0, MAX_ALPHA);\n  111  }\n  112  \n  ...\n  244                          0, 16, &histo);\n  245      alpha = GetAlpha(&histo);\n  246:     if (IS_BETTER_ALPHA(alpha, best_alpha)) {\n  247        best_alpha = alpha;\n  248        best_mode = mode;\n  ...\n  292                          16, 16 + 4 + 4, &histo);\n  293      alpha = GetAlpha(&histo);\n  294:     if (IS_BETTER_ALPHA(alpha, best_alpha)) {\n  295        best_alpha = alpha;\n  296      }\n  ...\n  307  static void MBAnalyze(VP8EncIterator* const it,\n  308                        int alphas[MAX_ALPHA + 1],\n  309:                       int* const alpha, int* const uv_alpha) {\n  310    const VP8Encoder* const enc = it->enc_;\n  311:   int best_alpha, best_uv_alpha;\n  312  \n  313    VP8SetIntra16Mode(it, 0);  // default: Intra16, DC_PRED\n  ...\n  369    WebPWorker worker;\n  370    int alphas[MAX_ALPHA + 1];\n  371:   int alpha, uv_alpha;\n  372    VP8EncIterator it;\n  373    int delta_progress;\n  ...\n  385        // Let's pretend we have perfect lossless reconstruction.\n  386        VP8IteratorImport(it, scratch);\n  387:       MBAnalyze(it, job->alphas, &job->alpha, &job->uv_alpha);\n  388        ok = VP8IteratorProgress(it, job->delta_progress);\n  389      } while (ok && VP8IteratorNext(it));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/histogram_enc.h:\n   45    double red_cost_;          // literal, red & blue.\n   46    double blue_cost_;\n   47:   uint8_t is_used_[5];       // 5 for literal, red, blue, alpha, distance\n   48  } VP8LHistogram;\n   49  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n   43  \n   44  // Returns true if alpha[] has non-0xff values.\n   45: static int CheckNonOpaque(const uint8_t* alpha, int width, int height,\n   46                            int x_step, int y_step) {\n   47    if (alpha == NULL) return 0;\n   ..\n   49    if (x_step == 1) {\n   50      for (; height-- > 0; alpha += y_step) {\n   51:       if (WebPHasAlpha8b(alpha, width)) return 1;\n   52      }\n   53    } else {\n   54      for (; height-- > 0; alpha += y_step) {\n   55:       if (WebPHasAlpha32b(alpha, width)) return 1;\n   56      }\n   57    }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/vp8l_enc.c:\n 1161  \n 1162  static int WriteRealAlphaAndVersion(VP8LBitWriter* const bw, int has_alpha) {\n 1163:   VP8LPutBits(bw, has_alpha, 1);\n 1164    VP8LPutBits(bw, VP8L_VERSION, VP8L_VERSION_BITS);\n 1165    return !bw->error_;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/mux/muxedit.c:\n  217    int is_lossless = 0;\n  218    WebPData image, alpha;\n  219:   WebPMuxError err = GetImageData(bitstream, &image, &alpha, &is_lossless);\n  220    const int image_tag =\n  221        is_lossless ? kChunks[IDX_VP8L].tag : kChunks[IDX_VP8].tag;\n  222    if (err != WEBP_MUX_OK) return err;\n  223    if (alpha.bytes != NULL) {\n  224:     err = AddDataToChunkList(&alpha, copy_data, kChunks[IDX_ALPHA].tag,\n  225                               &wpi->alpha_);\n  226      if (err != WEBP_MUX_OK) return err;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/IlmImf/ImfDwaCompressor.cpp:\n   39  // First, we try and figure out what compression strategy to take\n   40  // based in channel name. For RGB channels, we want a lossy method\n   41: // described below. But, if we have alpha, we should do something\n   42  // different (and probably using RLE). If we have depth, or velocity,\n   43  // or something else, just fall back to ZIP. The rules for deciding \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/IlmImf/ImfRgbaFile.h:\n  273      //--------------------------------------------------------------\n  274      // Constructors -- the same as the previous two, but the names\n  275:     // of the red, green, blue, alpha, luminance and chroma channels\n  276      // are expected to be layerName.R, layerName.G, etc.\n  277      //--------------------------------------------------------------\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/IlmImf/ImfScanLineInputFile.cpp:\n  757        // Channels are saved alphabetically, so the order is B G R.\n  758        // The last slice (R) will give us the location of our write pointer.\n  759:       // The only slice that we support skipping is alpha, i.e. the first one.  \n  760        // This does not impact the write pointer or the pixels to copy at all.\n  761        \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/IlmImf/ImfTiledRgbaFile.h:\n  363      //------------------------------------------------------------\n  364      // Constructors -- the same as the previous two, but the names\n  365:     // of the red, green, blue, alpha, and luminance channels are\n  366      // expected to be layerName.R, layerName.G, etc.\n  367      //------------------------------------------------------------\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/protobuf/src/google/protobuf/stubs/common.h:\n   85  #define GOOGLE_PROTOBUF_VERSION 3019001\n   86  \n   87: // A suffix string for alpha, beta or rc releases. Empty for stable releases.\n   88  #define GOOGLE_PROTOBUF_VERSION_SUFFIX \"\"\n   89  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/opencv_stitching_tool/opencv_stitching/seam_finder.py:\n   99  def add_weighted_image(img1, img2, alpha):\n  100      return cv.addWeighted(\n  101:         img1, alpha, img2, (1.0 - alpha), 0.0\n  102          )\n  103  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/traincascade/old_ml.hpp:\n  328      virtual void calc_non_rbf_base( int vec_count, int vec_size, const float** vecs,\n  329                                      const float* another, float* results,\n  330:                                     double alpha, double beta );\n  331      virtual void calc_intersec( int vcount, int var_count, const float** vecs,\n  332                              const float* another, float* results );\n  ...\n  371  \n  372      CvSVMSolver( int count, int var_count, const float** samples, schar* y,\n  373:                  int alpha_count, double* alpha, double Cp, double Cn,\n  374                   CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row,\n  375                   SelectWorkingSet select_working_set, CalcRho calc_rho );\n  376      virtual bool create( int count, int var_count, const float** samples, schar* y,\n  377:                  int alpha_count, double* alpha, double Cp, double Cn,\n  378                   CvMemStorage* storage, CvSVMKernel* kernel, GetRow get_row,\n  379                   SelectWorkingSet select_working_set, CalcRho calc_rho );\n  ...\n  385      virtual bool solve_c_svc( int count, int var_count, const float** samples, schar* y,\n  386                                double Cp, double Cn, CvMemStorage* storage,\n  387:                               CvSVMKernel* kernel, double* alpha, CvSVMSolutionInfo& si );\n  388      virtual bool solve_nu_svc( int count, int var_count, const float** samples, schar* y,\n  389                                 CvMemStorage* storage, CvSVMKernel* kernel,\n  390:                                double* alpha, CvSVMSolutionInfo& si );\n  391      virtual bool solve_one_class( int count, int var_count, const float** samples,\n  392                                    CvMemStorage* storage, CvSVMKernel* kernel,\n  393:                                   double* alpha, CvSVMSolutionInfo& si );\n  394  \n  395      virtual bool solve_eps_svr( int count, int var_count, const float** samples, const float* y,\n  396                                  CvMemStorage* storage, CvSVMKernel* kernel,\n  397:                                 double* alpha, CvSVMSolutionInfo& si );\n  398  \n  399      virtual bool solve_nu_svr( int count, int var_count, const float** samples, const float* y,\n  400                                 CvMemStorage* storage, CvSVMKernel* kernel,\n  401:                                double* alpha, CvSVMSolutionInfo& si );\n  402  \n  403      virtual float* get_row_base( int i, bool* _existed );\n  ...\n  531      virtual bool train1( int sample_count, int var_count, const float** samples,\n  532                      const void* responses, double Cp, double Cn,\n  533:                     CvMemStorage* _storage, double* alpha, double& rho );\n  534      virtual bool do_train( int svm_type, int sample_count, int var_count, const float** samples,\n  535                      const CvMat* responses, CvMemStorage* _storage, double* alpha );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/traincascade/old_ml_tree.cpp:\n 3505              parent->alpha = ((fold >= 0 ? parent->cv_node_risk[fold] : parent->node_risk)\n 3506                  - parent->tree_risk)/(parent->complexity - 1);\n 3507:             min_alpha = MIN( min_alpha, parent->alpha );\n 3508          }\n 3509  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/doc/js_tutorials/js_assets/js_trackbar.html:\n   57  let src2 = cv.imread('canvasInput2');\n   58  let dst = new cv.Mat();\n   59: cv.addWeighted( src1, alpha, src2, beta, 0.0, dst, -1);\n   60  cv.imshow('canvasOutput', dst);\n   61  dst.delete();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/doc/js_tutorials/js_gui/js_trackbar/js_trackbar.markdown:\n   55  let src2 = cv.imread('canvasInput2');\n   56  let dst = new cv.Mat();\n   57: cv.addWeighted( src1, alpha, src2, beta, 0.0, dst, -1);\n   58  cv.imshow('canvasOutput', dst);\n   59  dst.delete();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/doc/tutorials/core/basic_linear_transform/basic_linear_transform.markdown:\n  182  @add_toggle_cpp\n  183  @code{.cpp}\n  184: image.convertTo(new_image, -1, alpha, beta);\n  185  @endcode\n  186  @end_toggle\n  ...\n  188  @add_toggle_java\n  189  @code{.java}\n  190: image.convertTo(newImage, -1, alpha, beta);\n  191  @endcode\n  192  @end_toggle\n  ...\n  194  @add_toggle_python\n  195  @code{.py}\n  196: new_image = cv.convertScaleAbs(image, alpha=alpha, beta=beta)\n  197  @endcode\n  198  @end_toggle\n  ...\n  278  The gamma correction should tend to add less saturation effect as the mapping is non linear and there is no numerical saturation possible as in the previous method.\n  279  \n  280: ![Left: histogram after alpha, beta correction ; Center: histogram of the original image ; Right: histogram after the gamma correction](images/Basic_Linear_Transform_Tutorial_histogram_compare.png)\n  281  \n  282  The previous figure compares the histograms for the three images (the y-ranges are not the same between the three histograms).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/include/opencv2/calib3d.hpp:\n 2011                                        OutputArray R1, OutputArray R2, OutputArray R3,\n 2012                                        OutputArray P1, OutputArray P2, OutputArray P3,\n 2013:                                       OutputArray Q, double alpha, Size newImgSize,\n 2014                                        CV_OUT Rect* roi1, CV_OUT Rect* roi2, int flags );\n 2015  \n ....\n 2041   */\n 2042  CV_EXPORTS_W Mat getOptimalNewCameraMatrix( InputArray cameraMatrix, InputArray distCoeffs,\n 2043:                                             Size imageSize, double alpha, Size newImgSize = Size(),\n 2044                                              CV_OUT Rect* validPixROI = 0,\n 2045                                              bool centerPrincipalPoint = false);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/src/calibration.cpp:\n 2505                        CvSize imageSize, const CvMat* matR, const CvMat* matT,\n 2506                        CvMat* _R1, CvMat* _R2, CvMat* _P1, CvMat* _P2,\n 2507:                       CvMat* matQ, int flags, double alpha, CvSize newImgSize,\n 2508                        CvRect* roi1, CvRect* roi2 )\n 2509  {\n ....\n 2622      cvConvert(&pp, _P2);\n 2623  \n 2624:     alpha = MIN(alpha, 1.);\n 2625  \n 2626      icvGetRectangles( _cameraMatrix1, _distCoeffs1, _R1, _P1, imageSize, inner1, outer1 );\n ....\n 2898      double r[] =\n 2899      {\n 2900:         alpha, beta, 0,\n 2901:         -beta, alpha, 0,\n 2902          0, 0, 1\n 2903      };\n ....\n 3968                          OutputArray _Pmat1, OutputArray _Pmat2,\n 3969                          OutputArray _Qmat, int flags,\n 3970:                         double alpha, Size newImageSize,\n 3971                          Rect* validPixROI1, Rect* validPixROI2 )\n 3972  {\n ....\n 4023  cv::Mat cv::getOptimalNewCameraMatrix( InputArray _cameraMatrix,\n 4024                                         InputArray _distCoeffs,\n 4025:                                        Size imgSize, double alpha, Size newImgSize,\n 4026                                         Rect* validPixROI, bool centerPrincipalPoint )\n 4027  {\n ....\n 4035  \n 4036      cvGetOptimalNewCameraMatrix(&c_cameraMatrix, &c_distCoeffs, cvSize(imgSize),\n 4037:                                 alpha, &c_newCameraMatrix,\n 4038                                  cvSize(newImgSize), (CvRect*)validPixROI, (int)centerPrincipalPoint);\n 4039      return newCameraMatrix;\n ....\n 4189                     OutputArray _Pmat1, OutputArray _Pmat2, OutputArray _Pmat3,\n 4190                     OutputArray _Qmat,\n 4191:                    double alpha, Size newImgSize,\n 4192                     Rect* roi1, Rect* roi2, int flags )\n 4193  {\n ....\n 4195      stereoRectify( _cameraMatrix1, _distCoeffs1, _cameraMatrix2, _distCoeffs2,\n 4196                     imageSize, _Rmat12, _Tmat12, _Rmat1, _Rmat2, _Pmat1, _Pmat2, _Qmat,\n 4197:                    flags, alpha, newImgSize, roi1, roi2 );\n 4198  \n 4199      Mat R12 = _Rmat12.getMat(), R13 = _Rmat13.getMat(), T12 = _Tmat12.getMat(), T13 = _Tmat13.getMat();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/src/fisheye.cpp:\n   62  \n   63  void cv::fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, const Affine3d& affine,\n   64:     InputArray K, InputArray D, double alpha, OutputArray jacobian)\n   65  {\n   66      CV_INSTRUMENT_REGION();\n   67  \n   68:     projectPoints(objectPoints, imagePoints, affine.rvec(), affine.translation(), K, D, alpha, jacobian);\n   69  }\n   70  \n   71  void cv::fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, InputArray _rvec,\n   72:         InputArray _tvec, InputArray _K, InputArray _D, double alpha, OutputArray jacobian)\n   73  {\n   74      CV_INSTRUMENT_REGION();\n   ..\n  109      if (isJacobianNeeded)\n  110      {\n  111:         int nvars = 2 + 2 + 1 + 4 + 3 + 3; // f, c, alpha, k, om, T,\n  112          jacobian.create(2*(int)n, nvars, CV_64F);\n  113          Jn = jacobian.getMat().ptr<JacobianRow>(0);\n  ...\n  836  \n  837      //-------------------------------\n  838:     _K = Matx33d(finalParam.f[0], finalParam.f[0] * finalParam.alpha, finalParam.c[0],\n  839              0,                    finalParam.f[1], finalParam.c[1],\n  840              0,                                  0,               1);\n  ...\n 1089      rms = sqrt(rms);\n 1090  \n 1091:     _K1 = Matx33d(intrinsicLeft.f[0], intrinsicLeft.f[0] * intrinsicLeft.alpha, intrinsicLeft.c[0],\n 1092                                         0,                       intrinsicLeft.f[1], intrinsicLeft.c[1],\n 1093                                         0,                                        0,                 1);\n 1094  \n 1095:     _K2 = Matx33d(intrinsicRight.f[0], intrinsicRight.f[0] * intrinsicRight.alpha, intrinsicRight.c[0],\n 1096                                          0,                        intrinsicRight.f[1], intrinsicRight.c[1],\n 1097                                          0,                                          0,                  1);\n ....\n 1205  \n 1206      CV_Assert(!objectPoints.empty() && (objectPoints.type() == CV_32FC3 || objectPoints.type() == CV_64FC3));\n 1207:     Matx33d K(param.f[0], param.f[0] * param.alpha, param.c[0],\n 1208                         0,               param.f[1], param.c[1],\n 1209                         0,                        0,         1);\n 1210:     fisheye::projectPoints(objectPoints, imagePoints, _rvec, _tvec, K, param.k, param.alpha, jacobian);\n 1211  }\n 1212  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/src/undistort.dispatch.cpp:\n  608  }\n  609  \n  610: static Point2f mapPointSpherical(const Point2f& p, float alpha, Vec4d* J, enum UndistortTypes projType)\n  611  {\n  612      double x = p.x, y = p.y;\n  ...\n  644  \n  645  \n  646: static Point2f invMapPointSpherical(Point2f _p, float alpha, enum UndistortTypes projType)\n  647  {\n  648      double eps = 1e-12;\n  ...\n  653      for( i = 0; i < maxiter; i++ )\n  654      {\n  655:         Point2f p1 = mapPointSpherical(Point2f((float)q[0], (float)q[1]), alpha, &J, projType);\n  656          err = Vec2d(p1.x, p1.y) - p;\n  657          if( err[0]*err[0] + err[1]*err[1] < eps )\n  ...\n  697      cameraMatrix0.convertTo(cameraMatrix,CV_64F);\n  698  \n  699:     alpha = std::min(alpha, 0.999f);\n  700  \n  701      for( int i = 0; i < N; i++ )\n  ...\n  705              uvec[0] = p;\n  706              undistortPoints(uvec, vvec, cameraMatrix, distCoeffs, I, I);\n  707:             Point2f q = mapPointSpherical(vvec[0], alpha, 0, projType);\n  708              if( xmin > q.x ) xmin = q.x;\n  709              if( xmax < q.x ) xmax = q.x;\n  ...\n  728          {\n  729              Point2f p = (Point2f((float)x, (float)y) - dcenter)*(1.f/scale);\n  730:             Point2f q = invMapPointSpherical(p, alpha, projType);\n  731              if( q.x <= -FLT_MAX && q.y <= -FLT_MAX )\n  732              {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/test/test_cameracalibration.cpp:\n 1263          Size imageSize, const Mat& R, const Mat& T,\n 1264          Mat& R1, Mat& R2, Mat& P1, Mat& P2, Mat& Q,\n 1265:         double alpha, Size newImageSize,\n 1266          Rect* validPixROI1, Rect* validPixROI2, int flags ) = 0;\n 1267      virtual bool rectifyUncalibrated( const Mat& points1,\n ....\n 1666          Size imageSize, const Mat& R, const Mat& T,\n 1667          Mat& R1, Mat& R2, Mat& P1, Mat& P2, Mat& Q,\n 1668:         double alpha, Size newImageSize,\n 1669          Rect* validPixROI1, Rect* validPixROI2, int flags );\n 1670      virtual bool rectifyUncalibrated( const Mat& points1,\n ....\n 1696                                           Size imageSize, const Mat& R, const Mat& T,\n 1697                                           Mat& R1, Mat& R2, Mat& P1, Mat& P2, Mat& Q,\n 1698:                                          double alpha, Size newImageSize,\n 1699                                           Rect* validPixROI1, Rect* validPixROI2, int flags )\n 1700  {\n 1701      stereoRectify( cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2,\n 1702:                 imageSize, R, T, R1, R2, P1, P2, Q, flags, alpha, newImageSize,validPixROI1, validPixROI2 );\n 1703  }\n 1704  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/test/test_fisheye.cpp:\n  281  \n  282      cv::Mat jacobians;\n  283:     cv::fisheye::projectPoints(X, x1, om, theT, theK, k, alpha, jacobians);\n  284  \n  285      //test on T:\n  ...\n  288      dT *= 1e-9*cv::norm(theT);\n  289      cv::Mat T2 = theT + dT;\n  290:     cv::fisheye::projectPoints(X, x2, om, T2, theK, k, alpha, cv::noArray());\n  291      xpred = x1 + cv::Mat(jacobians.colRange(11,14) * dT).reshape(2, 1);\n  292      CV_Assert (cv::norm(x2 - xpred) < 1e-10);\n  ...\n  297      dom *= 1e-9*cv::norm(om);\n  298      cv::Mat om2 = om + dom;\n  299:     cv::fisheye::projectPoints(X, x2, om2, theT, theK, k, alpha, cv::noArray());\n  300      xpred = x1 + cv::Mat(jacobians.colRange(8,11) * dom).reshape(2, 1);\n  301      CV_Assert (cv::norm(x2 - xpred) < 1e-10);\n  ...\n  305      r.fill(df, cv::RNG::NORMAL, 0, 1);\n  306      df *= 1e-9*cv::norm(f);\n  307:     cv::Matx33d K2 = theK + cv::Matx33d(df.at<double>(0), df.at<double>(0) * alpha, 0, 0, df.at<double>(1), 0, 0, 0, 0);\n  308:     cv::fisheye::projectPoints(X, x2, om, theT, K2, k, alpha, cv::noArray());\n  309      xpred = x1 + cv::Mat(jacobians.colRange(0,2) * df).reshape(2, 1);\n  310      CV_Assert (cv::norm(x2 - xpred) < 1e-10);\n  ...\n  315      dc *= 1e-9*cv::norm(c);\n  316      K2 = theK + cv::Matx33d(0, 0, dc.at<double>(0), 0, 0, dc.at<double>(1), 0, 0, 0);\n  317:     cv::fisheye::projectPoints(X, x2, om, theT, K2, k, alpha, cv::noArray());\n  318      xpred = x1 + cv::Mat(jacobians.colRange(2,4) * dc).reshape(2, 1);\n  319      CV_Assert (cv::norm(x2 - xpred) < 1e-10);\n  ...\n  324      dk *= 1e-9*cv::norm(k);\n  325      cv::Mat k2 = k + dk;\n  326:     cv::fisheye::projectPoints(X, x2, om, theT, theK, k2, alpha, cv::noArray());\n  327      xpred = x1 + cv::Mat(jacobians.colRange(4,8) * dk).reshape(2, 1);\n  328      CV_Assert (cv::norm(x2 - xpred) < 1e-10);\n  ...\n  330      //test on alpha:\n  331      cv::Mat dalpha(1, 1, CV_64FC1);\n  332:     r.fill(dalpha, cv::RNG::NORMAL, 0, 1);\n  333      dalpha *= 1e-9*cv::norm(f);\n  334      double alpha2 = alpha + dalpha.at<double>(0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/test/test_fundam.cpp:\n  142                  CvMat _t1 = cvMat( 9, 4, CV_64FC1, dRdm1 );\n  143  \n  144:                 // m1 = [alpha, beta, gamma, omegav; A]\n  145                  memset( dm1dm2, 0, sizeof(dm1dm2) );\n  146                  dm1dm2[3] = -beta;\n  ...\n  209      {\n  210          double R[9], A[9], I[9], r[3], W[3], U[9], V[9];\n  211:         double tr, alpha, beta, theta;\n  212          CvMat matR = cvMat( 3, 3, CV_64F, R );\n  213          CvMat matA = cvMat( 3, 3, CV_64F, A );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core.hpp:\n  476  @sa add, addWeighted, subtract, Mat::dot, Mat::convertTo\n  477  */\n  478: CV_EXPORTS_W void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst);\n  479  \n  480  /** @example samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp\n  ...\n  504  @sa  add, subtract, scaleAdd, Mat::convertTo\n  505  */\n  506: CV_EXPORTS_W void addWeighted(InputArray src1, double alpha, InputArray src2,\n  507                                double beta, double gamma, OutputArray dst, int dtype = -1);\n  508  \n  ...\n  802  @param normType normalization type (see cv::NormTypes).\n  803  */\n  804: CV_EXPORTS void normalize( const SparseMat& src, SparseMat& dst, double alpha, int normType );\n  805  \n  806  /** @brief Finds the global minimum and maximum in an array.\n  ...\n 1670  The function cv::gemm performs generalized matrix multiplication similar to the\n 1671  gemm functions in BLAS level 3. For example,\n 1672: `gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)`\n 1673  corresponds to\n 1674  \\f[\\texttt{dst} =  \\texttt{alpha} \\cdot \\texttt{src1} ^T  \\cdot \\texttt{src2} +  \\texttt{beta} \\cdot \\texttt{src3} ^T\\f]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/cuda.hpp:\n  229  \n  230      //! converts GpuMat to another datatype with scaling (Blocking call)\n  231:     CV_WRAP void convertTo(OutputArray dst, int rtype, double alpha, double beta = 0.0) const;\n  232  \n  233      //! converts GpuMat to another datatype with scaling (Non-Blocking call)\n  234:     CV_WRAP void convertTo(OutputArray dst, int rtype, double alpha, Stream& stream) const;\n  235  \n  236      //! converts GpuMat to another datatype with scaling (Non-Blocking call)\n  237:     CV_WRAP void convertTo(OutputArray dst, int rtype, double alpha, double beta, Stream& stream) const;\n  238  \n  239      CV_WRAP void assignTo(GpuMat& m, int type = -1) const;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/cuda.inl.hpp:\n  184  \n  185  inline\n  186: void GpuMat::convertTo(OutputArray dst, int rtype, double alpha, double beta) const\n  187  {\n  188:     convertTo(dst, rtype, alpha, beta, Stream::Null());\n  189  }\n  190  \n  191  inline\n  192: void GpuMat::convertTo(OutputArray dst, int rtype, double alpha, Stream& stream) const\n  193  {\n  194:     convertTo(dst, rtype, alpha, 0.0, stream);\n  195  }\n  196  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/mat.hpp:\n 3587  \n 3588      Mat a, b, c;\n 3589:     double alpha, beta;\n 3590      Scalar s;\n 3591  };\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/mat.inl.hpp:\n 3068  inline\n 3069  MatExpr::MatExpr(const MatOp* _op, int _flags, const Mat& _a, const Mat& _b,\n 3070:                  const Mat& _c, double _alpha, double _beta, const Scalar& _s)\n 3071      : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s)\n 3072  {}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/matx.hpp:\n  210      Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_AddOp);\n  211      Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_SubOp);\n  212:     template<typename _T2> Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp);\n  213      Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_MulOp);\n  214      Matx(const Matx<_Tp, m, n>& a, const Matx<_Tp, m, n>& b, Matx_DivOp);\n  ...\n  401      Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_AddOp);\n  402      Vec(const Matx<_Tp, cn, 1>& a, const Matx<_Tp, cn, 1>& b, Matx_SubOp);\n  403:     template<typename _T2> Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp);\n  404  };\n  405  \n  ...\n  837  \n  838  template<typename _Tp, int m, int n> template<typename _T2> inline\n  839: Matx<_Tp,m,n>::Matx(const Matx<_Tp, m, n>& a, _T2 alpha, Matx_ScaleOp)\n  840  {\n  841      for( int i = 0; i < channels; i++ )\n  ...\n 1043  \n 1044  template<typename _Tp, int cn> template<typename _T2> inline\n 1045: Vec<_Tp, cn>::Vec(const Matx<_Tp, cn, 1>& a, _T2 alpha, Matx_ScaleOp op)\n 1046:     : Matx<_Tp, cn, 1>(a, alpha, op) {}\n 1047  \n 1048  template<typename _Tp, int cn> inline\n ....\n 1246  Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, int alpha)\n 1247  {\n 1248:     return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());\n 1249  }\n 1250  \n ....\n 1252  Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, float alpha)\n 1253  {\n 1254:     return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());\n 1255  }\n 1256  \n ....\n 1258  Matx<_Tp, m, n> operator * (const Matx<_Tp, m, n>& a, double alpha)\n 1259  {\n 1260:     return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());\n 1261  }\n 1262  \n 1263  template<typename _Tp, int m, int n> static inline\n 1264: Matx<_Tp, m, n> operator * (int alpha, const Matx<_Tp, m, n>& a)\n 1265  {\n 1266:     return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());\n 1267  }\n 1268  \n 1269  template<typename _Tp, int m, int n> static inline\n 1270: Matx<_Tp, m, n> operator * (float alpha, const Matx<_Tp, m, n>& a)\n 1271  {\n 1272:     return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());\n 1273  }\n 1274  \n 1275  template<typename _Tp, int m, int n> static inline\n 1276: Matx<_Tp, m, n> operator * (double alpha, const Matx<_Tp, m, n>& a)\n 1277  {\n 1278:     return Matx<_Tp, m, n>(a, alpha, Matx_ScaleOp());\n 1279  }\n 1280  \n ....\n 1298  Matx<_Tp, m, n> operator / (const Matx<_Tp, m, n>& a, float alpha)\n 1299  {\n 1300:     return Matx<_Tp, m, n>(a, 1.f/alpha, Matx_ScaleOp());\n 1301  }\n 1302  \n ....\n 1304  Matx<_Tp, m, n> operator / (const Matx<_Tp, m, n>& a, double alpha)\n 1305  {\n 1306:     return Matx<_Tp, m, n>(a, 1./alpha, Matx_ScaleOp());\n 1307  }\n 1308  \n ....\n 1429  Vec<_Tp, cn> operator * (const Vec<_Tp, cn>& a, int alpha)\n 1430  {\n 1431:     return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());\n 1432  }\n 1433  \n 1434  template<typename _Tp, int cn> static inline\n 1435: Vec<_Tp, cn> operator * (int alpha, const Vec<_Tp, cn>& a)\n 1436  {\n 1437:     return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());\n 1438  }\n 1439  \n ....\n 1441  Vec<_Tp, cn> operator * (const Vec<_Tp, cn>& a, float alpha)\n 1442  {\n 1443:     return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());\n 1444  }\n 1445  \n 1446  template<typename _Tp, int cn> static inline\n 1447: Vec<_Tp, cn> operator * (float alpha, const Vec<_Tp, cn>& a)\n 1448  {\n 1449:     return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());\n 1450  }\n 1451  \n ....\n 1453  Vec<_Tp, cn> operator * (const Vec<_Tp, cn>& a, double alpha)\n 1454  {\n 1455:     return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());\n 1456  }\n 1457  \n 1458  template<typename _Tp, int cn> static inline\n 1459: Vec<_Tp, cn> operator * (double alpha, const Vec<_Tp, cn>& a)\n 1460  {\n 1461:     return Vec<_Tp, cn>(a, alpha, Matx_ScaleOp());\n 1462  }\n 1463  \n ....\n 1465  Vec<_Tp, cn> operator / (const Vec<_Tp, cn>& a, int alpha)\n 1466  {\n 1467:     return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());\n 1468  }\n 1469  \n ....\n 1471  Vec<_Tp, cn> operator / (const Vec<_Tp, cn>& a, float alpha)\n 1472  {\n 1473:     return Vec<_Tp, cn>(a, 1.f/alpha, Matx_ScaleOp());\n 1474  }\n 1475  \n ....\n 1477  Vec<_Tp, cn> operator / (const Vec<_Tp, cn>& a, double alpha)\n 1478  {\n 1479:     return Vec<_Tp, cn>(a, 1./alpha, Matx_ScaleOp());\n 1480  }\n 1481  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.inl.hpp:\n  379  \n  380  template <typename T>\n  381: inline Quat<T> power(const Quat<T> &q1, const T alpha, QuatAssumeType assumeUnit)\n  382  {\n  383:     return q1.power(alpha, assumeUnit);\n  384  }\n  385  \n  386  template <typename T>\n  387: inline Quat<T> Quat<T>::power(const T alpha, QuatAssumeType assumeUnit) const\n  388  {\n  389      if (x * x + y * y + z * z > CV_QUAT_EPS)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/types.hpp:\n 2288  \n 2289  template<typename _Tp> static inline\n 2290: Scalar_<_Tp> operator * (_Tp alpha, const Scalar_<_Tp>& a)\n 2291  {\n 2292      return a*alpha;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/hal/hal.hpp:\n   71  \n   72  CV_EXPORTS void gemm32f(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n   73:                         float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n   74                          int m_a, int n_a, int n_d, int flags);\n   75  CV_EXPORTS void gemm64f(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n   76:                         double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n   77                          int m_a, int n_a, int n_d, int flags);\n   78  CV_EXPORTS void gemm32fc(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n   79:                         float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n   80                          int m_a, int n_a, int n_d, int flags);\n   81  CV_EXPORTS void gemm64fc(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n   82:                         double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n   83                          int m_a, int n_a, int n_d, int flags);\n   84  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/opencl/runtime/autogenerated/opencl_clblas.hpp:\n  454  \n  455  // generated by parser_clblas.py\n  456: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCaxpy)(size_t N, cl_float2 alpha, const cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  457  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCcopy)(size_t N, const cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  458  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCdotc)(size_t N, cl_mem dotProduct, size_t offDP, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  459  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCdotu)(size_t N, cl_mem dotProduct, size_t offDP, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  460: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCgbmv)(clblasOrder order, clblasTranspose trans, size_t M, size_t N, size_t KL, size_t KU, cl_float2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_float2 beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  461: extern CL_RUNTIME_EXPORT clblasStatus (*clblasCgemm)(clblasOrder order, clblasTranspose transA, clblasTranspose transB, size_t M, size_t N, size_t K, FloatComplex alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, FloatComplex beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  462: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCgemv)(clblasOrder order, clblasTranspose transA, size_t M, size_t N, FloatComplex alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem x, size_t offx, int incx, FloatComplex beta, cl_mem y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  463: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCgerc)(clblasOrder order, size_t M, size_t N, cl_float2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  464: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCgeru)(clblasOrder order, size_t M, size_t N, cl_float2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  465: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasChbmv)(clblasOrder order, clblasUplo uplo, size_t N, size_t K, cl_float2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_float2 beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  466: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasChemm)(clblasOrder order, clblasSide side, clblasUplo uplo, size_t M, size_t N, cl_float2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_float2 beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  467: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasChemv)(clblasOrder order, clblasUplo uplo, size_t N, FloatComplex alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, FloatComplex beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  468: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCher)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  469: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCher2)(clblasOrder order, clblasUplo uplo, size_t N, cl_float2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  470: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCher2k)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, size_t N, size_t K, FloatComplex alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_float beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  471: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCherk)(clblasOrder order, clblasUplo uplo, clblasTranspose transA, size_t N, size_t K, float alpha, const cl_mem A, size_t offa, size_t lda, float beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  472: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasChpmv)(clblasOrder order, clblasUplo uplo, size_t N, cl_float2 alpha, const cl_mem AP, size_t offa, const cl_mem X, size_t offx, int incx, cl_float2 beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  473: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasChpr)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  474: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasChpr2)(clblasOrder order, clblasUplo uplo, size_t N, cl_float2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  475  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCrotg)(cl_mem CA, size_t offCA, cl_mem CB, size_t offCB, cl_mem C, size_t offC, cl_mem S, size_t offS, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  476: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCscal)(size_t N, cl_float2 alpha, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  477  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCsrot)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_float C, cl_float S, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  478: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCsscal)(size_t N, cl_float alpha, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  479  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCswap)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  480: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCsymm)(clblasOrder order, clblasSide side, clblasUplo uplo, size_t M, size_t N, cl_float2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_float2 beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  481: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCsyr2k)(clblasOrder order, clblasUplo uplo, clblasTranspose transAB, size_t N, size_t K, FloatComplex alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, FloatComplex beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  482: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCsyrk)(clblasOrder order, clblasUplo uplo, clblasTranspose transA, size_t N, size_t K, FloatComplex alpha, const cl_mem A, size_t offA, size_t lda, FloatComplex beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  483  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtbmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  484  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtbsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  485  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtpmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem AP, size_t offa, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  486  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtpsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  487: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtrmm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, FloatComplex alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  488  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtrmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  489: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtrsm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, FloatComplex alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  490  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasCtrsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  491  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDasum)(size_t N, cl_mem asum, size_t offAsum, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  492: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDaxpy)(size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  493  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDcopy)(size_t N, const cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  494  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDdot)(size_t N, cl_mem dotProduct, size_t offDP, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  495: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDgbmv)(clblasOrder order, clblasTranspose trans, size_t M, size_t N, size_t KL, size_t KU, cl_double alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_double beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  496: extern CL_RUNTIME_EXPORT clblasStatus (*clblasDgemm)(clblasOrder order, clblasTranspose transA, clblasTranspose transB, size_t M, size_t N, size_t K, cl_double alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, cl_double beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  497: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDgemv)(clblasOrder order, clblasTranspose transA, size_t M, size_t N, cl_double alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem x, size_t offx, int incx, cl_double beta, cl_mem y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  498: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDger)(clblasOrder order, size_t M, size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  499  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDnrm2)(size_t N, cl_mem NRM2, size_t offNRM2, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  500  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDrot)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_double C, cl_double S, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  ...\n  502  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDrotm)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, const cl_mem DPARAM, size_t offDparam, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  503  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDrotmg)(cl_mem DD1, size_t offDD1, cl_mem DD2, size_t offDD2, cl_mem DX1, size_t offDX1, const cl_mem DY1, size_t offDY1, cl_mem DPARAM, size_t offDparam, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  504: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDsbmv)(clblasOrder order, clblasUplo uplo, size_t N, size_t K, cl_double alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_double beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  505: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDscal)(size_t N, cl_double alpha, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  506: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDspmv)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem AP, size_t offa, const cl_mem X, size_t offx, int incx, cl_double beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  507: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDspr)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  508: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDspr2)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  509  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDswap)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  510: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDsymm)(clblasOrder order, clblasSide side, clblasUplo uplo, size_t M, size_t N, cl_double alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_double beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  511: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDsymv)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem x, size_t offx, int incx, cl_double beta, cl_mem y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  512: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDsyr)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  513: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDsyr2)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  514: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDsyr2k)(clblasOrder order, clblasUplo uplo, clblasTranspose transAB, size_t N, size_t K, cl_double alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, cl_double beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  515: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDsyrk)(clblasOrder order, clblasUplo uplo, clblasTranspose transA, size_t N, size_t K, cl_double alpha, const cl_mem A, size_t offA, size_t lda, cl_double beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  516  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtbmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  517  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtbsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  518  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtpmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem AP, size_t offa, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  519  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtpsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  520: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtrmm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, cl_double alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  521  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtrmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  522: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtrsm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, cl_double alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  523  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDtrsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  524  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasDzasum)(size_t N, cl_mem asum, size_t offAsum, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  ...\n  526  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasGetVersion)(cl_uint* major, cl_uint* minor, cl_uint* patch);\n  527  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSasum)(size_t N, cl_mem asum, size_t offAsum, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  528: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSaxpy)(size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  529  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasScasum)(size_t N, cl_mem asum, size_t offAsum, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  530  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasScnrm2)(size_t N, cl_mem NRM2, size_t offNRM2, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  ...\n  532  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSdot)(size_t N, cl_mem dotProduct, size_t offDP, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  533  extern CL_RUNTIME_EXPORT clblasStatus (*clblasSetup)();\n  534: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSgbmv)(clblasOrder order, clblasTranspose trans, size_t M, size_t N, size_t KL, size_t KU, cl_float alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_float beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  535: extern CL_RUNTIME_EXPORT clblasStatus (*clblasSgemm)(clblasOrder order, clblasTranspose transA, clblasTranspose transB, size_t M, size_t N, size_t K, cl_float alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, cl_float beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  536: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSgemv)(clblasOrder order, clblasTranspose transA, size_t M, size_t N, cl_float alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem x, size_t offx, int incx, cl_float beta, cl_mem y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  537: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSger)(clblasOrder order, size_t M, size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  538  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSnrm2)(size_t N, cl_mem NRM2, size_t offNRM2, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  539  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSrot)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_float C, cl_float S, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  ...\n  541  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSrotm)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, const cl_mem SPARAM, size_t offSparam, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  542  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSrotmg)(cl_mem SD1, size_t offSD1, cl_mem SD2, size_t offSD2, cl_mem SX1, size_t offSX1, const cl_mem SY1, size_t offSY1, cl_mem SPARAM, size_t offSparam, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  543: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSsbmv)(clblasOrder order, clblasUplo uplo, size_t N, size_t K, cl_float alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_float beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  544: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSscal)(size_t N, cl_float alpha, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  545: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSspmv)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem AP, size_t offa, const cl_mem X, size_t offx, int incx, cl_float beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  546: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSspr)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  547: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSspr2)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  548  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSswap)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  549: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSsymm)(clblasOrder order, clblasSide side, clblasUplo uplo, size_t M, size_t N, cl_float alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_float beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  550: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSsymv)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem x, size_t offx, int incx, cl_float beta, cl_mem y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  551: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSsyr)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  552: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSsyr2)(clblasOrder order, clblasUplo uplo, size_t N, cl_float alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  553: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSsyr2k)(clblasOrder order, clblasUplo uplo, clblasTranspose transAB, size_t N, size_t K, cl_float alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, cl_float beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  554: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasSsyrk)(clblasOrder order, clblasUplo uplo, clblasTranspose transA, size_t N, size_t K, cl_float alpha, const cl_mem A, size_t offA, size_t lda, cl_float beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  555  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStbmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  556  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStbsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  557  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStpmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem AP, size_t offa, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  558  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStpsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  559: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStrmm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, cl_float alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  560  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStrmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  561: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStrsm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, cl_float alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  562  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasStrsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  563  extern CL_RUNTIME_EXPORT void (*clblasTeardown)();\n  564: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZaxpy)(size_t N, cl_double2 alpha, const cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  565  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZcopy)(size_t N, const cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  566  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZdotc)(size_t N, cl_mem dotProduct, size_t offDP, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  567  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZdotu)(size_t N, cl_mem dotProduct, size_t offDP, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  568  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZdrot)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_double C, cl_double S, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  569: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZdscal)(size_t N, cl_double alpha, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  570: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZgbmv)(clblasOrder order, clblasTranspose trans, size_t M, size_t N, size_t KL, size_t KU, cl_double2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_double2 beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  571: extern CL_RUNTIME_EXPORT clblasStatus (*clblasZgemm)(clblasOrder order, clblasTranspose transA, clblasTranspose transB, size_t M, size_t N, size_t K, DoubleComplex alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, DoubleComplex beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  572: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZgemv)(clblasOrder order, clblasTranspose transA, size_t M, size_t N, DoubleComplex alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem x, size_t offx, int incx, DoubleComplex beta, cl_mem y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  573: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZgerc)(clblasOrder order, size_t M, size_t N, cl_double2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  574: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZgeru)(clblasOrder order, size_t M, size_t N, cl_double2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  575: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZhbmv)(clblasOrder order, clblasUplo uplo, size_t N, size_t K, cl_double2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, cl_double2 beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  576: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZhemm)(clblasOrder order, clblasSide side, clblasUplo uplo, size_t M, size_t N, cl_double2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_double2 beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  577: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZhemv)(clblasOrder order, clblasUplo uplo, size_t N, DoubleComplex alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem X, size_t offx, int incx, DoubleComplex beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  578: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZher)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  579: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZher2)(clblasOrder order, clblasUplo uplo, size_t N, cl_double2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem A, size_t offa, size_t lda, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  580: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZher2k)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, size_t N, size_t K, DoubleComplex alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_double beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  581: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZherk)(clblasOrder order, clblasUplo uplo, clblasTranspose transA, size_t N, size_t K, double alpha, const cl_mem A, size_t offa, size_t lda, double beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  582: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZhpmv)(clblasOrder order, clblasUplo uplo, size_t N, cl_double2 alpha, const cl_mem AP, size_t offa, const cl_mem X, size_t offx, int incx, cl_double2 beta, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  583: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZhpr)(clblasOrder order, clblasUplo uplo, size_t N, cl_double alpha, const cl_mem X, size_t offx, int incx, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  584: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZhpr2)(clblasOrder order, clblasUplo uplo, size_t N, cl_double2 alpha, const cl_mem X, size_t offx, int incx, const cl_mem Y, size_t offy, int incy, cl_mem AP, size_t offa, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  585  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZrotg)(cl_mem CA, size_t offCA, cl_mem CB, size_t offCB, cl_mem C, size_t offC, cl_mem S, size_t offS, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  586: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZscal)(size_t N, cl_double2 alpha, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  587  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZswap)(size_t N, cl_mem X, size_t offx, int incx, cl_mem Y, size_t offy, int incy, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  588: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZsymm)(clblasOrder order, clblasSide side, clblasUplo uplo, size_t M, size_t N, cl_double2 alpha, const cl_mem A, size_t offa, size_t lda, const cl_mem B, size_t offb, size_t ldb, cl_double2 beta, cl_mem C, size_t offc, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  589: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZsyr2k)(clblasOrder order, clblasUplo uplo, clblasTranspose transAB, size_t N, size_t K, DoubleComplex alpha, const cl_mem A, size_t offA, size_t lda, const cl_mem B, size_t offB, size_t ldb, DoubleComplex beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  590: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZsyrk)(clblasOrder order, clblasUplo uplo, clblasTranspose transA, size_t N, size_t K, DoubleComplex alpha, const cl_mem A, size_t offA, size_t lda, DoubleComplex beta, cl_mem C, size_t offC, size_t ldc, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  591  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtbmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  592  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtbsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, size_t K, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  593  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtpmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem AP, size_t offa, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  594  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtpsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  595: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtrmm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, DoubleComplex alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  596  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtrmv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  597: //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtrsm)(clblasOrder order, clblasSide side, clblasUplo uplo, clblasTranspose transA, clblasDiag diag, size_t M, size_t N, DoubleComplex alpha, const cl_mem A, size_t offA, size_t lda, cl_mem B, size_t offB, size_t ldb, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  598  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasZtrsv)(clblasOrder order, clblasUplo uplo, clblasTranspose trans, clblasDiag diag, size_t N, const cl_mem A, size_t offa, size_t lda, cl_mem X, size_t offx, int incx, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n  599  //extern CL_RUNTIME_EXPORT clblasStatus (*clblasiCamax)(size_t N, cl_mem iMax, size_t offiMax, const cl_mem X, size_t offx, int incx, cl_mem scratchBuff, cl_uint numCommandQueues, cl_command_queue* commandQueues, cl_uint numEventsInWaitList, const cl_event* eventWaitList, cl_event* events);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/misc/java/src/java/core+Mat.java:\n  239      //\n  240  \n  241:     // javadoc: Mat::convertTo(m, rtype, alpha, beta)\n  242:     public void convertTo(Mat m, int rtype, double alpha, double beta) {\n  243:         n_convertTo(nativeObj, m.nativeObj, rtype, alpha, beta);\n  244      }\n  245  \n  ...\n 1673      // C++: void Mat::convertTo(Mat& m, int rtype, double alpha = 1, double beta\n 1674      // = 0)\n 1675:     private static native void n_convertTo(long nativeObj, long m_nativeObj, int rtype, double alpha, double beta);\n 1676  \n 1677      private static native void n_convertTo(long nativeObj, long m_nativeObj, int rtype, double alpha);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/misc/objc/common/Mat.mm:\n  246  \n  247  - (void)convertTo:(Mat*)mat rtype:(int)rtype alpha:(double)alpha beta:(double)beta {\n  248:     _nativePtr->convertTo(*(cv::Mat*)mat->_nativePtr, rtype, alpha, beta);\n  249  }\n  250  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/perf/perf_addWeighted.cpp:\n   30      }\n   31  \n   32:     TEST_CYCLE() cv::addWeighted( src1, alpha, src2, beta, gamma, dst, dst.type() );\n   33  \n   34      SANITY_CHECK(dst, depth == CV_32S ? 4 : 1);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/perf/perf_convertTo.cpp:\n    8  typedef perf::TestBaseWithParam<Size_DepthSrc_DepthDst_Channels_alpha_t> Size_DepthSrc_DepthDst_Channels_alpha;\n    9  \n   10: PERF_TEST_P( Size_DepthSrc_DepthDst_Channels_alpha, convertTo,\n   11               testing::Combine\n   12               (\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/perf/perf_norm.cpp:\n  179      declare.in(src, WARMUP_RNG).out(dst);\n  180  \n  181:     TEST_CYCLE() cv::normalize(src, dst, alpha, 0., normType);\n  182  \n  183      SANITY_CHECK(dst, 1e-6);\n  ...\n  207      declare.time(100);\n  208  \n  209:     TEST_CYCLE() cv::normalize(src, dst, alpha, 0., normType, -1, mask);\n  210  \n  211      SANITY_CHECK(dst, 1e-6);\n  ...\n  233      declare.in(src, WARMUP_RNG).out(dst);\n  234  \n  235:     TEST_CYCLE() cv::normalize(src, dst, alpha, 0., normType, CV_32F);\n  236  \n  237      SANITY_CHECK(dst, 1e-6, ERROR_RELATIVE);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/perf/opencl/perf_arithm.cpp:\n  652      double alpha = 2.0, beta = 1.0, gama = 3.0;\n  653  \n  654:     OCL_TEST_CYCLE() cv::addWeighted(src1, alpha, src2, beta, gama, dst);\n  655  \n  656      if (depth >= CV_32F)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/arithm.cpp:\n 1034  }\n 1035  \n 1036: void cv::addWeighted( InputArray src1, double alpha, InputArray src2,\n 1037                        double beta, double gamma, OutputArray dst, int dtype )\n 1038  {\n 1039      CV_INSTRUMENT_REGION();\n 1040  \n 1041:     double scalars[] = {alpha, beta, gamma};\n 1042      arithm_op(src1, src2, dst, noArray(), dtype, getAddWeightedTab(), true, scalars, OCL_OP_ADDW);\n 1043  }\n ....\n 1994          dst = cv::cvarrToMat(dstarr);\n 1995      CV_Assert( src1.size == dst.size && src1.channels() == dst.channels() );\n 1996:     cv::addWeighted( src1, alpha, src2, beta, gamma, dst, dst.type() );\n 1997  }\n 1998  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/arithm.simd.hpp:\n  129  // weight\n  130  template<typename T1, typename T2>\n  131: static inline T1 c_add(T1 a, T1 b, T2 alpha, T2 beta, T2 gamma)\n  132  { return saturate_cast<T1>(a * alpha + b * beta + gamma); }\n  133  template<>\n  134: inline uchar c_add<uchar, float>(uchar a, uchar b, float alpha, float beta, float gamma)\n  135  { return saturate_cast<uchar>(CV_8TO32F(a) * alpha + CV_8TO32F(b) * beta + gamma); }\n  136  \n  ...\n 1677      {\n 1678          const v_float32 v_alpha = vx_setall_f32(*scalar);\n 1679:         return v_fma(a, v_alpha, b);\n 1680      }\n 1681      static inline T1 r(T1 a, T1 b, const T2* scalar)\n ....\n 1692      {\n 1693          const v_float64 v_alpha = vx_setall_f64(*scalar);\n 1694:         return v_fma(a, v_alpha, b);\n 1695      }\n 1696  #endif\n ....\n 1710          const v_float32 v_beta  = vx_setall_f32(scalars[1]);\n 1711          const v_float32 v_gamma = vx_setall_f32(scalars[2]);\n 1712:         return v_fma(a, v_alpha, v_fma(b, v_beta, v_gamma));\n 1713      }\n 1714      static inline T1 r(T1 a, T1 b, const T2* scalars)\n ....\n 1727          const v_float64 v_beta  = vx_setall_f64(scalars[1]);\n 1728          const v_float64 v_gamma = vx_setall_f64(scalars[2]);\n 1729:         return v_fma(a, v_alpha, v_fma(b, v_beta, v_gamma));\n 1730      }\n 1731  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/convert.dispatch.cpp:\n  172  #endif\n  173  \n  174: void Mat::convertTo(OutputArray _dst, int _type, double alpha, double beta) const\n  175  {\n  176      CV_INSTRUMENT_REGION();\n  ...\n  204  \n  205      BinaryFunc func = noScale ? getConvertFunc(sdepth, ddepth) : getConvertScaleFunc(sdepth, ddepth);\n  206:     double scale[] = {alpha, beta};\n  207      int cn = channels();\n  208      CV_Assert( func != 0 );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/convert_scale.dispatch.cpp:\n   29  #ifdef HAVE_OPENCL\n   30  \n   31: static bool ocl_convertScaleAbs( InputArray _src, OutputArray _dst, double alpha, double beta )\n   32  {\n   33      const ocl::Device & d = ocl::Device::getDefault();\n   ..\n   75  \n   76      if (wdepth == CV_32F)\n   77:         k.args(srcarg, dstarg, (float)alpha, (float)beta);\n   78      else if (wdepth == CV_64F)\n   79:         k.args(srcarg, dstarg, alpha, beta);\n   80  \n   81      size_t globalsize[2] = { (size_t)src.cols * cn / kercn, ((size_t)src.rows + rowsPerWI - 1) / rowsPerWI };\n   ..\n   85  #endif\n   86  \n   87: void convertScaleAbs(InputArray _src, OutputArray _dst, double alpha, double beta)\n   88  {\n   89      CV_INSTRUMENT_REGION();\n   90  \n   91      CV_OCL_RUN(_src.dims() <= 2 && _dst.isUMat(),\n   92:                ocl_convertScaleAbs(_src, _dst, alpha, beta))\n   93  \n   94      Mat src = _src.getMat();\n   95      int cn = src.channels();\n   96:     double scale[] = {alpha, beta};\n   97      _dst.create( src.dims, src.size, CV_8UC(cn) );\n   98      Mat dst = _dst.getMat();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/cuda_gpu_mat.cpp:\n  503  }\n  504  \n  505: void cv::cuda::GpuMat::convertTo(OutputArray _dst, int rtype, double alpha, double beta, Stream& _stream) const\n  506  {\n  507      CV_UNUSED(_dst);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/downhill_simplex.cpp:\n  354              // Begin a new iteration. First, reflect the worst point about the centroid of others\n  355              double alpha = -1.0;\n  356:             double y_alpha = tryNewPoint(p, coord_sum, ihi, alpha, buf, fcount);\n  357  \n  358              dprintf((\"\\ny_lo=%g, y_nhi=%g, y_hi=%g, y_alpha=%g, p_alpha:\\n\", y_lo, y_nhi, y_hi, y_alpha));\n  ...\n  374                      }\n  375                  }\n  376:                 replacePoint(p, coord_sum, y, ihi, alpha, y_alpha);\n  377              }\n  378              else\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/hal_internal.cpp:\n  425  \n  426      if(typeid(fptype) == typeid(float))\n  427:         cblas_sgemm(CblasRowMajor, transA, transB, a_m, d_n, a_n, (float)alpha, (float*)src1, ldsrc1, (float*)src2, ldsrc2, (float)beta, (float*)dst, lddst);\n  428      else if(typeid(fptype) == typeid(double))\n  429:         cblas_dgemm(CblasRowMajor, transA, transB, a_m, d_n, a_n, (double)alpha, (double*)src1, ldsrc1, (double*)src2, ldsrc2, (double)beta, (double*)dst, lddst);\n  430  \n  431      return CV_HAL_ERROR_OK;\n  ...\n  443      int c_m, c_n, d_m;\n  444      CBLAS_TRANSPOSE transA, transB;\n  445:     std::complex<fptype> cAlpha(alpha, 0.0);\n  446      std::complex<fptype> cBeta(beta, 0.0);\n  447  \n  ...\n  575      if(m < HAL_GEMM_SMALL_MATRIX_THRESH)\n  576          return CV_HAL_ERROR_NOT_IMPLEMENTED;\n  577:     return lapack_gemm(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m, n, k, flags);\n  578  }\n  579  \n  ...\n  583      if(m < HAL_GEMM_SMALL_MATRIX_THRESH)\n  584          return CV_HAL_ERROR_NOT_IMPLEMENTED;\n  585:     return lapack_gemm(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m, n, k, flags);\n  586  }\n  587  \n  ...\n  591      if(m < HAL_GEMM_SMALL_COMPLEX_MATRIX_THRESH)\n  592          return CV_HAL_ERROR_NOT_IMPLEMENTED;\n  593:     return lapack_gemm_c(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m, n, k, flags);\n  594  }\n  595  int lapack_gemm64fc(const double *src1, size_t src1_step, const double *src2, size_t src2_step, double alpha,\n  ...\n  598      if(m < HAL_GEMM_SMALL_COMPLEX_MATRIX_THRESH)\n  599          return CV_HAL_ERROR_NOT_IMPLEMENTED;\n  600:     return lapack_gemm_c(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m, n, k, flags);\n  601  }\n  602  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/hal_internal.hpp:\n   57  int lapack_QR64f(double* src1, size_t src1_step, int m, int n, int k, double* src2, size_t src2_step, double* dst, int* info);\n   58  int lapack_gemm32f(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n   59:                    float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n   60                     int m, int n, int k, int flags);\n   61  int lapack_gemm64f(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n   62:                    double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n   63                     int m, int n, int k, int flags);\n   64  int lapack_gemm32fc(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n   65:                    float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n   66                     int m, int n, int k, int flags);\n   67  int lapack_gemm64fc(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n   68:                    double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n   69                     int m, int n, int k, int flags);\n   70  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/hal_replacement.hpp:\n  696  //! @{\n  697  inline int hal_ni_gemm32f(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n  698:                           float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n  699                            int m, int n, int k, int flags) { return CV_HAL_ERROR_NOT_IMPLEMENTED; }\n  700  inline int hal_ni_gemm64f(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n  701:                           double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n  702                            int m, int n, int k, int flags) { return CV_HAL_ERROR_NOT_IMPLEMENTED; }\n  703  inline int hal_ni_gemm32fc(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n  704:                           float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n  705                            int m, int n, int k, int flags) { return CV_HAL_ERROR_NOT_IMPLEMENTED; }\n  706  inline int hal_ni_gemm64fc(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n  707:                           double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n  708                            int m, int n, int k, int flags) { return CV_HAL_ERROR_NOT_IMPLEMENTED; }\n  709  //! @}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/intel_gpu_gemm.inl.hpp:\n   32      UMat B, Size sizeB,\n   33      UMat D, Size sizeD,\n   34:     double alpha, double beta,\n   35      bool atrans, bool btrans,\n   36      bool& isPropagatedC2D\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/lda.cpp:\n   79          // make reshape happy by cloning for non-continuous matrices\n   80          if(src.getMat(i).isContinuous()) {\n   81:             src.getMat(i).reshape(1, 1).convertTo(xi, rtype, alpha, beta);\n   82          } else {\n   83:             src.getMat(i).clone().reshape(1, 1).convertTo(xi, rtype, alpha, beta);\n   84          }\n   85      }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/matmul.dispatch.cpp:\n  116      if (type == CV_32FC1)\n  117          status = clblasSgemm(order, transA, transB, M, N, K,\n  118:                              (cl_float)alpha, (const cl_mem)A.handle(ACCESS_READ), offa, lda,\n  119                               (const cl_mem)B.handle(ACCESS_READ), offb, ldb,\n  120                               (cl_float)beta, (cl_mem)D.handle(ACCESS_RW), offc, ldc,\n  ...\n  122      else if (type == CV_64FC1)\n  123          status = clblasDgemm(order, transA, transB, M, N, K,\n  124:                              alpha, (const cl_mem)A.handle(ACCESS_READ), offa, lda,\n  125                               (const cl_mem)B.handle(ACCESS_READ), offb, ldb,\n  126                               beta, (cl_mem)D.handle(ACCESS_RW), offc, ldc,\n  ...\n  128      else if (type == CV_32FC2)\n  129      {\n  130:          cl_float2 alpha_2 = { { (cl_float)alpha, 0 } };\n  131           cl_float2 beta_2  = { { (cl_float)beta, 0 } };\n  132           status = clblasCgemm(order, transA, transB, M, N, K,\n  ...\n  138      else if (type == CV_64FC2)\n  139      {\n  140:         cl_double2 alpha_2 = { { alpha, 0 } };\n  141          cl_double2 beta_2  = { { beta, 0 } };\n  142          status = clblasZgemm(order, transA, transB, M, N, K,\n  ...\n  261                 ocl::KernelArg::ReadOnlyNoSize(B, cn, kercn),\n  262                 ocl::KernelArg::ReadWrite(D, cn, kercn),\n  263:                sizeA.width, alpha, beta);\n  264      else\n  265          k.args(ocl::KernelArg::ReadOnlyNoSize(A),\n  266                 ocl::KernelArg::ReadOnlyNoSize(B, cn, kercn),\n  267                 ocl::KernelArg::ReadWrite(D, cn, kercn),\n  268:                sizeA.width, (float)alpha, (float)beta);\n  269  \n  270      size_t globalsize[2] = { (size_t)sizeD.width * cn / kercn, (size_t)sizeD.height};\n  ...\n  279  \n  280  void gemm32f(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n  281:              float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n  282               int m_a, int n_a, int n_d, int flags)\n  283  {\n  284      CV_INSTRUMENT_REGION();\n  285:     CALL_HAL(gemm32f, cv_hal_gemm32f, src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags)\n  286  #ifdef CV_GEMM_BASELINE_ONLY\n  287:     CV_CPU_CALL_BASELINE(gemm32f, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags));\n  288  #else\n  289:     CV_CPU_DISPATCH(gemm32f, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags),\n  290          CV_CPU_DISPATCH_MODES_ALL);\n  291  #endif\n  ...\n  293  \n  294  void gemm64f(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n  295:              double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n  296               int m_a, int n_a, int n_d, int flags)\n  297  {\n  298      CV_INSTRUMENT_REGION();\n  299:     CALL_HAL(gemm64f, cv_hal_gemm64f, src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags)\n  300  #ifdef CV_GEMM_BASELINE_ONLY\n  301:     CV_CPU_CALL_BASELINE(gemm64f, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags));\n  302  #else\n  303:     CV_CPU_DISPATCH(gemm64f, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags),\n  304          CV_CPU_DISPATCH_MODES_ALL);\n  305  #endif\n  ...\n  307  \n  308  void gemm32fc(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n  309:               float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n  310                int m_a, int n_a, int n_d, int flags)\n  311  {\n  312      CV_INSTRUMENT_REGION();\n  313:     CALL_HAL(gemm32fc, cv_hal_gemm32fc, src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags)\n  314  #ifdef CV_GEMM_BASELINE_ONLY\n  315:     CV_CPU_CALL_BASELINE(gemm32fc, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags));\n  316  #else\n  317:     CV_CPU_DISPATCH(gemm32fc, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags),\n  318          CV_CPU_DISPATCH_MODES_ALL);\n  319  #endif\n  ...\n  321  \n  322  void gemm64fc(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n  323:               double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n  324                int m_a, int n_a, int n_d, int flags)\n  325  {\n  326      CV_INSTRUMENT_REGION();\n  327:     CALL_HAL(gemm64fc, cv_hal_gemm64fc, src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags)\n  328  #ifdef CV_GEMM_BASELINE_ONLY\n  329:     CV_CPU_CALL_BASELINE(gemm64fc, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags));\n  330  #else\n  331:     CV_CPU_DISPATCH(gemm64fc, (src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags),\n  332          CV_CPU_DISPATCH_MODES_ALL);\n  333  #endif\n  ...\n  342      CV_OCL_RUN(ocl::haveAmdBlas() && matA.dims() <= 2 && matB.dims() <= 2 && matC.dims() <= 2 && _matD.isUMat() &&\n  343          matA.cols() > 20 && matA.rows() > 20 && matB.cols() > 20, // since it works incorrect for small sizes\n  344:         ocl_gemm_amdblas(matA, matB, alpha, matC, beta, _matD, flags))\n  345  #endif\n  346  \n  347  #ifdef HAVE_OPENCL\n  348      CV_OCL_RUN(_matD.isUMat() && matA.dims() <= 2 && matB.dims() <= 2 && matC.dims() <= 2,\n  349:                ocl_gemm(matA, matB, alpha, matC, beta, _matD, flags))\n  350  #endif\n  351  \n  ...\n  497          if( scn == 1 )\n  498          {\n  499:             double alpha, beta;\n  500              if( mtype == CV_32F )\n  501                  alpha = m.at<float>(0), beta = m.at<float>(1);\n  502              else\n  503                  alpha = m.at<double>(0), beta = m.at<double>(1);\n  504:             src.convertTo(dst, dst.type(), alpha, beta);\n  505              return;\n  506          }\n  ...\n  585  #ifdef HAVE_OPENCL\n  586  \n  587: static bool ocl_scaleAdd( InputArray _src1, double alpha, InputArray _src2, OutputArray _dst, int type )\n  588  {\n  589      const ocl::Device & d = ocl::Device::getDefault();\n  ...\n  638  }\n  639  \n  640: void scaleAdd(InputArray _src1, double alpha, InputArray _src2, OutputArray _dst)\n  641  {\n  642      CV_INSTRUMENT_REGION();\n  ...\n  646  \n  647      CV_OCL_RUN(_src1.dims() <= 2 && _src2.dims() <= 2 && _dst.isUMat(),\n  648:             ocl_scaleAdd(_src1, alpha, _src2, _dst, type))\n  649  \n  650      if( depth < CV_32F )\n  651      {\n  652:         addWeighted(_src1, alpha, _src2, 1, 0, _dst, depth);\n  653          return;\n  654      }\n  ...\n 1109                 D.type() == A.type() );\n 1110  \n 1111:     gemm( A, B, alpha, C, beta, D, flags );\n 1112  }\n 1113  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/matmul.simd.hpp:\n   63  \n   64  void gemm32f(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n   65:              float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n   66               int m_a, int n_a, int n_d, int flags);\n   67  void gemm64f(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n   68:              double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n   69               int m_a, int n_a, int n_d, int flags);\n   70  void gemm32fc(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n   71:               float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n   72                int m_a, int n_a, int n_d, int flags);\n   73  void gemm64fc(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n   74:               double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n   75                int m_a, int n_a, int n_d, int flags);\n   76  \n   ..\n  183                 T* d_data, size_t d_step,\n  184                 Size a_size, Size d_size,\n  185:                double alpha, double beta, int flags )\n  186  {\n  187      int i, j, k, n = a_size.width, m = d_size.width, drows = d_size.height;\n  ...\n  540             const WT* d_buf, size_t d_buf_step,\n  541             T* d_data, size_t d_step, Size d_size,\n  542:            double alpha, double beta, int flags )\n  543  {\n  544      const T* _c_data = c_data;\n  ...\n  612                     const void* src2, size_t step2, const void* src3, size_t step3,\n  613                     void* dst, size_t dststep, Size srcsize, Size dstsize,\n  614:                    double alpha, double beta, int flags );\n  615  \n  616  typedef void (*GEMMBlockMulFunc)( const void* src1, size_t step1,\n  ...\n  620  typedef void (*GEMMStoreFunc)( const void* src1, size_t step1,\n  621                     const void* src2, size_t step2, void* dst, size_t dststep,\n  622:                    Size dstsize, double alpha, double beta, int flags );\n  623  \n  624  static void GEMMSingleMul_32f( const float* a_data, size_t a_step,\n  ...\n  627                float* d_data, size_t d_step,\n  628                Size a_size, Size d_size,\n  629:               double alpha, double beta, int flags )\n  630  {\n  631      GEMMSingleMul<float,double>(a_data, a_step, b_data, b_step, c_data,\n  632                                  c_step, d_data, d_step, a_size, d_size,\n  633:                                 alpha, beta, flags);\n  634  }\n  635  \n  ...\n  639                                double* d_data, size_t d_step,\n  640                                Size a_size, Size d_size,\n  641:                               double alpha, double beta, int flags )\n  642  {\n  643      GEMMSingleMul<double,double>(a_data, a_step, b_data, b_step, c_data,\n  644                                  c_step, d_data, d_step, a_size, d_size,\n  645:                                 alpha, beta, flags);\n  646  }\n  647  \n  ...\n  652                                Complexf* d_data, size_t d_step,\n  653                                Size a_size, Size d_size,\n  654:                               double alpha, double beta, int flags )\n  655  {\n  656      GEMMSingleMul<Complexf,Complexd>(a_data, a_step, b_data, b_step, c_data,\n  657                                  c_step, d_data, d_step, a_size, d_size,\n  658:                                 alpha, beta, flags);\n  659  }\n  660  \n  ...\n  664                                Complexd* d_data, size_t d_step,\n  665                                Size a_size, Size d_size,\n  666:                               double alpha, double beta, int flags )\n  667  {\n  668      GEMMSingleMul<Complexd,Complexd>(a_data, a_step, b_data, b_step, c_data,\n  669                                   c_step, d_data, d_step, a_size, d_size,\n  670:                                  alpha, beta, flags);\n  671  }\n  672  \n  ...\n  710            const double* d_buf, size_t d_buf_step,\n  711            float* d_data, size_t d_step, Size d_size,\n  712:           double alpha, double beta, int flags )\n  713  {\n  714:     GEMMStore(c_data, c_step, d_buf, d_buf_step, d_data, d_step, d_size, alpha, beta, flags);\n  715  }\n  716  \n  ...\n  719                        const double* d_buf, size_t d_buf_step,\n  720                        double* d_data, size_t d_step, Size d_size,\n  721:                       double alpha, double beta, int flags )\n  722  {\n  723:     GEMMStore(c_data, c_step, d_buf, d_buf_step, d_data, d_step, d_size, alpha, beta, flags);\n  724  }\n  725  \n  ...\n  728                            const Complexd* d_buf, size_t d_buf_step,\n  729                            Complexf* d_data, size_t d_step, Size d_size,\n  730:                           double alpha, double beta, int flags )\n  731  {\n  732:     GEMMStore(c_data, c_step, d_buf, d_buf_step, d_data, d_step, d_size, alpha, beta, flags);\n  733  }\n  734  \n  ...\n  737                            const Complexd* d_buf, size_t d_buf_step,\n  738                            Complexd* d_data, size_t d_step, Size d_size,\n  739:                           double alpha, double beta, int flags )\n  740  {\n  741:     GEMMStore(c_data, c_step, d_buf, d_buf_step, d_data, d_step, d_size, alpha, beta, flags);\n  742  }\n  743  \n  ...\n 1103          if( CV_MAT_DEPTH(type) == CV_32F )\n 1104          {\n 1105:             Complex32f _alpha, _beta;\n 1106  \n 1107              lda = A->step/sizeof(float);\n ....\n 1116  \n 1117              blas_func( transb, transa, &d_size.width, &d_size.height, &len,\n 1118:                    &_alpha, B->data.ptr, &ldb, A->data.ptr, &lda,\n 1119                     &_beta, D->data.ptr, &ldd );\n 1120          }\n 1121          else\n 1122          {\n 1123:             CvComplex64f _alpha, _beta;\n 1124  \n 1125              lda = A->step/sizeof(double);\n ....\n 1134  \n 1135              blas_func( transb, transa, &d_size.width, &d_size.height, &len,\n 1136:                    &_alpha, B->data.ptr, &ldb, A->data.ptr, &lda,\n 1137                     &_beta, D->data.ptr, &ldd );\n 1138          }\n ....\n 1144      {\n 1145          singleMulFunc( A.ptr(), A.step, B.ptr(), b_step, Cdata, Cstep,\n 1146:                        matD->ptr(), matD->step, a_size, d_size, alpha, beta, flags );\n 1147      }\n 1148      else\n ....\n 1275                      else\n 1276                          singleMulFunc( _a, _a_step, _b, _b_step, _c, Cstep,\n 1277:                                        _d, _d_step, a_bl_size, Size(dj,di), alpha, beta, flags );\n 1278                      flags |= 16;\n 1279                  }\n ....\n 1282                      storeFunc( _c, Cstep, _d, _d_step,\n 1283                                 matD->ptr(i) + j*elem_size,\n 1284:                                matD->step, Size(dj,di), alpha, beta, flags );\n 1285              }\n 1286          }\n ....\n 1348      Mat D(m_d, n_d, type, (void*)dst, dst_step);\n 1349  \n 1350:     gemmImpl(A, B, alpha, C, beta, D, flags);\n 1351  }\n 1352  \n 1353  void gemm32f(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n 1354:              float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n 1355               int m_a, int n_a, int n_d, int flags)\n 1356  {\n 1357      CV_INSTRUMENT_REGION();\n 1358:     callGemmImpl(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags, CV_32F);\n 1359  }\n 1360  \n 1361  void gemm64f(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n 1362:              double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n 1363               int m_a, int n_a, int n_d, int flags)\n 1364  {\n 1365      CV_INSTRUMENT_REGION();\n 1366:     callGemmImpl(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags, CV_64F);\n 1367  }\n 1368  \n 1369  void gemm32fc(const float* src1, size_t src1_step, const float* src2, size_t src2_step,\n 1370:               float alpha, const float* src3, size_t src3_step, float beta, float* dst, size_t dst_step,\n 1371                int m_a, int n_a, int n_d, int flags)\n 1372  {\n 1373      CV_INSTRUMENT_REGION();\n 1374:     callGemmImpl(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags, CV_32FC2);\n 1375  }\n 1376  \n 1377  void gemm64fc(const double* src1, size_t src1_step, const double* src2, size_t src2_step,\n 1378:               double alpha, const double* src3, size_t src3_step, double beta, double* dst, size_t dst_step,\n 1379                int m_a, int n_a, int n_d, int flags)\n 1380  {\n 1381      CV_INSTRUMENT_REGION();\n 1382:     callGemmImpl(src1, src1_step, src2, src2_step, alpha, src3, src3_step, beta, dst, dst_step, m_a, n_a, n_d, flags, CV_64FC2);\n 1383  }\n 1384  \n ....\n 1941      const int cWidth = v_float32::nlanes;\n 1942      for (; i <= len - cWidth; i += cWidth)\n 1943:         v_store(dst + i, v_muladd(vx_load(src1 + i), v_alpha, vx_load(src2 + i)));\n 1944      vx_cleanup();\n 1945  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/matrix_expressions.cpp:\n   66      void abs(const MatExpr& expr, MatExpr& res) const CV_OVERRIDE;\n   67  \n   68:     static void makeExpr(MatExpr& res, const Mat& a, const Mat& b, double alpha, double beta, const Scalar& s=Scalar());\n   69  };\n   70  \n   ..\n  230      {\n  231          e = MatExpr(expr.op, expr.flags, Mat(), Mat(), Mat(),\n  232:                     expr.alpha, expr.beta, expr.s);\n  233          if(expr.a.data)\n  234              e.a = expr.a(rowRange, colRange);\n  ...\n  251      {\n  252          e = MatExpr(expr.op, expr.flags, Mat(), Mat(), Mat(),\n  253:                     expr.alpha, expr.beta, expr.s);\n  254          if(expr.a.data)\n  255              e.a = expr.a.diag(d);\n  ...\n  350          else\n  351              e2.op->assign(e2, m2);\n  352:         MatOp_AddEx::makeExpr(res, m1, m2, alpha, beta, s);\n  353      }\n  354      else\n  ...\n  393          else\n  394              e2.op->assign(e2, m2);\n  395:         MatOp_AddEx::makeExpr(res, m1, m2, alpha, beta, s);\n  396      }\n  397      else\n  ...\n 1312                      cv::subtract(e.b, e.a, dst);\n 1313                  else\n 1314:                     cv::scaleAdd(e.a, e.alpha, e.b, dst);\n 1315              }\n 1316              else\n 1317:                 cv::addWeighted(e.a, e.alpha, e.b, e.beta, 0, dst);\n 1318  \n 1319              if( !e.s.isReal() )\n ....\n 1325                  CV_LOG_ONCE_WARNING(NULL, \"OpenCV/MatExpr: processing of multi-channel arrays might be changed in the future: \"\n 1326                                            \"https://github.com/opencv/opencv/issues/16739\");\n 1327:             cv::addWeighted(e.a, e.alpha, e.b, e.beta, e.s[0], dst);\n 1328          }\n 1329      }\n ....\n 1333              CV_LOG_ONCE_WARNING(NULL, \"OpenCV/MatExpr: processing of multi-channel arrays might be changed in the future: \"\n 1334                                        \"https://github.com/opencv/opencv/issues/16739\");\n 1335:         e.a.convertTo(m, _type, e.alpha, e.s[0]);\n 1336          return;\n 1337      }\n ....\n 1413  }\n 1414  \n 1415: inline void MatOp_AddEx::makeExpr(MatExpr& res, const Mat& a, const Mat& b, double alpha, double beta, const Scalar& s)\n 1416  {\n 1417:     res = MatExpr(&g_MatOp_AddEx, 0, a, b, Mat(), alpha, beta, s);\n 1418  }\n 1419  \n ....\n 1429          cv::divide(e.a, e.b, dst, e.alpha);\n 1430      else if( e.flags == '/' && !e.b.data )\n 1431:         cv::divide(e.alpha, e.a, dst );\n 1432      else if( e.flags == '&' && e.b.data )\n 1433          bitwise_and(e.a, e.b, dst);\n ....\n 1481  \n 1482      if( e.flags == '/' && (!e.b.data || e.beta == 0) )\n 1483:         MatOp_AddEx::makeExpr(res, e.a, Mat(), s/e.alpha, 0);\n 1484      else\n 1485          MatOp::divide(s, e, res);\n ....\n 1505          cv::compare(e.a, e.b, dst, e.flags);\n 1506      else\n 1507:         cv::compare(e.a, e.alpha, dst, e.flags);\n 1508  \n 1509      if( dst.data != m.data )\n ....\n 1518  inline void MatOp_Cmp::makeExpr(MatExpr& res, int cmpop, const Mat& a, double alpha)\n 1519  {\n 1520:     res = MatExpr(&g_MatOp_Cmp, cmpop, a, Mat(), Mat(), alpha, 1);\n 1521  }\n 1522  \n ....\n 1548          MatOp_Identity::makeExpr(res, e.a);\n 1549      else\n 1550:         MatOp_AddEx::makeExpr(res, e.a, Mat(), e.alpha, 0);\n 1551  }\n 1552  \n 1553  inline void MatOp_T::makeExpr(MatExpr& res, const Mat& a, double alpha)\n 1554  {\n 1555:     res = MatExpr(&g_MatOp_T, 0, a, Mat(), Mat(), alpha, 0);\n 1556  }\n 1557  \n ....\n 1562      Mat temp, &dst = _type == -1 || _type == e.a.type() ? m : temp;\n 1563  \n 1564:     cv::gemm(e.a, e.b, e.alpha, e.c, e.beta, dst, e.flags);\n 1565      if( dst.data != m.data )\n 1566          dst.convertTo(m, _type);\n ....\n 1572  \n 1573      bool i1 = isIdentity(e1), i2 = isIdentity(e2);\n 1574:     double alpha1 = i1 ? 1 : e1.alpha, alpha2 = i2 ? 1 : e2.alpha;\n 1575  \n 1576      if( isMatProd(e1) && (i2 || isScaled(e2) || isT(e2)) )\n ....\n 1591  \n 1592      bool i1 = isIdentity(e1), i2 = isIdentity(e2);\n 1593:     double alpha1 = i1 ? 1 : e1.alpha, alpha2 = i2 ? 1 : e2.alpha;\n 1594  \n 1595      if( isMatProd(e1) && (i2 || isScaled(e2) || isT(e2)) )\n ....\n 1626  \n 1627  inline void MatOp_GEMM::makeExpr(MatExpr& res, int flags, const Mat& a, const Mat& b,\n 1628:                                  double alpha, const Mat& c, double beta)\n 1629  {\n 1630:     res = MatExpr(&g_MatOp_GEMM, flags, a, b, c, alpha, beta);\n 1631  }\n 1632  \n ....\n 1705  inline void MatOp_Initializer::makeExpr(MatExpr& res, int method, Size sz, int type, double alpha)\n 1706  {\n 1707:     res = MatExpr(getGlobalMatOpInitializer(), method, Mat(sz, type, (void*)(size_t)0xEEEEEEEE), Mat(), Mat(), alpha, 0);\n 1708  }\n 1709  \n 1710  inline void MatOp_Initializer::makeExpr(MatExpr& res, int method, int ndims, const int* sizes, int type, double alpha)\n 1711  {\n 1712:     res = MatExpr(getGlobalMatOpInitializer(), method, Mat(ndims, sizes, type, (void*)(size_t)0xEEEEEEEE), Mat(), Mat(), alpha, 0);\n 1713  }\n 1714  \n ....\n 1827      swap(c, other.c);\n 1828  \n 1829:     swap(alpha, other.alpha);\n 1830      swap(beta, other.beta);\n 1831  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/matrix_sparse.cpp:\n   22  \n   23  template<typename T1, typename T2> void\n   24: convertScaleData_(const void* _from, void* _to, int cn, double alpha, double beta)\n   25  {\n   26      const T1* from = (const T1*)_from;\n   ..\n   34  \n   35  typedef void (*ConvertData)(const void* from, void* to, int cn);\n   36: typedef void (*ConvertScaleData)(const void* from, void* to, int cn, double alpha, double beta);\n   37  \n   38  static ConvertData getConvertElem(int fromType, int toType)\n   ..\n  404              const Node* n = from.node();\n  405              uchar* to = hdr == m.hdr ? from.ptr : m.newNode(n->idx, n->hashval);\n  406:             cvtfunc( from.ptr, to, cn, alpha, 0 );\n  407          }\n  408      }\n  ...\n  410  \n  411  \n  412: void SparseMat::convertTo( Mat& m, int rtype, double alpha, double beta ) const\n  413  {\n  414      int cn = channels();\n  ...\n  441              const Node* n = from.node();\n  442              uchar* to = m.ptr(n->idx);\n  443:             cvtfunc( from.ptr, to, cn, alpha, beta );\n  444          }\n  445      }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/umatrix.cpp:\n 1234  }\n 1235  \n 1236: void UMat::convertTo(OutputArray _dst, int _type, double alpha, double beta) const\n 1237  {\n 1238      CV_INSTRUMENT_REGION();\n ....\n 1273              UMat dst = _dst.getUMat();\n 1274  \n 1275:             float alphaf = (float)alpha, betaf = (float)beta;\n 1276              ocl::KernelArg srcarg = ocl::KernelArg::ReadOnlyNoSize(src),\n 1277                      dstarg = ocl::KernelArg::WriteOnly(dst, cn);\n ....\n 1282                  k.args(srcarg, dstarg, alphaf, betaf, rowsPerWI);\n 1283              else\n 1284:                 k.args(srcarg, dstarg, alpha, beta, rowsPerWI);\n 1285  \n 1286              size_t globalsize[2] = { (size_t)dst.cols * cn, ((size_t)dst.rows + rowsPerWI - 1) / rowsPerWI };\n ....\n 1296                         // Resolves issue 8693 in case of src == dst.\n 1297      Mat m = getMat(ACCESS_READ);\n 1298:     m.convertTo(_dst, _type, alpha, beta);\n 1299  }\n 1300  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/cuda/gpu_mat.cu:\n  498  \n  499      template <typename T, typename D>\n  500:     void convertToScale(const GpuMat& src, const GpuMat& dst, double alpha, double beta, Stream& stream)\n  501      {\n  502          typedef typename VecTraits<T>::elem_type src_elem_type;\n  ...\n  565  }\n  566  \n  567: void cv::cuda::GpuMat::convertTo(OutputArray _dst, int rtype, double alpha, double beta, Stream& stream) const\n  568  {\n  569      if (rtype < 0)\n  ...\n  580      GpuMat dst = _dst.getGpuMat();\n  581  \n  582:     typedef void (*func_t)(const GpuMat& src, const GpuMat& dst, double alpha, double beta, Stream& stream);\n  583      static const func_t funcs[7][7] =\n  584      {\n  ...\n  592      };\n  593  \n  594:     funcs[sdepth][ddepth](src.reshape(1), dst.reshape(1), alpha, beta, stream);\n  595  }\n  596  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/opencl/arithm.cl:\n  291  #elif defined OP_ADDW\n  292  #undef EXTRA_PARAMS\n  293: #define EXTRA_PARAMS , scaleT alpha, scaleT beta, scaleT gamma\n  294  #if wdepth <= 4\n  295: #define PROCESS_ELEM storedst(convertToDT(mad24(srcelem1, alpha, mad24(srcelem2, beta, gamma))))\n  296  #else\n  297: #define PROCESS_ELEM storedst(convertToDT(fma(srcelem1, alpha, fma(srcelem2, beta, gamma))))\n  298  #endif\n  299  \n  ...\n  351  #elif defined OP_CONVERT_SCALE_ABS\n  352  #undef EXTRA_PARAMS\n  353: #define EXTRA_PARAMS , workT1 alpha, workT1 beta\n  354  #if wdepth <= 4\n  355  #define PROCESS_ELEM \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/opencl/convert.cl:\n   55                          __global uchar * dstptr, int dst_step, int dst_offset, int dst_rows, int dst_cols,\n   56  #ifndef NO_SCALE\n   57:                         WT alpha, WT beta,\n   58  #endif\n   59                          int rowsPerWI)\n   ..\n   75              dst[0] = convertToDT(src[0]);\n   76  #else\n   77:             dst[0] = convertToDT(fma(convertToWT(src[0]), alpha, beta));\n   78  #endif\n   79          }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/opencl/gemm.cl:\n   47                     __global const uchar * B_ptr, int B_step, int B_offset,\n   48                     __global uchar * D_ptr, int D_step, int D_offset, int D_rows, int D_cols,\n   49:                    int n, T1 alpha, T1 beta)\n   50  {\n   51      int x = get_global_id(0);\n   ..\n  105          __global WT* D = (__global WT*)(D_ptr + mad24(y, D_step, mad24(x, WTSIZE, D_offset)));\n  106  #if HAVE_C\n  107:         D[0] = mad(alpha, sum, D[0]*beta);\n  108  #else\n  109          D[0] = alpha * sum;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/opencl/intel_gemm.cl:\n  557      output = (local_x == 7) ? _dot.s7 : output; \\\n  558      if (beta != 0.0f) \\\n  559:         dst_write0[0] = mad(output, (float)alpha, ((float)beta * dst_write0[0])); \\\n  560      else \\\n  561          dst_write0[0] = output * (float)alpha; \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/test/test_arithm.cpp:\n   16  {\n   17      enum { FIX_ALPHA=1, FIX_BETA=2, FIX_GAMMA=4, REAL_GAMMA=8, SUPPORT_MASK=16, SCALAR_OUTPUT=32, SUPPORT_MULTICHANNELMASK=64 };\n   18:     BaseElemWiseOp(int _ninputs, int _flags, double _alpha, double _beta,\n   19                     Scalar _gamma=Scalar::all(0), int _context=1)\n   20      : ninputs(_ninputs), flags(_flags), alpha(_alpha), beta(_beta), gamma(_gamma), context(_context) {}\n   ..\n   96  struct BaseAddOp : public BaseElemWiseOp\n   97  {\n   98:     BaseAddOp(int _ninputs, int _flags, double _alpha, double _beta, Scalar _gamma=Scalar::all(0))\n   99:     : BaseElemWiseOp(_ninputs, _flags, _alpha, _beta, _gamma) {}\n  100  \n  101      void refop(const vector<Mat>& src, Mat& dst, const Mat& mask)\n  ...\n  104          if( !mask.empty() )\n  105          {\n  106:             cvtest::add(src[0], alpha, src.size() > 1 ? src[1] : Mat(), beta, gamma, temp, src[0].type());\n  107              cvtest::copy(temp, dst, mask);\n  108          }\n  109          else\n  110:             cvtest::add(src[0], alpha, src.size() > 1 ? src[1] : Mat(), beta, gamma, dst, src[0].type());\n  111      }\n  112  };\n  ...\n  170      void op(const vector<Mat>& src, Mat& dst, const Mat&)\n  171      {\n  172:         cv::scaleAdd(src[0], alpha, src[1], dst);\n  173      }\n  174      double getMaxErr(int depth)\n  ...\n  184      void op(const vector<Mat>& src, Mat& dst, const Mat&)\n  185      {\n  186:         cv::addWeighted(src[0], alpha, src[1], beta, gamma[0], dst);\n  187      }\n  188      double getMaxErr(int depth)\n  ...\n  238      void op(const vector<Mat>& src, Mat& dst, const Mat&)\n  239      {\n  240:         cv::divide(alpha, src[0], dst);\n  241      }\n  242      void refop(const vector<Mat>& src, Mat& dst, const Mat&)\n  ...\n  711      void op(const vector<Mat>& src, Mat& dst, const Mat&)\n  712      {\n  713:         src[0].convertTo(dst, ddepth, alpha, gamma[0]);\n  714      }\n  715      void refop(const vector<Mat>& src, Mat& dst, const Mat&)\n  716      {\n  717:         cvtest::convert(src[0], dst, CV_MAKETYPE(ddepth, src[0].channels()), alpha, gamma[0]);\n  718      }\n  719      int getRandomType(RNG& rng)\n  ...\n  802      void op(const vector<Mat>& src, Mat& dst, const Mat&)\n  803      {\n  804:         cv::convertScaleAbs(src[0], dst, alpha, gamma[0]);\n  805      }\n  806      void refop(const vector<Mat>& src, Mat& dst, const Mat&)\n  807      {\n  808:         cvtest::add(src[0], alpha, Mat(), 0, Scalar::all(gamma[0]), dst, CV_8UC(src[0].channels()), true);\n  809      }\n  810      int getRandomType(RNG& rng)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/test/test_math.cpp:\n  615      void prepare_to_validation( int test_case_idx );\n  616      int tabc_flag;\n  617:     double alpha, beta;\n  618  };\n  619  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/test/ocl/test_arithm.cpp:\n  868          const double alpha = 2.0, beta = 1.0, gama = 3.0;\n  869  \n  870:         OCL_OFF(cv::addWeighted(src1_roi, alpha, src2_roi, beta, gama, dst1_roi));\n  871:         OCL_ON(cv::addWeighted(usrc1_roi, alpha, usrc2_roi, beta, gama, udst1_roi));\n  872  \n  873          if(dst1_roi.depth() >= CV_32F)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/test/ocl/test_gemm.cpp:\n   66      bool atrans, btrans, ctrans;\n   67  \n   68:     double alpha, beta;\n   69  \n   70      int M, N, K;\n   ..\n  134          SCOPED_TRACE(cv::format(\"i=%d: M=%d N=%d K=%d\", i, M, N, K));\n  135  \n  136:         OCL_OFF(cv::gemm(A_roi, B_roi, alpha, C_roi, beta, D_roi, flags));\n  137:         OCL_ON(cv::gemm(uA_roi, uB_roi, alpha, uC_roi, beta, uD_roi, flags));\n  138  \n  139          double eps = D_roi.size().area() * (1e-5 * K);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/test/ocl/test_matrix_operation.cpp:\n   94          double alpha = randomDouble(-4, 4), beta = randomDouble(-4, 4);\n   95  \n   96:         OCL_OFF(src_roi.convertTo(dst_roi, dstType, alpha, beta));\n   97:         OCL_ON(usrc_roi.convertTo(udst_roi, dstType, alpha, beta));\n   98  \n   99          double eps = CV_MAT_DEPTH(dstType) >= CV_32F ? 2e-4 : 1;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/include/opencv2/dnn/all_layers.hpp:\n  279  \n  280          int size;\n  281:         float alpha, beta, bias;\n  282          bool normBySize;\n  283  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda/activations.cu:\n  240  \n  241  template <class T>\n  242: void hardsigmoid(const Stream& stream, Span<T> output, View<T> input, T alpha, T beta) {\n  243:     generic_op<T, HardSigmoidFunctor<T>>(stream, output, input, {alpha, beta});\n  244  }\n  245  \n  246  template <class T>\n  247: void selu(const Stream& stream, Span<T> output, View<T> input, T alpha, T gamma) {\n  248:     generic_op<T, SeluFunctor<T>>(stream, output, input, {alpha, gamma});\n  249  }\n  250  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda/functors.hpp:\n  555          CUDA4DNN_HOST_DEVICE Params() : alpha(0.2), beta(0.5) { }\n  556          CUDA4DNN_HOST_DEVICE Params(T alpha_, T beta_) : alpha(alpha_), beta(beta_) { }\n  557:         T alpha, beta;\n  558      };\n  559  \n  ...\n  566      }\n  567  \n  568:     T alpha, beta;\n  569  };\n  570  \n  ...\n  575                                          gamma(1.0507009873554804934193349852946) { }\n  576          CUDA4DNN_HOST_DEVICE Params(T alpha_, T gamma_) : alpha(alpha_), gamma(gamma_) { }\n  577:         T alpha, gamma;\n  578      };\n  579  \n  ...\n  586      }\n  587  \n  588:     T alpha, gamma;\n  589  };\n  590  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda/scale_shift.cu:\n   65  \n   66          template <class T, std::size_t N>\n   67:         __global__ void scale1_with_bias1_vec(Span<T> output, View<T> input, T alpha, T beta)\n   68          {\n   69              using vector_type = get_vector_type_t<T, N>;\n   ..\n  171  \n  172      template <class T, std::size_t N> static\n  173:     void launch_scale1_with_bias1_vec_kernel(const Stream& stream, Span<T> output, View<T> input, T alpha, T beta) {\n  174          CV_Assert(is_fully_aligned<T>(output, N));\n  175          CV_Assert(is_fully_aligned<T>(input, N));\n  ...\n  177          auto kernel = raw::scale1_with_bias1_vec<T, N>;\n  178          auto policy = make_policy(kernel, output.size() / N, 0, stream);\n  179:         launch_kernel(kernel, policy, output, input, alpha, beta);\n  180      }\n  181  \n  182      template <class T>\n  183:     void scale1_with_bias1(const Stream& stream, Span<T> output, View<T> input, T alpha, T beta) {\n  184          CV_Assert(output.size() == input.size());\n  185  \n  186          if (is_fully_aligned<T>(output, 4) && is_fully_aligned<T>(input, 4)) {\n  187:             launch_scale1_with_bias1_vec_kernel<T, 4>(stream, output, input, alpha, beta);\n  188          } else if (is_fully_aligned<T>(output, 2) && is_fully_aligned<T>(input, 2)) {\n  189:             launch_scale1_with_bias1_vec_kernel<T, 2>(stream, output, input, alpha, beta);\n  190          } else {\n  191:             launch_scale1_with_bias1_vec_kernel<T, 1>(stream, output, input, alpha, beta);\n  192          }\n  193      }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/cublas.hpp:\n  182          bool transa, bool transb,\n  183          std::size_t rows_c, std::size_t cols_c, std::size_t common_dim,\n  184:         T alpha, const DevicePtr<const T> A, std::size_t lda,\n  185          const DevicePtr<const T> B, std::size_t ldb,\n  186          T beta, const DevicePtr<T> C, std::size_t ldc);\n  ...\n  190          bool transa, bool transb,\n  191          std::size_t rows_c, std::size_t cols_c, std::size_t common_dim,\n  192:         half alpha, const DevicePtr<const half> A, std::size_t lda,\n  193          const DevicePtr<const half> B, std::size_t ldb,\n  194          half beta, const DevicePtr<half> C, std::size_t ldc)\n  ...\n  210                  opa, opb,\n  211                  irows_c, icols_c, icommon_dim,\n  212:                 &alpha, A.get(), ilda,\n  213                  B.get(), ildb,\n  214                  &beta, C.get(), ildc\n  ...\n  221          bool transa, bool transb,\n  222          std::size_t rows_c, std::size_t cols_c, std::size_t common_dim,\n  223:         float alpha, const DevicePtr<const float> A, std::size_t lda,\n  224          const DevicePtr<const float> B, std::size_t ldb,\n  225          float beta, const DevicePtr<float> C, std::size_t ldc)\n  ...\n  241                  opa, opb,\n  242                  irows_c, icols_c, icommon_dim,\n  243:                 &alpha, A.get(), ilda,\n  244                  B.get(), ildb,\n  245                  &beta, C.get(), ildc\n  ...\n  279          bool transa, bool transb,\n  280          std::size_t rows_c, std::size_t cols_c, std::size_t common_dim,\n  281:         T alpha, const DevicePtr<const T> A, std::size_t lda, std::size_t strideA,\n  282          const DevicePtr<const T> B, std::size_t ldb, std::size_t strideB,\n  283          T beta, const DevicePtr<T> C, std::size_t ldc, std::size_t strideC,\n  ...\n  288          bool transa, bool transb,\n  289          std::size_t rows_c, std::size_t cols_c, std::size_t common_dim,\n  290:         half alpha, const DevicePtr<const half> A, std::size_t lda, std::size_t strideA,\n  291          const DevicePtr<const half> B, std::size_t ldb, std::size_t strideB,\n  292          half beta, const DevicePtr<half> C, std::size_t ldc, std::size_t strideC,\n  ...\n  316                  opa, opb,\n  317                  irows_c, icols_c, icommon_dim,\n  318:                 &alpha, A.get(), ilda, stride_a,\n  319                  B.get(), ildb, stride_b,\n  320                  &beta, C.get(), ildc, stride_c,\n  ...\n  328          bool transa, bool transb,\n  329          std::size_t rows_c, std::size_t cols_c, std::size_t common_dim,\n  330:         float alpha, const DevicePtr<const float> A, std::size_t lda, std::size_t strideA,\n  331          const DevicePtr<const float> B, std::size_t ldb, std::size_t strideB,\n  332          float beta, const DevicePtr<float> C, std::size_t ldc, std::size_t strideC,\n  ...\n  356                  opa, opb,\n  357                  irows_c, icols_c, icommon_dim,\n  358:                 &alpha, A.get(), ilda, stride_a,\n  359                  B.get(), ildb, stride_b,\n  360                  &beta, C.get(), ildc, stride_c,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/tensor_ops.hpp:\n   78           */\n   79          template <class T> inline\n   80:         void gemm(const cublas::Handle& handle, T beta, TensorSpan<T> result, T alpha, bool transa, TensorView<T> A, bool transb, TensorView<T> B) {\n   81              /* matrix operations can be performed only on tensors with rank two or below */\n   82              CV_Assert(get_effective_rank(A) <= 2);\n   ..\n  106                  transb, transa,\n  107                  result_nc, result_nr, common_dim,\n  108:                 alpha, B.get(), B_nc,\n  109                  A.get(), A_nc,\n  110                  beta, result.get(), result_nc);\n  ...\n  122           */\n  123          template <class T> inline\n  124:         void gemmStridedBatched(const cublas::Handle& handle, T beta, TensorSpan<T> result, T alpha, bool transa, TensorView<T> A, bool transb, TensorView<T> B) {\n  125              CV_Assert(A.rank() == 3);\n  126              CV_Assert(B.rank() == 3);\n  ...\n  146                  transb, transa,\n  147                  result_nc, result_nr, common_dim,\n  148:                 alpha, B.get(), B_nc, strideB,\n  149                  A.get(), A_nc, strideA,\n  150                  beta, result.get(), result_nc, strideC,\n  ...\n  417          LRN(const LRN&) = delete;\n  418          LRN(LRN&&) = default;\n  419:         LRN(cudnn::Handle handle, std::size_t local_size, T alpha, T beta, T k, LRNType type) {\n  420              cudnnHandle = std::move(handle);\n  421:             lrnDesc = LRNDescriptor(local_size, alpha, beta, k, type);\n  422          }\n  423  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/cudnn/convolution.hpp:\n  403          const TensorDescriptor<T>& inputDesc,\n  404          DevicePtr<const T> inputPtr,\n  405:         T alpha, T beta,\n  406          const TensorDescriptor<T>& outputDesc,\n  407          DevicePtr<T> outputPtr)\n  ...\n  412              cudnnConvolutionForward(\n  413                  handle.get(),\n  414:                 &alpha, inputDesc.get(), inputPtr.get(),\n  415                  filterDesc.get(), filterPtr.get(),\n  416                  convDesc.get(), convAlgo.get(),\n  ...\n  431          const TensorDescriptor<half>& inputDesc,\n  432          DevicePtr<const half> inputPtr,\n  433:         half alpha, half beta,\n  434          const TensorDescriptor<half>& outputDesc,\n  435          DevicePtr<half> outputPtr)\n  ...\n  438  \n  439          /* we specalize for fp16 as the scaling factors must be provided as `float` */\n  440:         float alpha_ = alpha, beta_ = beta;\n  441          CUDA4DNN_CHECK_CUDNN(\n  442              cudnnConvolutionForward(\n  ...\n  496          CUDA4DNN_CHECK_CUDNN(cudnnConvolutionBiasActivationForward(\n  497              handle.get(),\n  498:             &alpha, inputDesc.get(), inputPtr.get(),\n  499              filterDesc.get(), filterPtr.get(),\n  500              convDesc.get(), convAlgo.get(),\n  ...\n  525          CV_Assert(handle);\n  526  \n  527:         float alpha_ = alpha, alpha2 = 0.0;\n  528          CUDA4DNN_CHECK_CUDNN(cudnnConvolutionBiasActivationForward(\n  529              handle.get(),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/cudnn/lrn.hpp:\n   43           * @note \\p alpha is divided by the (window width)^spatialDimensions in within channel mode\n   44           *\n   45:          * @note the \\p alpha, \\p beta and \\p k will be type casted to the tensor datatype during operation\n   46           *\n   47           * Exception Guarantee: Basic\n   48           */\n   49:         LRNDescriptor(std::size_t local_size, double alpha, double beta, double k, LRNType type_) {\n   50:             constructor(local_size, alpha, beta, k, type_);\n   51          }\n   52  \n   ..\n   70  \n   71      private:\n   72:         void constructor(std::size_t local_size, double alpha, double beta, double k, LRNType type_) {\n   73              CV_Assert(CUDNN_LRN_MIN_N <= local_size && local_size <= CUDNN_LRN_MAX_N);\n   74  \n   ..\n  121          const TensorDescriptor<T>& inputDesc,\n  122          DevicePtr<const T> inputPtr,\n  123:         T alpha, T beta,\n  124          const TensorDescriptor<T>& outputDesc,\n  125          DevicePtr<T> outputPtr,\n  ...\n  133                      handle.get(),\n  134                      lrnDesc.get(), CUDNN_LRN_CROSS_CHANNEL_DIM1,\n  135:                     &alpha, inputDesc.get(), inputPtr.get(),\n  136                      &beta, outputDesc.get(), outputPtr.get()\n  137                  )\n  ...\n  148                      handle.get(),\n  149                      lrnDesc.get(), CUDNN_DIVNORM_PRECOMPUTED_MEANS,\n  150:                     &alpha, inputDesc.get(), inputPtr.get(),\n  151                      NULL,\n  152                      static_cast<void*>(temp1), static_cast<void*>(temp2),\n  ...\n  163         const TensorDescriptor<half>& inputDesc,\n  164         DevicePtr<const half> inputPtr,\n  165:        half alpha, half beta,\n  166         const TensorDescriptor<half>& outputDesc,\n  167         DevicePtr<half> outputPtr,\n  ...\n  171  \n  172          /* we specalize for fp16 as the scaling factors must be provided as `float` */\n  173:         float alpha_ = alpha, beta_ = beta;\n  174          if (lrnDesc.getType() == LRNDescriptor::LRNType::ACROSS_CHANNELS) {\n  175              CUDA4DNN_CHECK_CUDNN(\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/cudnn/pooling.hpp:\n  192          const TensorDescriptor<T>& inputDesc,\n  193          const DevicePtr<const T> inputPtr,\n  194:         T alpha, T beta,\n  195          const TensorDescriptor<T>& outputDesc,\n  196          DevicePtr<T> outputPtr)\n  ...\n  202                  handle.get(),\n  203                  poolingDesc.get(),\n  204:                 &alpha, inputDesc.get(), inputPtr.get(),\n  205                  &beta, outputDesc.get(), outputPtr.get()\n  206              )\n  ...\n  214          const TensorDescriptor<half>& inputDesc,\n  215          const DevicePtr<const half> inputPtr,\n  216:         half alpha, half beta,\n  217          const TensorDescriptor<half>& outputDesc,\n  218          DevicePtr<half> outputPtr)\n  ...\n  221  \n  222          /* we specalize for fp16 as the scaling factors must be provided as `float` */\n  223:         float alpha_ = alpha, beta_ = beta;\n  224          CUDA4DNN_CHECK_CUDNN(\n  225              cudnnPoolingForward(\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/cudnn/softmax.hpp:\n   39                  handle.get(),\n   40                  algo, CUDNN_SOFTMAX_MODE_CHANNEL,\n   41:                 &alpha, inputDesc.get(), input.get(),\n   42                  &beta, outputDesc.get(), output.get()\n   43              )\n   ..\n   58                  handle.get(),\n   59                  algo, CUDNN_SOFTMAX_MODE_CHANNEL,\n   60:                 &alpha, inputDesc.get(), input.get(),\n   61                  &beta, outputDesc.get(), output.get()\n   62              )\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/cudnn/transform.hpp:\n  111                  handle.get(),\n  112                  transDesc.get(),\n  113:                 &alpha, inputDesc.get(), inputPtr.get(),\n  114                  &beta, outputDesc.get(), outputPtr.get()\n  115              )\n  ...\n  132                  handle.get(),\n  133                  transDesc.get(),\n  134:                 &alpha, inputDesc.get(), inputPtr.get(),\n  135                  &beta, outputDesc.get(), outputPtr.get()\n  136              )\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/csl/cudnn/transpose_convolution.hpp:\n  133          const TensorDescriptor<T>& inputDesc,\n  134          DevicePtr<const T> inputPtr,\n  135:         T alpha, T beta,\n  136          const TensorDescriptor<T>& outputDesc,\n  137          DevicePtr<T> outputPtr)\n  ...\n  160          const TensorDescriptor<half>& inputDesc,\n  161          DevicePtr<const half> inputPtr,\n  162:         half alpha, half beta,\n  163          const TensorDescriptor<half>& outputDesc,\n  164          DevicePtr<half> outputPtr)\n  165      {\n  166          /* we specalize for fp16 as the scaling factors must be provided as `float` */\n  167:         float alpha_ = alpha, beta_ = beta;\n  168          CUDA4DNN_CHECK_CUDNN(\n  169              cudnnConvolutionBackwardData(\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/kernels/activations.hpp:\n  110  \n  111      template <class T>\n  112:     void hardsigmoid(const csl::Stream& stream, csl::Span<T> output, csl::View<T> input, T alpha, T beta);\n  113  \n  114      template <class T>\n  115:     void selu(const csl::Stream& stream, csl::Span<T> output, csl::View<T> input, T alpha, T gamma);\n  116  \n  117      template <class T>\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/kernels/scale_shift.hpp:\n   26  \n   27      template <class T>\n   28:     void scale1_with_bias1(const csl::Stream& stream, csl::Span<T> output, csl::View<T> input, T alpha, T beta);\n   29  \n   30      template <class T>\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/primitives/activation.hpp:\n  514          void calculate(csl::TensorSpan<T> output, csl::TensorView<T> input) const\n  515          {\n  516:             kernels::hardsigmoid<T>(stream, output, input, alpha, beta);\n  517          }\n  518  \n  519      private:\n  520          csl::Stream stream;\n  521:         const T alpha, beta;\n  522      };\n  523  \n  ...\n  530          void calculate(csl::TensorSpan<T> output, csl::TensorView<T> input) const\n  531          {\n  532:             kernels::selu<T>(stream, output, input, alpha, gamma);\n  533          }\n  534  \n  535      private:\n  536          csl::Stream stream;\n  537:         const T alpha, gamma;\n  538      };\n  539  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/cuda4dnn/primitives/lrn.hpp:\n   26          using wrapper_type = GetCUDABackendWrapperType<T>;\n   27  \n   28:         LRNOp(csl::cudnn::Handle handle, LRNType type_, std::size_t local_size, T alpha, T beta, T bias, std::size_t largestInputSize)\n   29              : scratch_mem_in_bytes { 0 }\n   30          {\n   ..\n   34              case LRNType::WITHIN_CHANNEL: type = csl::LRN<T>::LRNType::WITHIN_CHANNEL; break;\n   35              }\n   36:             lrn = csl::LRN<T>(std::move(handle), local_size, alpha, beta, bias, type);\n   37  \n   38              csl::WorkspaceBuilder builder;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/elementwise_layers.cpp:\n 1832      Ptr<BackendNode> initCUDA(int target, csl::Stream stream)\n 1833      {\n 1834:         return make_cuda_node<cuda4dnn::HardSigmoidOp>(target, stream, alpha, beta);\n 1835      }\n 1836  #endif\n ....\n 1871      Ptr<BackendNode> initCUDA(int target, csl::Stream stream)\n 1872      {\n 1873:         return make_cuda_node<cuda4dnn::SeluOp>(target, stream, alpha, gamma);\n 1874      }\n 1875  #endif\n ....\n 2590      float alpha = params.get<float>(\"alpha\", 0.2f);\n 2591      float beta = params.get<float>(\"beta\", 0.5f);\n 2592:     Ptr<HardSigmoidLayer> l(new ElementWiseLayer<HardSigmoidFunctor>(HardSigmoidFunctor(alpha, beta)));\n 2593      l->setParamsFrom(params);\n 2594      l->alpha = alpha;\n ....\n 2602      float alpha = params.get<float>(\"alpha\", 1.67326319217681884765625f);\n 2603      float gamma = params.get<float>(\"gamma\", 1.05070102214813232421875f);\n 2604:     Ptr<SeluLayer> l(new ElementWiseLayer<SeluFunctor>(SeluFunctor(alpha, gamma)));\n 2605      l->setParamsFrom(params);\n 2606      l->alpha = alpha;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/lrn_layer.cpp:\n  366      {\n  367  #ifdef HAVE_VULKAN\n  368:         std::shared_ptr<vkcom::OpBase> op(new vkcom::OpLRN(size / 2, bias, alpha, beta, normBySize));\n  369          return Ptr<BackendNode>(new VkComBackendNode(inputs, op));\n  370  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/ocl4dnn/src/math_functions.cpp:\n  514                  isBetaZero ? ocl::KernelArg::PtrWriteOnly(C) : ocl::KernelArg::PtrReadWrite(C), offC,\n  515                  M, N, K,\n  516:                 (float)alpha, (float)beta,\n  517                  start_index\n  518              );\n  ...\n  531              isBetaZero ? ocl::KernelArg::PtrWriteOnly(C) : ocl::KernelArg::PtrReadWrite(C), offC,\n  532              M, N, K,\n  533:             (float)alpha, (float)beta\n  534          );\n  535          ret = oclk_gemm_float.run(2, global, local, false);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/opencl/gemm_buffer.cl:\n  586      output = (local_x == 6) ? _dot.s6 : output; \\\n  587      output = (local_x == 7) ? _dot.s7 : output; \\\n  588:     dst_write0[0] = BETA_ZERO_CHECK(alpha * output, mad(output, alpha, beta * dst_write0[0])); \\\n  589      dst_write0 += N;\n  590  \n  ...\n  772      output = (local_x == 6) ? _dot.s6 : output; \\\n  773      output = (local_x == 7) ? _dot.s7 : output; \\\n  774:     dst_write0[0] = BETA_ZERO_CHECK(alpha * output, mad(output, alpha, beta * dst_write0[0])); \\\n  775      dst_write0 += N;\n  776  \n  ...\n  917    if(x_gid == N / 4) {\n  918      TEMPLATE(gemm_buffer_NT_M_2_edgerows,Dtype) \\\n  919:          (srca_read0, srca_read1, srcb_read, work0, work1, N, K, x_gid, lid, alpha, beta, (__global Dtype*)dstc0, (__global Dtype*)dstc1);\n  920    } else {\n  921      Dtype4 dot0[4] = {(Dtype4)(0.), (Dtype4)(0.), (Dtype4)(0.), (Dtype4)(0.)};\n  ...\n 1138      TEMPLATE(gemm_buffer_NT_M_4_edgerows,Dtype) \\\n 1139           (srca_read0, srca_read1, srca_read2, srca_read3, srcb_read, \\\n 1140:          work0, work1, work2, work3, N, K, x_gid, lid, alpha, beta, \\\n 1141           (__global Dtype*)dstc0, (__global Dtype*)dstc1, (__global Dtype*)dstc2, (__global Dtype*)dstc3);\n 1142    } else {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/opencl/gemm_image.cl:\n  162          blockC03 = isFirstColBlock ? BLOCKC_READ8( _C, coordC ) * beta : BLOCKC_READ8( _C, coordC ); \\\n  163          if (!ALPHA1) { \\\n  164:             blockC00 = mad(blockAxB00, (Dtype8)alpha, blockC00); \\\n  165:             blockC01 = mad(blockAxB01, (Dtype8)alpha, blockC01); \\\n  166:             blockC02 = mad(blockAxB02, (Dtype8)alpha, blockC02); \\\n  167:             blockC03 = mad(blockAxB03, (Dtype8)alpha, blockC03); \\\n  168          } else { \\\n  169              blockC00 += blockAxB00; \\\n  ...\n  178          blockC03 = isFirstColBlock ? (Dtype)0. : BLOCKC_READ8( _C, coordC ); \\\n  179          if (!ALPHA1) { \\\n  180:           blockC00 = mad(blockAxB00, (Dtype8)alpha, blockC00); \\\n  181:           blockC01 = mad(blockAxB01, (Dtype8)alpha, blockC01); \\\n  182:           blockC02 = mad(blockAxB02, (Dtype8)alpha, blockC02); \\\n  183:           blockC03 = mad(blockAxB03, (Dtype8)alpha, blockC03); \\\n  184          } else { \\\n  185            blockC00 += blockAxB00; \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/opencl/math.cl:\n   49  #define KERNEL_ARG_DTYPE float\n   50  \n   51: __kernel void TEMPLATE(axpy,Dtype)(const int n, const KERNEL_ARG_DTYPE alpha, __global const Dtype* x,\n   52                                     const int offx, __global Dtype* y,\n   53                                     const int offy) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/vkcom/include/op_lrn.hpp:\n   37  public:\n   38      OpLRN(const int radius, const float bias,\n   39:           const float alpha, const float beta,\n   40            const bool norm_by_size);\n   41      void reshapeOutTensor(Tensor& in, Tensor& out);\n   ..\n   47  private:\n   48      bool init(const int radius, const float bias,\n   49:               const float alpha, const float beta,\n   50                const bool norm_by_size);\n   51      bool computeGroupCount();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/vkcom/src/op_lrn.cpp:\n   32  \n   33  OpLRN::OpLRN(const int radius, const float bias,\n   34:              const float alpha, const float beta,\n   35               const bool norm_by_size)\n   36  {\n   37:     init(radius, bias, alpha, beta, norm_by_size);\n   38      type_ = \"LRN\";\n   39  }\n   ..\n   46  \n   47  bool OpLRN::init(const int radius, const float bias,\n   48:                  const float alpha, const float beta,\n   49                   const bool norm_by_size)\n   50  {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/test/test_halide_layers.cpp:\n  279  /*local size*/   Values(3, 5),\n  280                   Values(Vec3f(0.9f, 1.0f, 1.1f), Vec3f(0.9f, 1.1f, 1.0f),\n  281: /*alpha, beta, bias*/   Vec3f(1.0f, 0.9f, 1.1f), Vec3f(1.0f, 1.1f, 0.9f),\n  282                          Vec3f(1.1f, 0.9f, 1.0f), Vec3f(1.1f, 1.0f, 0.9f)),\n  283  /*norm_by_size*/ Bool(),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/core.hpp:\n 1323  @sa  add, sub\n 1324  */\n 1325: GAPI_EXPORTS GMat addWeighted(const GMat& src1, double alpha, const GMat& src2, double beta, double gamma, int ddepth = -1);\n 1326  \n 1327  /** @brief Calculates the  absolute L1 norm of a matrix.\n ....\n 1816  @sa norm, Mat::convertTo\n 1817  */\n 1818: GAPI_EXPORTS GMat normalize(const GMat& src, double alpha, double beta,\n 1819                              int norm_type, int ddepth = -1);\n 1820  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/perf/common/gapi_core_perf_tests_inl.hpp:\n 1222  \n 1223      // OpenCV code ///////////////////////////////////////////////////////////\n 1224:     cv::addWeighted(in_mat1, alpha, in_mat2, beta, gamma, out_mat_ocv, dtype);\n 1225  \n 1226      // G-API code ////////////////////////////////////////////////////////////\n 1227      cv::GMat in1, in2;\n 1228:     auto out = cv::gapi::addWeighted(in1, alpha, in2, beta, gamma, dtype);\n 1229      cv::GComputation c(GIn(in1, in2), GOut(out));\n 1230  \n ....\n 2085      compare_f cmpF;\n 2086      cv::GCompileArgs compile_args;\n 2087:     std::tie(cmpF, type_mat, depth_to, sz, alpha, beta, compile_args) = GetParam();\n 2088      MatType type_out = CV_MAKETYPE(depth_to, CV_MAT_CN(type_mat));\n 2089  \n ....\n 2091  \n 2092      // OpenCV code ///////////////////////////////////////////////////////////\n 2093:     in_mat1.convertTo(out_mat_ocv, depth_to, alpha, beta);\n 2094  \n 2095      // G-API code //////////////////////////////////////////////////////////////\n 2096      cv::GMat in;\n 2097:     auto out = cv::gapi::convertTo(in, depth_to, alpha, beta);\n 2098      cv::GComputation c(in, out);\n 2099  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/src/api/kernels_core.cpp:\n  240  }\n  241  \n  242: GMat addWeighted(const GMat& src1, double alpha, const GMat& src2, double beta, double gamma, int dtype)\n  243  {\n  244:     return core::GAddW::on(src1, alpha, src2, beta, gamma, dtype);\n  245  }\n  246  \n  ...\n  356  }\n  357  \n  358: GMat convertTo(const GMat& m, int rtype, double alpha, double beta)\n  359  {\n  360:     return core::GConvertTo::on(m, rtype, alpha, beta);\n  361  }\n  362  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/src/api/render_ocv.cpp:\n  227  \n  228                  img.convertTo(img, CV_32FC1, 1.0 / 255);\n  229:                 blendImage(img, ip.alpha, ip.org, in);\n  230                  break;\n  231              }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/src/backends/cpu/gcpucore.cpp:\n  353  GAPI_OCV_KERNEL(GCPUAddW, cv::gapi::core::GAddW)\n  354  {\n  355:     static void run(const cv::Mat& in1, double alpha, const cv::Mat& in2, double beta, double gamma, int dtype, cv::Mat& out)\n  356      {\n  357:         cv::addWeighted(in1, alpha, in2, beta, gamma, out, dtype);\n  358      }\n  359  };\n  ...\n  537  GAPI_OCV_KERNEL(GCPUConvertTo, cv::gapi::core::GConvertTo)\n  538  {\n  539:     static void run(const cv::Mat& in, int rtype, double alpha, double beta, cv::Mat& out)\n  540      {\n  541:         in.convertTo(out, rtype, alpha, beta);\n  542      }\n  543  };\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/src/backends/fluid/gfluidcore.cpp:\n   55  \n   56  template<typename DST, typename SRC1, typename SRC2>\n   57: static inline DST addWeighted(SRC1 src1, SRC2 src2, float alpha, float beta, float gamma)\n   58  {\n   59      float dst = src1*alpha + src2*beta + gamma;\n   ..\n  148  template<typename SRC, typename DST>\n  149  CV_ALWAYS_INLINE int addw_simd(const SRC in1[], const SRC in2[], DST out[],\n  150:                                const float _alpha, const float _beta,\n  151                                 const float _gamma, int length)\n  152  {\n  ...\n  175              v_float32 b2 = v_load_f32(&in2[x + nlanes / 2]);\n  176  \n  177:             addw_short_store(&out[x], v_round(v_fma(a1, alpha, v_fma(b1, beta, gamma))),\n  178:                                       v_round(v_fma(a2, alpha, v_fma(b2, beta, gamma))));\n  179          }\n  180  \n  ...\n  191  template<typename SRC>\n  192  CV_ALWAYS_INLINE int addw_simd(const SRC in1[], const SRC in2[], uchar out[],\n  193:                                const float _alpha, const float _beta,\n  194                                 const float _gamma, int length)\n  195  {\n  ...\n  217              v_float32 b4 = v_load_f32(&in2[x + 3 * nlanes / 4]);\n  218  \n  219:             v_int32 sum1 = v_round(v_fma(a1, alpha, v_fma(b1, beta, gamma))),\n  220:                     sum2 = v_round(v_fma(a2, alpha, v_fma(b2, beta, gamma))),\n  221:                     sum3 = v_round(v_fma(a3, alpha, v_fma(b3, beta, gamma))),\n  222:                     sum4 = v_round(v_fma(a4, alpha, v_fma(b4, beta, gamma)));\n  223  \n  224              vx_store(&out[x], v_pack_u(v_pack(sum1, sum2), v_pack(sum3, sum4)));\n  ...\n  247  template<typename DST, typename SRC1, typename SRC2>\n  248  static void run_addweighted(Buffer &dst, const View &src1, const View &src2,\n  249:                             double alpha, double beta, double gamma)\n  250  {\n  251      static_assert(std::is_same<SRC1, SRC2>::value, \"wrong types\");\n  ...\n  266      int x = 0;\n  267  #if CV_SSE2\n  268:     x = addw_simd(in1, in2, out, _alpha, _beta, _gamma, length);\n  269  #endif\n  270  \n  271      for (; x < length; ++x)\n  272:         out[x] = addWeighted<DST>(in1[x], in2[x], _alpha, _beta, _gamma);\n  273  }\n  274  \n  ...\n  277      static const int Window = 1;\n  278  \n  279:     static void run(const View &src1, double alpha, const View &src2,\n  280                                        double beta, double gamma, int /*dtype*/,\n  281                          Buffer &dst)\n  282      {\n  283          //      DST     SRC1    SRC2    OP               __VA_ARGS__\n  284:         BINARY_(uchar , uchar , uchar , run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  285:         BINARY_(uchar , ushort, ushort, run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  286:         BINARY_(uchar ,  short,  short, run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  287:         BINARY_( short,  short,  short, run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  288:         BINARY_(ushort, ushort, ushort, run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  289:         BINARY_( float, uchar , uchar , run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  290:         BINARY_( float, ushort, ushort, run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  291:         BINARY_( float,  short,  short, run_addweighted, dst, src1, src2, alpha, beta, gamma);\n  292  \n  293          CV_Error(cv::Error::StsBadArg, \"unsupported combination of types\");\n  ...\n 1773  \n 1774  template<typename DST, typename SRC>\n 1775: CV_ALWAYS_INLINE void run_convertto(DST *out, const SRC *in, const float alpha, const float beta,\n 1776                                      const int length)\n 1777  {\n ....\n 1785  \n 1786  template<typename DST, typename SRC>\n 1787: static void run_convertto(Buffer &dst, const View &src, double _alpha, double _beta)\n 1788  {\n 1789      const auto *in  = src.InLine<SRC>(0);\n ....\n 1805      else // if alpha or beta is non-trivial\n 1806      {\n 1807:         run_convertto(out, in, alpha, beta, length);\n 1808      }\n 1809  }\n ....\n 1813      static const int Window = 1;\n 1814  \n 1815:     static void run(const View &src, int /*rtype*/, double alpha, double beta, Buffer &dst)\n 1816      {\n 1817          //     DST     SRC     OP             __VA_ARGS__\n 1818:         UNARY_(uchar , uchar , run_convertto, dst, src, alpha, beta);\n 1819:         UNARY_(uchar , ushort, run_convertto, dst, src, alpha, beta);\n 1820:         UNARY_(uchar ,  short, run_convertto, dst, src, alpha, beta);\n 1821:         UNARY_(uchar ,  float, run_convertto, dst, src, alpha, beta);\n 1822:         UNARY_(ushort, uchar , run_convertto, dst, src, alpha, beta);\n 1823:         UNARY_(ushort, ushort, run_convertto, dst, src, alpha, beta);\n 1824:         UNARY_(ushort,  short, run_convertto, dst, src, alpha, beta);\n 1825:         UNARY_(ushort,  float, run_convertto, dst, src, alpha, beta);\n 1826:         UNARY_( short, uchar , run_convertto, dst, src, alpha, beta);\n 1827:         UNARY_( short, ushort, run_convertto, dst, src, alpha, beta);\n 1828:         UNARY_( short,  short, run_convertto, dst, src, alpha, beta);\n 1829:         UNARY_( short,  float, run_convertto, dst, src, alpha, beta);\n 1830:         UNARY_( float, uchar , run_convertto, dst, src, alpha, beta);\n 1831:         UNARY_( float, ushort, run_convertto, dst, src, alpha, beta);\n 1832:         UNARY_( float,  short, run_convertto, dst, src, alpha, beta);\n 1833:         UNARY_( float,  float, run_convertto, dst, src, alpha, beta);\n 1834  \n 1835          CV_Error(cv::Error::StsBadArg, \"unsupported combination of types\");\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/src/backends/fluid/gfluidcore_simd_sse41.hpp:\n  694  \n  695                  // horizontal pass\n  696:                 resize_horizontal_anyLPI(dst[l], tmp, mapsx, alpha, outSz.width);\n  697              }\n  698          }\n  ...\n  704  \n  705              // horizontal pass\n  706:             resize_horizontal_anyLPI(dst[l], src, mapsx, alpha, outSz.width);\n  707          }\n  708      } else if (!yRatioEq) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/src/backends/ocl/goclcore.cpp:\n  348  GAPI_OCL_KERNEL(GOCLAddW, cv::gapi::core::GAddW)\n  349  {\n  350:     static void run(const cv::UMat& in1, double alpha, const cv::UMat& in2, double beta, double gamma, int dtype, cv::UMat& out)\n  351      {\n  352:         cv::addWeighted(in1, alpha, in2, beta, gamma, out, dtype);\n  353      }\n  354  };\n  ...\n  517  GAPI_OCL_KERNEL(GOCLConvertTo, cv::gapi::core::GConvertTo)\n  518  {\n  519:     static void run(const cv::UMat& in, int rtype, double alpha, double beta, cv::UMat& out)\n  520      {\n  521:         in.convertTo(out, rtype, alpha, beta);\n  522      }\n  523  };\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/test/common/gapi_core_tests.hpp:\n  126  GAPI_TEST_FIXTURE(LUTTest, initNothing, <>, 0)\n  127  GAPI_TEST_FIXTURE(ConvertToTest, initNothing, FIXTURE_API(CompareMats, double, double), 3,\n  128:     cmpF, alpha, beta)\n  129  GAPI_TEST_FIXTURE(PhaseTest, initMatsRandU, FIXTURE_API(bool), 1, angle_in_degrees)\n  130  GAPI_TEST_FIXTURE(SqrtTest, initMatrixRandU, <>, 0)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/test/common/gapi_core_tests_inl.hpp:\n  649      // G-API code //////////////////////////////////////////////////////////////\n  650      cv::GMat in1, in2;\n  651:     auto out = cv::gapi::addWeighted(in1, alpha, in2, beta, gamma, dtype);\n  652      cv::GComputation c(GIn(in1, in2), GOut(out));\n  653  \n  ...\n  656      // OpenCV code /////////////////////////////////////////////////////////////\n  657      {\n  658:         cv::addWeighted(in_mat1, alpha, in_mat2, beta, gamma, out_mat_ocv, dtype);\n  659      }\n  660      // Comparison //////////////////////////////////////////////////////////////\n  ...\n 1259      // G-API code //////////////////////////////////////////////////////////////\n 1260      cv::GMat in;\n 1261:     auto out = cv::gapi::convertTo(in, depth_to, alpha, beta);\n 1262  \n 1263      cv::GComputation c(in, out);\n ....\n 1265      // OpenCV code /////////////////////////////////////////////////////////////\n 1266      {\n 1267:         in_mat1.convertTo(out_mat_ocv, depth_to, alpha, beta);\n 1268      }\n 1269      // Comparison //////////////////////////////////////////////////////////////\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgcodecs/test/test_png.cpp:\n   57      Mat img;\n   58  \n   59:     // First Test : Read PNG with alpha, imread flag -1\n   60      img = imread(root + \"readwrite/color_palette_alpha.png\", IMREAD_UNCHANGED);\n   61      ASSERT_FALSE(img.empty());\n   ..\n   66      EXPECT_EQ(img.at<Vec4b>(0, 1), Vec4b(0, 0, 255, 255));\n   67  \n   68:     // Second Test : Read PNG without alpha, imread flag -1\n   69      img = imread(root + \"readwrite/color_palette_no_alpha.png\", IMREAD_UNCHANGED);\n   70      ASSERT_FALSE(img.empty());\n   ..\n   75      EXPECT_EQ(img.at<Vec3b>(0, 1), Vec3b(0, 0, 255));\n   76  \n   77:     // Third Test : Read PNG with alpha, imread flag 1\n   78      img = imread(root + \"readwrite/color_palette_alpha.png\", IMREAD_COLOR);\n   79      ASSERT_FALSE(img.empty());\n   ..\n   84      EXPECT_EQ(img.at<Vec3b>(0, 1), Vec3b(0, 0, 255));\n   85  \n   86:     // Fourth Test : Read PNG without alpha, imread flag 1\n   87      img = imread(root + \"readwrite/color_palette_no_alpha.png\", IMREAD_COLOR);\n   88      ASSERT_FALSE(img.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n 2918   */\n 2919  CV_EXPORTS_W void accumulateWeighted( InputArray src, InputOutputArray dst,\n 2920:                                       double alpha, InputArray mask = noArray() );\n 2921  \n 2922  /** @brief The function is used to detect translational shifts that occur between two images.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/accum.cpp:\n  280              break;\n  281          case VX_ACCUMULATE_WEIGHTED_OP:\n  282:             ivx::IVX_CHECK_STATUS(vxuAccumulateWeightedImage(context, srcImage, alpha, dstImage));\n  283              break;\n  284          default:\n  ...\n  546  {\n  547  static bool ipp_accumulate_weighted( InputArray _src, InputOutputArray _dst,\n  548:                              double alpha, InputArray _mask )\n  549  {\n  550      CV_INSTRUMENT_REGION_IPP();\n  ...\n  610  \n  611  void cv::accumulateWeighted( InputArray _src, InputOutputArray _dst,\n  612:                              double alpha, InputArray _mask )\n  613  {\n  614      CV_INSTRUMENT_REGION();\n  ...\n  621  \n  622      CV_OCL_RUN(_src.dims() <= 2 && _dst.isUMat(),\n  623:                ocl_accumulate(_src, noArray(), _dst, alpha, _mask, ACCUMULATE_WEIGHTED))\n  624  \n  625:     CV_IPP_RUN((_src.dims() <= 2 || (_src.isContinuous() && _dst.isContinuous() && _mask.isContinuous())), ipp_accumulate_weighted(_src, _dst, alpha, _mask));\n  626  \n  627      CV_OVX_RUN(_src.dims() <= 2,\n  628:                openvx_accumulate(_src, _dst, _mask, alpha, VX_ACCUMULATE_WEIGHTED_OP))\n  629  \n  630      Mat src = _src.getMat(), dst = _dst.getMat(), mask = _mask.getMat();\n  ...\n  675  \n  676  CV_IMPL void\n  677: cvRunningAvg( const void* arr, void* sumarr, double alpha, const void* maskarr )\n  678  {\n  679      cv::Mat src = cv::cvarrToMat(arr), dst = cv::cvarrToMat(sumarr), mask;\n  680      if( maskarr )\n  681          mask = cv::cvarrToMat(maskarr);\n  682:     cv::accumulateWeighted( src, dst, alpha, mask );\n  683  }\n  684  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/accum.simd.hpp:\n  243  \n  244  template<typename T, typename AT> void\n  245: accW_general_( const T* src, AT* dst, const uchar* mask, int len, int cn, double alpha, int start = 0 )\n  246  {\n  247:     AT a = (AT)alpha, b = 1 - a;\n  248      int i = start;\n  249  \n  ...\n 2748      }\n 2749  #endif // CV_SIMD\n 2750:     accW_general_(src, dst, mask, len, cn, alpha, x);\n 2751  }\n 2752  \n ....\n 2851      }\n 2852  #endif // CV_SIMD\n 2853:     accW_general_(src, dst, mask, len, cn, alpha, x);\n 2854  }\n 2855  \n ....\n 2893      }\n 2894  #endif // CV_SIMD\n 2895:     accW_general_(src, dst, mask, len, cn, alpha, x);\n 2896  }\n 2897  \n ....\n 2940      }\n 2941  #endif // CV_SIMD_64F\n 2942:     accW_general_(src, dst, mask, len, cn, alpha, x);\n 2943  }\n 2944  \n ....\n 2986      }\n 2987  #endif // CV_SIMD_64F\n 2988:     accW_general_(src, dst, mask, len, cn, alpha, x);\n 2989  }\n 2990  \n ....\n 3050      }\n 3051  #endif // CV_SIMD_64F\n 3052:     accW_general_(src, dst, mask, len, cn, alpha, x);\n 3053  }\n 3054  \n ....\n 3098      }\n 3099  #endif // CV_SIMD_64F\n 3100:     accW_general_(src, dst, mask, len, cn, alpha, x);\n 3101  }\n 3102  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/bilateral_filter.simd.hpp:\n  616                          v_int32 idx = v_trunc(alpha);\n  617                          alpha -= v_cvt_f32(idx);\n  618:                         v_float32 w = (kweight0 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one-alpha))) & knan;\n  619                          v_float32 v_wsum = vx_load_aligned(wsum + j) + w;\n  620                          v_float32 v_sum = v_muladd(val & knan, w, vx_load_aligned(sum + j));\n  ...\n  625                          idx = v_trunc(alpha);\n  626                          alpha -= v_cvt_f32(idx);\n  627:                         w = (kweight1 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  628                          v_wsum += w;\n  629                          v_sum = v_muladd(val & knan, w, v_sum);\n  ...\n  634                          idx = v_trunc(alpha);\n  635                          alpha -= v_cvt_f32(idx);\n  636:                         w = (kweight2 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  637                          v_wsum += w;\n  638                          v_sum = v_muladd(val & knan, w, v_sum);\n  ...\n  643                          idx = v_trunc(alpha);\n  644                          alpha -= v_cvt_f32(idx);\n  645:                         w = (kweight3 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  646                          v_wsum += w;\n  647                          v_sum = v_muladd(val & knan, w, v_sum);\n  ...\n  665                          v_int32x4 idx = v_trunc(alpha);\n  666                          alpha -= v_cvt_f32(idx);\n  667:                         v_float32x4 w = (kweight4 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one4 - alpha))) & knan;\n  668                          wsum[j] += v_reduce_sum(w);\n  669                          sum[j] += v_reduce_sum((val & knan) * w);\n  ...\n  732                          alpha -= v_cvt_f32(idx);\n  733  \n  734:                         v_float32 w = (kweight * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one-alpha))) & knan;\n  735                          v_store_aligned(wsum + j, vx_load_aligned(wsum + j) + w);\n  736                          v_store_aligned(sum + j, v_muladd(val & knan, w, vx_load_aligned(sum + j)));\n  ...\n  804                          v_int32 idx = v_trunc(alpha);\n  805                          alpha -= v_cvt_f32(idx);\n  806:                         v_float32 w = (kweight0 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  807                          v_float32 v_wsum = vx_load_aligned(wsum + j) + w;\n  808                          v_float32 v_sum_b = v_muladd(kb & knan, w, vx_load_aligned(sum_b + j));\n  ...\n  815                          idx = v_trunc(alpha);\n  816                          alpha -= v_cvt_f32(idx);\n  817:                         w = (kweight1 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  818                          v_wsum += w;\n  819                          v_sum_b = v_muladd(kb & knan, w, v_sum_b);\n  ...\n  826                          idx = v_trunc(alpha);\n  827                          alpha -= v_cvt_f32(idx);\n  828:                         w = (kweight2 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  829                          v_wsum += w;\n  830                          v_sum_b = v_muladd(kb & knan, w, v_sum_b);\n  ...\n  837                          idx = v_trunc(alpha);\n  838                          alpha -= v_cvt_f32(idx);\n  839:                         w = (kweight3 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  840                          v_wsum += w;\n  841                          v_sum_b = v_muladd(kb & knan, w, v_sum_b);\n  ...\n  867                          v_int32x4 idx = v_trunc(alpha);\n  868                          alpha -= v_cvt_f32(idx);\n  869:                         v_float32x4 w = (kweight4 * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one4 - alpha))) & knan;\n  870                          wsum[j] += v_reduce_sum(w);\n  871                          sum_b[j] += v_reduce_sum((kb & knan) * w);\n  ...\n  952                          alpha -= v_cvt_f32(idx);\n  953  \n  954:                         v_float32 w = (kweight * v_muladd(v_lut(expLUT + 1, idx), alpha, v_lut(expLUT, idx) * (v_one - alpha))) & knan;\n  955                          v_store_aligned(wsum + j, vx_load_aligned(wsum + j) + w);\n  956                          v_store_aligned(sum_b + j, v_muladd(kb & knan, w, vx_load_aligned(sum_b + j)));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/drawing.cpp:\n  952      CV_Assert(0 < delta && delta <= 180);\n  953  \n  954:     float alpha, beta;\n  955      int i;\n  956  \n  ...\n  981          arc_end = 360;\n  982      }\n  983:     sincos( angle, alpha, beta );\n  984      pts.resize(0);\n  985  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.avx2.cpp:\n   56  {\n   57  \n   58: int warpAffineBlockline(int *adelta, int *bdelta, short* xy, short* alpha, int X0, int Y0, int bw)\n   59  {\n   60      const int AB_BITS = MAX(10, (int)INTER_BITS);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n 2240                          #if CV_TRY_AVX2\n 2241                          if ( useAVX2 )\n 2242:                             x1 = opt_AVX2::warpAffineBlockline(adelta + x, bdelta + x, xy, alpha, X0, Y0, bw);\n 2243                          #endif\n 2244                          #if CV_SIMD128\n ....\n 2808  }\n 2809  \n 2810: void WarpPerspectiveLine_Process_CV_SIMD(const double *M, short* xy, short* alpha, double X0, double Y0, double W0, int bw)\n 2811  {\n 2812      const v_float64x2 v_M0 = v_setall_f64(M[0]);\n ....\n 3020                          #if CV_TRY_SSE4_1\n 3021                          if (pwarp_impl_sse4)\n 3022:                             pwarp_impl_sse4->process(M, xy, alpha, X0, Y0, W0, bw);\n 3023                          else\n 3024                          #endif\n 3025                          #if CV_SIMD128_64F\n 3026:                         WarpPerspectiveLine_Process_CV_SIMD(M, xy, alpha, X0, Y0, W0, bw);\n 3027                          #else\n 3028                          for( int x1 = 0; x1 < bw; x1++ )\n ....\n 3245  \n 3246      Matx23d M(\n 3247:         alpha, beta, (1-alpha)*center.x - beta*center.y,\n 3248:         -beta, alpha, beta*center.x + (1-alpha)*center.y\n 3249      );\n 3250      return M;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   58  {\n   59  #if CV_TRY_AVX2\n   60: int warpAffineBlockline(int *adelta, int *bdelta, short* xy, short* alpha, int X0, int Y0, int bw);\n   61  #endif\n   62  }\n   ..\n   75      static Ptr<WarpPerspectiveLine_SSE4> getImpl(const double *M);\n   76      virtual void processNN(const double *M, short* xy, double X0, double Y0, double W0, int bw) = 0;\n   77:     virtual void process(const double *M, short* xy, short* alpha, double X0, double Y0, double W0, int bw) = 0;\n   78      virtual ~WarpPerspectiveLine_SSE4() {};\n   79  };\n   ..\n   83  #if CV_SIMD128_64F\n   84  void WarpPerspectiveLine_ProcessNN_CV_SIMD(const double *M, short* xy, double X0, double Y0, double W0, int bw);\n   85: void WarpPerspectiveLine_Process_CV_SIMD(const double *M, short* xy, short* alpha, double X0, double Y0, double W0, int bw);\n   86  #endif\n   87  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n  347          }\n  348      }\n  349:     virtual void process(const double *M, short* xy, short* alpha, double X0, double Y0, double W0, int bw) CV_OVERRIDE\n  350      {\n  351          const __m128d v_M0 = _mm_set1_pd(M[0]);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n 1584  {\n 1585      int operator()(const ST** src, DT** dst, int count, const int* xofs,\n 1586:         const AT* alpha, int, int, int cn, int, int xmax) const\n 1587      {\n 1588          const int nlanes = 4;\n ....\n 1829  \n 1830          int dx0 = vecOp(src, dst, count,\n 1831:             xofs, alpha, swidth, dwidth, cn, xmin, xmax );\n 1832  \n 1833          for( k = 0; k <= count - 2; k+=2 )\n ....\n 2113  \n 2114      resizeGeneric_Invoker(const Mat& _src, Mat &_dst, const int *_xofs, const int *_yofs,\n 2115:         const AT* _alpha, const AT* __beta, const Size& _ssize, const Size &_dsize,\n 2116          int _ksize, int _xmin, int _xmax) :\n 2117          ParallelLoopBody(), src(_src), dst(_dst), xofs(_xofs), yofs(_yofs),\n ....\n 2175      Mat dst;\n 2176      const int* xofs, *yofs;\n 2177:     const AT* alpha, *_beta;\n 2178      Size ssize, dsize;\n 2179      const int ksize, xmin, xmax;\n ....\n 2200  \n 2201      Range range(0, dsize.height);\n 2202:     resizeGeneric_Invoker<HResize, VResize> invoker(src, dst, xofs, yofs, (const AT*)_alpha, beta,\n 2203          ssize, dsize, ksize, xmin, xmax);\n 2204      parallel_for_(range, invoker, dst.total()/(double)(1<<16));\n ....\n 4034      }\n 4035  \n 4036:     func( src, dst, xofs, fixpt ? (void*)ialpha : (void*)alpha, yofs,\n 4037            fixpt ? (void*)ibeta : (void*)beta, xmin, xmax, ksize );\n 4038  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/opencl/accumulate.cl:\n   71                          dst[c] = fma(convertToDT(src[c]), convertToDT(src2[c]), dst[c]);\n   72  #elif defined ACCUMULATE_WEIGHTED\n   73:                         dst[c] = fma(1 - alpha, dst[c], src[c] * alpha);\n   74  #else\n   75  #error \"Unknown accumulation type\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/java/generator/src/cpp/Mat.cpp:\n  701  \n  702  JNIEXPORT void JNICALL Java_org_opencv_core_Mat_n_1convertTo__JJIDD\n  703:   (JNIEnv* env, jclass, jlong self, jlong m_nativeObj, jint rtype, jdouble alpha, jdouble beta);\n  704  \n  705  JNIEXPORT void JNICALL Java_org_opencv_core_Mat_n_1convertTo__JJIDD\n  706:   (JNIEnv* env, jclass, jlong self, jlong m_nativeObj, jint rtype, jdouble alpha, jdouble beta)\n  707  {\n  708      static const char method_name[] = \"Mat::n_1convertTo__JJIDD()\";\n  ...\n  711          Mat* me = (Mat*) self; //TODO: check for NULL\n  712          Mat& m = *((Mat*)m_nativeObj);\n  713:         me->convertTo( m, rtype, alpha, beta );\n  714      } catch(const std::exception &e) {\n  715          throwJavaException(env, &e, method_name);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/js/src/core_bindings.cpp:\n  162      }\n  163  \n  164:     void convertTo(const Mat& obj, Mat& m, int rtype, double alpha, double beta)\n  165      {\n  166:         obj.convertTo(m, rtype, alpha, beta);\n  167      }\n  168  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/js/test/test_imgproc.js:\n  745          assert.deepEqual(dst.data, expectedAdd);\n  746  \n  747:         cv.addWeighted(mat1, alpha, mat2, beta, gamma, dst, -1);\n  748          // Verify result.\n  749          size = dst.size();\n  ...\n  755  \n  756          // default parameter\n  757:         cv.addWeighted(mat1, alpha, mat2, beta, gamma, dst);\n  758          // Verify result.\n  759          size = dst.size();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/ml/doc/ml_intro.markdown:\n  394  \n  395  In ML, all the neurons have the same activation functions, with the same free parameters (\n  396: \\f$\\alpha, \\beta\\f$ ) that are specified by user and are not altered by the training algorithms.\n  397  \n  398  So, the whole trained network works as follows:\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/ml/include/opencv2/ml.hpp:\n  789      sum of kernel responses.\n  790       */\n  791:     CV_WRAP virtual double getDecisionFunction(int i, OutputArray alpha, OutputArray svidx) const = 0;\n  792  \n  793      /** @brief Generates a grid for %SVM parameters.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/ml/src/svm.cpp:\n  165      void calc_non_rbf_base( int vcount, int var_count, const float* vecs,\n  166                              const float* another, Qfloat* results,\n  167:                             double alpha, double beta )\n  168      {\n  169          int j, k;\n  ...\n  444      //  eps is the stopping criterion\n  445      //\n  446:     // solution will be put in \\alpha, objective value will be put in obj\n  447      //\n  448      class Solver\n  ...\n  484  \n  485          Solver( const Mat& _samples, const vector<schar>& _y,\n  486:                 vector<double>& _alpha, const vector<double>& _b,\n  487                  double _Cp, double _Cn,\n  488                  const Ptr<SVM::Kernel>& _kernel, GetRow _get_row,\n  ...\n 1017          static bool solve_c_svc( const Mat& _samples, const vector<schar>& _y,\n 1018                                   double _Cp, double _Cn, const Ptr<SVM::Kernel>& _kernel,\n 1019:                                  vector<double>& _alpha, SolutionInfo& _si, TermCriteria termCrit )\n 1020          {\n 1021              int sample_count = _samples.rows;\n ....\n 1024              vector<double> _b(sample_count, -1.);\n 1025  \n 1026:             Solver solver( _samples, _y, _alpha, _b, _Cp, _Cn, _kernel,\n 1027                             &Solver::get_row_svc,\n 1028                             &Solver::select_working_set,\n ....\n 1042          static bool solve_nu_svc( const Mat& _samples, const vector<schar>& _y,\n 1043                                    double nu, const Ptr<SVM::Kernel>& _kernel,\n 1044:                                   vector<double>& _alpha, SolutionInfo& _si,\n 1045                                    TermCriteria termCrit )\n 1046          {\n ....\n 1069              }\n 1070  \n 1071:             Solver solver( _samples, _y, _alpha, _b, 1., 1., _kernel,\n 1072                             &Solver::get_row_svc,\n 1073                             &Solver::select_working_set_nu_svm,\n ....\n 1093          static bool solve_one_class( const Mat& _samples, double nu,\n 1094                                       const Ptr<SVM::Kernel>& _kernel,\n 1095:                                      vector<double>& _alpha, SolutionInfo& _si,\n 1096                                       TermCriteria termCrit )\n 1097          {\n ....\n 1111                  _alpha[n-1] = nu * sample_count - (n-1);\n 1112  \n 1113:             Solver solver( _samples, _y, _alpha, _b, 1., 1., _kernel,\n 1114                             &Solver::get_row_one_class,\n 1115                             &Solver::select_working_set,\n ....\n 1122          static bool solve_eps_svr( const Mat& _samples, const vector<float>& _yf,\n 1123                                     double p, double C, const Ptr<SVM::Kernel>& _kernel,\n 1124:                                    vector<double>& _alpha, SolutionInfo& _si,\n 1125                                     TermCriteria termCrit )\n 1126          {\n ....\n 1143              }\n 1144  \n 1145:             Solver solver( _samples, _y, _alpha, _b, C, C, _kernel,\n 1146                             &Solver::get_row_svr,\n 1147                             &Solver::select_working_set,\n ....\n 1161          static bool solve_nu_svr( const Mat& _samples, const vector<float>& _yf,\n 1162                                    double nu, double C, const Ptr<SVM::Kernel>& _kernel,\n 1163:                                   vector<double>& _alpha, SolutionInfo& _si,\n 1164                                    TermCriteria termCrit )\n 1165          {\n ....\n 1186              }\n 1187  \n 1188:             Solver solver( _samples, _y, _alpha, _b, 1., 1., _kernel,\n 1189                             &Solver::get_row_svr,\n 1190                             &Solver::select_working_set_nu_svm,\n ....\n 1392  \n 1393              bool ok =\n 1394:             svmType == ONE_CLASS ? Solver::solve_one_class( _samples, params.nu, kernel, _alpha, sinfo, params.termCrit ) :\n 1395:             svmType == EPS_SVR ? Solver::solve_eps_svr( _samples, _yf, params.p, params.C, kernel, _alpha, sinfo, params.termCrit ) :\n 1396:             svmType == NU_SVR ? Solver::solve_nu_svr( _samples, _yf, params.nu, params.C, kernel, _alpha, sinfo, params.termCrit ) : false;\n 1397  \n 1398              if( !ok )\n ....\n 1505                      bool ok = params.svmType == C_SVC ?\n 1506                                  Solver::solve_c_svc( temp_samples, temp_y, Cp, Cn,\n 1507:                                                      kernel, _alpha, sinfo, params.termCrit ) :\n 1508                                params.svmType == NU_SVC ?\n 1509                                  Solver::solve_nu_svc( temp_samples, temp_y, params.nu,\n 1510:                                                       kernel, _alpha, sinfo, params.termCrit ) :\n 1511                                false;\n 1512                      if( !ok )\n ....\n 2032      }\n 2033  \n 2034:     double getDecisionFunction(int i, OutputArray _alpha, OutputArray _svidx ) const CV_OVERRIDE\n 2035      {\n 2036          CV_Assert( 0 <= i && i < (int)decision_func.size());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/ml/src/tree.cpp:\n 1309              parent->alpha = ((fold >= 0 ? w->cv_node_risk[pidx*cv_n + fold] : parent->node_risk)\n 1310                               - parent->tree_risk)/(parent->complexity - 1);\n 1311:             min_alpha = std::min( min_alpha, parent->alpha );\n 1312          }\n 1313  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/objdetect/src/qrcode_encoder.cpp:\n  443          int alpha = index_1 * 45 + index_2;\n  444  \n  445:         writeDecNumber(alpha, alpha_symbol_bits, output);\n  446      }\n  447      if (str_len % 2 != 0)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/photo/src/seamless_cloning.cpp:\n  111  }\n  112  \n  113: void cv::illuminationChange(InputArray _src, InputArray _mask, OutputArray _dst, float alpha, float beta)\n  114  {\n  115      CV_INSTRUMENT_REGION();\n  ...\n  124  \n  125      Cloning obj;\n  126:     obj.illuminationChange(src, cs_mask, mask, blend, alpha, beta);\n  127  \n  128  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/photo/src/seamless_cloning.hpp:\n   55          public:\n   56              void normalClone(const cv::Mat& destination, const cv::Mat &mask, const cv::Mat &wmask, cv::Mat &cloned, int flag);\n   57:             void illuminationChange(cv::Mat &I, cv::Mat &mask, cv::Mat &wmask, cv::Mat &cloned, float alpha, float beta);\n   58              void localColorChange(cv::Mat &I, cv::Mat &mask, cv::Mat &wmask, cv::Mat &cloned, float red_mul, float green_mul, float blue_mul);\n   59              void textureFlatten(cv::Mat &I, cv::Mat &mask, cv::Mat &wmask, float low_threshold, float high_threhold, int kernel_size, cv::Mat &cloned);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/photo/src/seamless_cloning_impl.cpp:\n  402  }\n  403  \n  404: void Cloning::illuminationChange(Mat &I, Mat &mask, Mat &wmask, Mat &cloned, float alpha, float beta)\n  405  {\n  406      CV_INSTRUMENT_REGION();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/ts/include/opencv2/ts.hpp:\n  294  Mat randomMat(RNG& rng, Size size, int type, double minVal, double maxVal, bool useRoi);\n  295  Mat randomMat(RNG& rng, const vector<int>& size, int type, double minVal, double maxVal, bool useRoi);\n  296: void add(const Mat& a, double alpha, const Mat& b, double beta,\n  297                        Scalar gamma, Mat& c, int ctype, bool calcAbs=false);\n  298  void multiply(const Mat& a, const Mat& b, Mat& c, double alpha=1);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/ts/src/ts_func.cpp:\n  150  }\n  151  \n  152: void add(const Mat& _a, double alpha, const Mat& _b, double beta,\n  153          Scalar gamma, Mat& c, int ctype, bool calcAbs)\n  154  {\n  ...\n  233  \n  234  template<typename _Tp1, typename _Tp2> inline void\n  235: convert_(const _Tp1* src, _Tp2* dst, size_t total, double alpha, double beta)\n  236  {\n  237      size_t i;\n  ...\n  248  \n  249  template<typename _Tp> inline void\n  250: convertTo(const _Tp* src, void* dst, int dtype, size_t total, double alpha, double beta)\n  251  {\n  252      switch( CV_MAT_DEPTH(dtype) )\n  253      {\n  254      case CV_8U:\n  255:         convert_(src, (uchar*)dst, total, alpha, beta);\n  256          break;\n  257      case CV_8S:\n  258:         convert_(src, (schar*)dst, total, alpha, beta);\n  259          break;\n  260      case CV_16U:\n  261:         convert_(src, (ushort*)dst, total, alpha, beta);\n  262          break;\n  263      case CV_16S:\n  264:         convert_(src, (short*)dst, total, alpha, beta);\n  265          break;\n  266      case CV_32S:\n  267:         convert_(src, (int*)dst, total, alpha, beta);\n  268          break;\n  269      case CV_32F:\n  270:         convert_(src, (float*)dst, total, alpha, beta);\n  271          break;\n  272      case CV_64F:\n  273:         convert_(src, (double*)dst, total, alpha, beta);\n  274          break;\n  275      default:\n  ...\n  278  }\n  279  \n  280: void convert(const Mat& src, cv::OutputArray _dst, int dtype, double alpha, double beta)\n  281  {\n  282      if (dtype < 0) dtype = _dst.depth();\n  ...\n  311          {\n  312          case CV_8U:\n  313:             convertTo((const uchar*)sptr, dptr, dtype, total, alpha, beta);\n  314              break;\n  315          case CV_8S:\n  316:             convertTo((const schar*)sptr, dptr, dtype, total, alpha, beta);\n  317              break;\n  318          case CV_16U:\n  319:             convertTo((const ushort*)sptr, dptr, dtype, total, alpha, beta);\n  320              break;\n  321          case CV_16S:\n  322:             convertTo((const short*)sptr, dptr, dtype, total, alpha, beta);\n  323              break;\n  324          case CV_32S:\n  325:             convertTo((const int*)sptr, dptr, dtype, total, alpha, beta);\n  326              break;\n  327          case CV_32F:\n  328:             convertTo((const float*)sptr, dptr, dtype, total, alpha, beta);\n  329              break;\n  330          case CV_64F:\n  331:             convertTo((const double*)sptr, dptr, dtype, total, alpha, beta);\n  332              break;\n  333          }\n  ...\n 2207        _Tp* d_data, int d_step,\n 2208        int d_rows, int d_cols, int a_cols, int cn,\n 2209:       double alpha, double beta)\n 2210  {\n 2211      for( int i = 0; i < d_rows; i++, d_data += d_step, c_data0 += c_step, a_data0 += a_step )\n ....\n 2312          GEMM_(a.ptr<float>(), a_step, a_delta, b.ptr<float>(), b_step, b_delta,\n 2313                !c.empty() ? c.ptr<float>() : 0, c_step, c_delta, d.ptr<float>(),\n 2314:               (int)d.step1(), a_rows, b_cols, a_cols, cn, alpha, beta );\n 2315      else\n 2316          GEMM_(a.ptr<double>(), a_step, a_delta, b.ptr<double>(), b_step, b_delta,\n 2317                !c.empty() ? c.ptr<double>() : 0, c_step, c_delta, d.ptr<double>(),\n 2318:               (int)d.step1(), a_rows, b_cols, a_cols, cn, alpha, beta );\n 2319  }\n 2320  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/variational_refinement.cpp:\n   61      int fixedPointIterations, sorIterations;\n   62      float omega;\n   63:     float alpha, delta, gamma;\n   64      float zeta, epsilon;\n   65  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/test/test_accum.cpp:\n  220  {\n  221      cvRunningAvg( test_array[INPUT][0], test_array[INPUT_OUTPUT][0],\n  222:                   alpha, test_array[MASK][0] );\n  223  }\n  224  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/train_HOG.cpp:\n   24      const int sv_total = sv.rows;\n   25      // get the decision function\n   26:     Mat alpha, svidx;\n   27:     double rho = svm->getDecisionFunction( 0, alpha, svidx );\n   28  \n   29      CV_Assert( alpha.total() == 1 && svidx.total() == 1 && sv_total == 1 );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/core/AddingImages/AddingImages.cpp:\n   46     //![blend_images]\n   47     beta = ( 1.0 - alpha );\n   48:    addWeighted( src1, alpha, src2, beta, 0.0, dst);\n   49     //![blend_images]\n   50  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp:\n   32     alpha = (double) alpha_slider/alpha_slider_max ;\n   33     beta = ( 1.0 - alpha );\n   34:    addWeighted( src1, alpha, src2, beta, 0.0, dst);\n   35     imshow( \"Linear Blend\", dst );\n   36  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/HighGUI/BasicLinearTransformsTrackbar.cpp:\n   61  \n   62     /// Create Trackbars\n   63:    createTrackbar( \"Contrast\", \"New Image\", &alpha, alpha_max, on_trackbar );\n   64     createTrackbar( \"Brightness\", \"New Image\", &beta, beta_max, on_trackbar );\n   65  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/ImgProc/BasicLinearTransforms.cpp:\n   50      /// Do the operation new_image(i,j) = alpha*image(i,j) + beta\n   51      /// Instead of these 'for' loops we could have used simply:\n   52:     /// image.convertTo(new_image, -1, alpha, beta);\n   53      /// but we wanted to show you how to access the pixels :)\n   54      //! [basic-linear-transform-operation]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/ImgProc/changing_contrast_brightness_image/changing_contrast_brightness_image.cpp:\n   83      namedWindow(\"Gamma correction\");\n   84  \n   85:     createTrackbar(\"Alpha gain (contrast)\", \"Brightness and contrast adjustments\", &alpha, 500, on_linear_transform_alpha_trackbar);\n   86      createTrackbar(\"Beta bias (brightness)\", \"Brightness and contrast adjustments\", &beta, 200, on_linear_transform_beta_trackbar);\n   87      createTrackbar(\"Gamma correction\", \"Gamma correction\", &gamma_cor, 200, on_gamma_correction_trackbar);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/java/tutorial_code/core/AddingImages/AddingImages.java:\n   31          //! [blend_images]\n   32          beta = ( 1.0 - alpha );\n   33:         Core.addWeighted( src1, alpha, src2, beta, 0.0, dst);\n   34          //! [blend_images]\n   35  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/java/tutorial_code/highgui/trackbar/AddingImagesTrackbar.java:\n   98          double alpha = alphaVal / (double) ALPHA_SLIDER_MAX;\n   99          double beta = 1.0 - alpha;\n  100:         Core.addWeighted(matImgSrc1, alpha, matImgSrc2, beta, 0, matImgDst);\n  101          Image img = HighGui.toBufferedImage(matImgDst);\n  102          imgLabel.setIcon(new ImageIcon(img));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/java/tutorial_code/ImgProc/changing_contrast_brightness_image/BasicLinearTransformsDemo.java:\n   45          /// Do the operation newImage(i,j) = alpha*image(i,j) + beta\n   46          /// Instead of these 'for' loops we could have used simply:\n   47:         /// image.convertTo(newImage, -1, alpha, beta);\n   48          /// but we wanted to show you how to access the pixels :)\n   49          //! [basic-linear-transform-operation]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/openvx/no_wrappers.cpp:\n  251          vxGaussian3x3Node(graph, inputImage, smoothed),\n  252          vxCannyEdgeDetectorNode(graph, smoothed, threshCanny, 3, VX_NORM_L2, cannied),\n  253:         vxAccumulateWeightedImageNode(graph, inputImage, alpha, halfImg),\n  254:         vxAccumulateWeightedImageNode(graph, cannied, alpha, halfCanny),\n  255          vxAddNode(graph, halfImg, halfCanny, VX_CONVERT_POLICY_SATURATE, outputImage)\n  256      };\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/openvx/wrappers.cpp:\n   50                   ivx::Scalar::create<VX_TYPE_INT32>(context, 3),\n   51                   ivx::Scalar::create<VX_TYPE_ENUM>(context, VX_NORM_L2), cannied);\n   52:     Node::create(graph, VX_KERNEL_ACCUMULATE_WEIGHTED, inputImage, alpha, halfImg);\n   53:     Node::create(graph, VX_KERNEL_ACCUMULATE_WEIGHTED, cannied, alpha, halfCanny);\n   54      Node::create(graph, VX_KERNEL_ADD, halfImg, halfCanny,\n   55                   ivx::Scalar::create<VX_TYPE_ENUM>(context, VX_CONVERT_POLICY_SATURATE), outputImage);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/openvx/wrappers_video.cpp:\n   55                   ivx::Scalar::create<VX_TYPE_INT32>(context, 3),\n   56                   ivx::Scalar::create<VX_TYPE_ENUM>(context, VX_NORM_L2), cannied);\n   57:     Node::create(graph, VX_KERNEL_ACCUMULATE_WEIGHTED, gray, alpha, halfImg);\n   58:     Node::create(graph, VX_KERNEL_ACCUMULATE_WEIGHTED, cannied, alpha, halfCanny);\n   59      Node::create(graph, VX_KERNEL_ADD, halfImg, halfCanny,\n   60                   ivx::Scalar::create<VX_TYPE_ENUM>(context, VX_CONVERT_POLICY_SATURATE), outputImage);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/python/tutorial_code/core/AddingImages/adding_images.py:\n   28  # [blend_images]\n   29  beta = (1.0 - alpha)\n   30: dst = cv.addWeighted(src1, alpha, src2, beta, 0.0)\n   31  # [blend_images]\n   32  # [display]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/python/tutorial_code/highgui/trackbar/AddingImagesTrackbar.py:\n   11      alpha = val / alpha_slider_max\n   12      beta = ( 1.0 - alpha )\n   13:     dst = cv.addWeighted(src1, alpha, src2, beta, 0.0)\n   14      cv.imshow(title_window, dst)\n   15  ## [on_trackbar]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/python/tutorial_code/imgProc/changing_contrast_brightness_image/BasicLinearTransforms.py:\n   37  # Do the operation new_image(i,j) = alpha*image(i,j) + beta\n   38  # Instead of these 'for' loops we could have used simply:\n   39: # new_image = cv.convertScaleAbs(image, alpha=alpha, beta=beta)\n   40  # but we wanted to show you how to access the pixels :)\n   41  ## [basic-linear-transform-operation]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/python/tutorial_code/imgProc/changing_contrast_brightness_image/changing_contrast_brightness_image.py:\n   13  \n   14  def basicLinearTransform():\n   15:     res = cv.convertScaleAbs(img_original, alpha=alpha, beta=beta)\n   16      img_corrected = cv.hconcat([img_original, res])\n   17      cv.imshow(\"Brightness and contrast adjustments\", img_corrected)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/alphamat/src/cm.cpp:\n   90      Mat ptDotN(20, 1, DataType<float>::type), imd(20, 1, DataType<float>::type);\n   91      Mat Cones(20, 1, DataType<float>::type), Cinv(20, 1, DataType<float>::type);\n   92:     float alpha, beta, lagrangeMult;\n   93      Cones.setTo(cv::Scalar::all(1));\n   94  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaarithm/include/opencv2/cudaarithm.hpp:\n  336  @sa addWeighted\n  337   */\n  338: CV_EXPORTS_W void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst,\n  339                              int dtype = -1, Stream& stream = Stream::Null());\n  340  \n  341  //! adds scaled array to another one (dst = alpha*src1 + src2)\n  342: static inline void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst, Stream& stream = Stream::Null())\n  343  {\n  344:     addWeighted(src1, alpha, src2, 1.0, 0.0, dst, -1, stream);\n  345  }\n  346  \n  ...\n  722  @sa normalize\n  723   */\n  724: CV_EXPORTS_W void normalize(InputArray src, OutputArray dst, double alpha, double beta,\n  725                            int norm_type, int dtype, InputArray mask = noArray(),\n  726                            Stream& stream = Stream::Null());\n  ...\n  767  \n  768  The function performs generalized matrix multiplication similar to the gemm functions in BLAS level\n  769: 3. For example, gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) corresponds to\n  770  \n  771  \\f[\\texttt{dst} =  \\texttt{alpha} \\cdot \\texttt{src1} ^T  \\cdot \\texttt{src2} +  \\texttt{beta} \\cdot \\texttt{src3} ^T\\f]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaarithm/perf/perf_reductions.cpp:\n  413          cv::cuda::GpuMat dst;\n  414  \n  415:         TEST_CYCLE() cv::cuda::normalize(d_src, dst, alpha, beta, norm_type, type, cv::cuda::GpuMat());\n  416  \n  417          CUDA_SANITY_CHECK(dst, 1e-6);\n  ...\n  421          cv::Mat dst;\n  422  \n  423:         TEST_CYCLE() cv::normalize(src, dst, alpha, beta, norm_type, type);\n  424  \n  425          CPU_SANITY_CHECK(dst);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaarithm/src/arithm.cpp:\n  155  // gemm\n  156  \n  157: void cv::cuda::gemm(InputArray _src1, InputArray _src2, double alpha, InputArray _src3, double beta, OutputArray _dst, int flags, Stream& stream)\n  158  {\n  159  #ifndef HAVE_CUBLAS\n  ...\n  235      const cuComplex betacf = make_cuComplex(betaf, 0);\n  236  \n  237:     const cuDoubleComplex alphac = make_cuDoubleComplex(alpha, 0);\n  238      const cuDoubleComplex betac = make_cuDoubleComplex(beta, 0);\n  239  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaarithm/src/cuda/add_weighted.cu:\n   82  \n   83      template <typename T1, typename T2, typename D>\n   84:     void addWeightedImpl(const GpuMat& src1, double alpha, const GpuMat& src2, double beta, double gamma, GpuMat& dst, Stream& stream)\n   85      {\n   86          typedef typename LargerType<T1, T2>::type larger_type1;\n   ..\n   97  }\n   98  \n   99: void cv::cuda::addWeighted(InputArray _src1, double alpha, InputArray _src2, double beta, double gamma, OutputArray _dst, int ddepth, Stream& stream)\n  100  {\n  101:     typedef void (*func_t)(const GpuMat& src1, double alpha, const GpuMat& src2, double beta, double gamma, GpuMat& dst, Stream& stream);\n  102      static const func_t funcs[7][7][7] =\n  103      {\n  ...\n  580      {\n  581          src1_single.swap(src2_single);\n  582:         std::swap(alpha, beta);\n  583          std::swap(sdepth1, sdepth2);\n  584      }\n  ...\n  589          CV_Error(cv::Error::StsUnsupportedFormat, \"Unsupported combination of source and destination types\");\n  590  \n  591:     func(src1_single, alpha, src2_single, beta, gamma, dst_single, stream);\n  592  \n  593      syncOutput(dst, _dst, stream);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaarithm/test/test_arithm.cpp:\n   88          {\n   89              cv::cuda::GpuMat dst;\n   90:             cv::cuda::gemm(loadMat(src1), loadMat(src2), alpha, loadMat(src3), beta, dst, flags);\n   91          }\n   92          catch (const cv::Exception& e)\n   ..\n  100          {\n  101              cv::cuda::GpuMat dst;\n  102:             cv::cuda::gemm(loadMat(src1), loadMat(src2), alpha, loadMat(src3), beta, dst, flags);\n  103          }\n  104          catch (const cv::Exception& e)\n  ...\n  110      {\n  111          cv::cuda::GpuMat dst = createMat(size, type, useRoi);\n  112:         cv::cuda::gemm(loadMat(src1, useRoi), loadMat(src2, useRoi), alpha, loadMat(src3, useRoi), beta, dst, flags);\n  113  \n  114          cv::Mat dst_gold;\n  115:         cv::gemm(src1, src2, alpha, src3, beta, dst_gold, flags);\n  116  \n  117          EXPECT_MAT_NEAR(dst_gold, dst, CV_MAT_DEPTH(type) == CV_32F ? 1e-1 : 1e-10);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaarithm/test/test_element_operations.cpp:\n 2500          {\n 2501              cv::cuda::GpuMat dst;\n 2502:             cv::cuda::addWeighted(loadMat(src1), alpha, loadMat(src2), beta, gamma, dst, dst_depth);\n 2503          }\n 2504          catch (const cv::Exception& e)\n ....\n 2510      {\n 2511          cv::cuda::GpuMat dst = createMat(size, dst_depth, useRoi);\n 2512:         cv::cuda::addWeighted(loadMat(src1, useRoi), alpha, loadMat(src2, useRoi), beta, gamma, dst, dst_depth);\n 2513  \n 2514          cv::Mat dst_gold;\n 2515:         cv::addWeighted(src1, alpha, src2, beta, gamma, dst_gold, dst_depth);\n 2516  \n 2517          EXPECT_MAT_NEAR(dst_gold, dst, dst_depth < CV_32F ? 2.0 : 1e-3);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaarithm/test/test_reductions.cpp:\n  934  \n  935      cv::cuda::GpuMat dst = createMat(size, type, useRoi);\n  936:     cv::cuda::normalize(loadMat(src, useRoi), dst, alpha, beta, norm_type, type);\n  937  \n  938      cv::Mat dst_gold;\n  939:     cv::normalize(src, dst_gold, alpha, beta, norm_type, type);\n  940  \n  941      EXPECT_MAT_NEAR(dst_gold, dst, type < CV_32F ? 1.0 : 1e-4);\n  ...\n  949      cv::cuda::GpuMat dst = createMat(size, type, useRoi);\n  950      dst.setTo(cv::Scalar::all(0));\n  951:     cv::cuda::normalize(loadMat(src, useRoi), dst, alpha, beta, norm_type, -1, loadMat(mask, useRoi));\n  952  \n  953      cv::Mat dst_gold(size, type);\n  954      dst_gold.setTo(cv::Scalar::all(0));\n  955:     cv::normalize(src, dst_gold, alpha, beta, norm_type, -1, mask);\n  956  \n  957      EXPECT_MAT_NEAR(dst_gold, dst, type < CV_32F ? 1.0 : 1e-4);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/cuda/NCVBroxOpticalFlow.cu:\n  389                                                          float *numerator_u, float *numerator_v,\n  390                                                          int w, int h, int s,\n  391:                                                         float alpha, float gamma)\n  392  {\n  393      __shared__ float u[PSOR_PITCH * PSOR_HEIGHT];\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaoptflow/src/brox.cpp:\n   57      {\n   58      public:\n   59:         BroxOpticalFlowImpl(double alpha, double gamma, double scale_factor,\n   60                              int inner_iterations, int outer_iterations, int solver_iterations) :\n   61              alpha_(alpha), gamma_(gamma), scale_factor_(scale_factor),\n   ..\n  189  }\n  190  \n  191: Ptr<BroxOpticalFlow> cv::cuda::BroxOpticalFlow::create(double alpha, double gamma, double scale_factor, int inner_iterations, int outer_iterations, int solver_iterations)\n  192  {\n  193:     return makePtr<BroxOpticalFlowImpl>(alpha, gamma, scale_factor, inner_iterations, outer_iterations, solver_iterations);\n  194  }\n  195  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/face_utils.hpp:\n   36          // make reshape happy by cloning for non-continuous matrices\n   37          if(src.getMat(i).isContinuous()) {\n   38:             src.getMat(i).reshape(1, 1).convertTo(xi, rtype, alpha, beta);\n   39          } else {\n   40:             src.getMat(i).clone().reshape(1, 1).convertTo(xi, rtype, alpha, beta);\n   41          }\n   42      }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/img_hash/include/opencv2/img_hash/marr_hildreth_hash.hpp:\n   35          @param scale int level of scale factor (default = 1)\n   36      */\n   37:     CV_WRAP void setKernelParam(float alpha, float scale);\n   38  \n   39      /**\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/img_hash/src/marr_hildreth_hash.cpp:\n   11  namespace {\n   12  \n   13: void getMHKernel(float alpha, float level, cv::Mat &kernel)\n   14  {\n   15      int const sigma = static_cast<int>(4*std::pow(alpha,level));\n   16  \n   17:     float const ratio = std::pow(alpha, -level);\n   18      kernel.create(2*sigma+1, 2*sigma+1, CV_32F);\n   19      for(int row = 0; row != kernel.rows; ++row)\n   ..\n  140      }\n  141  \n  142:     void setKernelParam(float alpha, float scale)\n  143      {\n  144          alphaVal = alpha;\n  ...\n  184  }\n  185  \n  186: void MarrHildrethHash::setKernelParam(float alpha, float scale)\n  187  {\n  188:     getLocalImpl(pImpl)->setKernelParam(alpha, scale);\n  189  }\n  190  \n  191: Ptr<MarrHildrethHash> MarrHildrethHash::create(float alpha, float scale)\n  192  {\n  193      Ptr<MarrHildrethHash> res(new MarrHildrethHash);\n  194:     res->pImpl = makePtr<MarrHildrethHashImpl>(alpha, scale);\n  195      return res;\n  196  }\n  ...\n  198  void marrHildrethHash(cv::InputArray inputArr,\n  199                        cv::OutputArray outputArr,\n  200:                       float alpha, float scale)\n  201  {\n  202:     MarrHildrethHashImpl(alpha, scale).compute(inputArr, outputArr);\n  203  }\n  204  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/matlab/test/OpenCVTest.m:\n  129        gamma = 1.61803;\n  130        d = alpha*a*b + gamma*c;\n  131:       e = cv.gemm(a, b, alpha, c, gamma);\n  132        testcase.verifyLessThan(norm(d - e), 1e-8, 'Matrices are multiplied with insufficient precision');\n  133      end\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/mcc/src/colorspace.cpp:\n  174      alpha = a + 1;\n  175      K0 = a / (gamma - 1);\n  176:     phi = (pow(alpha, gamma) * pow(gamma - 1, gamma - 1)) / (pow(a, gamma - 1) * pow(gamma, gamma));\n  177      beta = K0 / phi;\n  178  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ovis/src/ovis.cpp:\n  857          // convert to NDC\n  858          double alpha = 2.0/std::numeric_limits<uint16>::max();\n  859:         tmp.convertTo(depth, CV_64F, alpha, -1);\n  860  \n  861          // convert to linear\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/sfm/src/libmv_light/libmv/multiview/fundamental.cc:\n  183  \n  184    // Run fundamental_7point_coeffs.py to get the below coefficients.\n  185:   // The coefficients are in ascending powers of alpha, i.e. P[N]*x^N.\n  186    double P[4] = {\n  187      a*e*i + b*f*g + c*d*h - a*f*h - b*d*i - c*e*g,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/sfm/src/libmv_light/libmv/multiview/fundamental_kernel.cc:\n   62  \n   63    // Run fundamental_7point_coeffs.py to get the below coefficients.\n   64:   // The coefficients are in ascending powers of alpha, i.e. P[N]*x^N.\n   65    double P[4] = {\n   66      a*e*i + b*f*g + c*d*h - a*f*h - b*d*i - c*e*g,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/sfm/src/libmv_light/libmv/multiview/panography.cc:\n   51    //   f^6 * p + f^4 * q + f^2* r + s = 0;\n   52    //\n   53:   // Coefficients in ascending powers of alpha, i.e. P[N]*x^N.\n   54    // Run panography_coeffs.py to get the below coefficients.\n   55    P[0] = b1*b2*a12*a12-a1*a2*b12*b12;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/superres/src/btv_l1.cpp:\n  345      }\n  346  \n  347:     void calcBtvWeights(int btvKernelSize, double alpha, std::vector<float>& btvWeights)\n  348      {\n  349          const size_t size = btvKernelSize * btvKernelSize;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/superres/src/btv_l1_cuda.cpp:\n  169      }\n  170  \n  171:     void calcBtvWeights(int btvKernelSize, double alpha, std::vector<float>& btvWeights)\n  172      {\n  173          const size_t size = btvKernelSize * btvKernelSize;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/surface_matching/include/opencv2/surface_matching/pose_3d.hpp:\n  123    virtual ~Pose3D() {}\n  124  \n  125:   CV_PROP double alpha, residual;\n  126    CV_PROP size_t modelIndex, numVotes;\n  127    CV_PROP Matx44d pose;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/surface_matching/src/pose_3d.cpp:\n  161  Pose3DPtr Pose3D::clone()\n  162  {\n  163:   Ptr<Pose3D> new_pose(new Pose3D(alpha, modelIndex, numVotes));\n  164  \n  165    new_pose->pose = this->pose;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/surface_matching/src/ppf_match_3d.cpp:\n  570      Matx33d R;\n  571      Vec3d t = Vec3d::all(0);\n  572:     getUnitXRotation(alpha, R);\n  573      rtToPose(R, t, Talpha);\n  574  \n  575      Matx44d rawPose = TsgInv * (Talpha * Tmg);\n  576  \n  577:     Pose3DPtr pose(new Pose3D(alpha, refIndMax, maxVotes));\n  578      pose->updatePose(rawPose);\n  579      #if defined (_OPENMP)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/trackerKCF.cpp:\n  106      void shiftCols(Mat& mat, int n) const;\n  107  #ifdef HAVE_OPENCL\n  108:     bool inline oclTransposeMM(const Mat src, float alpha, UMat &dst);\n  109  #endif\n  110  \n  ...\n  556  \n  557  #ifdef HAVE_OPENCL\n  558:   bool inline TrackerKCFImpl::oclTransposeMM(const Mat src, float alpha, UMat &dst){\n  559      // Current kernel only support matrix's rows is multiple of 4.\n  560      // And if one line is less than 512KB, CPU will likely be faster.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/opencl/tmm.cl:\n    9  #define BLOCK_SIZE_X  3\n   10  \n   11: __kernel void tmm(__global float *A, int m, int n, float alpha, __global float *D)\n   12  {\n   13    int lidX = get_local_id(0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/boostdesc.cpp:\n  168      Mat m_wl_x_min, m_wl_x_max;\n  169      Mat m_wl_y_min, m_wl_y_max;\n  170:     Mat m_wl_alpha, m_wl_beta;\n  171  \n  172  private:\n  ...\n  392                          const Mat& _wl_y_min, const Mat& _wl_y_max,\n  393                          const Mat& _wl_thresh, const Mat& _wl_orient,\n  394:                         const Mat& _wl_alpha, const Mat& _wl_beta,\n  395                          const bool _use_scale_orientation,\n  396                          const float _scale_factor )\n  ...\n  534  \n  535      Mat wl_x_min, wl_x_max, wl_y_min, wl_y_max;\n  536:     Mat wl_thresh, wl_orient, wl_alpha, wl_beta;\n  537  \n  538      float scale_factor;\n  ...\n  577                              m_patch_size, m_nWLs, m_Dims,\n  578                              m_wl_x_min, m_wl_x_max, m_wl_y_min, m_wl_y_max,\n  579:                             m_wl_thresh, m_wl_orient, m_wl_alpha, m_wl_beta,\n  580                              m_use_scale_orientation, m_scale_factor )\n  581      );\n  ...\n  659                        nDim, nWLs, thresh, orient,\n  660                        x_min, x_max, y_min, y_max,\n  661:                       alpha, NULL );\n  662          }\n  663          break;\n  ...\n  669                        nDim, nWLs, thresh, orient,\n  670                        x_min, x_max, y_min, y_max,\n  671:                       alpha, NULL );\n  672          }\n  673          break;\n  ...\n  679                        nDim, nWLs, thresh, orient,\n  680                        x_min, x_max, y_min, y_max,\n  681:                       alpha, NULL );\n  682          }\n  683          break;\n  ...\n  689                        nDim, nWLs, thresh, orient,\n  690                        x_min, x_max, y_min, y_max,\n  691:                       alpha, beta );\n  692          }\n  693          break;\n  ...\n  699                        nDim, nWLs, thresh, orient,\n  700                        x_min, x_max, y_min, y_max,\n  701:                       alpha, beta );\n  702          }\n  703          break;\n  ...\n  709                        nDim, nWLs, thresh, orient,\n  710                        x_min, x_max, y_min, y_max,\n  711:                       alpha, beta );\n  712          }\n  713          break;\n  ...\n  719                        nDim, nWLs, thresh, orient,\n  720                        x_min, x_max, y_min, y_max,\n  721:                       alpha, beta );\n  722          }\n  723          break;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/freak.cpp:\n  208      patternLookup.resize(FREAK::NB_SCALES*FREAK_NB_ORIENTATION*FREAK_NB_POINTS);\n  209      double scaleStep = std::pow(2.0, (double)(nOctaves)/FREAK::NB_SCALES ); // 2 ^ ( (nOctaves-1) /nbScales)\n  210:     double scalingFactor, alpha, beta, theta = 0;\n  211  \n  212      // pattern definition, radius normalized to 1.0 (outer point position+sigma=1.0)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc.hpp:\n  209   @param niters The number of iterations\n  210  */\n  211: CV_EXPORTS_W void anisotropicDiffusion(InputArray src, OutputArray dst, float alpha, float K, int niters );\n  212  \n  213  //! @}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/paillou_filter.hpp:\n   59  * @sa GradientPaillouX, GradientPaillouY\n   60  */\n   61: CV_EXPORTS void GradientPaillouY(InputArray op, OutputArray _dst, double alpha, double omega);\n   62: CV_EXPORTS void GradientPaillouX(InputArray op, OutputArray _dst, double alpha, double omega);\n   63  \n   64  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/samples/filterdemo.cpp:\n   91  \n   92          float t = (float)getTickCount();\n   93:         ximgproc::anisotropicDiffusion(src, dst, alpha, sigma, niters);\n   94          t = (float)getTickCount() - t;\n   95          printf(\"time: %.1fms\\n\", t*1000./getTickFrequency());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/adaptive_manifold_filter_n.cpp:\n  409  \n  410              subtract(g, f, g);\n  411:             multiply(alpha, g, g);\n  412              add(g, f, g);\n  413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/anisodiff.cpp:\n  202  #ifdef HAVE_OPENCL\n  203  static bool ocl_anisotropicDiffusion(InputArray src_, OutputArray dst_,\n  204:                                      float alpha, int niters,\n  205                                       const std::vector<float>& exptab)\n  206  {\n  ...\n  240  #endif\n  241  \n  242: void anisotropicDiffusion(InputArray src_, OutputArray dst_, float alpha, float K, int niters )\n  243  {\n  244      if( niters == 0 )\n  ...\n  266  \n  267      CV_OCL_RUN(dst_.isUMat(),\n  268:                ocl_anisotropicDiffusion(src_, dst_, alpha, niters, exptab_));\n  269  \n  270      Mat src0 = src_.getMat();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/bilateral_texture_filter.cpp:\n   47  {\n   48    void compute_mRTV(const Mat& L, Mat& mRTV, int fr);\n   49:   void compute_G(const Mat& B, const Mat& mRTV, Mat& G, Mat& alpha, int fr);\n   50    void joint_bilateral_filter(const Mat& img, const Mat& G, Mat& r_img, int fr2, double sigma_avg);\n   51    void joint_bilateral_filter3(const Mat& img, const Mat& G, Mat& r_img, int fr2, double sigma_avg);\n   ..\n   90        Mat diff = mRTV - minmRTV;\n   91        Mat alpha = -diff.mul(sigmaAlpha);\n   92:       exp(alpha, alpha);\n   93        alpha = alpha + 1.;\n   94:       pow(alpha, -1, alpha);\n   95        alpha = (alpha - 0.5) * 2;\n   96        Mat alphainv = -(alpha - 1);\n   ..\n  212    }\n  213  \n  214:   void compute_G(const Mat& B, const Mat& mRTV, Mat& G, Mat& alpha, int fr)\n  215    {\n  216      B.copyTo(G);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/deriche_filter.cpp:\n   99  \n  100  template<typename T> static void\n  101: HorizontalIIRFilter(Mat &img, Mat &dst, const Range &r, double alpha, double omega)\n  102  {\n  103      float *f1;\n  ...\n  179          break;\n  180          case CV_8S:\n  181:             VerticalIIRFilter<char>(img, dst, range, alpha, omega);\n  182          break;\n  183          case CV_16U:\n  184:             VerticalIIRFilter<ushort>(img, dst, range, alpha, omega);\n  185              break;\n  186          case CV_16S:\n  187:             VerticalIIRFilter<short>(img, dst, range, alpha, omega);\n  188              break;\n  189          case CV_32F:\n  190:             VerticalIIRFilter<float>(img, dst, range, alpha, omega);\n  191              break;\n  192          default:\n  ...\n  396              break;\n  397          case CV_8S:\n  398:             HorizontalIIRFilter<char>(img, dst, range, alpha, omega);\n  399              break;\n  400          case CV_16U:\n  401:             HorizontalIIRFilter<ushort>(img, dst, range, alpha, omega);\n  402              break;\n  403          case CV_16S:\n  404:             HorizontalIIRFilter<short>(img, dst, range, alpha, omega);\n  405              break;\n  406          case CV_32F:\n  407:             HorizontalIIRFilter<float>(img, dst, range, alpha, omega);\n  408              break;\n  409          default:\n  ...\n  436  }\n  437  \n  438: void GradientDericheX(InputArray _op, OutputArray _dst, double alpha, double omega)\n  439  {\n  440      std::vector<Mat> planSrc;\n  ...\n  448          CV_Assert(planSrc[i].isContinuous() && planTmp[i].isContinuous() && planDst[i].isContinuous());\n  449  \n  450:         ParallelGradientDericheXRows x(planSrc[i], planTmp[i], alpha, omega);\n  451          parallel_for_(Range(0, planSrc[i].rows), x, getNumThreads());\n  452:         ParallelGradientDericheXCols xr(planTmp[i], planDst[i], alpha, omega);\n  453          parallel_for_(Range(0, planTmp[i].cols), xr, getNumThreads());\n  454      }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edgeaware_filters_common.cpp:\n  212  }\n  213  \n  214: void mad(float *dst, float *src1, float alpha, float beta, int w)\n  215  {\n  216      int j = 0;\n  ...\n  541              prev = _mm_loadu_ps(prevRow + j);\n  542  \n  543:             res = _mm_mul_ps(alpha, _mm_sub_ps(prev, cur));\n  544              res = _mm_add_ps(res, cur);\n  545              _mm_storeu_ps(curRow + j, res);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edgeaware_filters_common.hpp:\n   59  \n   60      //dst = alpha*src + beta\n   61:     void mad(float *dst, float *src1, float alpha, float beta, int w);\n   62  \n   63      void add_mul(float *dst, float *src1, float *src2, int w);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/fourier_descriptors.cpp:\n  139      long\t\t    n, nbElt = ctrSize;\n  140      double \t\t    s1, s2, sign1, sign2, df, x1 = nbElt, x2 = nbElt, dx;\n  141:     double\t\t    dist, distMin = 10000, alpha, s, phi;\n  142      std::complex<double> \tj(0, 1), zz;\n  143  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/guided_filter.cpp:\n  741              alpha[si][gi].create(h, w, CV_32FC1);\n  742      }\n  743:     runParBody(ComputeAlpha_ParBody(*this, alpha, covSrcGuide));\n  744      covSrcGuide.clear();\n  745  \n  746      vector<Mat>& beta = srcCnMean;\n  747:     runParBody(ComputeBeta_ParBody(*this, alpha, srcCnMean, beta));\n  748  \n  749      parMeanFilter(beta, beta);\n  750:     parMeanFilter(alpha, alpha);\n  751  \n  752:     runParBody(ApplyTransform_ParBody(*this, alpha, beta));\n  753      if (dDepth != CV_32F)\n  754      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/paillou_filter.cpp:\n  384  };\n  385  \n  386: void GradientPaillouY(InputArray _op, OutputArray _dst, double alpha, double omega)\n  387  {\n  388      std::vector<Mat> planSrc;\n  ...\n  403  }\n  404  \n  405: void GradientPaillouX(InputArray _op, OutputArray _dst, double alpha, double omega)\n  406  {\n  407      std::vector<Mat> planSrc;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_adaptive_manifold_ref_impl.cpp:\n  446              ensureSizeIsEnough(srcSize, buf_.diff);\n  447              subtract(buf_.tilde_dst, src_f_, buf_.diff);\n  448:             times(buf_.diff, buf_.alpha, buf_.diff);\n  449  \n  450              ensureSizeIsEnough(srcSize, buf_.dst);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_anisodiff.cpp:\n   20      float K = 0.02f;\n   21      int niters = 10;\n   22:     ximgproc::anisotropicDiffusion(original, result, alpha, K, niters);\n   23  \n   24      double adiff_psnr = cvtest::PSNR(original, result);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_guided_filter.cpp:\n   78      void computeCovGuideInv();\n   79  \n   80:     void applyTransform(int cNum, Mat *Ichannels, Mat *beta, Mat **alpha, int dDepth);\n   81  \n   82      void computeCovGuideAndSrc(int cNum, Mat **vars_I, Mat *Ichannels, Mat *exp_I);\n   ..\n   84      void computeBeta(int cNum, Mat *beta, Mat *exp_I, Mat **alpha);\n   85  \n   86:     void computeAlpha(int cNum, Mat **alpha, Mat **vars_I);\n   87  \n   88  public:\n   ..\n  208      CV_Assert(height == src.rows && width == src.cols);\n  209  \n  210:     Mat *Ichannels, *exp_I, **vars_I, **alpha, *beta;\n  211      Ichannels = new Mat[cNum];\n  212      exp_I     = new Mat[cNum];\n  ...\n  229      computeCovGuideAndSrc(cNum, vars_I, Ichannels, exp_I);\n  230  \n  231:     computeAlpha(cNum, alpha, vars_I);\n  232  \n  233      computeBeta(cNum, beta, exp_I, alpha);\n  ...\n  240                  meanFilter(beta[j], beta[j]);\n  241  \n  242:     applyTransform(cNum, Ichannels, beta, alpha, dDepth);\n  243      merge(Ichannels, cNum, dst);\n  244  \n  ...\n  256  }\n  257  \n  258: void GuidedFilterRefImpl::computeAlpha(int cNum, Mat **alpha, Mat **vars_I)\n  259  {\n  260      for (int i = 0; i < chNum; ++i)\n  ...\n  289  }\n  290  \n  291: void GuidedFilterRefImpl::applyTransform(int cNum, Mat *Ichannels, Mat *beta, Mat **alpha, int dDepth)\n  292  {\n  293      for (int i = 0; i < cNum; ++i)\n\n/home/roman/Projects/plot-cv/qjs-opencv/pngpp/test/pngsuite/pngsuite.doc:\n  109  When the PNG file contains a background chunck, this should be used for\n  110  pictures with alpha-channel or pictures with a transparency chunck. For\n  111: pictures without this background-chunk, but with alpha, this testset\n  112  assumes a black background.\n  113  \n  ...\n  368  ------------------------------------------\n  369  \n  370:         bgai4a08    -   8 bit grayscale, alpha, no background chunk, interlaced\n  371:         bgai4a16    -   16 bit grayscale, alpha, no background chunk, interlaced\n  372:         bgan6a08    -   3x8 bits rgb color, alpha, no background chunk\n  373:         bgan6a16    -   3x16 bits rgb color, alpha, no background chunk\n  374  \n  375:         bgbn4a08    -   8 bit grayscale, alpha, black background chunk\n  376:         bggn4a16    -   16 bit grayscale, alpha, gray background chunk\n  377:         bgwn6a08    -   3x8 bits rgb color, alpha, white background chunk\n  378:         bgyn6a16    -   3x16 bits rgb color, alpha, yellow background chunk\n  379  \n  380  \n\n/home/roman/Projects/plot-cv/quickjs/opencv-4.5.4-xenial.tar.gz:\n    File too large, skipping\n\n/home/roman/Projects/plot-cv/quickjs/qjscalc:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/deps/stb_image_write.h:\n  285  }\n  286  \n  287: static void stbiw__write_pixel(stbi__write_context *s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char *d)\n  288  {\n  289     unsigned char bg[3] = { 255, 0, 255}, px[3];\n  ...\n  320  }\n  321  \n  322: static void stbiw__write_pixels(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)\n  323  {\n  324     stbiw_uint32 zero = 0;\n  ...\n  336        for (i=0; i < x; ++i) {\n  337           unsigned char *d = (unsigned char *) data + (j*x+i)*comp;\n  338:          stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);\n  339        }\n  340        s->func(s->context, &zero, scanline_pad);\n  ...\n  342  }\n  343  \n  344: static int stbiw__outfile(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)\n  345  {\n  346     if (y < 0 || x < 0) {\n  ...\n  395  \n  396     if (!stbi_write_tga_with_rle) {\n  397:       return stbiw__outfile(s, -1, -1, x, y, comp, 0, (void *) data, has_alpha, 0,\n  398           \"111 221 2222 11\", 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);\n  399     } else {\n  ...\n  440                 s->func(s->context, &header, 1);\n  441                 for (k = 0; k < len; ++k) {\n  442:                   stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);\n  443                 }\n  444              } else {\n  445                 unsigned char header = STBIW_UCHAR(len - 129);\n  446                 s->func(s->context, &header, 1);\n  447:                stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);\n  448              }\n  449           }\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/docs/window.dox:\n 1387  If you are using version 3.0 or later of OpenGL or OpenGL ES, the\n 1388  `glGetFramebufferAttachmentParameteriv` function can be used to retrieve the\n 1389: number of bits for the red, green, blue, alpha, depth and stencil buffer\n 1390  channels.  Otherwise, the `glGetIntegerv` function can be used.\n 1391  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/examples/wave.c:\n  161      // Rotate the view\n  162      glRotatef(beta, 1.0, 0.0, 0.0);\n  163:     glRotatef(alpha, 0.0, 0.0, 1.0);\n  164  \n  165      glDrawElements(GL_QUADS, 4 * QUADNUM, GL_UNSIGNED_INT, quad);\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/src/win32_window.c:\n 1954  \n 1955      if (exStyle & WS_EX_LAYERED)\n 1956:         GetLayeredWindowAttributes(window->win32.handle, &key, &alpha, &flags);\n 1957  \n 1958      if (enabled)\n ....\n 1973  \n 1974      if (enabled)\n 1975:         SetLayeredWindowAttributes(window->win32.handle, key, alpha, flags);\n 1976  }\n 1977  \n ....\n 1982  \n 1983      if ((GetWindowLongW(window->win32.handle, GWL_EXSTYLE) & WS_EX_LAYERED) &&\n 1984:         GetLayeredWindowAttributes(window->win32.handle, NULL, &alpha, &flags))\n 1985      {\n 1986          if (flags & LWA_ALPHA)\n ....\n 1999          exStyle |= WS_EX_LAYERED;\n 2000          SetWindowLongW(window->win32.handle, GWL_EXSTYLE, exStyle);\n 2001:         SetLayeredWindowAttributes(window->win32.handle, 0, alpha, LWA_ALPHA);\n 2002      }\n 2003      else if (exStyle & WS_EX_TRANSPARENT)\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/quickjs-imgui.cpp:\n  800      case IMGUI_SET_NEXT_WINDOW_BG_ALPHA: {\n  801        double alpha;\n  802:       JS_ToFloat64(ctx, &alpha, argv[0]);\n  803        ImGui::SetNextWindowBgAlpha(alpha);\n  804        break;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/imgui.cpp:\n 6660  // BeginDisabled()/EndDisabled()\n 6661  // - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)\n 6662: // - Visually this is currently altering alpha, but it is expected that in a future styling system this would work differently.\n 6663  // - Feedback welcome at https://github.com/ocornut/imgui/issues/211\n 6664  // - BeginDisabled(false) essentially does nothing useful but is provided to facilitate use of boolean expressions. If you can avoid calling BeginDisabled(False)/EndDisabled() best to avoid it.\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/imgui_widgets.cpp:\n 5405      // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)\n 5406      float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;\n 5407:     draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, 12);\n 5408      draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, 12);\n 5409      draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, col_white, 12);\n ....\n 5415          ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);\n 5416          RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0, bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));\n 5417:         draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~IM_COL32_A_MASK, user_col32_striped_of_alpha & ~IM_COL32_A_MASK);\n 5418          float bar1_line_y = IM_ROUND(picker_pos.y + (1.0f - alpha) * sv_picker_size);\n 5419          RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/backends/imgui_impl_opengl3.cpp:\n  482      glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);\n  483      glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);\n  484:     glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);\n  485      if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);\n  486      if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/examples/example_win32_directx12/main.cpp:\n  197          // Render Dear ImGui graphics\n  198          const float clear_color_with_alpha[4] = { clear_color.x * clear_color.w, clear_color.y * clear_color.w, clear_color.z * clear_color.w, clear_color.w };\n  199:         g_pd3dCommandList->ClearRenderTargetView(g_mainRenderTargetDescriptor[backBufferIdx], clear_color_with_alpha, 0, NULL);\n  200          g_pd3dCommandList->OMSetRenderTargets(1, &g_mainRenderTargetDescriptor[backBufferIdx], FALSE, NULL);\n  201          g_pd3dCommandList->SetDescriptorHeaps(1, &g_pd3dSrvDescHeap);\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg-qjs.c:\n  354  FUNC(GlobalAlpha) {\n  355    float alpha;\n  356:   JS_ToFloat32(ctx, &alpha, argv[0]);\n  357    nvgGlobalAlpha(g_NVGcontext, alpha);\n  358    return JS_UNDEFINED;\n  ...\n  778    JS_ToFloat64(ctx, &angle, argv[4]);\n  779    JS_ToInt32(ctx, &image, argv[5]);\n  780:   JS_ToFloat64(ctx, &alpha, argv[6]);\n  781  \n  782    paint = nvgImagePattern(g_NVGcontext, ox, oy, ex, ey, angle, image, alpha);\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/example/stb_image_write.h:\n  107  }\n  108  \n  109: static void write_pixels(FILE *f, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad)\n  110  {\n  111     unsigned char bg[3] = { 255, 0, 255}, px[3];\n  ...\n  150  }\n  151  \n  152: static int outfile(char const *filename, int rgb_dir, int vdir, int x, int y, int comp, void *data, int alpha, int pad, const char *fmt, ...)\n  153  {\n  154     FILE *f;\n  ...\n  178  {\n  179     int has_alpha = !(comp & 1);\n  180:    return outfile(filename, -1,-1, x, y, comp, (void *) data, has_alpha, 0,\n  181:                   \"111 221 2222 11\", 0,0,2, 0,0,0, 0,0,x,y, 24+8*has_alpha, 8*has_alpha);\n  182  }\n  183  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_image.h:\n 1327  //    individual types do this automatically as much as possible (e.g. jpeg\n 1328  //    does all cases internally since it needs to colorspace convert anyway,\n 1329: //    and it never has alpha, so very few cases ). png can automatically\n 1330  //    interleave an alpha=255 channel, but falls back to this for other cases\n 1331  //\n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/curl/lib/curl_fnmatch.h:\n   37   * [a-zA-Z0-9] enumeration support\n   38   *\n   39:  * keywords: alnum, digit, xdigit, alpha, print, blank, lower, graph, space\n   40   *           and upper (use as \"[[:alnum:]]\")\n   41   */\n\n/home/roman/Projects/plot-cv/src/plot-cv.cpp:\n  201  \n  202    int histSize = 256;\n  203:   float alpha, beta;\n  204    double minGray = 0, maxGray = 0;\n  205  \n  ...\n  250    // Apply brightness and contrast normalization\n  251    // convertTo operates with saurate_cast\n  252:   src.convertTo(dst, -1, alpha, beta);\n  253  \n  254    // restore alpha channel from source\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 1743  //    individual types do this automatically as much as possible (e.g. jpeg\n 1744  //    does all cases internally since it needs to colorspace convert anyway,\n 1745: //    and it never has alpha, so very few cases ). png can automatically\n 1746  //    interleave an alpha=255 channel, but falls back to this for other cases\n 1747  //\n ....\n 5141  #undef STBI__CASE\n 5142  \n 5143:       // the loop above sets the high byte of the pixels' alpha, but for\n 5144        // 16 bit png files we also need the low byte set. we'll do that here.\n 5145        if(depth == 16) {\n\n/home/roman/Projects/plot-cv/uftrace.data/3720907.dat:\n    File too large, skipping\n\n1011 matches across 237 files\n\n\nSearching 19285 files for \"1\\.0 -\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/127.0.0.1.har:\n 12438              \"size\": 11111,\n 12439              \"mimeType\": \"application/javascript\",\n 12440:             \"text\": \"import Util from '../util.js';\\n\\nconst SymSpecies = Util.tryCatch(\\n  () => Symbol,\\n  sym => sym.species\\n);\\n\\nconst CTOR = obj => {\\n  if(obj[SymSpecies]) return obj[SymSpecies];\\n  let p = Object.getPrototypeOf(obj);\\n  if(p[SymSpecies]) return p[SymSpecies];\\n  return p.constructor;\\n};\\n\\nexport function Point(...args) {\\n  let isNew = this instanceof Point;\\n  args = args[0] instanceof Array ? args.shift() : args;\\n  let p = isNew ? this : new Point(...args);\\n  let arg = args.shift();\\n\\n  if(!new.target) if (arg instanceof Point) return arg;\\n\\n  if(typeof arg === 'undefined') {\\n    p.x = arg;\\n    p.y = args.shift();\\n  } else if(typeof arg === 'number') {\\n    p.x = parseFloat(arg);\\n    p.y = parseFloat(args.shift());\\n  } else if(typeof arg === 'string') {\\n    const matches = [...arg.matchAll(/([-+]?d*.?d+)(?:[eE]([-+]?d+))?/g)];\\n\\n    p.x = parseFloat(matches[0]);\\n    p.y = parseFloat(matches[1]);\\n  } else if(typeof arg == 'object' && arg !== null && (arg.x !== undefined || arg.y !== undefined)) {\\n    p.x = arg.x;\\n    p.y = arg.y;\\n  } else if(typeof arg == 'object' && arg !== null && arg.length > 0 && x !== undefined && y !== undefined) {\\n    p.x = parseFloat(arg.shift());\\n    p.y = parseFloat(arg.shift());\\n  } else if(typeof args[0] === 'number' && typeof args[1] === 'number') {\\n    p.x = args[0];\\n    p.y = args[1];\\n    args.shift(2);\\n  } else {\\n    p.x = 0;\\n    p.y = 0;\\n  }\\n  if(p.x === undefined) p.x = 0;\\n  if(p.y === undefined) p.y = 0;\\n  if(isNaN(p.x)) p.x = undefined;\\n  if(isNaN(p.y)) p.y = undefined;\\n\\n  if(!isNew) {\\n    /* if(p.prototype == Object) p.prototype = Point.prototype;\\n    else Object.assign(p, Point.prototype);*/\\n    return p;\\n  }\\n}\\nconst getOther = args => (console.debug('getOther', ...args), typeof args[0] == 'number' ? [{ x: args[0], y: args[1] }] : args);\\n\\nObject.defineProperties(Point.prototype, {\\n  X: {\\n    get() {\\n      return this.x;\\n    }\\n  },\\n  Y: {\\n    get() {\\n      return this.y;\\n    }\\n  }\\n});\\n\\nPoint.prototype.move = function(x, y) {\\n  this.x += x;\\n  this.y += y;\\n  return this;\\n};\\nPoint.prototype.moveTo = function(x, y) {\\n  this.x = x;\\n  this.y = y;\\n  return this;\\n};\\nPoint.prototype.clear = function(x, y) {\\n  this.x = 0;\\n  this.y = 0;\\n  return this;\\n};\\nPoint.prototype.set = function(fn) {\\n  if(typeof fn != 'function') {\\n    Point.apply(this, [...arguments]);\\n    return this;\\n  }\\n  return fn(this.x, this.y);\\n};\\nPoint.prototype.clone = function() {\\n  const ctor = this[Symbol.species] || this.constructor[Symbol.species];\\n\\n  return new ctor({ x: this.x, y: this.y });\\n};\\nPoint.prototype.sum = function(...args) {\\n  const p = new Point(...args);\\n  let r = new Point(this.x, this.y);\\n  r.x += p.x;\\n  r.y += p.y;\\n  return r;\\n};\\nPoint.prototype.add = function(...args) {\\n  const other = new Point(...args);\\n  this.x += other.x;\\n  this.y += other.y;\\n  return this;\\n};\\nPoint.prototype.diff = function(arg) {\\n  let { x, y } = this;\\n  let fn = function(other) {\\n    let r = new Point(x, y);\\n    return r.sub(other);\\n  };\\n  if(arg) return fn(arg);\\n  return fn;\\n};\\nPoint.prototype.sub = function(...args) {\\n  const other = new Point(...args);\\n  this.x -= other.x;\\n  this.y -= other.y;\\n  return this;\\n};\\nPoint.prototype.prod = function(f) {\\n  const o = isPoint(f) ? f : { x: f, y: f };\\n  return new Point(this.x * o.x, this.y * o.y);\\n};\\nPoint.prototype.mul = function(f) {\\n  const o = isPoint(f) ? f : { x: f, y: f };\\n  this.x *= o.x;\\n  this.y *= o.y;\\n  return this;\\n};\\nPoint.prototype.quot = function(other) {\\n  other = isPoint(other) ? other : { x: other, y: other };\\n  return new Point(this.x / other.x, this.y / other.y);\\n};\\nPoint.prototype.div = function(other) {\\n  other = isPoint(other) ? other : { x: other, y: other };\\n  this.x /= other.x;\\n  this.y /= other.y;\\n  return this;\\n};\\nPoint.prototype.comp = function() {\\n  return new Point({ x: -this.x, y: -this.y });\\n};\\nPoint.prototype.neg = function() {\\n  this.x *= -1;\\n  this.y *= -1;\\n  return this;\\n};\\nPoint.prototype.distanceSquared = function(other = { x: 0, y: 0 }) {\\n  return (other.y - this.y) * (other.y - this.y) + (other.x - this.x) * (other.x - this.x);\\n};\\nPoint.prototype.distance = function(other = { x: 0, y: 0 }) {\\n  return Math.sqrt(Point.prototype.distanceSquared.call(this, Point(other)));\\n};\\nPoint.prototype.equals = function(other) {\\n  let { x, y } = this;\\n  return +x == +other.x && +y == +other.y;\\n};\\nPoint.prototype.round = function(precision = 0.001, digits, type) {\\n  let { x, y } = this;\\n  digits = digits || Util.roundDigits(precision);\\n  type = type || 'round';\\n  this.x = Util.roundTo(x, precision, digits, type);\\n  this.y = Util.roundTo(y, precision, digits, type);\\n  return this;\\n};\\nPoint.prototype.ceil = function() {\\n  let { x, y } = this;\\n  this.x = Math.ceil(x);\\n  this.y = Math.ceil(y);\\n  return this;\\n};\\nPoint.prototype.floor = function() {\\n  let { x, y } = this;\\n  this.x = Math.floor(x);\\n  this.y = Math.floor(y);\\n  return this;\\n};\\n\\nPoint.prototype.dot = function(other) {\\n  return this.x * other.x + this.y * other.y;\\n};\\n\\nPoint.prototype.values = function() {\\n  return [this.x, this.y];\\n};\\nPoint.prototype.fromAngle = function(angle, dist = 1.0) {\\n  this.x = Math.cos(angle) * dist;\\n  this.y = Math.sin(angle) * dist;\\n  return this;\\n};\\nPoint.prototype.toAngle = function(deg = false) {\\n  return Math.atan2(this.x, this.y) * (deg ? 180 / Math.PI : 1);\\n};\\nPoint.prototype.angle = function(other, deg = false) {\\n  other = other || { x: 0, y: 0 };\\n  return Point.prototype.diff.call(this, other).toAngle(deg);\\n};\\nPoint.prototype.rotate = function(angle, origin = { x: 0, y: 0 }) {\\n  this.x -= origin.x;\\n  this.y -= origin.y;\\n  let c = Math.cos(angle),\\n    s = Math.sin(angle);\\n  let xnew = this.x * c - this.y * s;\\n  let ynew = this.x * s + this.y * c;\\n  this.x = xnew;\\n  this.y = ynew;\\n  return this;\\n};\\nUtil.defineGetter(Point.prototype, Symbol.iterator, function() {\\n  const { x, y } = this;\\n  let a = [x, y];\\n  return a[Symbol.iterator].bind(a);\\n});\\n\\n/*Point.prototype.valueOf = function(shl = 16) {\\n  const { x, y } = this;\\n  return x | (y << shl);\\n};\\n*/ Point.prototype.toString = function(opts = {}) {\\n  const { precision = 0.001, unit = '', separator = ',', left = '', right = '', pad = 0 } = opts;\\n  let x = Util.roundTo(this.x, precision);\\n  let y = Util.roundTo(this.y, precision);\\n  if(pad > 0) {\\n    x = x + '';\\n    y = y + '';\\n    if(y[0] != '-') y = ' ' + y;\\n    if(x[0] != '-') x = ' ' + x;\\n  }\\n  //console.debug(\\\"toString\\\", {x,y}, {pad});\\n  return `${left}${(x + '').padStart(pad, ' ')}${unit}${separator}${(y + '').padEnd(pad, ' ')}${unit}${right}`;\\n};\\nPoint.prototype[Symbol.toStringTag] = 'Point';\\nPoint.prototype.toSource = function(opts = {}) {\\n  const { asArray = false, plainObj = false, pad = a => a /*a.padStart(4, ' ')*/, showNew = true } = opts;\\n  let x = pad(this.x + '');\\n  let y = pad(this.y + '');\\n  let c = t => t;\\n  if(typeof this != 'object' || this === null) return '';\\n  if(asArray) return `[${x},${y}]`;\\n  if(plainObj) return `{x:${x},y:${y}}`;\\n\\n  return `${c(showNew ? 'new ' : '', 1, 31)}${c('Point', 1, 33)}${c('(', 1, 36)}${c(x, 1, 32)}${c(',', 1, 36)}${c(y, 1, 32)}${c(')', 1, 36)}`;\\n};\\n\\n/*Point.prototype.toSource = function() {\\n  return '{x:' + this.x + ',y:' + this.y + '}';\\n};*/\\nPoint.prototype.toObject = function(proto = Point.prototype) {\\n  const { x, y } = this;\\n  const obj = { x, y };\\n  Object.setPrototypeOf(obj, proto);\\n  return obj;\\n};\\nPoint.prototype.toCSS = function(precision = 0.001, edges = ['left', 'top']) {\\n  return {\\n    [edges[0]]: Util.roundTo(this.x, precision) + 'px',\\n    [edges[1]]: Util.roundTo(this.y, precision) + 'px'\\n  };\\n};\\nPoint.prototype.toFixed = function(digits) {\\n  return new Point(+this.x.toFixed(digits), +this.y.toFixed(digits));\\n};\\nPoint.prototype.isNull = function() {\\n  return this.x == 0 && this.y == 0;\\n};\\nPoint.prototype.inside = function(rect) {\\n  return this.x >= rect.x && this.x < rect.x + rect.width && this.y >= rect.y && this.y < rect.y + rect.height;\\n};\\nPoint.prototype.transform = function(m, round = true) {\\n  if(Util.isObject(m) && typeof m.toMatrix == 'function') m = m.toMatrix();\\n  //if(Util.isObject(m) && typeof m.transform_point == 'function') return m.transform_point(this);\\n\\n  const x = m[0] * this.x + m[1] * this.y + m[2];\\n  const y = m[3] * this.x + m[4] * this.y + m[5];\\n\\n  this.x = x;\\n  this.y = y;\\n  if(round) Point.prototype.round.call(this, 1e-13, 13);\\n\\n  return this;\\n};\\nPoint.prototype.scaleTo = function(minmax) {\\n  return new Point({\\n    x: (this.x - minmax.x1) / (minmax.x2 - minmax.x1),\\n    y: (this.y - minmax.y1) / (minmax.y2 - minmax.y1)\\n  });\\n};\\nPoint.prototype.normalize = function() {\\n  let d = Point.prototype.distance.call(this);\\n  return Point.prototype.div.call(this, { x: d, y: d });\\n};\\nPoint.prototype.normal = function() {\\n  let d = Point.prototype.distance.call(this);\\n  return new Point({ x: this.x / d, y: this.y / d });\\n};\\n\\nPoint.fromString = str => new Point(...str.split(/[^-.0-9]+/g).map(n => +n));\\nPoint.move = (point, x, y) => Point.prototype.move.call(point, x, y);\\nPoint.angle = (point, other, deg = false) => Point.prototype.angle.call(point, other, deg);\\nPoint.inside = (point, rect) => Point.prototype.inside.call(point, rect);\\nPoint.sub = (point, other) => Point.prototype.sub.call(point, other);\\nPoint.prod = (a, b) => Point.prototype.prod.call(a, b);\\nPoint.quot = (a, b) => Point.prototype.quot.call(a, b);\\nPoint.equals = (a, b) => Point.prototype.equals.call(a, b);\\nPoint.round = (point, prec, digits, type) => Point.prototype.round.call(point, prec, digits, type);\\nPoint.fromAngle = (angle, f) => new Point().fromAngle(angle, f);\\n\\nfor(let name of [\\n  'clone',\\n  'comp',\\n  'neg',\\n  'sides',\\n  'dimension',\\n  'toString',\\n  //'toSource',\\n  'toCSS',\\n  'sub',\\n  'diff',\\n  'add',\\n  'sum',\\n  'distance'\\n]) {\\n  Point[name] = (point, ...args) => Point.prototype[name].call(Point(point), ...args);\\n}\\nPoint.interpolate = (p1, p2, a) => {\\n  a = Util.clamp(0, 1, a);\\n  return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\\n};\\n\\nPoint.toSource = (point, { space = ' ', padding = ' ', separator = ',' }) => `{${padding}x:${space}${point.x}${separator}y:${space}${point.y}${padding}}`;\\n\\nexport const isPoint = o => o && ((o.x !== undefined && o.y !== undefined) || ((o.left !== undefined || o.right !== undefined) && (o.top !== undefined || o.bottom !== undefined)) || o instanceof Point || Object.getPrototypeOf(o).constructor === Point);\\n\\nPoint.isPoint = isPoint;\\n\\nPoint.prototype[Util.inspectSymbol] = function(depth, options) {\\n  const { x, y } = this;\\n  return /*Object.setPrototypeOf*/ { x, y } /*, Point.prototype*/;\\n};\\n\\nPoint.bind = (...args) => {\\n  const keys = ['x', 'y'];\\n  let [o, p] = args;\\n  if(p == null) p = keys;\\n  const { x, y } = (Util.isArray(p) && p.reduce((acc, name, i) => ({ ...acc, [keys[i]]: name }), {})) || p;\\n  //console.debug('Point.bind', { keys, o, p, x, y });\\n  return Object.setPrototypeOf(Util.bindProperties({}, o, { x, y }), Point.prototype);\\n};\\nexport default Point;\\n\\nUtil.defineGetter(Point, Symbol.species, function() {\\n  return this;\\n});\\n\\nexport const ImmutablePoint = Util.immutableClass(Point);\\nUtil.defineGetter(ImmutablePoint, Symbol.species, () => ImmutablePoint);\\n\"\n 12441            },\n 12442            \"redirectURL\": \"\",\n .....\n 13268              \"size\": 4109,\n 13269              \"mimeType\": \"application/javascript\",\n 13270:             \"text\": \"import { Point, isPoint } from './point.js';\\nimport { Rect } from './rect.js';\\nimport { Line, isLine } from './line.js';\\nimport { PointList } from './pointList.js';\\nimport { SVG } from '../dom/svg.js';\\nimport Util from '../util.js';\\n\\nlet createFactory = Util.memoize((...args) => SVG.factory(...args));\\n\\nexport class Polyline extends PointList {\\n  constructor(lines = []) {\\n    super(typeof lines == 'string' ? lines : undefined);\\n\\n    if(this.length > 0) return this;\\n\\n    /*if(typeof(lines) == 'string'){\\n       lines = [...lines.matchAll(/(-?[.0-9]+)[^-0-9.](-?[.0-9]+)/g)].map(m => m[0]);\\n    }*/\\n\\n    const addUnique = point => {\\n      if(typeof point == 'string') point = new Point(point);\\n\\n      const ok = this.length > 0 ? !Point.equals(this[this.length - 1], point) : true;\\n      if(ok) Array.prototype.push.call(this, Point.clone(point));\\n      return ok;\\n    };\\n\\n    let prev;\\n    for(let i = 0; i < lines.length; i++) {\\n      const line = lines[i];\\n      //console.log(`Polyline lines[${i}] =`, line);\\n      if(isLine(line)) {\\n        if(i > 0) {\\n          const eq = [Point.equals(prev, line.a)];\\n          if(!eq[0] && !Point.equals(prev, line.b)) break;\\n        } else {\\n          addUnique(line.a);\\n        }\\n        addUnique(line.b);\\n        prev = line.b;\\n      } /* if(isPoint(line))*/ else {\\n        addUnique(line);\\n        prev = line;\\n      }\\n    }\\n  }\\n\\n  toSVG(factory, attrs = { stroke: '#000', fill: 'none' }, parent = null, prec) {\\n    if(!factory) factory = createFactory(document.body);\\n    console.log('Polyline.toSVG', factory);\\n\\n    return factory(this.closed ? 'polygon' : 'polyline', { points: PointList.prototype.toString.call(this), ...attrs }, parent, prec);\\n  }\\n\\n  push(...args) {\\n    const last = this[this.length - 1];\\n    for(let arg of args) {\\n      if(last && Point.equals(arg, last)) continue;\\n      PointList.prototype.push.call(this, arg);\\n    }\\n    return this;\\n  }\\n\\n  inside(point) {\\n    let i,\\n      j,\\n      c = false,\\n      nvert = this.length;\\n    for(i = 0, j = nvert - 1; i < nvert; j = i++) {\\n      if(this[i].y > point.y !== this[j].y > point.y && point.x < ((this[j].x - this[i].x) * (point.y - this[i].y)) / (this[j].y - this[i].y) + this[i].x) {\\n        c = !c;\\n      }\\n    }\\n    return c;\\n  }\\n\\n  static inside(a, b) {\\n    return a.every(point => b.inside(point));\\n  }\\n\\n  isClockwise() {\\n    let sum = 0;\\n    for(let i = 0; i < this.length - 1; i++) {\\n      let cur = this[i],\\n        next = this[i + 1];\\n      sum += (next.x - cur.x) * (next.y + cur.y);\\n    }\\n    return sum > 0;\\n  }\\n\\n  get clockwise() {\\n    let ret = new (this[Symbol.species] || this.constructor)().concat(this);\\n    return Polyline.prototype.isClockwise.call(this) ? ret : ret.reverse();\\n  }\\n\\n  get counterClockwise() {\\n    let ret = new (this[Symbol.species] || this.constructor)().concat(this);\\n    return Polyline.prototype.isClockwise.call(this) ? ret.reverse() : ret;\\n  }\\n\\n  static isClockwise(poly) {\\n    let sum = 0;\\n    for(let i = 0; i < poly.length - 1; i++) {\\n      let cur = poly[i],\\n        next = poly[i + 1];\\n      sum += (next.x - cur.x) * (next.y + cur.y);\\n    }\\n    return sum > 0;\\n  }\\n\\n  isClosed() {\\n    let first = this[0];\\n    let last = this[this.length - 1];\\n\\n    return Point.equals(first, last);\\n  }\\n\\n  get closed() {\\n    return this.isClosed();\\n  }\\n\\n  close() {\\n    if(!this.closed) this.push(this[0]);\\n    return this;\\n  }\\n\\n  get [Symbol.species]() {\\n    return Polyline;\\n  }\\n\\n  pointAt(pos) {\\n    const { totalLength } = this;\\n    return this.atIndex((pos * (this.length - 1)) / totalLength);\\n  }\\n\\n  atIndex(i) {\\n    i = Math.min(this.length - 1, i < 0 ? this.length + i : i);\\n    let fract = i - Math.floor(i);\\n    i = Math.floor(i);\\n    let ret = new Point(this[i]);\\n    if(fract > 0) {\\n      let next = this[i + 1];\\n      ret.x = ret.x * (1.0 - fract) + next.x * fract;\\n      ret.y = ret.y * (1.0 - fract) + next.y * fract;\\n    }\\n    return ret;\\n  }\\n\\n  getTotalLength() {\\n    return this.slice(1).reduce((a, p, i) => a + Point.distance(this[i], p), 0);\\n  }\\n  get totalLength() {\\n    return this.getTotalLength();\\n  }\\n}\\n\\nexport default Polyline;\\n\"\n 13271            },\n 13272            \"redirectURL\": \"\",\n .....\n 18082              \"size\": 22395,\n 18083              \"mimeType\": \"application/javascript\",\n 18084:             \"text\": \"import { HSLA, ImmutableHSLA } from './hsla.js';\\nimport Util from '../util.js';\\n\\n/**\\n * @brief [brief description]\\n * @param r  red value 0-255\\n * @param g  green value 0-255\\n * @param b  blue value 0-255\\n * @param a  alpha value 0-1\\n *\\n * @return [description]\\n */\\nexport function RGBA(...args) {\\n  let ret = this instanceof RGBA ? this : {};\\n  let c = [];\\n\\n  if(args.length == 1 && Util.isArray(args[0]) && args[0].length >= 3) args = args[0];\\n  //console.log('RGBA(', args, ')');\\n\\n  if(args.length >= 3) {\\n    const [r = 0, g = 0, b = 0, a = 255] = args;\\n    ret.r = r;\\n    ret.g = g;\\n    ret.b = b;\\n    if(!isNaN(+a) /* && +a !== 255*/) ret.a = a;\\n  } else if(args.length <= 2) {\\n    const arg = args[0];\\n    if(typeof arg === 'number') {\\n      Object.assign(ret, RGBA.decode[args[1] !== undefined ? args[1] : RGBA.order.ABGR](arg));\\n    } else if(typeof arg === 'string') {\\n      if(arg.startsWith('#')) {\\n        c = arg.length >= 7 ? /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?$/i.exec(arg) : /^#?([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])?$/i.exec(arg);\\n\\n        let mul = arg.length >= 7 ? 1 : 17;\\n\\n        //console.log('RGBA match:', c, ' mul:', mul);\\n\\n        ret.r = parseInt(c[1], 16) * mul;\\n        ret.g = parseInt(c[2], 16) * mul;\\n        ret.b = parseInt(c[3], 16) * mul;\\n        if(c.length > 3) {\\n          let a = parseInt(c[4], 16) * mul;\\n          /*if(a !== 255)*/ ret.a = a;\\n        }\\n      } else if(arg.toLowerCase().startsWith('rgb')) {\\n        c = arg.match(/[\\\\d.%]+/g).map(x => (x.endsWith('%') ? parseFloat(x.slice(0, -1)) * 2.55 : +x));\\n\\n        c = [...c].slice();\\n\\n        ret.r = Math.round(c[0]);\\n        ret.g = Math.round(c[1]);\\n        ret.b = Math.round(c[2]);\\n        if(c.length > 3) ret.a = Math.round(c[3] * 255);\\n      }\\n    } else if(typeof arg === 'object' && arg.r !== undefined) {\\n      ret.r = arg.r;\\n      ret.g = arg.g;\\n      ret.b = arg.b;\\n      if(arg.a !== undefined) ret.a = arg.a;\\n    } else {\\n      ret.r = 0;\\n      ret.g = 0;\\n      ret.b = 0;\\n      ret.a = 0;\\n    }\\n  }\\n\\n  if(ret.a !== undefined && isNaN(+ret.a)) ret.a = 255;\\n  if(isNaN(ret.a)) ret.a = 255;\\n\\n  //console.log('RGBA ', ret);\\n  if(!(ret instanceof RGBA)) return ret; //Object.setPrototypeOf(ret, RGBA.prototype);\\n}\\n\\nRGBA.properties = ['r', 'g', 'b', 'a'];\\nexport const isRGBA = obj => RGBA.properties.every(prop => obj.hasOwnProperty(prop));\\n\\nRGBA.fromString = str => {\\n  let c = Util.tryCatch(\\n    () => new HSLA(str),\\n    c => c.toRGBA(),\\n    () => undefined\\n  );\\n  if(!c)\\n    c = Util.tryCatch(\\n      () => new RGBA(str),\\n      c => c,\\n      () => undefined\\n    );\\n  return c;\\n};\\nRGBA.order = {\\n  RGBA: 0,\\n  BGRA: 1,\\n  ARGB: 2,\\n  ABGR: 3\\n};\\n\\nRGBA.decode = [\\n  /*RGBA:*/ n => ({\\n    r: (n >> 24) & 0xff,\\n    g: (n >> 16) & 0xff,\\n    b: (n >> 8) & 0xff,\\n    a: n & 0xff\\n  }),\\n  /*BGRA:*/ n => ({\\n    b: (n >> 24) & 0xff,\\n    g: (n >> 16) & 0xff,\\n    r: (n >> 8) & 0xff,\\n    a: n & 0xff\\n  }),\\n  /*ARGB:*/ n => ({\\n    a: (n >> 24) & 0xff,\\n    r: (n >> 16) & 0xff,\\n    g: (n >> 8) & 0xff,\\n    b: n & 0xff\\n  }),\\n  /*ABGR:*/ n => ({\\n    a: (n >> 24) & 0xff,\\n    b: (n >> 16) & 0xff,\\n    g: (n >> 8) & 0xff,\\n    r: n & 0xff\\n  })\\n];\\nRGBA.encode = [\\n  /*RGBA:*/ ({ r, g, b, a }) => [r, g, b, a].map(n => ('00' + (n & 0xff).toString(16)).slice(-2)).join(''),\\n  /*BGRA:*/ ({ r, g, b, a }) => [b, g, r, a].map(n => ('00' + (n & 0xff).toString(16)).slice(-2)).join(''),\\n  /*ARGB:*/ ({ r, g, b, a }) => [a, r, g, b].map(n => ('00' + (n & 0xff).toString(16)).slice(-2)).join(''),\\n  /*ABGR:*/ ({ r, g, b, a }) => [a, b, g, r].map(n => ('00' + (n & 0xff).toString(16)).slice(-2)).join('')\\n];\\nRGBA.fmt = [({ r, g, b, a }) => [r, g, b, a], ({ b, g, r, a }) => [b, g, r, a], ({ a, r, g, b }) => [a, r, g, b], ({ a, b, g, r }) => [a, b, g, r]];\\n\\nRGBA.calculators = [({ r, g, b, a }) => ((r * 256 + g) * 256 + b) * 256 + a, ({ b, g, r, a }) => ((b * 256 + g) * 256 + r) * 256 + a, ({ a, r, g, b }) => ((a * 256 + r) * 256 + g) * 256 + b, ({ a, b, g, r }) => ((a * 256 + b) * 256 + g) * 256 + r];\\n\\nRGBA.prototype.clone = function() {\\n  const ctor = this.constructor[Symbol.species];\\n  const { r, g, b, a } = this;\\n  return new ctor(r, g, b, a);\\n};\\nRGBA.prototype.binaryValue = function(order = 0) {\\n  const { r, g, b, a } = this;\\n  return RGBA.calculators[order](RGBA.clamp(this));\\n};\\nRGBA.prototype.valid = function() {\\n  const { r, g, b, a } = this;\\n  return [r, g, b, a].every(n => {\\n    n = +n;\\n    return !isNaN(n) && n >= 0 && n <= 255;\\n  });\\n};\\n\\nRGBA.prototype.compareTo = function(other) {\\n  let d = RGBA.prototype.binaryValue.call(other) - RGBA.prototype.binaryValue.call(this);\\n  return d < 0 ? -1 : d > 0 ? 1 : 0;\\n};\\nRGBA.fromHex = (hex, alpha = 255) => {\\n  if(hex[0] != '#') hex = ('ffffffff' + hex).slice(-8);\\n\\n  const matches = hex && (hex.length >= 7 ? /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?$/i.exec(hex) : /^#?([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])?$/i.exec(hex));\\n  if(matches === null) return null;\\n  let mul = hex.length >= 7 ? 1 : 17;\\n\\n  const [r, g, b, a] = [...matches].slice(1).map(x => parseInt(x, 16) * mul);\\n  //console.log('RGBA.fromHex', { hex, matches, r, g, b, a });\\n  return new RGBA(r, g, b, matches.length > 3 && !isNaN(a) ? a : alpha);\\n};\\n\\nRGBA.prototype.hex = function(opts = {}) {\\n  const { bits, prefix = '#', order = RGBA.order.RGBA } = opts;\\n  const { r, g, b, a } = RGBA.clamp(RGBA.round(this));\\n  const n = RGBA.encode[order]({ r, g, b, a });\\n  return prefix + ('0000000000' + n.toString(16)).slice(-8).slice(0, a === 255 || a === undefined ? 6 : 8);\\n};\\n\\n/*RGBA.prototype.valueOf = function() {\\n  const hex = RGBA.prototype.hex.call(this);\\n  return parseInt('0x' + hex.slice(1));\\n};*/\\n\\nRGBA.prototype.toRGB = function() {\\n  const { r, g, b } = this;\\n  return new RGBA(r, g, b, 255);\\n};\\n\\nRGBA.toHex = rgba => RGBA.prototype.hex.call(rgba);\\n\\nRGBA.clamp = rgba => RGBA(Math.min(Math.max(rgba.r, 0), 255), Math.min(Math.max(rgba.g, 0), 255), Math.min(Math.max(rgba.b, 0), 255), Math.min(Math.max(rgba.a, 0), 255));\\nRGBA.round = rgba => RGBA.prototype.round.call(rgba);\\n\\nRGBA.prototype.round = function() {\\n  const { r, g, b, a } = this;\\n  let x = [r, g, b, a].map(n => Math.round(n));\\n  if(Object.isFrozen(this)) return new RGBA(...x);\\n  this.r = x[0];\\n  this.g = x[1];\\n  this.b = x[2];\\n  this.a = x[3];\\n  return this;\\n};\\nRGBA.prototype.setOpacity = function(a) {\\n  this.a = Util.clamp(0, 255, a * 255);\\n  return this;\\n};\\nRGBA.normalize = function(rgba, src = 255, dst = 1.0) {\\n  return {\\n    r: (rgba.r * dst) / src,\\n    g: (rgba.g * dst) / src,\\n    b: (rgba.b * dst) / src,\\n    a: (rgba.a * dst) / src\\n  };\\n};\\nRGBA.prototype.css = () => prop => (prop ? prop + ':' : '') + 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + (this.a / 255).toFixed(3) + ')';\\n\\nRGBA.prototype.toCSS = function(fmt = num => +num.toFixed(3)) {\\n  const { r, g, b, a } = this;\\n  const sep = ',';\\n  if(a === undefined || a == 255) return 'rgb(' + fmt(r) + sep + fmt(g) + sep + fmt(b) + ')';\\n  return 'rgba(' + fmt(r) + sep + fmt(g) + sep + fmt(b) + sep + (a * 100) / 255 + '%)';\\n};\\nRGBA.prototype.toString = function(opts) {\\n  return RGBA.prototype.hex.call(this, opts);\\n};\\nUtil.defineGetter(RGBA.prototype, Symbol.toStringTag, function() {\\n  const { r, g, b, a } = this;\\n  return `[object RGBA ${r},${g},${b},${a}]`;\\n});\\nRGBA.prototype[Symbol.toPrimitive] = function(hint) {\\n  //console.log(\\\"RGBA.toPrimitive\\\", {hint});\\n  if(hint == 'number') return +RGBA.prototype.hex.call(this, { prefix: '0x' });\\n  if(hint == 'string') return RGBA.prototype.toString.call(this);\\n  if(hint == 'default') return RGBA.prototype.hex.call(this, { prefix: '#' });\\n};\\nfunction toHex(n) {\\n  return '0x' + ('00' + (+n).toString(16)).slice(-2);\\n}\\nRGBA.prototype.toSource = function(sep = ',') {\\n  let a = this.a;\\n  if(a === undefined) return 'new RGBA(' + this.r + sep + this.g + sep + this.b + ')';\\n  let s = 'new RGBA(' + toHex(this.r) + sep + toHex(this.g) + sep + toHex(this.b);\\n\\n  if(a != 255) s += sep + toHex(a);\\n\\n  s += ')';\\n  return s;\\n};\\n\\nRGBA.prototype.normalize = function(src = 255, dst = 1.0) {\\n  return new RGBA((this.r * dst) / src, (this.g * dst) / src, (this.b * dst) / src, (this.a * dst) / src);\\n};\\n\\nRGBA.blend = (a, b, o = 0.5) => {\\n  a = new RGBA(a);\\n  b = new RGBA(b);\\n  return new RGBA(Math.round(a.r * (1 - o) + b.r * o), Math.round(a.g * (1 - o) + b.g * o), Math.round(a.b * (1 - o) + b.b * o), Math.round(a.a * (1 - o) + b.a * o));\\n};\\n\\nRGBA.prototype.toAlpha = Util.curry(function (other) {\\n  let color = RGBA.normalize(this);\\n  let src = new RGBA(other).normalize();\\n  let alpha = {};\\n\\n  alpha.a = src.a;\\n  if(color.r < 0.0001) alpha.r = src.r;\\n  else if(src.r > color.r) alpha.r = (src.r - color.r) / (1.0 - color.r);\\n  else if(src.r < color.r) alpha.r = (color.r - src.r) / color.r;\\n  else alpha.r = 0.0;\\n  if(color.g < 0.0001) alpha.g = src.g;\\n  else if(src.g > color.g) alpha.g = (src.g - color.g) / (1.0 - color.g);\\n  else if(src.g < color.g) alpha.g = (color.g - src.g) / color.g;\\n  else alpha.g = 0.0;\\n  if(color.b < 0.0001) alpha.b = src.b;\\n  else if(src.b > color.b) alpha.b = (src.b - color.b) / (1.0 - color.b);\\n  else if(src.b < color.b) alpha.b = (color.b - src.b) / color.b;\\n  else alpha.b = 0.0;\\n  if(alpha.r > alpha.g) {\\n    if(alpha.r > alpha.b) {\\n      src.a = alpha.r;\\n    } else {\\n      src.a = alpha.b;\\n    }\\n  } else if(alpha.g > alpha.b) {\\n    src.a = alpha.g;\\n  } else {\\n    src.a = alpha.b;\\n  }\\n  if(src.a >= 0.0001) {\\n    src.r = (src.r - color.r) / src.a + color.r;\\n    src.g = (src.g - color.g) / src.a + color.g;\\n    src.b = (src.b - color.b) / src.a + color.b;\\n    src.a *= alpha.a;\\n  }\\n\\n  let dst = new RGBA(src.r * 255, src.g * 255, src.b * 255, src.a * 255);\\n\\n  return dst.round();\\n});\\nRGBA.prototype.toRGB = function() {\\n  const ctor = this.constructor[Symbol.species];\\n  const { r, g, b } = this;\\n  return new ctor(r, g, b, 255);\\n};\\nRGBA.prototype.toHSLA = function() {\\n  let { r, g, b, a } = this;\\n  r /= 255;\\n  g /= 255;\\n  b /= 255;\\n  a /= 255;\\n  let max = Math.max(r, g, b);\\n  let min = Math.min(r, g, b);\\n  let h;\\n  let s;\\n  let l = (max + min) / 2;\\n  if(max == min) {\\n    h = s = 0; //achromatic\\n  } else {\\n    let d = max - min;\\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\\n    switch (max) {\\n      case r:\\n        h = (g - b) / d + (g < b ? 6 : 0);\\n        break;\\n      case g:\\n        h = (b - r) / d + 2;\\n        break;\\n      case b:\\n        h = (r - g) / d + 4;\\n        break;\\n    }\\n    h /= 6;\\n  }\\n\\n  h *= 360;\\n  s *= 100;\\n  l *= 100;\\n\\n  //console.log(\\\"RGBA.toHSLA \\\", { h, s, l, a });\\n\\n  return new (Object.isFrozen(this) ? ImmutableHSLA : HSLA)(Math.round(h), Util.roundTo(s, 100 / 255), Util.roundTo(l, 100 / 255), Util.roundTo(a, 1 / 255));\\n};\\n\\nRGBA.prototype.toCMYK = function() {\\n  let res = {};\\n  let { r, g, b } = RGBA.prototype.normalize.call(this, 255);\\n\\n  res.k = Math.min(1 - r, 1 - g, 1 - b);\\n  res.c = (1 - r - res.k) / (1 - res.k);\\n  res.m = (1 - g - res.k) / (1 - res.k);\\n  res.y = (1 - b - res.k) / (1 - res.k);\\n\\n  return {\\n    c: Math.round(res.c * 100),\\n    m: Math.round(res.m * 100),\\n    y: Math.round(res.y * 100),\\n    k: Math.round(res.k * 100),\\n    a: this.a\\n  };\\n};\\n\\nRGBA.prototype.toLAB = function() {\\n  let { r, g, b } = RGBA.prototype.normalize.call(this, 255);\\n  let x, y, z;\\n\\n  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\\n  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\\n  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\\n\\n  x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;\\n  y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.0;\\n  z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;\\n\\n  x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\\n  y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\\n  z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\\n\\n  return { l: 116 * y - 16, A: 500 * (x - y), B: 200 * (y - z), a: this.a };\\n};\\nRGBA.fromLAB = function(lab) {\\n  let y = (lab.l + 16) / 116,\\n    x = lab.A / 500 + y,\\n    z = y - lab.B / 200,\\n    r,\\n    g,\\n    b;\\n\\n  x = 0.95047 * (x * x * x > 0.008856 ? x * x * x : (x - 16 / 116) / 7.787);\\n  y = 1.0 * (y * y * y > 0.008856 ? y * y * y : (y - 16 / 116) / 7.787);\\n  z = 1.08883 * (z * z * z > 0.008856 ? z * z * z : (z - 16 / 116) / 7.787);\\n\\n  r = x * 3.2406 + y * -1.5372 + z * -0.4986;\\n  g = x * -0.9689 + y * 1.8758 + z * 0.0415;\\n  b = x * 0.0557 + y * -0.204 + z * 1.057;\\n\\n  r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;\\n  g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;\\n  b = b > 0.0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : 12.92 * b;\\n\\n  return new this(Math.round(Math.max(0, Math.min(1, r)) * 255), Math.round(Math.max(0, Math.min(1, g)) * 255), Math.round(Math.max(0, Math.min(1, b)) * 255), lab.a || 255);\\n  return this;\\n};\\n\\nRGBA.prototype.linear = function() {\\n  let { r, g, b } = RGBA.prototype.normalize.call(this, 255);\\n\\n  //apply gamma\\n  let gamma = 2.2;\\n  r = Math.pow(r, gamma); //linearize red\\n  g = Math.pow(g, gamma); //linearize green\\n  b = Math.pow(b, gamma); //linearize blue\\n  return { r, g, b };\\n};\\n\\nRGBA.prototype.luminance = function() {\\n  let lin = RGBA.prototype.linear.call(this);\\n  let Y = 0.2126 * lin.r; //red channel\\n  Y = Y + 0.7152 * lin.g; //green channel\\n  Y = Y + 0.0722 * lin.b; //blue channel\\n  return Y;\\n};\\nRGBA.prototype.invert = function() {\\n  const { r, g, b, a } = RGBA.clamp(this);\\n  return new RGBA(255 - r, 255 - g, 255 - b, a);\\n};\\nRGBA.prototype.blackwhite = function(a = this.a) {\\n  return this.luminanace() >= 0.558 ? new RGBA(255, 255, 255, a) : new RGBA(0, 0, 0, a);\\n};\\nRGBA.prototype.distance = function(other) {\\n  return Math.sqrt(Math.pow(other.r - this.r, 2) + Math.pow(other.g - this.g, 2) + Math.pow(other.b - this.b, 2)) / 441.67295593006370984949;\\n};\\nRGBA.prototype.luminanace = function() {\\n  const { r, g, b } = RGBA.prototype.normalize.call(this, 255);\\n  let a = [r, g, b].map(v => (v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)));\\n  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\\n};\\nRGBA.prototype.contrast = function contrast(other) {\\n  let lum1 = this.luminanace();\\n  let lum2 = RGBA.prototype.luminanace.call(other);\\n  let brightest = Math.max(lum1, lum2);\\n  let darkest = Math.min(lum1, lum2);\\n  return (brightest + 0.05) / (darkest + 0.05);\\n};\\nRGBA.prototype.toConsole = function(fn = 'toString', css = []) {\\n  const textColor = this.invert().blackwhite();\\n  const bgColor = textColor.invert();\\n  if(typeof fn == 'string' && fn in this) {\\n    let method = fn;\\n    fn = () => this[method]();\\n  } else if(typeof fn == 'function') {\\n    let method = fn;\\n    fn = () => method.call(this, this);\\n  }\\n  let text = fn();\\n  let style = [`text-shadow: 1px 1px 1px ${bgColor.hex()}`, `border: 1px solid black`, `padding: 2px`, `background-color: ${this.hex()}`, `color: ${textColor}`, `background-color: none`, ...css];\\n  return [`%c${text}%c`, style.join(';'), `color: inherit; background-color: inherit;`];\\n};\\nRGBA.prototype.dump = function(...args) {\\n  console.log(...this.toConsole(...args));\\n};\\n\\nRGBA.prototype.equals = function(other) {\\n  const { r, g, b, a } = this;\\n  return r == other.r && g == other.g && b == other.b && a == other.a;\\n};\\nRGBA.prototype.toObject = function() {\\n  const { r, g, b, a } = RGBA.clamp(this);\\n  return { r, g, b, a };\\n};\\nRGBA.prototype.toArray = function() {\\n  return Uint8Array.from(this);\\n};\\nRGBA.prototype.toAnsi = function(background = false) {\\n  const { r, g, b } = this;\\n\\n  return `\\\\u001b[${background ? 48 : 38};2;${[r, g, b].join(';')}m  `;\\n};\\nRGBA.fromAnsi256 = function(n) {\\n  let r, g, b;\\n  let c;\\n  if(n < 16) {\\n    r = n & 1;\\n    n >>= 1;\\n    g = n & 1;\\n    n >>= 1;\\n    b = n & 1;\\n    n >>= 1;\\n    c = [r, g, b].map(v => [n & 1 ? 85 : 0, n & 1 ? 255 : 170][v]);\\n  } else if(n >= 16 && n < 232) {\\n    n -= 16;\\n    b = n % 6;\\n    n /= 6;\\n    g = n % 6;\\n    n /= 6;\\n    r = n % 6;\\n    c = [r, g, b].map(n => (n * 255) / 5);\\n  } else if(n >= 232) {\\n    n -= 231;\\n    r = g = b = (n * 255) / (255 - 231);\\n    c = [r, g, b];\\n  }\\n  if(c) {\\n    c = c.map(Math.round);\\n    c = c.map(n => Math.min(255, n));\\n    return new RGBA(...c);\\n  }\\n};\\nRGBA.nearestColor = (color, palette, distFn = (a, b) => Math.sqrt(Math.pow(a.r - b.r, 2) + Math.pow(a.g - b.g, 2) + Math.pow(a.b - b.b, 2))) => {\\n  if(!(color instanceof RGBA)) color = new RGBA(color);\\n  //console.log(\\\"RGBA.nearestColor\\\", color.hex(),Util.className(color),Util.className(palette));\\n  if(!color) return null;\\n  let dist,\\n    minDist = Infinity,\\n    rgb,\\n    v,\\n    vi;\\n  palette || (palette = RGBA.palette16);\\n  for(let i = 0; i < palette.length; ++i) {\\n    rgb = palette[i];\\n    dist = distFn(color, rgb);\\n    if(dist < minDist) {\\n      minDist = dist;\\n      v = palette[i];\\n      vi = i;\\n    }\\n  }\\n  if(v) {\\n    return {\\n      value: v,\\n      index: vi,\\n      distance: minDist\\n    };\\n  }\\n  return v;\\n};\\nRGBA.prototype.toAnsi256 = function(background = false) {\\n  const { r, g, b } = this;\\n  const { index, distance } = RGBA.nearestColor(this, RGBA.palette16);\\n  if(distance == 0) {\\n    let bold = index & 0x08 ? 1 : 0;\\n    let num = (index & 0x07) + (background ? 40 : 30);\\n\\n    return `\\\\x1b[${bold};${num}m`;\\n  }\\n  const fromRGB = (r, g, b) => {\\n    if(r === g && g === b) {\\n      if(r < 8) return 16;\\n\\n      if(r > 248) return 231;\\n      return Math.round(((r - 8) / 247) * 24) + 232;\\n    }\\n    return 16 + 36 * Math.round((r / 255) * 5) + 6 * Math.round((g / 255) * 5) + Math.round((b / 255) * 5);\\n  };\\n  let value = fromRGB(r, g, b);\\n  const toString = (background = false) => `\\\\x1b[${background ? 48 : 38};5;${value}m`;\\n  let ret = toString(background);\\n  //ret.value = value;\\n  return ret;\\n};\\n\\nRGBA.prototype[Symbol.iterator] = function* () {\\n  const { r, g, b, a } = this;\\n  yield* [r, g, b, a][Symbol.iterator]();\\n};\\n\\nRGBA.prototype[Symbol.for('nodejs.util.inspect.custom')] = function() {\\n  const { r, g, b, a } = this;\\n  let arr = a !== undefined && a != 255 ? [r, g, b, a] : [r, g, b];\\n  let ret = arr\\n    .map(toHex) /*.map(n => (n + '').padStart(3, ' '))*/\\n    .join(',');\\n  const color = this.toAnsi(/*256*/ true);\\n  const l = this.toHSLA().l;\\n  let s = '';\\n\\n  s += arr.map(n => `\\\\x1b[0;33m${toHex(n)}\\\\x1b[0m`).join('');\\n  s = color + s;\\n\\n  return `\\\\x1b[1;31mRGBA\\\\x1b[1;36m` + `(${ret})`.padEnd(18, ' ') + ` ${color}    \\\\x1b[0m`;\\n};\\n\\nUtil.define(RGBA, {\\n  get palette16() {\\n    //const clamp = Util.clamp(0, 255);\\n    // /* prettier-ignore */ const a = [[0, 0, 0], [2, 0, 0], [0, 2, 0], [2, 2, 0], [0, 0, 2], [2, 0, 2], [0, 2, 2], [3, 3, 3], [2, 2, 2], [4, 0, 0], [0, 4, 0], [4, 4, 0], [0, 0, 4], [4, 0, 4], [0, 4, 4], [4, 4, 4] ];\\n    // /* prettier-ignore */ const b = [[1, 1, 1], [4, 0, 0], [2, 3, 1], [4, 3, 0], [1, 2, 3], [2, 2, 2], [1, 3, 3], [4, 4, 4], [2, 2, 2], [4, 1, 1], [3, 4, 1], [4, 4, 2], [2, 3, 4], [3, 2, 3], [1, 4, 4], [4, 4, 4] ];\\n    //return b.map(c => new RGBA(c.map(n => Math.round(clamp(n * 64)))));\\n    return this.palette256.slice(0, 16);\\n  },\\n  get palette256() {\\n    /* prettier-ignore */ return [0x000000, 0xaa0000, 0x00aa00, 0xaaaa00, 0x0000aa, 0xaa00aa, 0x00aaaa, 0xaaaaaa, 0x555555, 0xff5555, 0x55ff55, 0xffff55, 0x5555ff, 0xff55ff, 0x55ffff, 0xffffff, 0x000000, 0x010933, 0x031166, 0x041a99, 0x0622cc, 0x072bff, 0x093300, 0x0a3c33, 0x0b4466, 0x0d4d99, 0x0e55cc, 0x105eff, 0x116600, 0x126f33, 0x147766, 0x158099, 0x1788cc, 0x1891ff, 0x1a9900, 0x1ba233, 0x1caa66, 0x1eb399, 0x1fbbcc, 0x21c4ff, 0x22cc00, 0x23d533, 0x25dd66, 0x26e699, 0x28eecc, 0x29f7ff, 0x2bff00, 0x2cff33, 0x2dff66, 0x2fff99, 0x30ffcc, 0x32ffff, 0x330000, 0x340933, 0x361166, 0x371a99, 0x3922cc, 0x3a2aff, 0x3c3300, 0x3d3c33, 0x3e4466, 0x404d99, 0x4155cc, 0x435dff, 0x446600, 0x456e33, 0x477766, 0x488099, 0x4a88cc, 0x4b91ff, 0x4d9900, 0x4ea133, 0x4faa66, 0x51b399, 0x52bbcc, 0x54c4ff, 0x55cc00, 0x56d433, 0x58dd66, 0x59e699, 0x5beecc, 0x5cf7ff, 0x5eff00, 0x5fff33, 0x60ff66, 0x62ff99, 0x63ffcc, 0x65ffff, 0x660000, 0x670833, 0x691166, 0x6a1a99, 0x6c22cc, 0x6d2bff, 0x6f3300, 0x703b33, 0x714466, 0x734d99, 0x7455cc, 0x765eff, 0x776600, 0x786e33, 0x7a7766, 0x7b8099, 0x7d88cc, 0x7e91ff, 0x809900, 0x81a133, 0x82aa66, 0x84b399, 0x85bbcc, 0x87c4ff, 0x88cc00, 0x89d533, 0x8bdd66, 0x8ce699, 0x8eeecc, 0x8ff6ff, 0x91ff00, 0x92ff33, 0x93ff66, 0x95ff99, 0x96ffcc, 0x98ffff, 0x990000, 0x9a0933, 0x9c1166, 0x9d1a99, 0x9f22cc, 0xa02aff, 0xa23300, 0xa33c33, 0xa44466, 0xa64d99, 0xa755cc, 0xa95dff, 0xaa6600, 0xab6f33, 0xad7766, 0xae8099, 0xb088cc, 0xb190ff, 0xb39900, 0xb4a233, 0xb5aa66, 0xb7b399, 0xb8bbcc, 0xbac3ff, 0xbbcc00, 0xbcd533, 0xbedd66, 0xbfe699, 0xc1eecc, 0xc2f6ff, 0xc4ff00, 0xc5ff33, 0xc6ff66, 0xc8ff99, 0xc9ffcc, 0xcbffff, 0xcc0000, 0xcd0933, 0xcf1166, 0xd01a99, 0xd222cc, 0xd32aff, 0xd53300, 0xd63c33, 0xd74466, 0xd94d99, 0xda55cc, 0xdc5dff, 0xdd6600, 0xde6f33, 0xe07766, 0xe18099, 0xe388cc, 0xe490ff, 0xe69900, 0xe7a233, 0xe8aa66, 0xeab399, 0xebbbcc, 0xedc3ff, 0xeecc00, 0xefd533, 0xf1dd66, 0xf2e699, 0xf4eecc, 0xf5f6ff, 0xf7ff00, 0xf8ff33, 0xf9ff66, 0xfbff99, 0xfcffcc, 0xfeffff, 0xff0000, 0xff0933, 0xff1166, 0xff1a99, 0xff22cc, 0xff2aff, 0xff3300, 0xff3c33, 0xff4466, 0xff4d99, 0xff55cc, 0xff5dff, 0xff6600, 0xff6e33, 0xff7766, 0xff8099, 0xff88cc, 0xff91ff, 0xff9900, 0xffa133, 0xffaa66, 0xffb399, 0xffbbcc, 0xffc4ff, 0xffcc00, 0xffd433, 0xffdd66, 0xffe699, 0xffeecc, 0xfff7ff, 0xffff00, 0xffff33, 0xffff66, 0xffff99, 0xffffcc, 0xffffff, 0x0b0b0b, 0x151515, 0x202020, 0x2b2b2b, 0x353535, 0x404040, 0x4a4a4a, 0x555555, 0x606060, 0x6a6a6a, 0x757575, 0x808080, 0x8a8a8a, 0x959595, 0x9f9f9f, 0xaaaaaa, 0xb5b5b5, 0xbfbfbf, 0xcacaca, 0xd5d5d5, 0xdfdfdf, 0xeaeaea, 0xf4f4f4, 0xffffff].map(n => new RGBA(n|0xff000000, RGBA.order.ARGB));\\n  }\\n});\\n\\nRGBA.random = function(r = [0, 255], g = [0, 255], b = [0, 255], a = [255, 255], rng = Math.random) {\\n  return new RGBA(Util.randInt(...r, rng), Util.randInt(...g, rng), Util.randInt(...b, rng), Util.randInt(...a, rng));\\n};\\n\\nfor(let name of ['hex', 'toRGB', 'round', 'toHSLA', 'toCMYK', 'toLAB', 'linear', 'luminance', 'distance']) {\\n  RGBA[name] = (...args) => RGBA.prototype[name].call(...args);\\n}\\n/*\\nfor(let name of ['fromLAB']) {\\n  RGBA[name] = arg => {\\n    let ret = new RGBA();\\n    return RGBA.prototype[name].call(ret, arg);\\n  };\\n}*/\\n\\nUtil.defineGetter(RGBA, Symbol.species, function() {\\n  return this;\\n});\\nexport const ImmutableRGBA = Util.immutableClass(RGBA);\\nUtil.defineGetter(ImmutableRGBA, Symbol.species, () => ImmutableRGBA);\\n\\nexport default RGBA;\\n\"\n 18085            },\n 18086            \"redirectURL\": \"\",\n\n/home/roman/Projects/plot-cv/apival:\n    <binary>\n\n/home/roman/Projects/plot-cv/apival32:\n    <binary>\n\n/home/roman/Projects/plot-cv/get-res:\n    <binary>\n\n/home/roman/Projects/plot-cv/libs.js:\n 6805  Point.interpolate = (p1, p2, a) => {\n 6806    a = Util.clamp(0, 1, a);\n 6807:   return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\n 6808  };\n 6809  \n\n/home/roman/Projects/plot-cv/opencv-video:\n    <binary>\n\n/home/roman/Projects/plot-cv/portmidi-testio:\n    <binary>\n\n/home/roman/Projects/plot-cv/simplest_ffmpeg_audio_decoder:\n    <binary>\n\n/home/roman/Projects/plot-cv/sockval:\n    <binary>\n\n/home/roman/Projects/plot-cv/sublime_text:\n    <binary>\n\n/home/roman/Projects/plot-cv/svg-arc-to-cubic-bezier.js:\n  148    // this issue, we round to 1.0 when the ratio is close to 1.0.\n  149    let ratio = Math.abs(ang2) / (TAU / 4);\n  150:   if(Math.abs(1.0 - ratio) < 0.0000001) {\n  151      ratio = 1.0;\n  152    }\n\n/home/roman/Projects/plot-cv/sys-root:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/xclm:\n    <binary>\n\n/home/roman/Projects/plot-cv/data/bookmarks_21.07.21.html:\n 5312              <DT><A HREF=\"https://makingcircuits.com/blog/ic-555-li-ion-battery-charger-circuit/\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACJElEQVQ4jX1SSUuVARQ9537DC83KVCrDSBuMjEDIMhxSMttEtGrdvp/UH7BNCyEsojmkiBYVRZNBA2Vovnym3/ume1qoDZvu6k6Hc+/h0N1JYj0k/acEQEnlhxmfXQDAtu1hV4ekP2NStYXi9Xu42LjJDuyHL32rnT0117Jrvr3z+8GB+vRLuZdF4WXppXu2/PPihbmWjvn2zvnuvvr0K1N9xauLNLKx0T+9SS9PiiQBOQl/9jCdvMlNmxlFWqr5XNVoxsBkUXisz1qa8vu3yy810iSCzK5NldU8Gh6y1iaIDM3WnqtnwdGB8GCnv3mRP3gigoGp+jmbus2t7fH4CFHKBdAAwIx5ajt2x2ODSKrZ1HXlIFhM382fvwt7j4W93UrrNEKyVfEgAVE0csJaNxbT98q3s6Cnk1eVWDQ+Zs0NKkqCINdOglFpFvQciXq6/ONM/uCxf32b33lk7V3x2BA9J0wkAFtVGzTkmeKmcLifZZLdupFOXCk/zwf9g8HeNqUpSErrAAACIEjx6XHb2VI+vJVcmkC8OTo5aiaVAoF/GIwMjERw+Eh4aA9WlrW4aB374tF+CaSBtgaQXPW6VhIVDpANrdFgn5JlLS4HfcfDrm0kJVeSKElUlCErDUFPT1hssZ1tq26Lz5zL7j9VDZXzZ0kJZNOWoPcwfliwvZmSK8vlzkqFpCSQyFI4sKECCSQhZZkcrMR017/+xerS38nvBoBf+SIpwd3MiUYAAAAASUVORK5CYII=\">IC 555 Li-Ion Battery Charger Circuit</A>\n 5313              <DT><A HREF=\"https://www.instructables.com/id/Inductance-Meter-Using-Arduino/\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACm0lEQVQ4jY2TS29TZxCGn/nOd44dHxzjGOwEIgICtV1AxEUgQCoUNkhddc+Gf9BN8yOqItFNd11R8QNoWXARkQApC0CQiwBhESJSbJAviU8wjnOOzzddpEHtLrMbzbyvZkbPyFwnPi4qvwicBzy2F6nCAxWdkvnV5L7Axa2KMR6pc6iC5xlEAAVVRdX9z0VhWhZWkxjwAdI0ZXbmIWtLT8n4QpDfRVisEI6Mki+NkhseIchmEXTLI7FbYsRQfXyX6s2rXJoMOFTO0Y8dScew0fbZWMzTtWVWw0n2n/4B61sA3wCICFG7Sfj3X5z/xrJ/NGQ4DFDxePqiQ63eIXRNDpoX7Fx7QpoOvqxhRATEsDB9h+TjIpmMTy7rAUL1VcTMgwbvXka0OwOW32/wudOm9aGGMR4igo1W2qw2G6xf/4PWWER4dheBNShK822XfalSDC0zDxsEgWF8bJ169XfCH3/Ctz52+e0bluaeU6zV+TyUIU4czSimHzvGjxXJ7xnixNEipeUefVF2tGPqz+apLsxSLO3GTp46w9j4Pu7e+5PxcoT1BOsJ3fUUNUJYybLY6OPnPEZyllajT/7wJCe+vYD1PKxzjnyhwPdXjlDovaYRpZR3ZthdyKAoyUDZSBz92GE95X2lTOXsZay1qHPYzUsqe4s+K2uOWrvD3FKXbs+ROsNExSOXDVACnPMJ8sPsGNuLiEFxWCOGTnuF5VfzTBRecu5ol+FQGQwgSSGfAzB86llqzYD6hxKlhRt4X18kW/oKmW31de35rxzoXmVPKUX+y9m/vG6CtpnECcQDIUrKtILvkNu3fo5P+r/5xaFPOJVtfZIAiOJSl5iDvWuPCtnti7eGUhXEeI/MxOhgCmQaSLftsNk77cRM/QPPERus3ACQuwAAAABJRU5ErkJggg==\">Inductance Meter Using Arduino: 12 Steps</A>\n 5314:             <DT><A HREF=\"http://www.josepino.com/?insider-v10\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAn0lEQVQ4jZ1SwRHDMAiTc50ja3iebOJNPIinUV5soT5IHeqmaVIdD4wlDJgkCQHrilr347JgnvEGvWCmUgSMVorMOkuboDXlfMB2y1mtBYHZGbtr/B1IYyUSutPNa5MEckwWBUOQ1BRn8hO1YrpBBwA8zq+l5E5KuiTovB3e9Gd/Q9CNDGONEzwUbGOVRF76OPLv1XCQX5fPczvS3fV+AiOvIUYXrS9KAAAAAElFTkSuQmCC\">INSIDER V1.0 - Jose Pino&#39;s Projects and Tidbits.</A>\n 5315              <DT><A HREF=\"https://raw.githubusercontent.com/PinguinoIDE/pinguino-bootloaders/master/p32/usb/v1.x/IPECMD.txt\" ADD_DATE=\"1624232811\">ipecmd.sh</A>\n 5316              <DT><A HREF=\"https://www.villagehatshop.com/category/458/1/all-fedoras.html?Brand=217\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZElEQVQ4jWNkQAX/GYgDjDAGE7rM///EmoHDAFLBMDCABZkzeeoMFBoXyM3OoJ4LGBmIj3usgGIXUAX8x8JG9xayOApmYSAdMCJz8BmAK3CxiqM7HZcXMPTBXACLTkYcCnEaBABlaxvOY6FR1AAAAABJRU5ErkJggg==\">Jaxon Hats - Village Hat Shop</A>\n\n/home/roman/Projects/plot-cv/data/bookmarks_9_4_21.html:\n 5980              <DT><A HREF=\"https://makingcircuits.com/blog/ic-555-li-ion-battery-charger-circuit/\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAACJElEQVQ4jX1SSUuVARQ9537DC83KVCrDSBuMjEDIMhxSMttEtGrdvp/UH7BNCyEsojmkiBYVRZNBA2Vovnym3/ume1qoDZvu6k6Hc+/h0N1JYj0k/acEQEnlhxmfXQDAtu1hV4ekP2NStYXi9Xu42LjJDuyHL32rnT0117Jrvr3z+8GB+vRLuZdF4WXppXu2/PPihbmWjvn2zvnuvvr0K1N9xauLNLKx0T+9SS9PiiQBOQl/9jCdvMlNmxlFWqr5XNVoxsBkUXisz1qa8vu3yy810iSCzK5NldU8Gh6y1iaIDM3WnqtnwdGB8GCnv3mRP3gigoGp+jmbus2t7fH4CFHKBdAAwIx5ajt2x2ODSKrZ1HXlIFhM382fvwt7j4W93UrrNEKyVfEgAVE0csJaNxbT98q3s6Cnk1eVWDQ+Zs0NKkqCINdOglFpFvQciXq6/ONM/uCxf32b33lk7V3x2BA9J0wkAFtVGzTkmeKmcLifZZLdupFOXCk/zwf9g8HeNqUpSErrAAACIEjx6XHb2VI+vJVcmkC8OTo5aiaVAoF/GIwMjERw+Eh4aA9WlrW4aB374tF+CaSBtgaQXPW6VhIVDpANrdFgn5JlLS4HfcfDrm0kJVeSKElUlCErDUFPT1hssZ1tq26Lz5zL7j9VDZXzZ0kJZNOWoPcwfliwvZmSK8vlzkqFpCSQyFI4sKECCSQhZZkcrMR017/+xerS38nvBoBf+SIpwd3MiUYAAAAASUVORK5CYII=\">IC 555 Li-Ion Battery Charger Circuit</A>\n 5981              <DT><A HREF=\"https://www.instructables.com/id/Inductance-Meter-Using-Arduino/\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACm0lEQVQ4jY2TS29TZxCGn/nOd44dHxzjGOwEIgICtV1AxEUgQCoUNkhddc+Gf9BN8yOqItFNd11R8QNoWXARkQApC0CQiwBhESJSbJAviU8wjnOOzzddpEHtLrMbzbyvZkbPyFwnPi4qvwicBzy2F6nCAxWdkvnV5L7Axa2KMR6pc6iC5xlEAAVVRdX9z0VhWhZWkxjwAdI0ZXbmIWtLT8n4QpDfRVisEI6Mki+NkhseIchmEXTLI7FbYsRQfXyX6s2rXJoMOFTO0Y8dScew0fbZWMzTtWVWw0n2n/4B61sA3wCICFG7Sfj3X5z/xrJ/NGQ4DFDxePqiQ63eIXRNDpoX7Fx7QpoOvqxhRATEsDB9h+TjIpmMTy7rAUL1VcTMgwbvXka0OwOW32/wudOm9aGGMR4igo1W2qw2G6xf/4PWWER4dheBNShK822XfalSDC0zDxsEgWF8bJ169XfCH3/Ctz52+e0bluaeU6zV+TyUIU4czSimHzvGjxXJ7xnixNEipeUefVF2tGPqz+apLsxSLO3GTp46w9j4Pu7e+5PxcoT1BOsJ3fUUNUJYybLY6OPnPEZyllajT/7wJCe+vYD1PKxzjnyhwPdXjlDovaYRpZR3ZthdyKAoyUDZSBz92GE95X2lTOXsZay1qHPYzUsqe4s+K2uOWrvD3FKXbs+ROsNExSOXDVACnPMJ8sPsGNuLiEFxWCOGTnuF5VfzTBRecu5ol+FQGQwgSSGfAzB86llqzYD6hxKlhRt4X18kW/oKmW31de35rxzoXmVPKUX+y9m/vG6CtpnECcQDIUrKtILvkNu3fo5P+r/5xaFPOJVtfZIAiOJSl5iDvWuPCtnti7eGUhXEeI/MxOhgCmQaSLftsNk77cRM/QPPERus3ACQuwAAAABJRU5ErkJggg==\">Inductance Meter Using Arduino: 12 Steps</A>\n 5982:             <DT><A HREF=\"http://www.josepino.com/?insider-v10\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAn0lEQVQ4jZ1SwRHDMAiTc50ja3iebOJNPIinUV5soT5IHeqmaVIdD4wlDJgkCQHrilr347JgnvEGvWCmUgSMVorMOkuboDXlfMB2y1mtBYHZGbtr/B1IYyUSutPNa5MEckwWBUOQ1BRn8hO1YrpBBwA8zq+l5E5KuiTovB3e9Gd/Q9CNDGONEzwUbGOVRF76OPLv1XCQX5fPczvS3fV+AiOvIUYXrS9KAAAAAElFTkSuQmCC\">INSIDER V1.0 - Jose Pino&#39;s Projects and Tidbits.</A>\n 5983              <DT><A HREF=\"https://raw.githubusercontent.com/PinguinoIDE/pinguino-bootloaders/master/p32/usb/v1.x/IPECMD.txt\" ADD_DATE=\"1624232811\">ipecmd.sh</A>\n 5984              <DT><A HREF=\"https://www.villagehatshop.com/category/458/1/all-fedoras.html?Brand=217\" ADD_DATE=\"1624232811\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAZElEQVQ4jWNkQAX/GYgDjDAGE7rM///EmoHDAFLBMDCABZkzeeoMFBoXyM3OoJ4LGBmIj3usgGIXUAX8x8JG9xayOApmYSAdMCJz8BmAK3CxiqM7HZcXMPTBXACLTkYcCnEaBABlaxvOY6FR1AAAAABJRU5ErkJggg==\">Jaxon Hats - Village Hat Shop</A>\n\n/home/roman/Projects/plot-cv/lib/bezier.js:\n   18  \n   19  function A(aA1, aA2) {\n   20:   return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n   21  }\n   22  function B(aA1, aA2) {\n\n/home/roman/Projects/plot-cv/lib/color/rgba.js:\n  262    alpha.a = src.a;\n  263    if(color.r < 0.0001) alpha.r = src.r;\n  264:   else if(src.r > color.r) alpha.r = (src.r - color.r) / (1.0 - color.r);\n  265    else if(src.r < color.r) alpha.r = (color.r - src.r) / color.r;\n  266    else alpha.r = 0.0;\n  267    if(color.g < 0.0001) alpha.g = src.g;\n  268:   else if(src.g > color.g) alpha.g = (src.g - color.g) / (1.0 - color.g);\n  269    else if(src.g < color.g) alpha.g = (color.g - src.g) / color.g;\n  270    else alpha.g = 0.0;\n  271    if(color.b < 0.0001) alpha.b = src.b;\n  272:   else if(src.b > color.b) alpha.b = (src.b - color.b) / (1.0 - color.b);\n  273    else if(src.b < color.b) alpha.b = (color.b - src.b) / color.b;\n  274    else alpha.b = 0.0;\n\n/home/roman/Projects/plot-cv/lib/geom/point.js:\n  341  Point.interpolate = (p1, p2, a) => {\n  342    a = Util.clamp(0, 1, a);\n  343:   return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\n  344  };\n  345  \n\n/home/roman/Projects/plot-cv/lib/geom/polyline.js:\n  141      if(fract > 0) {\n  142        let next = this[i + 1];\n  143:       ret.x = ret.x * (1.0 - fract) + next.x * fract;\n  144:       ret.y = ret.y * (1.0 - fract) + next.y * fract;\n  145      }\n  146      return ret;\n\n/home/roman/Projects/plot-cv/opencv/sedz6Im82:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/opencv/sedzzP7Ww:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/opencv/utils.cpp:\n  371    if(!all.empty()) {\n  372      double alpha = 0.7;\n  373:     addWeighted(all_img, alpha, src, 1.0 - alpha, 0.0, all_img);\n  374      cv::imshow(\"all\", all_img);\n  375    }\n\n/home/roman/Projects/plot-cv/opencv/disabled/adaptiveThresholding.cpp:\n   66                  integralImg[y1 * IMAGE_WIDTH + x1];\n   67  \n   68:       if((long)(input[index] * count) < (long)(cv::sum * (1.0 - T)))\n   69          bin[index] = 0;\n   70        else\n\n/home/roman/Projects/plot-cv/opencv/disabled/main_ui.cpp:\n   37        cv::Vec4f rgba1 = palette_.at<cv::Vec4f>(val_1);\n   38  \n   39:       cv::Vec4f rgba = rgba0 * (1.0 - w) + rgba1 * w;\n   40        res.at<cv::Vec4b>(r, c) = rgba * 255.0;\n   41      }\n\n/home/roman/Projects/plot-cv/opencv/disabled/sedOLi7bJ:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/qjs-opencv/example:\n    <binary>\n\n/home/roman/Projects/plot-cv/qjs-opencv/js_line.cpp:\n  321        sigma = fmin(fmax(sigma, 0), 1);\n  322  \n  323:       p.x = ln->points[0].x * (1.0 - sigma) + ln->points[1].x * sigma;\n  324:       p.y = ln->points[0].y * (1.0 - sigma) + ln->points[1].y * sigma;\n  325  \n  326        ret = js_point_new(ctx, p);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/doc/index.html:\n   19  <li>version 1.6 - nov 2011:<ul>\n   20  <li>changes in the interface,</li><li>max_grad parameter removed,</li><li>the factor 11 was added to the number of test to consider the different precision values tested,</li><li>a minor bug corrected in the gradient sorting code,</li><li>the algorithm now also returns p and log_nfa for each detection,</li><li>a minor bug was corrected in the image scaling,</li><li>the angle comparison in \"isaligned\" changed from &lt; to &lt;=,</li><li>\"eps\" variable renamed \"log_eps\",</li><li>\"lsd_scale_region\" interface was added,</li><li>minor changes to comments.</li></ul>\n   21: </li><li>version 1.5 - dec 2010: Changes in 'refine', -W option added, and more comments added.</li><li>version 1.4 - jul 2010: lsd_scale interface added and doxygen doc.</li><li>version 1.3 - feb 2010: Multiple bug correction and improved code.</li><li>version 1.2 - dec 2009: First full Ansi C Language version.</li><li>version 1.1 - sep 2009: Systematic subsampling to scale 0.8 and correction to partially handle \"angle problem\".</li><li>version 1.0 - jan 2009: First complete Megawave2 and Ansi C Language version.</li></ul>\n   22  <p>\n   23  <dl compact><dt><b>Author:</b></dt><dd>rafael grompone von gioi &lt;<a href=\"mailto:grompone@gmail.com\">grompone@gmail.com</a>&gt; </dd></dl>\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/doc/lsd_8c-source.html:\n   95  00088 <span class=\"comment\">    - version 1.1 - sep 2009: Systematic subsampling to scale 0.8 and</span>\n   96  00089 <span class=\"comment\">                              correction to partially handle \"angle problem\".</span>\n   97: 00090 <span class=\"comment\">    - version 1.0 - jan 2009: First complete Megawave2 and Ansi C Language</span>\n   98  00091 <span class=\"comment\">                              version.</span>\n   99  00092 <span class=\"comment\"></span>\n  ...\n 1149  01142 <span class=\"comment\">             the i term can be bounded by a geometric series of form</span>\n 1150  01143 <span class=\"comment\">             term_i * sum mult_term_i^j.                            */</span>\n 1151: 01144           err = term * ( ( 1.0 - pow( mult_term, (<span class=\"keywordtype\">double</span>) (n-i+1) ) ) /\n 1152  01145                          (1.0-mult_term) - 1.0 );\n 1153  01146 \n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/doc/lsd_8c.html:\n 3631  01142 <span class=\"comment\">             the i term can be bounded by a geometric series of form</span>\n 3632  01143 <span class=\"comment\">             term_i * sum mult_term_i^j.                            */</span>\n 3633: 01144           err = term * ( ( 1.0 - pow( mult_term, (<span class=\"keywordtype\">double</span>) (n-i+1) ) ) /\n 3634  01145                          (1.0-mult_term) - 1.0 );\n 3635  01146 \n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n   88      - version 1.1 - sep 2009: Systematic subsampling to scale 0.8 and\n   89                                correction to partially handle \"angle problem\".\n   90:     - version 1.0 - jan 2009: First complete Megawave2 and Ansi C Language\n   91                                version.\n   92  \n   ..\n 1092  \n 1093    /* probability term */\n 1094:   p_term = p / (1.0 - p);\n 1095  \n 1096    /* compute the first term of the series */\n ....\n 1103     */\n 1104    log1term = log_gamma((double)n + 1.0) - log_gamma((double)k + 1.0) - log_gamma((double)(n - k) + 1.0) + (double)k * log(p) +\n 1105:              (double)(n - k) * log(1.0 - p);\n 1106    term = exp(log1term);\n 1107  \n ....\n 1141           the i term can be bounded by a geometric series of form\n 1142           term_i * sum mult_term_i^j.                            */\n 1143:       err = term * ((1.0 - pow(mult_term, (double)(n - i + 1))) / (1.0 - mult_term) - 1.0);\n 1144  \n 1145        /* One wants an error at most of tolerance*final_result, or:\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd_opencv.cpp:\n 1239  \n 1240    double log1term = (double(n) + 1) - log_gamma(double(k) + 1) - log_gamma(double(n - k) + 1) + double(k) * log(p) +\n 1241:                     double(n - k) * log(1.0 - p);\n 1242    double term = exp(log1term);\n 1243  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/histogram_enc.c:\n  256    {\n  257      double min_limit = 2 * entropy->sum - entropy->max_val;\n  258:     min_limit = mix * min_limit + (1.0 - mix) * entropy->entropy;\n  259      return (entropy->entropy < min_limit) ? min_limit : entropy->entropy;\n  260    }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/opencv_stitching_tool/opencv_stitching/seam_finder.py:\n   99  def add_weighted_image(img1, img2, alpha):\n  100      return cv.addWeighted(\n  101:         img1, alpha, img2, (1.0 - alpha), 0.0\n  102          )\n  103  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/doc/js_tutorials/js_assets/js_trackbar.html:\n   53  let trackbar = document.getElementById('trackbar');\n   54  let alpha = trackbar.value/trackbar.max;\n   55: let beta = ( 1.0 - alpha );\n   56  let src1 = cv.imread('canvasInput1');\n   57  let src2 = cv.imread('canvasInput2');\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/doc/js_tutorials/js_gui/js_trackbar/js_trackbar.markdown:\n   51  weightValue.setAttribute('value', trackbar.value);\n   52  let alpha = trackbar.value/trackbar.max;\n   53: let beta = ( 1.0 - alpha );\n   54  let src1 = cv.imread('canvasInput1');\n   55  let src2 = cv.imread('canvasInput2');\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/src/fisheye.cpp:\n  622      double fmax = std::max(f1, std::max(f2, std::max(f3, f4)));\n  623  \n  624:     double f = balance * fmin + (1.0 - balance) * fmax;\n  625      f *= fov_scale > 0 ? 1.0/fov_scale : 1.0;\n  626  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/src/ippe.cpp:\n  776          Ra(2,0) = ax;\n  777          Ra(2,1) = ay;\n  778:         Ra(2,2) = 1.0 - (ax2 + ay2)*d;\n  779      }\n  780  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/src/rho.cpp:\n 1530  inline void   RHO_HEST_REFC::designSPRTTest(void){\n 1531      eval.A = sacDesignSPRTTest(eval.delta, eval.epsilon, eval.t_M, eval.m_S);\n 1532:     eval.lambdaReject = ((1.0 - eval.delta) / (1.0 - eval.epsilon));\n 1533      eval.lambdaAccept = ((   eval.delta   ) / (    eval.epsilon  ));\n 1534  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/src/usac/local_optimization.cpp:\n   37          gc_sample_size = lo_sampler_->getSubsetSize();\n   38          lo_inner_iterations = gc_inner_iteration_number_;\n   39:         one_minus_lambda = 1.0 - spatial_coherence;\n   40  \n   41          energies = std::vector<double>(points_size);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/calib3d/test/test_modelest.cpp:\n  197          double startWeight = cvtest::randReal(rng);\n  198          CV_Assert(arr.type() == CV_64FC2);\n  199:         arr.at<Point2d>(modifiedPointIndex) = startWeight * arr.at<Point2d>(startPointIndex) + (1.0 - startWeight) * arr.at<Point2d>(endPointIndex);\n  200      }\n  201  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/types.hpp:\n 2015      double Aab = (a & b).area();\n 2016      // distance = 1 - jaccard_index\n 2017:     return 1.0 - Aab / (Aa + Ab - Aab);\n 2018  }\n 2019  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/src/downhill_simplex.cpp:\n  421          int j, ndim = p.cols;\n  422  \n  423:         double alpha = (1.0 - alpha_)/ndim;\n  424          double beta = alpha - alpha_;\n  425          double* p_ihi = p.ptr<double>(ihi);\n  ...\n  438          int j, ndim = p.cols;\n  439  \n  440:         double alpha = (1.0 - alpha_)/ndim;\n  441          double beta = alpha - alpha_;\n  442          double* p_ihi = p.ptr<double>(ihi);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/test/test_operations.cpp:\n  242          /////////////////////////////\n  243  \n  244:         CHECK_DIFF(1.0 - (maskMat5 | maskMat5), -maskMat4);\n  245          CHECK_DIFF((maskMat4 | maskMat4) * 1.0 + 1.0, maskMat5);\n  246          CHECK_DIFF(1.0 + (maskMat4 | maskMat4) * 1.0, maskMat5);\n  247:         CHECK_DIFF((maskMat5 | maskMat5) * 1.0 - 1.0, maskMat4);\n  248          CHECK_DIFF(5.0 - (maskMat4 | maskMat4) * 1.0, maskMat1);\n  249          CHECK_DIFF((maskMat4 | maskMat4) * 1.0 + 0.5 + 0.5, maskMat5);\n  ...\n  274          CHECK_DIFF((maskMat1*3.0 + 1.0) + (maskMat1*2.0 + 2.0), maskMat1 * 8);\n  275  \n  276:         CHECK_DIFF(maskMat5*1.0 - maskMat4, maskMat1);\n  277          CHECK_DIFF(maskMat5 - maskMat1 * 4.0, maskMat1);\n  278          CHECK_DIFF((maskMat4 * 1.0 + 4.0)- maskMat4, maskMat4);\n  279          CHECK_DIFF(maskMat5 - (maskMat1 * 2.0 + 2.0), maskMat1);\n  280:         CHECK_DIFF(maskMat5*1.0 - (maskMat4 | maskMat4), maskMat1);\n  281          CHECK_DIFF((maskMat5 | maskMat5) - maskMat1 * 4.0, maskMat1);\n  282          CHECK_DIFF((maskMat4 * 1.0 + 4.0)- (maskMat4 | maskMat4), maskMat4);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/test/test_quaternion.cpp:\n  391      EXPECT_EQ(2.0 * dq1, dq12);\n  392      EXPECT_EQ(dq1 - 1.0, DualQuatd(0, 2, 3, 4, 5, 6, 7, 8));\n  393:     EXPECT_EQ(1.0 - dq1, DualQuatd(0, -2, -3, -4, -5, -6, -7, -8));\n  394      EXPECT_EQ(dq1 + 1.0, DualQuatd(2, 2, 3, 4, 5, 6, 7, 8));\n  395      EXPECT_EQ(1.0 + dq1, DualQuatd(2, 2, 3, 4, 5, 6, 7, 8));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/test/test_common.impl.hpp:\n  126                  topIoU = std::max(topIoU, iou);\n  127                  refBoxesIoUDiff[j] = std::min(refBoxesIoUDiff[j], 1.0f - iou);\n  128:                 if (1.0 - iou < boxes_iou_diff)\n  129                  {\n  130                      matched = true;\n  ...\n  201                  double iou = intersectArea / (contourArea(testPoly) + contourArea(gtPolys[j]) - intersectArea);\n  202                  topIoU = std::max(topIoU, iou);\n  203:                 if (1.0 - iou < boxes_iou_diff)\n  204                  {\n  205                      matched = true;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/kaze/nldiffusion_functions.cpp:\n  176  \n  177    exp(dst, dst);\n  178:   dst = 1.0 - dst;\n  179  }\n  180  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/lsd.cpp:\n 1074      double log1term = (double(n) + 1) - log_gamma(double(k) + 1)\n 1075                  - log_gamma(double(n-k) + 1)\n 1076:                 + double(k) * log(p) + double(n-k) * log(1.0 - p);\n 1077      double term = exp(log1term);\n 1078  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/phasecorr.cpp:\n  616      double coeff0 = 2.0 * CV_PI / (double)(cols - 1), coeff1 = 2.0f * CV_PI / (double)(rows - 1);\n  617      for(int j = 0; j < cols; j++)\n  618:         wc[j] = 0.5 * (1.0 - cos(coeff0 * j));\n  619  \n  620      if(dst.depth() == CV_32F)\n  ...\n  623          {\n  624              float* dstData = dst.ptr<float>(i);\n  625:             double wr = 0.5 * (1.0 - cos(coeff1 * i));\n  626              for(int j = 0; j < cols; j++)\n  627                  dstData[j] = (float)(wr * wc[j]);\n  ...\n  633          {\n  634              double* dstData = dst.ptr<double>(i);\n  635:             double wr = 0.5 * (1.0 - cos(coeff1 * i));\n  636              for(int j = 0; j < cols; j++)\n  637                  dstData[j] = wr * wc[j];\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/ts/src/ocl_test.cpp:\n  122          int result = cv::countNonZero(result_ > 0);\n  123          if (cpu_area!=0 && result!=0)\n  124:             final_test_result = 1.0 - (double)result/(double)cpu_area;\n  125          else if(cpu_area==0 && result!=0)\n  126              final_test_result = -1;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/tracking/tracker_dasiamrpn.cpp:\n  250  \n  251      pscore = penalty.mul(score);\n  252:     pscore = pscore * (1.0 - trackState.windowInfluence) + trackState.windows * trackState.windowInfluence;\n  253  \n  254      int bestID[2] = { 0, 0 };\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/videoio/test/test_ffmpeg.cpp:\n   47                    Point2i(coeff * i, coeff * i),\n   48                    Point2i(coeff * (i + 1), coeff * (i + 1)),\n   49:                   Scalar::all(255 * (1.0 - static_cast<double>(i) / (fps * time_sec * 2))),\n   50                    -1);\n   51          writer << img;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/core/AddingImages/AddingImages.cpp:\n   45  \n   46     //![blend_images]\n   47:    beta = ( 1.0 - alpha );\n   48     addWeighted( src1, alpha, src2, beta, 0.0, dst);\n   49     //![blend_images]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/HighGUI/AddingImagesTrackbar.cpp:\n   31  {\n   32     alpha = (double) alpha_slider/alpha_slider_max ;\n   33:    beta = ( 1.0 - alpha );\n   34     addWeighted( src1, alpha, src2, beta, 0.0, dst);\n   35     imshow( \"Linear Blend\", dst );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/dnn/virtual_try_on.py:\n  100          for xx in range(0, outSize):\n  101              point = points[xx]\n  102:             bilinear = np.where(point < 1.0, 1.0 - abs(point), 0.0)\n  103              ww = np.sum(bilinear)\n  104              kk[xx * ksize : xx * ksize + bilinear.size] = np.where(ww == 0.0, bilinear, bilinear / ww)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/java/tutorial_code/core/AddingImages/AddingImages.java:\n   30  \n   31          //! [blend_images]\n   32:         beta = ( 1.0 - alpha );\n   33          Core.addWeighted( src1, alpha, src2, beta, 0.0, dst);\n   34          //! [blend_images]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/java/tutorial_code/highgui/trackbar/AddingImagesTrackbar.java:\n   97      private void update() {\n   98          double alpha = alphaVal / (double) ALPHA_SLIDER_MAX;\n   99:         double beta = 1.0 - alpha;\n  100          Core.addWeighted(matImgSrc1, alpha, matImgSrc2, beta, 0, matImgDst);\n  101          Image img = HighGui.toBufferedImage(matImgDst);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/python/coherence.py:\n   42          img1 = ero\n   43          img1[m] = dil[m]\n   44:         img = np.uint8(img*(1.0 - blend) + img1*blend)\n   45      print('done')\n   46      return img\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/python/tutorial_code/core/AddingImages/adding_images.py:\n   27      exit(-1)\n   28  # [blend_images]\n   29: beta = (1.0 - alpha)\n   30  dst = cv.addWeighted(src1, alpha, src2, beta, 0.0)\n   31  # [blend_images]\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/python/tutorial_code/highgui/trackbar/AddingImagesTrackbar.py:\n   10  def on_trackbar(val):\n   11      alpha = val / alpha_slider_max\n   12:     beta = ( 1.0 - alpha )\n   13      dst = cv.addWeighted(src1, alpha, src2, beta, 0.0)\n   14      cv.imshow(title_window, dst)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bgsegm/src/bgfg_gmg.cpp:\n  388  \n  389                  // see Godbehere, Matsukawa, Goldberg (2012) for reasoning behind this implementation of Bayes rule\n  390:                 const double posterior = (weight * backgroundPrior_) / (weight * backgroundPrior_ + (1.0 - weight) * (1.0 - backgroundPrior_));\n  391  \n  392:                 isForeground = ((1.0 - posterior) > decisionThreshold_);\n  393  \n  394                  // update histogram.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bgsegm/src/synthetic_seq.cpp:\n   75  \n   76      for (unsigned i = 0; i < bpp; i++) {\n   77:         double m0 = (1.0 - x) * values[0][i] + x * values[1][i];\n   78:         double m1 = (1.0 - x) * values[2][i] + x * values[3][i];\n   79:         dest[i] = (uchar) ((1.0 - y) * m0 + y * m1);\n   80      }\n   81  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/dpm/src/dpm_feature.cpp:\n  223              double vy0 = yp - iyp;\n  224              double vx0 = xp - ixp;\n  225:             double vy1 = 1.0 - vy0;\n  226:             double vx1 = 1.0 - vx0;\n  227              v = sqrt(v);\n  228  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/facemarkAAM.cpp:\n 1229              Mat beta = (v1x-v0x)*(y-v0y)-(v1y-v0y)*(x-v0x);\n 1230  \n 1231:             Mat res = 1.0 - alpha/denominator - beta/denominator; // same just different order\n 1232  \n 1233              /*remap to image form*/\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/freetype/src/freetype.cpp:\n  428                  double blendAlpha = (double ) cl / 255.0;\n  429  \n  430:                 (*ptr)[0] = (double) _color[0] * blendAlpha + (*ptr)[0] * (1.0 - blendAlpha );\n  431:                 (*ptr)[1] = (double) _color[1] * blendAlpha + (*ptr)[1] * (1.0 - blendAlpha );\n  432:                 (*ptr)[2] = (double) _color[2] * blendAlpha + (*ptr)[2] * (1.0 - blendAlpha );\n  433              }\n  434          }\n  ...\n  598          // Split Bezier to lines ( in FreeType coordinates ).\n  599          double u = (double)i * 1.0 / (p->mCtoL) ;\n  600:         double nu = 1.0 - u;\n  601          double p0 =                  nu * nu;\n  602          double p1 = 2.0 * u *        nu;\n  ...\n  629          // Split Bezier to lines ( in FreeType coordinates ).\n  630          double u = (double)i * 1.0 / (p->mCtoL) ;\n  631:         double nu = 1.0 - u;\n  632          double p0 =                  nu * nu * nu;\n  633          double p1 = 3.0 * u *        nu * nu;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/line_descriptor/include/opencv2/line_descriptor/descriptor.hpp:\n  770  \n  771        /* probability term */\n  772:       p_term = p / ( 1.0 - p );\n  773  \n  774        /* compute the first term of the series */\n  ...\n  782        log1term = log_gamma( (double) n + 1.0 )- log_gamma( (double ) k + 1.0 )- log_gamma( (double ) ( n - k ) + 1.0 )\n  783  + (double) k * log( p )\n  784: + (double) ( n - k ) * log( 1.0 - p );\n  785  term = exp( log1term );\n  786  \n  ...\n  818       the i term can be bounded by a geometric series of form\n  819       term_i * sum mult_term_i^j.                            */\n  820:     err = term * ( ( 1.0 - pow( mult_term, (double) ( n - i + 1 ) ) ) / ( 1.0 - mult_term ) - 1.0 );\n  821      /* One wants an error at most of tolerance*final_result, or:\n  822       tolerance * abs(-log10(bin_tail)-logNT).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/mcc/src/distance.cpp:\n   72      double C_bar = (C1 + C2) / 2.0;\n   73      double G = sqrt(pow(C_bar, 7) / (pow(C_bar, 7) + pow(25, 7)));\n   74:     double a1_apo = lab1[1] + lab1[1] / 2.0 * (1.0 - G);\n   75:     double a2_apo = lab2[1] + lab2[1] / 2.0 * (1.0 - G);\n   76      double C1_apo = sqrt(pow(a1_apo, 2) + pow(lab1[2], 2));\n   77      double C2_apo = sqrt(pow(a2_apo, 2) + pow(lab2[2], 2));\n   ..\n  136  \n  137      double delta_H_apo = 2.0 * sqrt(C1_apo * C2_apo) * sin(delta_h_apo / 2.0);\n  138:     double T = 1.0 - 0.17 * cos(H_bar_apo - toRad(30.)) + 0.24 * cos(2.0 * H_bar_apo) + 0.32 * cos(3.0 * H_bar_apo + toRad(6.0)) - 0.2 * cos(4.0 * H_bar_apo - toRad(63.0));\n  139      double sC = 1.0 + 0.045 * C_bar_apo;\n  140      double sH = 1.0 + 0.015 * C_bar_apo * T;\n  ...\n  179      double sL = lab1[0] < 16. ? 0.511 : (0.040975 * lab1[0]) / (1.0 + 0.01765 * lab1[0]);\n  180      double sC = (0.0638 * C1) / (1.0 + 0.0131 * C1) + 0.638;\n  181:     double sH = sC * (F * T + 1.0 - F);\n  182  \n  183      return sqrt(pow(dL / (kL * sL), 2.0) + pow(dC / (kC * sC), 2.0) + pow(dH / sH, 2.0));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparse_matching_gpc.cpp:\n  469  }\n  470  \n  471: double getRobustMedian( double m ) { return m < 0 ? m * ( 1.0 + epsTolerance ) : m * ( 1.0 - epsTolerance ); }\n  472  }\n  473  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rapid/src/histogram.cpp:\n  221                      // handle object clutter as in eq. (5)\n  222                      if(s > tau)\n  223:                         s = 1.0 - bhattacharyyaCoeff(bgHist, hist);\n  224                      scores(i, j) = float(s);\n  225                      start = j;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/pose_graph.cpp:\n  852                  enoughLm = true;\n  853  \n  854:                 lambdaLevMarq *= std::max(1.0 / initialLmDownFactor, 1.0 - pow(2.0 * stepQuality - 1.0, 3));\n  855                  lmUpFactor = initialLmUpFactor;\n  856  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/sfm/include/opencv2/sfm/robust.hpp:\n   57    @param outliers_probability outliers probability (in ]0,1[).\n   58           The number of iterations is controlled using the following equation:\n   59:          \\f$k = \\frac{log(1-p)}{log(1.0 - w^n )}\\f$ where \\f$k\\f$, \\f$w\\f$ and \\f$n\\f$ are the number of\n   60           iterations, the inliers ratio and minimun number of selected independent samples.\n   61           The more this value is high, the less the function selects ramdom samples.\n   ..\n   80    @param outliers_probability outliers probability (in ]0,1[).\n   81           The number of iterations is controlled using the following equation:\n   82:          \\f$k = \\frac{log(1-p)}{log(1.0 - w^n )}\\f$ where \\f$k\\f$, \\f$w\\f$ and \\f$n\\f$ are the number of\n   83           iterations, the inliers ratio and minimun number of selected independent samples.\n   84           The more this value is high, the less the function selects ramdom samples.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/sfm/src/libmv_light/libmv/multiview/euclidean_resection.cc:\n  396    alphas->block(1, 0, 3, num_points) = a;\n  397    for (size_t c = 0; c < num_points; c++) {\n  398:     (*alphas)(0, c) = 1.0 - alphas->col(c).sum();\n  399    }\n  400  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/sfm/src/libmv_light/libmv/multiview/robust_estimation.h:\n   59                          double inlier_ratio) {\n   60    return static_cast<uint>(\n   61:       log(outliers_probability) / log(1.0 - pow(inlier_ratio, min_samples)));\n   62  }\n   63  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/augmented_unscented_kalman.cpp:\n  213      {\n  214          Wm.at<double>(0,0) = lambda/tmpLambda;\n  215:         Wc.at<double>(0,0) = lambda/tmpLambda + 1.0 - alpha*alpha + beta;\n  216      }\n  217      else\n  218      {\n  219          Wm.at<float>(0,0) = (float)(lambda/tmpLambda);\n  220:         Wc.at<float>(0,0) = (float)(lambda/tmpLambda + 1.0 - alpha*alpha + beta);\n  221      }\n  222  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/trackerCSRT.cpp:\n  363  \n  364      // calculate probability for the background\n  365:     p_b = 1.0 - ((x2-x1+1) * (y2-y1+1)) /\n  366          ((double) (outer_x2-outer_x1+1) * (outer_y2-outer_y1+1));\n  367  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/trackerCSRTSegmentation.cpp:\n  214      cv::Mat prob_o(newSize, foregroundLikelihood.type());\n  215      prob_o = p_o*foregroundLikelihood / (p_o*foregroundLikelihood + p_b*backgroundLikelihood);\n  216:     cv::Mat prob_b = 1.0 - prob_o;\n  217  \n  218      std::pair<cv::Mat, cv::Mat> sizedProbs = getRegularizedSegmentation(prob_o, prob_b, fgPriorScaled, bgPriorScaled);\n  ...\n  279      cv::Mat prob_o(newSize, foregroundLikelihood.type());\n  280      prob_o = p_o*foregroundLikelihood / (p_o*foregroundLikelihood + p_b*backgroundLikelihood);\n  281:     cv::Mat prob_b = 1.0 - prob_o;\n  282  \n  283      std::pair<cv::Mat, cv::Mat> sizedProbs = getRegularizedSegmentation(prob_o, prob_b,\n  ...\n  342      cv::Mat prob_o(newSize, foregroundLikelihood.type());\n  343      prob_o = p_o*foregroundLikelihood / (p_o*foregroundLikelihood + p_b*backgroundLikelihood);\n  344:     cv::Mat prob_b = 1.0 - prob_o;\n  345  \n  346      std::pair<cv::Mat, cv::Mat> sizedProbs = getRegularizedSegmentation(prob_o, prob_b, fgPriorScaled, bgPriorScaled);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/trackerCSRTUtils.cpp:\n  221      if(NN != 0) {\n  222          for (int i = 0; i < hann_rows.rows; ++i) {\n  223:             hann_rows.at<float>(i,0) = (float)(1.0/2.0 * (1.0 - cos(2*CV_PI*i/NN)));\n  224          }\n  225      }\n  ...\n  227      if(NN != 0) {\n  228          for (int i = 0; i < hann_cols.cols; ++i) {\n  229:             hann_cols.at<float>(0,i) = (float)(1.0/2.0 * (1.0 - cos(2*CV_PI*i/NN)));\n  230          }\n  231      }\n  ...\n  244      for(int n = 0; n <= N; ++n) {\n  245          double K = (2.0 * n * 1.0/N) - 1.0;\n  246:         double x = sqrt(1.0 - (K * K));\n  247          kaiser_rows.at<float>(n,0) = static_cast<float>(modified_bessel(0, shape * x) * den);\n  248      }\n  ...\n  251      for(int n = 0; n <= N; ++n) {\n  252          double K = (2.0 * n * 1.0/N) - 1.0;\n  253:         double x = sqrt(1.0 - (K * K));\n  254          kaiser_cols.at<float>(0,n) = static_cast<float>(modified_bessel(0, shape * x) * den);\n  255      }\n  ...\n  366              double vy0 = yp - iyp;\n  367              double vx0 = xp - ixp;\n  368:             double vy1 = 1.0 - vy0;\n  369:             double vx1 = 1.0 - vx0;\n  370              v = sqrt(v);\n  371  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/tracking_by_matching.cpp:\n   49      double yy = descr2.dot(descr2);\n   50      double norm = sqrt(xx * yy) + 1e-6;\n   51:     return 0.5f * static_cast<float>(1.0 - xy / norm);\n   52  }\n   53  \n   ..\n 1008          i++;\n 1009      }\n 1010:     dissimilarity_matrix = 1.0 - am;\n 1011  }\n 1012  \n ....\n 1093  \n 1094      for (size_t i = 0; i < track_and_det_ids.size(); i++) {\n 1095:         auto reid_affinity = 1.0 - distances[i];\n 1096  \n 1097          size_t track_id = track_and_det_ids[i].first;\n ....\n 1215      if (time_aff < eps) return 0.0;\n 1216  \n 1217:     float app_aff = static_cast<float>(1.0 - distance_fast_->compute(descriptor1, descriptor2));\n 1218  \n 1219      return shp_aff * mot_aff * app_aff * time_aff;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/tracking/src/unscented_kalman.cpp:\n  197      {\n  198          Wm.at<double>(0,0) = lambda/tmpLambda;\n  199:         Wc.at<double>(0,0) = lambda/tmpLambda + 1.0 - alpha*alpha + beta;\n  200      }\n  201      else\n  202      {\n  203          Wm.at<float>(0,0) = (float)(lambda/tmpLambda);\n  204:         Wc.at<float>(0,0) = (float)(lambda/tmpLambda + 1.0 - alpha*alpha + beta);\n  205      }\n  206  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/adaptive_manifold_filter_n.cpp:\n   71  {\n   72      const double Hs = floor(Log2(sigma_s)) - 1.0;\n   73:     const double Lr = 1.0 - sigma_r;\n   74      return max(2, static_cast<int>(ceil(Hs * Lr)));\n   75  }\n   ..\n  479          vector<Mat> eta_minus(jointCnNum), eta_plus(jointCnNum);\n  480          {\n  481:             Mat1f teta = 1.0 - w_k;\n  482              computeEta(teta, cluster_minus, eta_minus);\n  483              computeEta(teta, cluster_plus, eta_plus);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 5008      arcs[noArcs].sTheta = sTheta;\n 5009      arcs[noArcs].eTheta = eTheta;\n 5010:     arcs[noArcs].coverRatio = (double)((1.0 - overlapRatio) * noPixels) / computeEllipsePerimeter(pEq);\n 5011      arcs[noArcs].turn = turn;\n 5012  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_adaptive_manifold_ref_impl.cpp:\n  221      {\n  222          const double Hs = floor(Log2(sigma_s)) - 1.0;\n  223:         const double Lr = 1.0 - sigma_r;\n  224          return max(2, static_cast<int>(ceil(Hs * Lr)));\n  225      }\n\n/home/roman/Projects/plot-cv/quickjs/libquickjs.so.1:\n    <binary>\n\n/home/roman/Projects/plot-cv/quickjs/opencv-4.5.4-xenial.tar.gz:\n    File too large, skipping\n\n/home/roman/Projects/plot-cv/quickjs/qjsc:\n    <binary>\n\n/home/roman/Projects/plot-cv/quickjs/qjscalc:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/quickjs/run-test262:\n    <binary>\n\n/home/roman/Projects/plot-cv/quickjs/examples/hello:\n    <binary>\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/src/linux_joystick.c:\n   95              // Normalize to 0.0 -> 1.0\n   96              normalized = (normalized - info->minimum) / range;\n   97:             // Normalize to -1.0 -> 1.0\n   98              normalized = normalized * 2.0f - 1.0f;\n   99          }\n\n/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm:\n    <binary>\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/obsolete/nanovg_gl2.h:\n  286  \t\t\"\tfcolor = color;\\n\"\n  287  \t\t\"\tfpos = vertex;\\n\"\n  288: \t\t\"\tgl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 1.0 - 2.0*vertex.y/viewSize.y, 0, 1);\\n\"\n  289  \t\t\"}\\n\";\n  290  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/obsolete/nanovg_gl3.h:\n  288  \t\t\"\tfcolor = color;\\n\"\n  289  \t\t\"\tfpos = vertex;\\n\"\n  290: \t\t\"\tgl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 1.0 - 2.0*vertex.y/viewSize.y, 0, 1);\\n\"\n  291  \t\t\"}\\n\";\n  292  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/nanovg_gl.h:\n  550  \t\t\"\tftcoord = tcoord;\\n\"\n  551  \t\t\"\tfpos = vertex;\\n\"\n  552: \t\t\"\tgl_Position = vec4(2.0*vertex.x/viewSize.x - 1.0, 1.0 - 2.0*vertex.y/viewSize.y, 0, 1);\\n\"\n  553  \t\t\"}\\n\";\n  554  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/curl/docs/cmdline-opts/proxy1.0.d:\n    3  Help: Use HTTP/1.0 proxy on given port\n    4  Category: proxy\n    5: Example: --proxy1.0 -x http://proxy $URL\n    6  Added: 7.19.4\n    7  See-also: proxy socks5 preproxy\n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/curl/lib/vtls/openssl.c:\n  127        LIBRESSL_VERSION_NUMBER < 0x20700000L)\n  128  #define SSLEAY_VERSION_NUMBER OPENSSL_VERSION_NUMBER\n  129: #define HAVE_X509_GET0_EXTENSIONS 1 /* added in 1.1.0 -pre1 */\n  130: #define HAVE_OPAQUE_EVP_PKEY 1 /* since 1.1.0 -pre3 */\n  131: #define HAVE_OPAQUE_RSA_DSA_DH 1 /* since 1.1.0 -pre5 */\n  132  #define CONST_EXTS const\n  133  #define HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED 1\n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/curl/tests/libtest/lib1514.c:\n   70    easy_setopt(curl, CURLOPT_READDATA, &pooh);\n   71  #ifdef LIB1539\n   72:   /* speak HTTP 1.0 - no chunked! */\n   73    easy_setopt(curl, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);\n   74  #endif\n\n/home/roman/Projects/plot-cv/uftrace.data/3720907.dat:\n    File too large, skipping\n\n150 matches across 90 files\n\n\nSearching 19285 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/127.0.0.1.har:\n 12438              \"size\": 11111,\n 12439              \"mimeType\": \"application/javascript\",\n 12440:             \"text\": \"import Util from '../util.js';\\n\\nconst SymSpecies = Util.tryCatch(\\n  () => Symbol,\\n  sym => sym.species\\n);\\n\\nconst CTOR = obj => {\\n  if(obj[SymSpecies]) return obj[SymSpecies];\\n  let p = Object.getPrototypeOf(obj);\\n  if(p[SymSpecies]) return p[SymSpecies];\\n  return p.constructor;\\n};\\n\\nexport function Point(...args) {\\n  let isNew = this instanceof Point;\\n  args = args[0] instanceof Array ? args.shift() : args;\\n  let p = isNew ? this : new Point(...args);\\n  let arg = args.shift();\\n\\n  if(!new.target) if (arg instanceof Point) return arg;\\n\\n  if(typeof arg === 'undefined') {\\n    p.x = arg;\\n    p.y = args.shift();\\n  } else if(typeof arg === 'number') {\\n    p.x = parseFloat(arg);\\n    p.y = parseFloat(args.shift());\\n  } else if(typeof arg === 'string') {\\n    const matches = [...arg.matchAll(/([-+]?d*.?d+)(?:[eE]([-+]?d+))?/g)];\\n\\n    p.x = parseFloat(matches[0]);\\n    p.y = parseFloat(matches[1]);\\n  } else if(typeof arg == 'object' && arg !== null && (arg.x !== undefined || arg.y !== undefined)) {\\n    p.x = arg.x;\\n    p.y = arg.y;\\n  } else if(typeof arg == 'object' && arg !== null && arg.length > 0 && x !== undefined && y !== undefined) {\\n    p.x = parseFloat(arg.shift());\\n    p.y = parseFloat(arg.shift());\\n  } else if(typeof args[0] === 'number' && typeof args[1] === 'number') {\\n    p.x = args[0];\\n    p.y = args[1];\\n    args.shift(2);\\n  } else {\\n    p.x = 0;\\n    p.y = 0;\\n  }\\n  if(p.x === undefined) p.x = 0;\\n  if(p.y === undefined) p.y = 0;\\n  if(isNaN(p.x)) p.x = undefined;\\n  if(isNaN(p.y)) p.y = undefined;\\n\\n  if(!isNew) {\\n    /* if(p.prototype == Object) p.prototype = Point.prototype;\\n    else Object.assign(p, Point.prototype);*/\\n    return p;\\n  }\\n}\\nconst getOther = args => (console.debug('getOther', ...args), typeof args[0] == 'number' ? [{ x: args[0], y: args[1] }] : args);\\n\\nObject.defineProperties(Point.prototype, {\\n  X: {\\n    get() {\\n      return this.x;\\n    }\\n  },\\n  Y: {\\n    get() {\\n      return this.y;\\n    }\\n  }\\n});\\n\\nPoint.prototype.move = function(x, y) {\\n  this.x += x;\\n  this.y += y;\\n  return this;\\n};\\nPoint.prototype.moveTo = function(x, y) {\\n  this.x = x;\\n  this.y = y;\\n  return this;\\n};\\nPoint.prototype.clear = function(x, y) {\\n  this.x = 0;\\n  this.y = 0;\\n  return this;\\n};\\nPoint.prototype.set = function(fn) {\\n  if(typeof fn != 'function') {\\n    Point.apply(this, [...arguments]);\\n    return this;\\n  }\\n  return fn(this.x, this.y);\\n};\\nPoint.prototype.clone = function() {\\n  const ctor = this[Symbol.species] || this.constructor[Symbol.species];\\n\\n  return new ctor({ x: this.x, y: this.y });\\n};\\nPoint.prototype.sum = function(...args) {\\n  const p = new Point(...args);\\n  let r = new Point(this.x, this.y);\\n  r.x += p.x;\\n  r.y += p.y;\\n  return r;\\n};\\nPoint.prototype.add = function(...args) {\\n  const other = new Point(...args);\\n  this.x += other.x;\\n  this.y += other.y;\\n  return this;\\n};\\nPoint.prototype.diff = function(arg) {\\n  let { x, y } = this;\\n  let fn = function(other) {\\n    let r = new Point(x, y);\\n    return r.sub(other);\\n  };\\n  if(arg) return fn(arg);\\n  return fn;\\n};\\nPoint.prototype.sub = function(...args) {\\n  const other = new Point(...args);\\n  this.x -= other.x;\\n  this.y -= other.y;\\n  return this;\\n};\\nPoint.prototype.prod = function(f) {\\n  const o = isPoint(f) ? f : { x: f, y: f };\\n  return new Point(this.x * o.x, this.y * o.y);\\n};\\nPoint.prototype.mul = function(f) {\\n  const o = isPoint(f) ? f : { x: f, y: f };\\n  this.x *= o.x;\\n  this.y *= o.y;\\n  return this;\\n};\\nPoint.prototype.quot = function(other) {\\n  other = isPoint(other) ? other : { x: other, y: other };\\n  return new Point(this.x / other.x, this.y / other.y);\\n};\\nPoint.prototype.div = function(other) {\\n  other = isPoint(other) ? other : { x: other, y: other };\\n  this.x /= other.x;\\n  this.y /= other.y;\\n  return this;\\n};\\nPoint.prototype.comp = function() {\\n  return new Point({ x: -this.x, y: -this.y });\\n};\\nPoint.prototype.neg = function() {\\n  this.x *= -1;\\n  this.y *= -1;\\n  return this;\\n};\\nPoint.prototype.distanceSquared = function(other = { x: 0, y: 0 }) {\\n  return (other.y - this.y) * (other.y - this.y) + (other.x - this.x) * (other.x - this.x);\\n};\\nPoint.prototype.distance = function(other = { x: 0, y: 0 }) {\\n  return Math.sqrt(Point.prototype.distanceSquared.call(this, Point(other)));\\n};\\nPoint.prototype.equals = function(other) {\\n  let { x, y } = this;\\n  return +x == +other.x && +y == +other.y;\\n};\\nPoint.prototype.round = function(precision = 0.001, digits, type) {\\n  let { x, y } = this;\\n  digits = digits || Util.roundDigits(precision);\\n  type = type || 'round';\\n  this.x = Util.roundTo(x, precision, digits, type);\\n  this.y = Util.roundTo(y, precision, digits, type);\\n  return this;\\n};\\nPoint.prototype.ceil = function() {\\n  let { x, y } = this;\\n  this.x = Math.ceil(x);\\n  this.y = Math.ceil(y);\\n  return this;\\n};\\nPoint.prototype.floor = function() {\\n  let { x, y } = this;\\n  this.x = Math.floor(x);\\n  this.y = Math.floor(y);\\n  return this;\\n};\\n\\nPoint.prototype.dot = function(other) {\\n  return this.x * other.x + this.y * other.y;\\n};\\n\\nPoint.prototype.values = function() {\\n  return [this.x, this.y];\\n};\\nPoint.prototype.fromAngle = function(angle, dist = 1.0) {\\n  this.x = Math.cos(angle) * dist;\\n  this.y = Math.sin(angle) * dist;\\n  return this;\\n};\\nPoint.prototype.toAngle = function(deg = false) {\\n  return Math.atan2(this.x, this.y) * (deg ? 180 / Math.PI : 1);\\n};\\nPoint.prototype.angle = function(other, deg = false) {\\n  other = other || { x: 0, y: 0 };\\n  return Point.prototype.diff.call(this, other).toAngle(deg);\\n};\\nPoint.prototype.rotate = function(angle, origin = { x: 0, y: 0 }) {\\n  this.x -= origin.x;\\n  this.y -= origin.y;\\n  let c = Math.cos(angle),\\n    s = Math.sin(angle);\\n  let xnew = this.x * c - this.y * s;\\n  let ynew = this.x * s + this.y * c;\\n  this.x = xnew;\\n  this.y = ynew;\\n  return this;\\n};\\nUtil.defineGetter(Point.prototype, Symbol.iterator, function() {\\n  const { x, y } = this;\\n  let a = [x, y];\\n  return a[Symbol.iterator].bind(a);\\n});\\n\\n/*Point.prototype.valueOf = function(shl = 16) {\\n  const { x, y } = this;\\n  return x | (y << shl);\\n};\\n*/ Point.prototype.toString = function(opts = {}) {\\n  const { precision = 0.001, unit = '', separator = ',', left = '', right = '', pad = 0 } = opts;\\n  let x = Util.roundTo(this.x, precision);\\n  let y = Util.roundTo(this.y, precision);\\n  if(pad > 0) {\\n    x = x + '';\\n    y = y + '';\\n    if(y[0] != '-') y = ' ' + y;\\n    if(x[0] != '-') x = ' ' + x;\\n  }\\n  //console.debug(\\\"toString\\\", {x,y}, {pad});\\n  return `${left}${(x + '').padStart(pad, ' ')}${unit}${separator}${(y + '').padEnd(pad, ' ')}${unit}${right}`;\\n};\\nPoint.prototype[Symbol.toStringTag] = 'Point';\\nPoint.prototype.toSource = function(opts = {}) {\\n  const { asArray = false, plainObj = false, pad = a => a /*a.padStart(4, ' ')*/, showNew = true } = opts;\\n  let x = pad(this.x + '');\\n  let y = pad(this.y + '');\\n  let c = t => t;\\n  if(typeof this != 'object' || this === null) return '';\\n  if(asArray) return `[${x},${y}]`;\\n  if(plainObj) return `{x:${x},y:${y}}`;\\n\\n  return `${c(showNew ? 'new ' : '', 1, 31)}${c('Point', 1, 33)}${c('(', 1, 36)}${c(x, 1, 32)}${c(',', 1, 36)}${c(y, 1, 32)}${c(')', 1, 36)}`;\\n};\\n\\n/*Point.prototype.toSource = function() {\\n  return '{x:' + this.x + ',y:' + this.y + '}';\\n};*/\\nPoint.prototype.toObject = function(proto = Point.prototype) {\\n  const { x, y } = this;\\n  const obj = { x, y };\\n  Object.setPrototypeOf(obj, proto);\\n  return obj;\\n};\\nPoint.prototype.toCSS = function(precision = 0.001, edges = ['left', 'top']) {\\n  return {\\n    [edges[0]]: Util.roundTo(this.x, precision) + 'px',\\n    [edges[1]]: Util.roundTo(this.y, precision) + 'px'\\n  };\\n};\\nPoint.prototype.toFixed = function(digits) {\\n  return new Point(+this.x.toFixed(digits), +this.y.toFixed(digits));\\n};\\nPoint.prototype.isNull = function() {\\n  return this.x == 0 && this.y == 0;\\n};\\nPoint.prototype.inside = function(rect) {\\n  return this.x >= rect.x && this.x < rect.x + rect.width && this.y >= rect.y && this.y < rect.y + rect.height;\\n};\\nPoint.prototype.transform = function(m, round = true) {\\n  if(Util.isObject(m) && typeof m.toMatrix == 'function') m = m.toMatrix();\\n  //if(Util.isObject(m) && typeof m.transform_point == 'function') return m.transform_point(this);\\n\\n  const x = m[0] * this.x + m[1] * this.y + m[2];\\n  const y = m[3] * this.x + m[4] * this.y + m[5];\\n\\n  this.x = x;\\n  this.y = y;\\n  if(round) Point.prototype.round.call(this, 1e-13, 13);\\n\\n  return this;\\n};\\nPoint.prototype.scaleTo = function(minmax) {\\n  return new Point({\\n    x: (this.x - minmax.x1) / (minmax.x2 - minmax.x1),\\n    y: (this.y - minmax.y1) / (minmax.y2 - minmax.y1)\\n  });\\n};\\nPoint.prototype.normalize = function() {\\n  let d = Point.prototype.distance.call(this);\\n  return Point.prototype.div.call(this, { x: d, y: d });\\n};\\nPoint.prototype.normal = function() {\\n  let d = Point.prototype.distance.call(this);\\n  return new Point({ x: this.x / d, y: this.y / d });\\n};\\n\\nPoint.fromString = str => new Point(...str.split(/[^-.0-9]+/g).map(n => +n));\\nPoint.move = (point, x, y) => Point.prototype.move.call(point, x, y);\\nPoint.angle = (point, other, deg = false) => Point.prototype.angle.call(point, other, deg);\\nPoint.inside = (point, rect) => Point.prototype.inside.call(point, rect);\\nPoint.sub = (point, other) => Point.prototype.sub.call(point, other);\\nPoint.prod = (a, b) => Point.prototype.prod.call(a, b);\\nPoint.quot = (a, b) => Point.prototype.quot.call(a, b);\\nPoint.equals = (a, b) => Point.prototype.equals.call(a, b);\\nPoint.round = (point, prec, digits, type) => Point.prototype.round.call(point, prec, digits, type);\\nPoint.fromAngle = (angle, f) => new Point().fromAngle(angle, f);\\n\\nfor(let name of [\\n  'clone',\\n  'comp',\\n  'neg',\\n  'sides',\\n  'dimension',\\n  'toString',\\n  //'toSource',\\n  'toCSS',\\n  'sub',\\n  'diff',\\n  'add',\\n  'sum',\\n  'distance'\\n]) {\\n  Point[name] = (point, ...args) => Point.prototype[name].call(Point(point), ...args);\\n}\\nPoint.interpolate = (p1, p2, a) => {\\n  a = Util.clamp(0, 1, a);\\n  return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\\n};\\n\\nPoint.toSource = (point, { space = ' ', padding = ' ', separator = ',' }) => `{${padding}x:${space}${point.x}${separator}y:${space}${point.y}${padding}}`;\\n\\nexport const isPoint = o => o && ((o.x !== undefined && o.y !== undefined) || ((o.left !== undefined || o.right !== undefined) && (o.top !== undefined || o.bottom !== undefined)) || o instanceof Point || Object.getPrototypeOf(o).constructor === Point);\\n\\nPoint.isPoint = isPoint;\\n\\nPoint.prototype[Util.inspectSymbol] = function(depth, options) {\\n  const { x, y } = this;\\n  return /*Object.setPrototypeOf*/ { x, y } /*, Point.prototype*/;\\n};\\n\\nPoint.bind = (...args) => {\\n  const keys = ['x', 'y'];\\n  let [o, p] = args;\\n  if(p == null) p = keys;\\n  const { x, y } = (Util.isArray(p) && p.reduce((acc, name, i) => ({ ...acc, [keys[i]]: name }), {})) || p;\\n  //console.debug('Point.bind', { keys, o, p, x, y });\\n  return Object.setPrototypeOf(Util.bindProperties({}, o, { x, y }), Point.prototype);\\n};\\nexport default Point;\\n\\nUtil.defineGetter(Point, Symbol.species, function() {\\n  return this;\\n});\\n\\nexport const ImmutablePoint = Util.immutableClass(Point);\\nUtil.defineGetter(ImmutablePoint, Symbol.species, () => ImmutablePoint);\\n\"\n 12441            },\n 12442            \"redirectURL\": \"\",\n .....\n 12770              \"size\": 15233,\n 12771              \"mimeType\": \"application/javascript\",\n 12772:             \"text\": \"import { Point, isPoint } from './point.js';\\nimport { BBox } from './bbox.js';\\nimport Util from '../util.js';\\n\\nexport function Line(...args) {\\n  if(!new.target) if (args[0] instanceof Line) return args[0];\\n\\n  let [x1, y1, x2, y2] = args;\\n  let obj;\\n  let arg;\\n  let ret;\\n  if(args.length >= 4 && args.every(arg => !isNaN(parseFloat(arg)))) {\\n    arg = { x1, y1, x2, y2 };\\n  } else if(args.length == 1) {\\n    arg = args[0];\\n  }\\n  obj = new.target ? this : null /* new Line()*/;\\n\\n  //obj = this || { ...arg };\\n\\n  if(obj === null) obj = Object.create(Line.prototype);\\n\\n  if(Object.getPrototypeOf(obj) !== Line.prototype) Object.setPrototypeOf(obj, Line.prototype);\\n\\n  //if(!('a' in obj) || !('b' in obj)) throw new Error('no a/b prop');\\n  if(arg && arg.x1 !== undefined && arg.y1 !== undefined && arg.x2 !== undefined && arg.y2 !== undefined) {\\n    const { x1, y1, x2, y2 } = arg;\\n    obj.x1 = parseFloat(x1);\\n    obj.y1 = parseFloat(y1);\\n    obj.x2 = parseFloat(x2);\\n    obj.y2 = parseFloat(y2);\\n    ret = 1;\\n  } else if(isPoint(args[0]) && isPoint(args[1])) {\\n    args = args.map(a => Point(a));\\n\\n    obj.x1 = args[0].x;\\n    obj.y1 = args[0].y;\\n    obj.x2 = args[1].x;\\n    obj.y2 = args[1].y;\\n    ret = 2;\\n  } else if(arg && arg.length >= 4 && arg.slice(0, 4).every(arg => !isNaN(+arg))) {\\n    const [x1, y1, x2, y2] = arg.map(a => +a);\\n    obj.x1 = x1;\\n    obj.y1 = y1;\\n    obj.x2 = x2;\\n    obj.y2 = y2;\\n    ret = 4;\\n  } else {\\n    ret = 0;\\n  }\\n\\n  if(!('a' in obj) || obj.a === undefined)\\n    Object.defineProperty(obj, 'a', {\\n      value: new Point(obj.x1, obj.y1),\\n      enumerable: false\\n    });\\n  if(!('b' in obj) || obj.b === undefined)\\n    Object.defineProperty(obj, 'b', {\\n      value: new Point(obj.x2, obj.y2),\\n      enumerable: false\\n    });\\n\\n  if(!isLine(obj)) {\\n    //console.log('ERROR: is not a line: ', Util.inspect(arg), Util.inspect(obj));\\n  }\\n\\n  if(!['x1', 'y1', 'x2', 'y2'].every(prop => !isNaN(+obj[prop]))) return null;\\n\\n  /*  if(this !== obj)*/ return obj;\\n}\\n\\nexport const isLine = obj => (Util.isObject(obj) && ['x1', 'y1', 'x2', 'y2'].every(prop => obj[prop] !== undefined)) || ['a', 'b'].every(prop => isPoint(obj[prop]));\\n\\n/*\\nObject.defineProperty(Line.prototype, 'a', { value: new Point(), enumerable: true });\\nObject.defineProperty(Line.prototype, 'b', { value: new Point(), enumerable: true });\\n*/\\n\\nLine.prototype.intersect = function(other) {\\n  const ma = (this[0].y - this[1].y) / (this[0].x - this[1].x);\\n  const mb = (other[0].y - other[1].y) / (other[0].x - other[1].x);\\n  if(ma - mb < Number.EPSILON) return undefined;\\n  return new Point({\\n    x: (ma * this[0].x - mb * other[0].x + other[0].y - this[0].y) / (ma - mb),\\n    y: (ma * mb * (other[0].x - this[0].x) + mb * this[0].y - ma * other[0].y) / (mb - ma)\\n  });\\n};\\n\\nObject.defineProperty(Line.prototype, 'a', {\\n  get() {\\n    return Line.a(this);\\n  },\\n  set(value) {\\n    if(!(value instanceof Point)) value = Point(value);\\n    this.x1 = value.x;\\n    this.y1 = value.y;\\n  },\\n  enumerable: false\\n});\\nObject.defineProperty(Line.prototype, 'b', {\\n  get() {\\n    return Line.b(this);\\n  },\\n  set(value) {\\n    if(!(value instanceof Point)) value = Point(value);\\n    this.x2 = value.x;\\n    this.y2 = value.y;\\n  },\\n  enumerable: false\\n});\\n\\nObject.defineProperty(Line.prototype, 0, {\\n  get() {\\n    return this.a;\\n  },\\n  set(v) {\\n    this.a = v;\\n  },\\n  enumerable: false\\n});\\nObject.defineProperty(Line.prototype, 1, {\\n  get() {\\n    return this.b;\\n  },\\n  set(v) {\\n    this.b = v;\\n  },\\n  enumerable: false\\n});\\n/*Object.defineProperty(Line.prototype, 'x1', {get() {return this.a && this.a.x; }, set(v) {if(!this.a) Object.defineProperty(this, 'a', { value: new Point(), enumerable: false }); this.a.x = v; }, enumerable: true });\\nObject.defineProperty(Line.prototype, 'y1', {get() {return this.a && this.a.y; }, set(v) {if(!this.a) Object.defineProperty(this, 'a', {value: new Point(), enumerable: false }); this.a.y = v; }, enumerable: true });\\nObject.defineProperty(Line.prototype, 'x2', {get() {return this.b && this.b.x; }, set(v) {if(!this.b) Object.defineProperty(this, 'b', {value: new Point(), enumerable: false }); this.b.x = v; }, enumerable: true });\\nObject.defineProperty(Line.prototype, 'y2', {get() {return this.b && this.b.y; }, set(v) {if(!this.b) Object.defineProperty(this, 'b', {value: new Point(), enumerable: false }); this.b.y = v; }, enumerable: true });\\n*/\\nLine.prototype.direction = function() {\\n  let dist = Point.prototype.distance.call(this.a, this.b);\\n  return Point.prototype.quot.call(Line.prototype.getSlope.call(this), dist);\\n};\\nLine.prototype.getVector = function() {\\n  return { x: this.x2 - this.x1, y: this.y2 - this.y1 };\\n};\\nObject.defineProperty(Line.prototype, 'vector', {\\n  get: Line.prototype.getVector\\n});\\nLine.prototype.getSlope = function() {\\n  return (this.y2 - this.y1) / (this.x2 - this.x1);\\n};\\nObject.defineProperty(Line.prototype, 'slope', {\\n  get() {\\n    return new Point(this.x2 - this.x1, this.y2 - this.y1);\\n  }\\n});\\nLine.prototype.yIntercept = function() {\\n  let v = Line.prototype.getVector.call(this);\\n  if(v.x !== 0) {\\n    let slope = v.y / v.x;\\n    return [this.a.y - this.a.x * slope, slope || 0];\\n  }\\n};\\nLine.prototype.xIntercept = function() {\\n  let v = Line.prototype.getVector.call(this);\\n  if(v.y !== 0) {\\n    let slope = v.x / v.y;\\n    return [this.a.x - this.a.y * slope, slope || 0];\\n  }\\n};\\nLine.prototype.isHorizontal = function() {\\n  return Line.prototype.getVector.call(this).y === 0;\\n};\\nLine.prototype.isVertical = function() {\\n  return Line.prototype.getVector.call(this).x === 0;\\n};\\n\\nLine.prototype.isNull = function() {\\n  return this.x1 == 0 && this.y1 == 0 && this.x2 == 0 && this.y2 == 0;\\n};\\nLine.prototype.equations = function() {\\n  let intercept = {\\n    y: Line.prototype.yIntercept.call(this),\\n    x: Line.prototype.xIntercept.call(this)\\n  };\\n  let equations = [];\\n  for(let axis in intercept) {\\n    if(intercept[axis]) {\\n      let [c0, m] = intercept[axis];\\n      let rhs = `${c0}`;\\n      if(m !== 0) rhs += ` + ${m} * ${axis == 'y' ? 'x' : 'y'}`;\\n      equations.push(`${axis} = ${rhs}`);\\n    }\\n  }\\n  return equations;\\n};\\nLine.prototype.functions = function() {\\n  let i;\\n  let fns = {};\\n  if((i = Line.prototype.yIntercept.call(this))) {\\n    let [y0, myx] = i;\\n    fns.y = x => y0 + myx * x;\\n  } else {\\n    let { y } = this.a;\\n    fns.y = new Function('x', `return ${y}`);\\n  }\\n  if((i = Line.prototype.xIntercept.call(this))) {\\n    let [x0, mxy] = i;\\n    fns.x = y => x0 + mxy * y;\\n  } else {\\n    let { x } = this.a;\\n    fns.x = new Function('y', `return ${x}`); //y => x;\\n  }\\n  return fns;\\n};\\nLine.prototype.angle = function() {\\n  return Point.prototype.angle.call(Line.prototype.getVector.call(this));\\n};\\nLine.prototype.getLength = function() {\\n  const { a, b } = this;\\n  const { x1, y1, x2, y2 } = this;\\n  //console.log(\\\"a:\\\",a, \\\" b:\\\",b);\\n  //console.log('a:', a, ' b:', b);\\n  //console.log('this:', this);\\n  return Point.prototype.distance.call(a, b);\\n};\\nLine.prototype.endpointDist = function(point) {\\n  return Math.min(point.distance(this.a), point.distance(this.b));\\n};\\nLine.prototype.matchEndpoints = function(arr) {\\n  const { a, b } = this;\\n  return [...arr.entries()].filter(([i, otherLine]) => !Line.prototype.equals.call(this, otherLine) && (Point.prototype.equals.call(a, otherLine.a) || Point.prototype.equals.call(b, otherLine.b) || Point.prototype.equals.call(b, otherLine.a) || Point.prototype.equals.call(a, otherLine.b)));\\n};\\n\\nLine.prototype.distanceToPointSquared = function(p) {\\n  const { a, b } = this;\\n  let l2 = Point.prototype.distanceSquared.call(a, b);\\n  if(l2 === 0) return Point.prototype.distanceSquared.call(p, a);\\n  let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;\\n  t = Math.max(0, Math.min(1, t));\\n  return Point.prototype.distanceSquared.call(p, new Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y)));\\n};\\nLine.prototype.distanceToPoint = function(p) {\\n  return Math.sqrt(Line.prototype.distanceToPointSquared.call(this, p));\\n};\\n\\nObject.defineProperty(Line.prototype, 'len', {\\n  get: Line.prototype.getLength\\n});\\nObject.defineProperty(Line.prototype, 'cross', {\\n  get() {\\n    const { x1, x2, y1, y2 } = this;\\n    return x1 * y2 - y1 * x2;\\n  }\\n});\\nObject.defineProperty(Line.prototype, 'dot', {\\n  get() {\\n    const { x1, x2, y1, y2 } = this;\\n    return x1 * x2 + y1 * y2;\\n  }\\n});\\n\\nLine.prototype.pointAt = function(pos) {\\n  return Point.interpolate(...this.toPoints(), pos);\\n\\n  //return new Point(pos * (this.x2 - this.x1) + this.x1, pos * (this.y2 - this.y1) + this.y1);\\n};\\nLine.prototype.transform = function(m) {\\n  this.a = this.a.transform(m);\\n  this.b = this.b.transform(m);\\n\\n  if(round) Line.prototype.round.call(this, 1e-13, 13);\\n\\n  return this;\\n};\\nLine.prototype.bbox = function() {\\n  const { x1, y1, x2, y2 } = this;\\n  return new BBox(x1, y1, x2, y2);\\n};\\n\\nLine.prototype.points = function() {\\n  const { a, b } = this;\\n  return [a, b];\\n};\\n\\nLine.prototype[Symbol.for('nodejs.util.inspect.custom')] = function(n, options = {}) {\\n  const { x1, y1, x2, y2 } = this;\\n  return this[Symbol.toStringTag] + ' ' + Util.inspect({ x1, y1, x2, y2 }, options) + ' }';\\n};\\nLine.prototype.toString = function(opts = {}) {\\n  let { separator = ', ', brackets, pad = 6, ...options } = opts;\\n\\n  if(typeof brackets != 'function') brackets = brackets ? s => `[ ${s} ]` : s => s;\\n\\n  const { x1, y1, x2, y2 } = this;\\n  return (\\n    brackets(\\n      Point.toString(this.a || Point(x1, y1), {\\n        ...options,\\n        /*separator,*/ pad: 0\\n      })\\n    ) +\\n    separator +\\n    brackets(\\n      Point.toString(this.b || Point(x2, y2), {\\n        ...options,\\n        /*separator,*/ pad: 0\\n      })\\n    )\\n  );\\n};\\nLine.prototype.toSource = function() {\\n  const { x1, y1, x2, y2 } = this;\\n  return `new Line(${[x1, y1, x2, y2].join(',')})`;\\n};\\nLine.prototype.reverse = function() {\\n  const { a, b } = this;\\n  this.b = a;\\n  this.a = b;\\n  if(this.curve !== undefined) this.curve = -this.curve;\\n  if(this.width !== undefined) this.width = this.width;\\n  return this;\\n};\\nLine.prototype.toObject = function(t = num => num) {\\n  const { x1, y1, x2, y2 } = this;\\n  const obj = { x1: t(x1), y1: t(y1), x2: t(x2), y2: t(y2) };\\n  //Object.setPrototypeOf(obj, Line.prototype);\\n  return obj;\\n};\\nLine.prototype.clone = function() {\\n  const ctor = this.constructor[Symbol.species];\\n  const { x1, y1, x2, y2 } = this;\\n  let ret = new ctor(x1, y1, x2, y2);\\n\\n  if(this.curve !== undefined) ret.curve = this.curve;\\n\\n  return ret;\\n};\\n\\nLine.prototype.round = function(precision = 0.001, digits, type) {\\n  let { x1, y1, x2, y2 } = this;\\n  this.x1 = Util.roundTo(x1, precision, digits, type);\\n  this.y1 = Util.roundTo(y1, precision, digits, type);\\n  this.x2 = Util.roundTo(x2, precision, digits, type);\\n  this.y2 = Util.roundTo(y2, precision, digits, type);\\n  return this;\\n};\\nLine.prototype.sum = function(...args) {\\n  let r = new Line(...this);\\n  return Line.prototype.add.call(r, ...args);\\n};\\nLine.prototype.add = function(...args) {\\n  let other;\\n  if((other = Line(...args))) {\\n    this.x1 += other.x1;\\n    this.y1 += other.y1;\\n    this.x2 += other.x2;\\n    this.y2 += other.y2;\\n  } else if((other = Point(...args))) {\\n    this.x1 += other.x;\\n    this.y1 += other.y;\\n    this.x2 += other.x;\\n    this.y2 += other.y;\\n  }\\n  return this;\\n};\\nLine.prototype.diff = function(...args) {\\n  let r = new Line(...this);\\n  return Line.prototype.sub.call(r, ...args);\\n};\\nLine.prototype.sub = function(...args) {\\n  let other;\\n  if((other = Line(...args))) {\\n    this.x1 -= other.x1;\\n    this.y1 -= other.y1;\\n    this.x2 -= other.x2;\\n    this.y2 -= other.y2;\\n  } else if((other = Point(...args))) {\\n    this.x1 -= other.x;\\n    this.y1 -= other.y;\\n    this.x2 -= other.x;\\n    this.y2 -= other.y;\\n  }\\n  return this;\\n};\\nLine.prototype.prod = function(...args) {\\n  let r = new Line(...this);\\n  return Line.prototype.mul.call(r, ...args);\\n};\\nLine.prototype.mul = function(...args) {\\n  const o = args.length == 1 && typeof args[0] == 'number' ? { x: args[0], y: args[0] } : new Point(...args);\\n  this.x1 *= o.x;\\n  this.y1 *= o.y;\\n  this.x2 *= o.x;\\n  this.y2 *= o.y;\\n  return this;\\n};\\nLine.prototype.quot = function(...args) {\\n  let r = new Line(...this);\\n  return Line.prototype.div.call(r, ...args);\\n};\\nLine.prototype.div = function(...args) {\\n  const o = args.length == 1 && typeof args[0] == 'number' ? { x: args[0], y: args[0] } : new Point(...args);\\n  this.x1 /= o.x;\\n  this.y1 /= o.y;\\n  this.x2 /= o.x;\\n  this.y2 /= o.y;\\n  return this;\\n};\\nLine.prototype.some = function(pred) {\\n  return pred(this.a) || pred(this.b);\\n};\\nLine.prototype.every = function(pred) {\\n  return pred(this.a) && pred(this.b);\\n};\\nLine.prototype.includes = function(point) {\\n  return Point.prototype.equals.call(this.a, point) || Point.prototype.equals.call(this.b, point);\\n};\\nLine.prototype.equals = function(...args) {\\n  let other = Line(...args);\\n  if(Point.equals(this.a, other.a) && Point.equals(this.b, other.b)) return 1;\\n  if(Point.equals(this.a, other.b) && Point.equals(this.b, other.a)) return -1;\\n  return 0;\\n};\\nLine.prototype.indexOf = function(point) {\\n  let i = 0;\\n  for(let p of [this.a, this.b]) {\\n    if(Point.prototype.equals.call(p, point)) return i;\\n    i++;\\n  }\\n  return -1;\\n};\\nLine.prototype.lastIndexOf = function(point) {\\n  let i = 0;\\n  for(let p of [this.b, this.a]) {\\n    if(Point.prototype.equals.call(p, point)) return i;\\n    i++;\\n  }\\n  return -1;\\n};\\nLine.prototype.map = function(fn) {\\n  let i = 0;\\n  let r = [];\\n  for(let p of [this.a, this.b]) {\\n    r.push(fn(p, i, this));\\n    i++;\\n  }\\n  return new Line(...r);\\n};\\nLine.prototype.swap = function(fn) {\\n  let line = new Line(this.b, this.a);\\n  if(this.curve !== undefined) line.curve = -this.curve;\\n  if(this.width !== undefined) line.width = this.width;\\n  return line;\\n};\\nLine.prototype.toPoints = function(ctor = Array.of) {\\n  const { x1, y1, x2, y2 } = this;\\n  return ctor({ x: x1, y: y1 }, { x: x2, y: y2 });\\n};\\nLine.prototype[Symbol.iterator] = function() {\\n  const { x1, y1, x2, y2 } = this;\\n  return [x1, y1, x2, y2][Symbol.iterator]();\\n};\\n\\nfor(let name of ['direction', 'round', 'slope', 'angle', 'bbox', 'points', 'inspect', 'toString', 'toObject', 'toSource', 'distanceToPointSquared', 'distanceToPoint']) {\\n  Line[name] = (line, ...args) => Line.prototype[name].call(line || new Line(line), ...args);\\n}\\n\\nUtil.defineInspect(Line.prototype, 'x1', 'y1', 'x2', 'y2');\\n\\nLine.a = Util.memoize(line => Point.bind(line, ['x1', 'y1']), new WeakMap());\\nLine.b = Util.memoize(line => Point.bind(line, ['x2', 'y2']), new WeakMap());\\nLine.from = obj => {\\n  let l = new Line(obj);\\n\\n  for(let extra of ['curve', 'width']) {\\n    if(typeof obj[extra] == 'number') l[extra] = obj[extra];\\n    else if(typeof obj[extra] == 'string' && !isNaN(+obj[extra])) l[extra] = +obj[extra];\\n  }\\n  return l;\\n};\\n\\nLine.bind = (o, p, gen) => {\\n  const [x1, y1, x2, y2] = p || ['x1', 'y1', 'x2', 'y2'];\\n  if(!gen) gen = k => v => v === undefined ? o[k] : (o[k] = v);\\n\\n  let proxy = { a: Point.bind(o, [x1, y1]), b: Point.bind(o, [x2, y2]) };\\n  Util.bindProperties(proxy, o, { x1, y1, x2, y2 }, gen);\\n  return Object.setPrototypeOf(proxy, Line.prototype);\\n};\\n\\nUtil.defineGetter(Line, Symbol.species, function() {\\n  return this;\\n});\\n\\nexport const ImmutableLine = Util.immutableClass(Line);\\nUtil.defineGetter(ImmutableLine, Symbol.species, () => ImmutableLine);\\n\"\n 12773            },\n 12774            \"redirectURL\": \"\",\n\n/home/roman/Projects/plot-cv/files.list:\n 7222  qjs-opencv/opencv/modules/core/include/opencv2/core/cuda/warp_shuffle.hpp\n 7223  qjs-opencv/opencv/modules/core/include/opencv2/core/cuda/vec_distance.hpp\n 7224: qjs-opencv/opencv/modules/core/include/opencv2/core/cuda/border_interpolate.hpp\n 7225  qjs-opencv/opencv/modules/core/include/opencv2/core/cuda/block.hpp\n 7226  qjs-opencv/opencv/modules/core/include/opencv2/core/cuda/transform.hpp\n ....\n 11723  qjs-opencv/opencv_contrib/modules/cudalegacy/src/precomp.hpp\n 11724  qjs-opencv/opencv_contrib/modules/cudalegacy/src/bm.cpp\n 11725: qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp\n 11726  qjs-opencv/opencv_contrib/modules/cudalegacy/src/calib3d.cpp\n 11727  qjs-opencv/opencv_contrib/modules/cudalegacy/src/needle_map.cpp\n .....\n 110099  node_modules/ts-standard/node_modules/eslint-config-standard-with-typescript/node_modules/eslint-config-standard/node_modules/eslint/lib/linter/apply-disable-directives.js\n 110100  node_modules/ts-standard/node_modules/eslint-config-standard-with-typescript/node_modules/eslint-config-standard/node_modules/eslint/lib/linter/source-code-fixer.js\n 110101: node_modules/ts-standard/node_modules/eslint-config-standard-with-typescript/node_modules/eslint-config-standard/node_modules/eslint/lib/linter/interpolate.js\n 110102  node_modules/ts-standard/node_modules/eslint-config-standard-with-typescript/node_modules/eslint-config-standard/node_modules/eslint/lib/linter/safe-emitter.js\n 110103  node_modules/ts-standard/node_modules/eslint-config-standard-with-typescript/node_modules/eslint-config-standard/node_modules/eslint/lib/linter/rule-fixer.js\n .....\n 111716  node_modules/ts-standard/node_modules/eslint/lib/linter/apply-disable-directives.js\n 111717  node_modules/ts-standard/node_modules/eslint/lib/linter/source-code-fixer.js\n 111718: node_modules/ts-standard/node_modules/eslint/lib/linter/interpolate.js\n 111719  node_modules/ts-standard/node_modules/eslint/lib/linter/safe-emitter.js\n 111720  node_modules/ts-standard/node_modules/eslint/lib/linter/rule-fixer.js\n .....\n 122343  node_modules/enquirer/lib/utils.js\n 122344  node_modules/enquirer/lib/prompt.js\n 122345: node_modules/enquirer/lib/interpolate.js\n 122346  node_modules/enquirer/lib/theme.js\n 122347  node_modules/enquirer/lib/completer.js\n .....\n 125477  node_modules/readdirp/index.d.ts\n 125478  node_modules/readdirp/index.js\n 125479: node_modules/lodash._reinterpolate/\n 125480: node_modules/lodash._reinterpolate/README.md\n 125481: node_modules/lodash._reinterpolate/package.json\n 125482: node_modules/lodash._reinterpolate/LICENSE.txt\n 125483: node_modules/lodash._reinterpolate/index.js\n 125484  node_modules/content-type/\n 125485  node_modules/content-type/README.md\n .....\n 130227  node_modules/eslint-plugin-import/node_modules/eslint/lib/linter/apply-disable-directives.js\n 130228  node_modules/eslint-plugin-import/node_modules/eslint/lib/linter/source-code-fixer.js\n 130229: node_modules/eslint-plugin-import/node_modules/eslint/lib/linter/interpolate.js\n 130230  node_modules/eslint-plugin-import/node_modules/eslint/lib/linter/safe-emitter.js\n 130231  node_modules/eslint-plugin-import/node_modules/eslint/lib/linter/rule-fixer.js\n .....\n 134137  node_modules/eslint/lib/linter/apply-disable-directives.js\n 134138  node_modules/eslint/lib/linter/source-code-fixer.js\n 134139: node_modules/eslint/lib/linter/interpolate.js\n 134140  node_modules/eslint/lib/linter/safe-emitter.js\n 134141  node_modules/eslint/lib/linter/rule-fixer.js\n\n/home/roman/Projects/plot-cv/libs.js:\n 6803    Point[name] = (point, ...args) => Point.prototype[name].call(Point(point), ...args);\n 6804  }\n 6805: Point.interpolate = (p1, p2, a) => {\n 6806    a = Util.clamp(0, 1, a);\n 6807    return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\n ....\n 7619  \n 7620  Line.prototype.pointAt = function(pos) {\n 7621:   return Point.interpolate(...this.toPoints(), pos);\n 7622  \n 7623    //return new Point(pos * (this.x2 - this.x1) + this.x1, pos * (this.y2 - this.y1) + this.y1);\n\n/home/roman/Projects/plot-cv/sublime_text:\n    <binary>\n\n/home/roman/Projects/plot-cv/sys-root:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/yarn.lock:\n 3276      lodash._reescape \"^3.0.0\"\n 3277      lodash._reevaluate \"^3.0.0\"\n 3278:     lodash._reinterpolate \"^3.0.0\"\n 3279      lodash.template \"^3.0.0\"\n 3280      minimist \"^1.1.0\"\n ....\n 4177    integrity sha1-WLx0xAZklTrgsSTYBpltrKQx4u0=\n 4178  \n 4179: lodash._reinterpolate@^3.0.0:\n 4180    version \"3.0.0\"\n 4181:   resolved \"https://registry.yarnpkg.com/lodash._reinterpolate/-/lodash._reinterpolate-3.0.0.tgz#0ccf2d89166af03b3663c796538b75ac6e114d9d\"\n 4182    integrity sha1-DM8tiRZq8Ds2Y8eWU4t1rG4RTZ0=\n 4183  \n ....\n 4242      lodash._basevalues \"^3.0.0\"\n 4243      lodash._isiterateecall \"^3.0.0\"\n 4244:     lodash._reinterpolate \"^3.0.0\"\n 4245      lodash.escape \"^3.0.0\"\n 4246      lodash.keys \"^3.0.0\"\n ....\n 4253    integrity sha1-+zB4RHU7Zrnxr6VOJix0UwfbqOU=\n 4254    dependencies:\n 4255:     lodash._reinterpolate \"^3.0.0\"\n 4256      lodash.escape \"^3.0.0\"\n 4257  \n\n/home/roman/Projects/plot-cv/data/excelsior.xml:\n  840          <string>Template String Element</string>\n  841          <key>scope</key>\n  842:         <string>punctuation.definition.string.interpolated.element</string>\n  843          <key>settings</key>\n  844          <dict>\n  ...\n  990          <string>Syntax Template Literal Interpolated</string>\n  991          <key>scope</key>\n  992:         <string>meta.interpolation.interpolated</string>\n  993          <key>settings</key>\n  994          <dict>\n\n/home/roman/Projects/plot-cv/imgui/imstb_truetype.h:\n 1934            scy = y;\n 1935            if(!(vertices[off + i + 1].type & 1)) {\n 1936:             // next point is also a curve point, so interpolate an on-point curve\n 1937              sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;\n 1938              sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;\n ....\n 1953        } else {\n 1954          if(!(flags & 1)) { // if it's a curve\n 1955:           if(was_off)      // two off-curve control points in a row means interpolate an on-curve\n 1956                             // midpoint\n 1957              stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);\n\n/home/roman/Projects/plot-cv/lib/geom/line.js:\n  258  \n  259  Line.prototype.pointAt = function(pos) {\n  260:   return Point.interpolate(...this.toPoints(), pos);\n  261  \n  262    //return new Point(pos * (this.x2 - this.x1) + this.x1, pos * (this.y2 - this.y1) + this.y1);\n\n/home/roman/Projects/plot-cv/lib/geom/point.js:\n  339    Point[name] = (point, ...args) => Point.prototype[name].call(Point(point), ...args);\n  340  }\n  341: Point.interpolate = (p1, p2, a) => {\n  342    a = Util.clamp(0, 1, a);\n  343    return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\n\n/home/roman/Projects/plot-cv/lib/geom/splinePoints.js:\n   10  }\n   11  \n   12: function interpolate(p0, p1, p2, p3, t) {\n   13    let v0 = (p2 - p0) * 0.5;\n   14    let v1 = (p3 - p1) * 0.5;\n   ..\n   47      let step = 1 / numSteps;\n   48      for(let t = 0; t < 1; t += step) {\n   49:       let x = interpolate(points[c0][0], points[c1][0], points[c2][0], points[c3][0], t);\n   50:       let y = interpolate(points[c0][1], points[c1][1], points[c2][1], points[c3][1], t);\n   51:       let z = interpolate(points[c0][2], points[c1][2], points[c2][2], points[c3][2], t);\n   52        subpoints.push([x, y, z]);\n   53      }\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/opencv/sedz6Im82:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/opencv/sedzzP7Ww:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/opencv/disabled/detect_board_charuco.cpp:\n  194        cv::aruco::refineDetectedMarkers(image, board, markerCorners, markerIds, rejectedMarkers, camMatrix, distCoeffs);\n  195  \n  196:     // interpolate charuco corners\n  197:     int interpolatedCorners = 0;\n  198      if(markerIds.size() > 0)\n  199:       interpolatedCorners = cv::aruco::interpolateCornersCharuco(\n  200            markerCorners, markerIds, image, charucoboard, charucoCorners, charucoIds, camMatrix, distCoeffs);\n  201  \n  ...\n  223        cv::aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, cv::noArray(), cv::Scalar(100, 0, 255));\n  224  \n  225:     if(interpolatedCorners > 0) {\n  226        cv::Scalar color;\n  227        color = cv::Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/opencv/disabled/sedOLi7bJ:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/doc/lsd_8c-source.html:\n  599  00592 <span class=\"comment\">    centered on the coordinates of the required sample. In this way,</span>\n  600  00593 <span class=\"comment\">    when applied, it gives directly the result of convolving the image</span>\n  601: 00594 <span class=\"comment\">    with the kernel and interpolated to that particular position.</span>\n  602  00595 <span class=\"comment\"></span>\n  603  00596 <span class=\"comment\">    A fast algorithm is done using the separability of the Gaussian</span>\n  ...\n 1368  01361       <span class=\"comment\">/* update lower y limit (start) for the new 'column'.</span>\n 1369  01362 <span class=\"comment\"></span>\n 1370: 01363 <span class=\"comment\">         We need to interpolate the y value that corresponds to the</span>\n 1371  01364 <span class=\"comment\">         lower side of the rectangle. The first thing is to decide if</span>\n 1372  01365 <span class=\"comment\">         the corresponding side is</span>\n ....\n 1375  01368 <span class=\"comment\">           vx[3],vy[3] to vx[2],vy[2]</span>\n 1376  01369 <span class=\"comment\"></span>\n 1377: 01370 <span class=\"comment\">         Then, the side is interpolated for the x value of the</span>\n 1378  01371 <span class=\"comment\">         'column'. But, if the side is vertical (as it could happen if</span>\n 1379  01372 <span class=\"comment\">         the rectangle is vertical and we are dealing with the first</span>\n ....\n 1388  01381       <span class=\"comment\">/* update upper y limit (end) for the new 'column'.</span>\n 1389  01382 <span class=\"comment\"></span>\n 1390: 01383 <span class=\"comment\">         We need to interpolate the y value that corresponds to the</span>\n 1391  01384 <span class=\"comment\">         upper side of the rectangle. The first thing is to decide if</span>\n 1392  01385 <span class=\"comment\">         the corresponding side is</span>\n ....\n 1395  01388 <span class=\"comment\">           vx[1],vy[1] to vx[2],vy[2]</span>\n 1396  01389 <span class=\"comment\"></span>\n 1397: 01390 <span class=\"comment\">         Then, the side is interpolated for the x value of the</span>\n 1398  01391 <span class=\"comment\">         'column'. But, if the side is vertical (as it could happen if</span>\n 1399  01392 <span class=\"comment\">         the rectangle is vertical and we are dealing with the first</span>\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/doc/lsd_8c.html:\n 1426  <li>sigma = sigma_scale / scale, if scale &lt; 1.0</li><li>sigma = sigma_scale, if scale &gt;= 1.0</li></ul>\n 1427  <p>\n 1428: To be able to sub-sample at non-integer steps, some interpolation is needed. In this implementation, the interpolation is done by the Gaussian kernel, so both operations (filtering and sampling) are done at the same time. The Gaussian kernel is computed centered on the coordinates of the required sample. In this way, when applied, it gives directly the result of convolving the image with the kernel and interpolated to that particular position.<p>\n 1429  A fast algorithm is done using the separability of the Gaussian kernel. Applying the 2D Gaussian kernel is equivalent to applying first a horizontal 1D Gaussian kernel and then a vertical 1D Gaussian kernel (or the other way round). The reason is that <p class=formulaDsp>\n 1430  <img class=formulaDsp alt=\"\\[ G(x,y) = G(x) * G(y) \\]\" src=\"form_1.png\">\n ....\n 4815  01361       <span class=\"comment\">/* update lower y limit (start) for the new 'column'.</span>\n 4816  01362 <span class=\"comment\"></span>\n 4817: 01363 <span class=\"comment\">         We need to interpolate the y value that corresponds to the</span>\n 4818  01364 <span class=\"comment\">         lower side of the rectangle. The first thing is to decide if</span>\n 4819  01365 <span class=\"comment\">         the corresponding side is</span>\n ....\n 4822  01368 <span class=\"comment\">           vx[3],vy[3] to vx[2],vy[2]</span>\n 4823  01369 <span class=\"comment\"></span>\n 4824: 01370 <span class=\"comment\">         Then, the side is interpolated for the x value of the</span>\n 4825  01371 <span class=\"comment\">         'column'. But, if the side is vertical (as it could happen if</span>\n 4826  01372 <span class=\"comment\">         the rectangle is vertical and we are dealing with the first</span>\n ....\n 4835  01381       <span class=\"comment\">/* update upper y limit (end) for the new 'column'.</span>\n 4836  01382 <span class=\"comment\"></span>\n 4837: 01383 <span class=\"comment\">         We need to interpolate the y value that corresponds to the</span>\n 4838  01384 <span class=\"comment\">         upper side of the rectangle. The first thing is to decide if</span>\n 4839  01385 <span class=\"comment\">         the corresponding side is</span>\n ....\n 4842  01388 <span class=\"comment\">           vx[1],vy[1] to vx[2],vy[2]</span>\n 4843  01389 <span class=\"comment\"></span>\n 4844: 01390 <span class=\"comment\">         Then, the side is interpolated for the x value of the</span>\n 4845  01391 <span class=\"comment\">         'column'. But, if the side is vertical (as it could happen if</span>\n 4846  01392 <span class=\"comment\">         the rectangle is vertical and we are dealing with the first</span>\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/doc/tutorials/ios/image_manipulation/image_manipulation.markdown:\n  103                                       provider,                                   //CGDataProviderRef\n  104                                       NULL,                                       //decode\n  105:                                      false,                                      //should interpolate\n  106                                       kCGRenderingIntentDefault                   //intent\n  107                                       );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/doc/colors.markdown:\n  157  ![Bayer patterns (BGGR, GBRG, GRGB, RGGB)](pics/Bayer_patterns.png)\n  158  \n  159: The output RGB components of a pixel are interpolated from 1, 2, or 4 neighbors of the pixel\n  160  having the same color.\n  161  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/opencl/warp_affine.cl:\n  235  #ifdef AMD_DEVICE\n  236  \n  237: inline void interpolateCubic( float x, float* coeffs )\n  238  {\n  239      const float A = -0.75f;\n  ...\n  305          float ayy = INTER_SCALE * ay;\n  306          float axx = INTER_SCALE * ax;\n  307:         interpolateCubic(ayy, tab1y);\n  308:         interpolateCubic(axx, tab1x);\n  309  \n  310          int dst_index = mad24(dy, dst_step, mad24(dx, pixsize, dst_offset));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/opencl/warp_perspective.cl:\n  166  #elif defined INTER_CUBIC\n  167  \n  168: inline void interpolateCubic( float x, float* coeffs )\n  169  {\n  170      const float A = -0.75f;\n  ...\n  208          float ayy = INTER_SCALE * ay;\n  209          float axx = INTER_SCALE * ax;\n  210:         interpolateCubic(ayy, tab1y);\n  211:         interpolateCubic(axx, tab1x);\n  212  \n  213          int dst_index = mad24(dy, dst_step, dst_offset + dx * pixsize);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/photo/src/cuda/nlm.cu:\n   46  #include \"opencv2/core/cuda/functional.hpp\"\n   47  #include \"opencv2/core/cuda/reduce.hpp\"\n   48: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   49  \n   50  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/stitching/src/cuda/build_warp_maps.cu:\n   47  #include \"opencv2/core/cuda/vec_math.hpp\"\n   48  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   49: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   50  \n   51  namespace cv { namespace cuda { namespace device\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/videoio/misc/objc/ios/CvVideoCamera2.mm:\n  493                                       provider,                                   // CGDataProviderRef\n  494                                       NULL,                                       // decode\n  495:                                      false,                                      // should interpolate\n  496                                       kCGRenderingIntentDefault                   // intent\n  497                                       );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/videoio/src/cap_ios_video_camera.mm:\n  559                                       provider,                                   // CGDataProviderRef\n  560                                       NULL,                                       // decode\n  561:                                      false,                                      // should interpolate\n  562                                       kCGRenderingIntentDefault                   // intent\n  563                                       );\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/platforms/js/opencv_js.config.py:\n  169          }\n  170  \n  171: aruco = {'': ['detectMarkers', 'drawDetectedMarkers', 'drawAxis', 'estimatePoseSingleMarkers', 'estimatePoseBoard', 'estimatePoseCharucoBoard', 'interpolateCornersCharuco', 'drawDetectedCornersCharuco'],\n  172          'aruco_Dictionary': ['get', 'drawMarker'],\n  173          'aruco_Board': ['create'],\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp:\n  434   *\n  435   * This function tries to find markers that were not detected in the basic detecMarkers function.\n  436:  * First, based on the current detected marker and the board layout, the function interpolates\n  437   * the position of the missing markers. Then it tries to find correspondence between the reprojected\n  438   * markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n  439   * parameters.\n  440   * If camera parameters and distortion coefficients are provided, missing markers are reprojected\n  441:  * using projectPoint function. If not, missing marker projections are interpolated using global\n  442   * homography, and all the marker corners in the board must have the same Z coordinate.\n  443   */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp:\n  141   * should be sent in corners and ids parameters.\n  142   * @param board layout of ChArUco board.\n  143:  * @param charucoCorners interpolated chessboard corners\n  144:  * @param charucoIds interpolated chessboard corners identifiers\n  145   * @param cameraMatrix optional 3x3 floating-point camera matrix\n  146   * \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n  ...\n  154   * Only visible corners are returned. For each corner, its corresponding identifier is\n  155   * also returned in charucoIds.\n  156:  * The function returns the number of interpolated corners.\n  157   */\n  158: CV_EXPORTS_W int interpolateCornersCharuco(InputArrayOfArrays markerCorners, InputArray markerIds,\n  159                                             InputArray image, const Ptr<CharucoBoard> &board,\n  160                                             OutputArray charucoCorners, OutputArray charucoIds,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/calibrate_camera_charuco.cpp:\n  178          if(refindStrategy) aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  179  \n  180:         // interpolate charuco corners\n  181          Mat currentCharucoCorners, currentCharucoIds;\n  182          if(ids.size() > 0)\n  183:             aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners,\n  184                                               currentCharucoIds);\n  185  \n  ...\n  248  \n  249      for(int i = 0; i < nFrames; i++) {\n  250:         // interpolate using camera parameters\n  251          Mat currentCharucoCorners, currentCharucoIds;\n  252:         aruco::interpolateCornersCharuco(allCorners[i], allIds[i], allImgs[i], charucoboard,\n  253                                           currentCharucoCorners, currentCharucoIds, cameraMatrix,\n  254                                           distCoeffs);\n  ...\n  280      cout << \"Calibration saved to \" << outputFile << endl;\n  281  \n  282:     // show interpolated charuco corners for debugging\n  283      if(showChessboardCorners) {\n  284          for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/detect_board_charuco.cpp:\n  173                                           camMatrix, distCoeffs);\n  174  \n  175:         // interpolate charuco corners\n  176:         int interpolatedCorners = 0;\n  177          if(markerIds.size() > 0)\n  178:             interpolatedCorners =\n  179:                 aruco::interpolateCornersCharuco(markerCorners, markerIds, image, charucoboard,\n  180                                                   charucoCorners, charucoIds, camMatrix, distCoeffs);\n  181  \n  ...\n  207              aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, noArray(), Scalar(100, 0, 255));\n  208  \n  209:         if(interpolatedCorners > 0) {\n  210              Scalar color;\n  211              color = Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/tutorial_charuco_create_detect.cpp:\n   59                  std::vector<cv::Point2f> charucoCorners;\n   60                  std::vector<int> charucoIds;\n   61:                 cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);\n   62                  //! [charidcor]\n   63                  // if at least one charuco corner detected\n   ..\n  110              std::vector<cv::Point2f> charucoCorners;\n  111              std::vector<int> charucoIds;\n  112:             cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds);\n  113              //! [charidcorwc]\n  114              // if at least one charuco corner detected\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/aruco.cpp:\n  749   * @param nContours, contour-container\n  750   */\n  751: static Point3f _interpolate2Dline(const std::vector<cv::Point2f>& nContours){\n  752  \tfloat minX, minY, maxX, maxY;\n  753  \tminX = maxX = nContours[0].x;\n  ...\n  864  \tPoint3f lines[4];\n  865  \tfor(int i=0; i<4; i++){\n  866: \t\tlines[i]=_interpolate2Dline(cntPts[i]);\n  867  \t}\n  868  \n  ...\n 1723          }\n 1724  \n 1725:         // interpolate tiny marker to marker position in markerZone\n 1726          inCorners[0] = Point2f(-0.5f, -0.5f);\n 1727          inCorners[1] = Point2f(marker.cols - 0.5f, -0.5f);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/charuco.cpp:\n  394    * Interpolate charuco corners using approximated pose estimation\n  395    */\n  396: static int _interpolateCornersCharucoApproxCalib(InputArrayOfArrays _markerCorners,\n  397                                                   InputArray _markerIds, InputArray _image,\n  398                                                   const Ptr<CharucoBoard> &_board,\n  ...\n  438    * Interpolate charuco corners using local homography\n  439    */\n  440: static int _interpolateCornersCharucoLocalHom(InputArrayOfArrays _markerCorners,\n  441                                                InputArray _markerIds, InputArray _image,\n  442                                                const Ptr<CharucoBoard> &_board,\n  ...\n  482          Point2f objPoint2D = Point2f(_board->chessboardCorners[i].x, _board->chessboardCorners[i].y);\n  483  \n  484:         vector< Point2f > interpolatedPositions;\n  485          for(unsigned int j = 0; j < _board->nearestMarkerIdx[i].size(); j++) {\n  486              int markerId = _board->ids[_board->nearestMarkerIdx[i][j]];\n  ...\n  498                  in.push_back(objPoint2D);\n  499                  perspectiveTransform(in, out, transformations[markerIdx]);\n  500:                 interpolatedPositions.push_back(out[0]);\n  501              }\n  502          }\n  503  \n  504          // none of the closest markers detected\n  505:         if(interpolatedPositions.size() == 0) continue;\n  506  \n  507          // more than one closest marker detected, take middle point\n  508:         if(interpolatedPositions.size() > 1) {\n  509:             allChessboardImgPoints[i] = (interpolatedPositions[0] + interpolatedPositions[1]) / 2.;\n  510          }\n  511          // a single closest marker detected\n  512:         else allChessboardImgPoints[i] = interpolatedPositions[0];\n  513      }\n  514  \n  ...\n  529  /**\n  530    */\n  531: int interpolateCornersCharuco(InputArrayOfArrays _markerCorners, InputArray _markerIds,\n  532                                InputArray _image, const Ptr<CharucoBoard> &_board,\n  533                                OutputArray _charucoCorners, OutputArray _charucoIds,\n  ...\n  536      // if camera parameters are avaible, use approximated calibration\n  537      if(_cameraMatrix.total() != 0) {\n  538:         _interpolateCornersCharucoApproxCalib(_markerCorners, _markerIds, _image, _board,\n  539                                                       _cameraMatrix, _distCoeffs, _charucoCorners,\n  540                                                       _charucoIds);\n  ...\n  542      // else use local homography\n  543      else {\n  544:         _interpolateCornersCharucoLocalHom(_markerCorners, _markerIds, _image, _board,\n  545                                                    _charucoCorners, _charucoIds);\n  546      }\n  ...\n  791              }\n  792  \n  793:             // interpolate the charuco corners of the diamond\n  794              vector< Point2f > currentMarkerCorners;\n  795              Mat aux;\n  796:             interpolateCornersCharuco(currentMarker, currentMarkerId, grey, _charucoDiamondLayout,\n  797                                        currentMarkerCorners, aux, _cameraMatrix, _distCoeffs);\n  798  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/test/test_charucodetection.cpp:\n  256                  }\n  257  \n  258:                 // interpolate charuco corners\n  259                  vector< Point2f > charucoCorners;\n  260                  vector< int > charucoIds;\n  261  \n  262                  if(iter % 2 == 0) {\n  263:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  264                                                       charucoIds);\n  265                  } else {\n  266:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  267                                                       charucoIds, cameraMatrix, distCoeffs);\n  268                  }\n  ...\n  354                  }\n  355  \n  356:                 // interpolate charuco corners\n  357                  vector< Point2f > charucoCorners;\n  358                  vector< int > charucoIds;\n  359  \n  360                  if(iter % 2 == 0) {\n  361:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  362                                                       charucoIds);\n  363                  } else {\n  364:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  365                                                       charucoIds, cameraMatrix, distCoeffs);\n  366                  }\n  ...\n  719  \n  720      cv::Mat c_ids, c_corners;\n  721:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids, K);\n  722      cv::Mat corners_reshaped = c_corners.reshape(1);\n  723  \n  ...\n  727      c_ids = cv::Mat();\n  728      c_corners = cv::Mat();\n  729:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids);\n  730      corners_reshaped = c_corners.reshape(1);\n  731  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/tutorials/charuco_detection/charuco_detection.markdown:\n   17  ![Charuco definition](images/charucodefinition.png)\n   18  \n   19: The ArUco part is used to interpolate the position of the chessboard corners, so that it has the versatility of marker\n   20: boards, since it allows occlusions or partial views. Moreover, since the interpolated corners belong to a chessboard,\n   21  they are very accurate in terms of subpixel accuracy.\n   22  \n   ..\n  135  - markerIds - vector of identifiers of the detected markers\n  136  - params - marker detection parameters\n  137: The detection of the ChArUco corners is based on the previous detected markers. So that, first markers are detected, and then ChArUco corners are interpolated from markers.\n  138  \n  139  - **Interpolation of charuco corners from markers**\n  ...\n  147  @snippet samples/tutorial_charuco_create_detect.cpp charidcorwc\n  148  \n  149: The function that detect the ChArUco corners is cv::aruco::interpolateCornersCharuco(). This function returns the number of Charuco corners interpolated.\n  150  \n  151  - ```std::vector<cv::Point2f> charucoCorners``` : list of image positions of the detected corners.\n  152  - ```std::vector<int> charucoIds``` : ids for each of the detected corners in ```charucoCorners```.\n  153  \n  154: If calibration parameters are provided, the ChArUco corners are interpolated by, first, estimating a rough pose from the ArUco markers\n  155  and, then, reprojecting the ChArUco corners back to the image.\n  156  \n  157: On the other hand, if calibration parameters are not provided, the ChArUco corners are interpolated by calculating the\n  158  corresponding homography between the ChArUco plane and the ChArUco image projection.\n  159  \n  ...\n  168  Furthermore, only those corners whose two surrounding markers have be found are returned. If any of the two surrounding markers has\n  169  not been detected, this usually means that there is some occlusion or the image quality is not good in that zone. In any case, it is\n  170: preferable not to consider that corner, since what we want is to be sure that the interpolated ChArUco corners are very accurate.\n  171  \n  172: After the ChArUco corners have been interpolated, a subpixel refinement is performed.\n  173  \n  174: Once we have interpolated the ChArUco corners, we would probably want to draw them to see if their detections are correct.\n  175  This can be easily done using the ```drawDetectedCornersCharuco()``` function:\n  176  \n  ...\n  179  - ```imageCopy``` is the image where the corners will be drawn (it will normally be the same image where the corners were detected).\n  180  - The ```outputImage``` will be a clone of ```inputImage``` with the corners drawn.\n  181: - ```charucoCorners``` and ```charucoIds``` are the detected Charuco corners from the ```interpolateCornersCharuco()``` function.\n  182  - Finally, the last parameter is the (optional) color we want to draw the corners with, of type ```cv::Scalar```.\n  183  \n  ...\n  190  ![Charuco board detected](images/chcorners.jpg)\n  191  \n  192: In the presence of occlusion. like in the following image, although some corners are clearly visible, not all their surrounding markers have been detected due occlusion and, thus, they are not interpolated:\n  193  \n  194  ![Charuco detection with occlusion](images/chocclusion.jpg)\n  ...\n  224  @snippet samples/tutorial_charuco_create_detect.cpp pose\n  225  \n  226: - The ```charucoCorners``` and ```charucoIds``` parameters are the detected charuco corners from the ```interpolateCornersCharuco()```\n  227  function.\n  228  - The third parameter is the ```CharucoBoard``` object.\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retina_ocl.cpp:\n 1155      demultiplex(ocl_multiplexed_input, _demultiplexedTempBuffer);\n 1156  \n 1157:     // interpolate the demultiplexed frame depending on the color sampling method\n 1158      if (!adaptiveFiltering)\n 1159      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.cpp:\n  264          _demultiplexedTempBuffer[*(colorSamplingPRT++)]=*(multiplexedColorFramePtr++);\n  265  \n  266:     // interpolate the demultiplexed frame depending on the color sampling method\n  267      if (!adaptiveFiltering)\n  268:         _interpolateImageDemultiplexedImage(&_demultiplexedTempBuffer[0]);\n  269  \n  270      // low pass filtering the demultiplexed frame\n  ...\n  453  }\n  454  \n  455: void RetinaColor::_interpolateImageDemultiplexedImage(float *inputOutputBuffer)\n  456  {\n  457  \n  ...\n  460  \n  461      case RETINA_COLOR_RANDOM:\n  462:         return; // no need to interpolate\n  463          break;\n  464  \n  465      case RETINA_COLOR_DIAGONAL:\n  466:         _interpolateSingleChannelImage111(inputOutputBuffer);\n  467          break;\n  468  \n  469      case RETINA_COLOR_BAYER: // default sets bayer sampling\n  470:         _interpolateBayerRGBchannels(inputOutputBuffer);\n  471          break;\n  472      default:\n  ...\n  479  }\n  480  \n  481: void RetinaColor::_interpolateSingleChannelImage111(float *inputOutputBuffer)\n  482  {\n  483      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows(); ++indexr)\n  ...\n  499  }\n  500  \n  501: void RetinaColor::_interpolateBayerRGBchannels(float *inputOutputBuffer)\n  502  {\n  503      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows()-1; indexr+=2)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.hpp:\n  243          // protected functions\n  244          void _initColorSampling();\n  245:         void _interpolateImageDemultiplexedImage(float *inputOutputBuffer);\n  246:         void _interpolateSingleChannelImage111(float *inputOutputBuffer);\n  247:         void _interpolateBayerRGBchannels(float *inputOutputBuffer);\n  248          void _applyRIFfilter(const float *sourceBuffer, float *destinationBuffer);\n  249          void _getNormalizedContoursImage(const float *inputFrame, float *outputFrame);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudacodec/src/cuda/nv12_to_rgb.cu:\n  141              uint chromaCr = srcImage[chromaOffset + y_chroma * nSourcePitch + x + 1];\n  142  \n  143:             if (y_chroma < ((height >> 1) - 1)) // interpolate chroma vertically\n  144              {\n  145                  chromaCb = (chromaCb + srcImage[chromaOffset + (y_chroma + 1) * nSourcePitch + x    ] + 1) >> 1;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/column_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/filter2d.cu:\n   45  #include \"opencv2/core/cuda/common.hpp\"\n   46  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   47: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   48  \n   49  namespace cv { namespace cuda { namespace device\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/median_filter.cu:\n   52  #include \"opencv2/core/cuda/vec_math.hpp\"\n   53  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   54: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   55  \n   56  namespace cv { namespace cuda { namespace device\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/row_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaimgproc/src/cuda/bilateral_filter.cu:\n   46  #include \"opencv2/core/cuda/vec_traits.hpp\"\n   47  #include \"opencv2/core/cuda/vec_math.hpp\"\n   48: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   49  \n   50  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaimgproc/src/cuda/corners.cu:\n   47  #include \"opencv2/core/cuda/vec_math.hpp\"\n   48  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   49: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   50  \n   51  #include \"opencv2/opencv_modules.hpp\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaimgproc/src/cuda/mean_shift.cu:\n   47  #include \"opencv2/core/cuda/vec_math.hpp\"\n   48  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   49: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   50  \n   51  namespace cv { namespace cuda { namespace device\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy.hpp:\n  219  @param newFrame Output image.\n  220  @param buf Temporary buffer, will have width x 6\\*height size, CV_32FC1 type and contain 6\n  221: GpuMat: occlusion masks for first frame, occlusion masks for second, interpolated forward\n  222: horizontal flow, interpolated forward vertical flow, interpolated backward horizontal flow,\n  223: interpolated backward vertical flow.\n  224  @param stream Stream for the asynchronous version.\n  225   */\n  226: CV_EXPORTS void interpolateFrames(const GpuMat& frame0, const GpuMat& frame1,\n  227                                    const GpuMat& fu, const GpuMat& fv,\n  228                                    const GpuMat& bu, const GpuMat& bv,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy/NCVPyramid.hpp:\n   56      {\n   57          CV_EXPORTS void downsampleX2(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   58:         CV_EXPORTS void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   59      }\n   60  }}}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/image_pyramid.cpp:\n  136          }\n  137  \n  138:         cv::cuda::device::pyramid::interpolateFrom1(lastLayer, outImg, outImg.depth(), outImg.channels(), StreamAccessor::getStream(stream));\n  139      }\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp:\n   48  #if !defined (HAVE_CUDA) || !defined (HAVE_OPENCV_CUDALEGACY) || defined (CUDA_DISABLER)\n   49  \n   50: void cv::cuda::interpolateFrames(const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, float, GpuMat&, GpuMat&, Stream&) { throw_no_cuda(); }\n   51  \n   52  #else\n   53  \n   54: void cv::cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv,\n   55                                  float pos, GpuMat& newFrame, GpuMat& buf, Stream& s)\n   56  {\n   ..\n   71      GpuMat occ1 = buf.rowRange(1 * frame0.rows, 2 * frame0.rows);\n   72  \n   73:     // interpolated forward flow\n   74      GpuMat fui = buf.rowRange(2 * frame0.rows, 3 * frame0.rows);\n   75      GpuMat fvi = buf.rowRange(3 * frame0.rows, 4 * frame0.rows);\n   76  \n   77:     // interpolated backward flow\n   78      GpuMat bui = buf.rowRange(4 * frame0.rows, 5 * frame0.rows);\n   79      GpuMat bvi = buf.rowRange(5 * frame0.rows, 6 * frame0.rows);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/cuda/NCVPyramid.cu:\n  307          }\n  308  \n  309:         void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream)\n  310          {\n  311              typedef void (*func_t)(PtrStepSzb src, PtrStepSzb dst, cudaStream_t stream);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/cuda/NPP_staging.cu:\n 1974          1.0f - pState->pos,\n 1975          bwdU) );\n 1976:     // interpolate frame\n 1977      ncvAssertReturnNcvStat (\n 1978          BlendFrames (pState->pSrcFrame0,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaoptflow/src/cuda/farneback.cu:\n   44  \n   45  #include \"opencv2/core/cuda/common.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  #define tx threadIdx.x\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaoptflow/src/cuda/pyrlk.cu:\n   50  #include \"opencv2/core/cuda/reduce.hpp\"\n   51  #include \"opencv2/core/cuda/filters.hpp\"\n   52: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   53  \n   54  #include <iostream>\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudaoptflow/src/cuda/tvl1flow.cu:\n   44  \n   45  #include \"opencv2/core/cuda/common.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  #include \"opencv2/core/cuda/limits.hpp\"\n   48  #include \"opencv2/core/cuda.hpp\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudawarping/src/cuda/pyr_down.cu:\n   44  \n   45  #include \"opencv2/core/cuda/common.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  #include \"opencv2/core/cuda/vec_traits.hpp\"\n   48  #include \"opencv2/core/cuda/vec_math.hpp\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudawarping/src/cuda/pyr_up.cu:\n   44  \n   45  #include \"opencv2/core/cuda/common.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  #include \"opencv2/core/cuda/vec_traits.hpp\"\n   48  #include \"opencv2/core/cuda/vec_math.hpp\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudawarping/src/cuda/remap.cu:\n   44  \n   45  #include \"opencv2/core/cuda/common.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  #include \"opencv2/core/cuda/vec_traits.hpp\"\n   48  #include \"opencv2/core/cuda/vec_math.hpp\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudawarping/src/cuda/resize.cu:\n   45  #include <cfloat>\n   46  #include \"opencv2/core/cuda/common.hpp\"\n   47: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   48  #include \"opencv2/core/cuda/vec_traits.hpp\"\n   49  #include \"opencv2/core/cuda/vec_math.hpp\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudawarping/src/cuda/warp.cu:\n   44  \n   45  #include \"opencv2/core/cuda/common.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  #include \"opencv2/core/cuda/vec_traits.hpp\"\n   48  #include \"opencv2/core/cuda/vec_math.hpp\"\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/lbph_faces.cpp:\n  241          for(int i=radius; i < src.rows-radius;i++) {\n  242              for(int j=radius;j < src.cols-radius;j++) {\n  243:                 // calculate interpolated value\n  244                  float t = static_cast<float>(w1*src.at<_Tp>(i+fy,j+fx) + w2*src.at<_Tp>(i+fy,j+cx) + w3*src.at<_Tp>(i+cy,j+fx) + w4*src.at<_Tp>(i+cy,j+cx));\n  245                  // floating point precision, so check some machine-dependent epsilon\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/tutorials/face_recognition/face_tutorial.markdown:\n  500  The operator is an extension to the original LBP codes, so it's sometimes called *Extended LBP*\n  501  (also referred to as *Circular LBP*) . If a points coordinate on the circle doesn't correspond to\n  502: image coordinates, the point get's interpolated. Computer science has a bunch of clever\n  503  interpolation schemes, the OpenCV implementation does a bilinear interpolation:\n  504  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlofflow.cpp:\n  218              gd->setFGSSigma(fgs_sigma);\n  219              gd->setUsePostProcessing(use_post_proc);\n  220:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  221          }\n  222          else if (interp_type == InterpolationType::INTERP_RIC)\n  ...\n  230              gd->setUseGlobalSmootherFilter(use_post_proc);\n  231              gd->setUseVariationalRefinement(false);\n  232:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  233          }\n  234          else\n  ...\n  237              GaussianBlur(prevImage, blurredPrevImage, cv::Size(5, 5), -1);\n  238              std::vector<uchar> status(filtered_currPoints.size(), 1);\n  239:             interpolate_irregular_nn_raster(filtered_prevPoints, filtered_currPoints, status, blurredPrevImage).copyTo(dense_flow);\n  240              std::vector<Mat> vecMats;\n  241              std::vector<Mat> vecMats2(2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparsetodenseflow.cpp:\n  106      gd->setFGSLambda(fgs_lambda);\n  107      gd->setFGSSigma (fgs_sigma);\n  108:     gd->interpolate(prev,points_filtered,cur,dst_points_filtered,dense_flow);\n  109  }\n  110  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.cpp:\n  115  }\n  116  \n  117: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n  118      const std::vector<Point2f> & nextPoints,\n  119      const std::vector<uchar> & status,\n  ...\n  241  }\n  242  \n  243: Mat interpolate_irregular_knn(\n  244      const std::vector<Point2f> & _prevPoints,\n  245      const std::vector<Point2f> & _nextPoints,\n  ...\n  401  \n  402  \n  403: Mat interpolate_irregular_nn(\n  404      const std::vector<Point2f> & _prevPoints,\n  405      const std::vector<Point2f> & _nextPoints,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.hpp:\n   12  Mat sgeo_dist(const Mat& gra, int y, int x, float max, Mat &prev);\n   13  Mat sgeo_dist(const Mat& gra, const std::vector<Point2f> & points, float max, Mat &prev);\n   14: Mat interpolate_irregular_nw(const Mat &in, const Mat &mask, const Mat &color_img, float max_d, float bandwidth, float pixeldistance);\n   15: Mat interpolate_irregular_nn(\n   16      const std::vector<Point2f> & prevPoints,\n   17      const std::vector<Point2f> & nextPoints,\n   ..\n   19      const Mat &color_img,\n   20      float pixeldistance);\n   21: Mat interpolate_irregular_knn(\n   22      const std::vector<Point2f> & _prevPoints,\n   23      const std::vector<Point2f> & _nextPoints,\n   ..\n   27      float pixeldistance);\n   28  \n   29: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n   30      const std::vector<Point2f> & nextPoints,\n   31      const std::vector<uchar> & status,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapaffine.cpp:\n   80  \n   81      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   82:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   83      // remap will not touch them).\n   84      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapprojec.cpp:\n   83  \n   84      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   85:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   86      // remap will not touch them).\n   87      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapshift.cpp:\n   81  \n   82      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   83:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   84      // remap will not touch them).\n   85      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/colored_tsdf.cpp:\n   85      virtual RGBTsdfVoxel at(const Vec3i& volumeIdx) const;\n   86  \n   87:     float interpolateVoxel(const cv::Point3f& p) const;\n   88      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   89:     float interpolateColor(float tx, float ty, float tz, float vx[8]) const;\n   90      Point3f getColorVoxel(const cv::Point3f& p) const;\n   91  \n   92  #if USE_INTRINSICS\n   93:     float interpolateVoxel(const v_float32x4& p) const;\n   94      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   95      v_float32x4 getColorVoxel(const v_float32x4& p) const;\n   ..\n  185  #if USE_INTRINSICS\n  186  // all coordinate checks should be done in inclosing cycle\n  187: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  188  {\n  189      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  190:     return interpolateVoxel(p);\n  191  }\n  192  \n  193: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  194  {\n  195      // tx, ty, tz = floor(p)\n  ...\n  232  }\n  233  #else\n  234: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  235  {\n  236      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  384  \n  385  #if USE_INTRINSICS\n  386: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  387  {\n  388      v_float32x4 v0246, v1357;\n  ...\n  402  }\n  403  #else\n  404: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  405  {\n  406      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  463      float ty = t.get0(); t = v_rotate_right<1>(t);\n  464      float tz = t.get0();\n  465:     rgb[0] = interpolateColor(tx, ty, tz, r);\n  466:     rgb[1] = interpolateColor(tx, ty, tz, g);\n  467:     rgb[2] = interpolateColor(tx, ty, tz, b);\n  468      rgb[3] = 0.f;\n  469  #else\n  ...\n  512      float tz = ptVox.z - iptVox[2];\n  513  \n  514:     res=Point3f(interpolateColor(tx, ty, tz, r),\n  515:                 interpolateColor(tx, ty, tz, g),\n  516:                 interpolateColor(tx, ty, tz, b));\n  517  #else\n  518      res=Point3f(volData[coordBase].r, volData[coordBase].g, volData[coordBase].b);\n  ...\n  627                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  628                      v_float32x4 next = (orig + dir * v_setall_f32(tmin));\n  629:                     float f = volume.interpolateVoxel(next), fnext = f;\n  630  \n  631                      //raymarch\n  ...\n  644                          if (fnext != f)\n  645                          {\n  646:                             fnext = volume.interpolateVoxel(next);\n  647  \n  648                              // when ray crosses a surface\n  ...\n  655  \n  656                      // if ray penetrates a surface from outside\n  657:                     // linearly interpolate t between two f values\n  658                      if (f > 0.f && fnext < 0.f)\n  659                      {\n  660                          v_float32x4 tp = next - rayStep;\n  661:                         float ft = volume.interpolateVoxel(tp);\n  662:                         float ftdt = volume.interpolateVoxel(next);\n  663                          float ts = tmin + tstep * (steps - ft / (ftdt - ft));\n  664  \n  ...\n  740                      Point3f rayStep = dir * tstep;\n  741                      Point3f next = (orig + dir * tmin);\n  742:                     float f = volume.interpolateVoxel(next), fnext = f;\n  743  \n  744                      //raymarch\n  ...\n  757                          if(fnext != f)\n  758                          {\n  759:                             fnext = volume.interpolateVoxel(next);\n  760                              // when ray crosses a surface\n  761                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  766                      }\n  767                      // if ray penetrates a surface from outside\n  768:                     // linearly interpolate t between two f values\n  769                      if(f > 0.f && fnext < 0.f)\n  770                      {\n  771                          Point3f tp    = next - rayStep;\n  772:                         float ft   = volume.interpolateVoxel(tp);\n  773:                         float ftdt = volume.interpolateVoxel(next);\n  774                          // float t = tmin + steps*tstep;\n  775                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  893                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  894                  {\n  895:                     //linearly interpolate coordinate\n  896                      float Vn    = Vc + vol.voxelSize;\n  897                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/dynafu_tsdf.cpp:\n   48      virtual void reset() override;\n   49  \n   50:     volumeType interpolateVoxel(cv::Point3f p) const;\n   51      Point3f getNormalVoxel(cv::Point3f p) const;\n   52  \n   ..\n   59  \n   60  private:\n   61:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const;\n   62  };\n   63  \n   ..\n  330  }\n  331  \n  332: inline volumeType TSDFVolumeCPU::interpolateVoxel(Point3f p) const\n  333  {\n  334      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  472                      Point3f rayStep = dir * tstep;\n  473                      Point3f next = (orig + dir * tmin);\n  474:                     volumeType f = volume.interpolateVoxel(next), fnext = f;\n  475  \n  476                      //raymarch\n  ...\n  489                          if(fnext != f)\n  490                          {\n  491:                             fnext = volume.interpolateVoxel(next);\n  492  \n  493                              // when ray crosses a surface\n  ...\n  500  \n  501                      // if ray penetrates a surface from outside\n  502:                     // linearly interpolate t between two f values\n  503                      if(f > 0.f && fnext < 0.f)\n  504                      {\n  505                          Point3f tp = next - rayStep;\n  506:                         volumeType ft   = volume.interpolateVoxel(tp);\n  507:                         volumeType ftdt = volume.interpolateVoxel(next);\n  508                          // float t = tmin + steps*tstep;\n  509                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  621                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  622                  {\n  623:                     //linearly interpolate coordinate\n  624                      float Vn = Vc + vol.voxelSize;\n  625                      float dinv = 1.f/(abs(v0)+abs(vd));\n  ...\n  790      }\n  791  \n  792:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const\n  793      {\n  794          float dV = 0.5f;\n  ...\n  835  \n  836                      if (edgeTable[cubeIndex] & 1)\n  837:                         vertices[0] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[1],\n  838                                                             tsdfValues[0], tsdfValues[1]);\n  839                      if (edgeTable[cubeIndex] & 2)\n  840:                         vertices[1] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[2],\n  841                                                             tsdfValues[1], tsdfValues[2]);\n  842                      if (edgeTable[cubeIndex] & 4)\n  843:                         vertices[2] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[3],\n  844                                                             tsdfValues[2], tsdfValues[3]);\n  845                      if (edgeTable[cubeIndex] & 8)\n  846:                         vertices[3] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[0],\n  847                                                             tsdfValues[3], tsdfValues[0]);\n  848                      if (edgeTable[cubeIndex] & 16)\n  849:                         vertices[4] = basePt + interpolate(mcNeighbourPts[4], mcNeighbourPts[5],\n  850                                                             tsdfValues[4], tsdfValues[5]);\n  851                      if (edgeTable[cubeIndex] & 32)\n  852:                         vertices[5] = basePt + interpolate(mcNeighbourPts[5], mcNeighbourPts[6],\n  853                                                             tsdfValues[5], tsdfValues[6]);\n  854                      if (edgeTable[cubeIndex] & 64)\n  855:                         vertices[6] = basePt + interpolate(mcNeighbourPts[6], mcNeighbourPts[7],\n  856                                                             tsdfValues[6], tsdfValues[7]);\n  857                      if (edgeTable[cubeIndex] & 128)\n  858:                         vertices[7] = basePt + interpolate(mcNeighbourPts[7], mcNeighbourPts[4],\n  859                                                             tsdfValues[7], tsdfValues[4]);\n  860                      if (edgeTable[cubeIndex] & 256)\n  861:                         vertices[8] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[4],\n  862                                                             tsdfValues[0], tsdfValues[4]);\n  863                      if (edgeTable[cubeIndex] & 512)\n  864:                         vertices[9] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[5],\n  865                                                             tsdfValues[1], tsdfValues[5]);\n  866                      if (edgeTable[cubeIndex] & 1024)\n  867:                         vertices[10] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[6],\n  868                                                              tsdfValues[2], tsdfValues[6]);\n  869                      if (edgeTable[cubeIndex] & 2048)\n  870:                         vertices[11] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[7],\n  871                                                              tsdfValues[3], tsdfValues[7]);\n  872  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/fast_icp.cpp:\n  243                      continue;\n  244  \n  245:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  246                  v_float32x4 oldP;\n  247                  v_float32x4 oldN;\n  ...\n  390                      continue;\n  391  \n  392:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  393                  int xi = cvFloor(oldCoords.x), yi = cvFloor(oldCoords.y);\n  394                  float tx  = oldCoords.x - xi, ty = oldCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/hash_tsdf.cpp:\n  126  \n  127  \n  128:     float interpolateVoxelPoint(const Point3f& point) const;\n  129:     float interpolateVoxel(const cv::Point3f& point) const;\n  130      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  131  \n  ...\n  421  \n  422  #if USE_INTRINSICS\n  423: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  424  {\n  425      v_float32x4 v0246, v1357;\n  ...\n  440  \n  441  #else\n  442: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  443  {\n  444      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  454  #endif\n  455  \n  456: float HashTSDFVolumeCPU::interpolateVoxelPoint(const Point3f& point) const\n  457  {\n  458      const Vec3i neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n  ...\n  495      }\n  496  \n  497:     return interpolate(tx, ty, tz, vx);\n  498  }\n  499  \n  500: inline float HashTSDFVolumeCPU::interpolateVoxel(const cv::Point3f& point) const\n  501  {\n  502:     return interpolateVoxelPoint(point * voxelSizeInv);\n  503  }\n  504  \n  ...\n  631      float tz = ptVox.z - iptVox[2];\n  632  \n  633:     normal[0] = interpolate(tx, ty, tz, cxv);\n  634:     normal[1] = interpolate(tx, ty, tz, cyv);\n  635:     normal[2] = interpolate(tx, ty, tz, czv);\n  636  #endif\n  637  \n  ...\n  921  \n  922  \n  923:     float interpolateVoxelPoint(const Point3f& point) const;\n  924:     float interpolateVoxel(const cv::Point3f& point) const;\n  925      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  926  \n  ...\n 1380  }\n 1381  \n 1382: float HashTSDFVolumeGPU::interpolateVoxelPoint(const Point3f& point) const\n 1383  {\n 1384      const Vec3i local_neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n ....\n 1421      }\n 1422  \n 1423:     return interpolate(tx, ty, tz, vx);\n 1424  }\n 1425  \n 1426: inline float HashTSDFVolumeGPU::interpolateVoxel(const cv::Point3f& point) const\n 1427  {\n 1428:     return interpolateVoxelPoint(point * voxelSizeInv);\n 1429  }\n 1430  \n ....\n 1556      float tz = ptVox.z - iptVox[2];\n 1557  \n 1558:     normal[0] = interpolate(tx, ty, tz, cxv);\n 1559:     normal[1] = interpolate(tx, ty, tz, cyv);\n 1560:     normal[2] = interpolate(tx, ty, tz, czv);\n 1561  #endif\n 1562      float nv = sqrt(normal[0] * normal[0] +\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/nonrigid_icp.cpp:\n  306                  continue;\n  307  \n  308:             // TODO: interpolate Vg instead of simply converting projected coords to int\n  309              Vg.at<Vec3f>(y, x) = vertImage.at<Vec3f>((int)newCoords.y, (int)newCoords.x);\n  310  \n  311:             // bilinearly interpolate newPoints under newCoords point\n  312              int xi = cvFloor(newCoords.x), yi = cvFloor(newCoords.y);\n  313              float tx  = newCoords.x - xi, ty = newCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.cpp:\n  137  #if USE_INTRINSICS\n  138  // all coordinate checks should be done in inclosing cycle\n  139: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  140  {\n  141      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  142:     return interpolateVoxel(p);\n  143  }\n  144  \n  145: inline float TSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  146  {\n  147      // tx, ty, tz = floor(p)\n  ...\n  184  }\n  185  #else\n  186: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  187  {\n  188      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  438                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  439                      v_float32x4 next    = (orig + dir * v_setall_f32(tmin));\n  440:                     float f = volume.interpolateVoxel(next), fnext = f;\n  441  \n  442                      //raymarch\n  ...\n  455                          if(fnext != f)\n  456                          {\n  457:                             fnext = volume.interpolateVoxel(next);\n  458  \n  459                              // when ray crosses a surface\n  ...\n  466  \n  467                      // if ray penetrates a surface from outside\n  468:                     // linearly interpolate t between two f values\n  469                      if(f > 0.f && fnext < 0.f)\n  470                      {\n  471                          v_float32x4 tp = next - rayStep;\n  472:                         float ft    = volume.interpolateVoxel(tp);\n  473:                         float ftdt  = volume.interpolateVoxel(next);\n  474                          float ts = tmin + tstep*(steps - ft/(ftdt - ft));\n  475  \n  ...\n  547                      Point3f rayStep = dir * tstep;\n  548                      Point3f next = (orig + dir * tmin);\n  549:                     float f = volume.interpolateVoxel(next), fnext = f;\n  550  \n  551                      //raymarch\n  ...\n  564                          if(fnext != f)\n  565                          {\n  566:                             fnext = volume.interpolateVoxel(next);\n  567                              // when ray crosses a surface\n  568                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  573                      }\n  574                      // if ray penetrates a surface from outside\n  575:                     // linearly interpolate t between two f values\n  576                      if(f > 0.f && fnext < 0.f)\n  577                      {\n  578                          Point3f tp    = next - rayStep;\n  579:                         float ft   = volume.interpolateVoxel(tp);\n  580:                         float ftdt = volume.interpolateVoxel(next);\n  581                          // float t = tmin + steps*tstep;\n  582                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  692                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  693                  {\n  694:                     //linearly interpolate coordinate\n  695                      float Vn    = Vc + vol.voxelSize;\n  696                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.hpp:\n   74      virtual TsdfVoxel at(const Vec3i& volumeIdx) const;\n   75  \n   76:     float interpolateVoxel(const cv::Point3f& p) const;\n   77      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   78  \n   79  #if USE_INTRINSICS\n   80:     float interpolateVoxel(const v_float32x4& p) const;\n   81      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   82  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf_functions.cpp:\n  249  \n  250                      depthType v;\n  251:                     // bilinearly interpolate depth at projected\n  252                      {\n  253                          const v_float32x4& pt = projected;\n  ...\n  284                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  285                              v_float32x4 ty = v_setall_f32(t.get0());\n  286:                             // vx is y-interpolated between rows 0 and 1\n  287                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  288                              float v0 = vx.get0();\n  ...\n  514  \n  515                      depthType v;\n  516:                     // bilinearly interpolate depth at projected\n  517                      {\n  518                          const v_float32x4& pt = projected;\n  ...\n  549                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  550                              v_float32x4 ty = v_setall_f32(t.get0());\n  551:                             // vx is y-interpolated between rows 0 and 1\n  552                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  553                              float v0 = vx.get0();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/warpfield.cpp:\n  212  \n  213          Affine3f pose = DQB(weights, transforms);\n  214:         // linearly interpolate translations\n  215          Vec3f translation(0,0,0);\n  216          float totalWeight = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/opencl/hash_tsdf.cl:\n  157  \n  158          float v;\n  159:         // bilinearly interpolate depth at projected\n  160          if(all(projected >= 0) && all(projected < limits))\n  161          {\n  ...\n  352  }\n  353  \n  354: inline float interpolate(float3 t, float8 vz)\n  355  {\n  356      float4 vy = mix(vz.s0246, vz.s1357, t.z);\n  ...\n  465  \n  466      float3 tv = ptVox - fip;\n  467:     normal.x = interpolate(tv, cx);\n  468:     normal.y = interpolate(tv, cy);\n  469:     normal.z = interpolate(tv, cz);\n  470  #endif\n  471  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/opencl/icp.cl:\n   75          return;\n   76  \n   77:     // bilinearly interpolate oldPts and oldNrm under oldCoords point\n   78      float3 oldP, oldN;\n   79      float2 ip = floor(oldCoords);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/opencl/tsdf.cl:\n  118  \n  119          float v;\n  120:         // bilinearly interpolate depth at projected\n  121          if(all(projected >= 0) && all(projected < limits))\n  122          {\n  ...\n  181  \n  182  \n  183: inline float interpolateVoxel(float3 p, __global const struct TsdfVoxel* volumePtr,\n  184                                int3 volDims, int8 neighbourCoords)\n  185  {\n  ...\n  340          float3 rayStep = dir*tstep;\n  341          float3 next = (orig + dir*tmin);\n  342:         float f = interpolateVoxel(next, volumeptr, volDims, neighbourCoords);\n  343          float fnext = f;\n  344  \n  ...\n  362                  if(fnext != f)\n  363                  {\n  364:                     fnext = interpolateVoxel(next, volumeptr, volDims, neighbourCoords);\n  365  \n  366                      // when ray crosses a surface\n  ...\n  377  \n  378          // if ray penetrates a surface from outside\n  379:         // linearly interpolate t between two f values\n  380          if(f > 0 && fnext < 0)\n  381          {\n  382              float3 tp = next - rayStep;\n  383:             float ft   = interpolateVoxel(tp,   volumeptr, volDims, neighbourCoords);\n  384:             float ftdt = interpolateVoxel(next, volumeptr, volDims, neighbourCoords);\n  385              // float t = tmin + steps*tstep;\n  386              // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  544                  if(!scan)\n  545                  {\n  546:                     // linearly interpolate coordinate\n  547                      float Vn = Vc + voxelSize;\n  548                      float dinv = 1.f/(fabs(v0)+fabs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/include/opencv2/viz/widgets.hpp:\n  665              @param radius Radius of the spheres.\n  666              @param from Color for first sphere.\n  667:             @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  668               */\n  669              WTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/misc/python/python_viz.hpp:\n  841      @param radius Radius of the spheres.\n  842      @param from Color for first sphere.\n  843:     @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  844       */\n  845      CV_WRAP PyWTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/daisy.cpp:\n  371  \n  372  \n  373: static float interpolate_peak( float left, float center, float right )\n  374  {\n  375      if( center < 0.0 )\n  ...\n 1409                 next -= m_orientation_resolution;\n 1410  \n 1411:             peak = interpolate_peak(hist.at<float>(prev), hist.at<float>(max_ind), hist.at<float>(next));\n 1412              angle = (float)( ((float)max_ind + peak)*360.0/m_orientation_resolution );\n 1413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/msd.cpp:\n  263               * @param scale scale of the key-point over the image pyramid\n  264               * @param saliency pointer to the saliency array\n  265:              * @param p_res interpolated coordinates of the key-point referred to the lowest level of the pyramid (i.e. in the ref. frame of the input image)\n  266               * @return false if the current key-point has to be rejected, true otherwise\n  267               */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.cpp:\n  220   * approximated using central differences. The linear system Ax = b is then\n  221   * solved, where A is the Hessian, b is the negative gradient, and x is the\n  222:  * offset of the interpolated maxima coordinates from the initial estimate.\n  223   * This is equivalent to an iteration of Netwon's optimisation algorithm.\n  224   *\n  ...\n  232   */\n  233  static int\n  234: interpolateKeypoint( float N9[3][9], int dx, int dy, int ds, KeyPoint& kpt )\n  235  {\n  236      Vec3f b(-(N9[1][5]-N9[1][3])/2,  // Negative 1st deriv with respect to x\n  ...\n  433                      /* Interpolate maxima location within the 3x3x3 neighbourhood  */\n  434                      int ds = size - sizes[layer-1];\n  435:                     int interp_ok = interpolateKeypoint( N9, sampleStep, sampleStep, ds, kpt );\n  436  \n  437                      /* Sometimes the interpolation step gives a negative size etc. */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.hpp:\n  116      bool findMaximaInLayer(int counterOffset, int octave, int layer_rows, int layer_cols);\n  117  \n  118:     bool interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int maxFeatures);\n  119  \n  120      bool calcOrientation(UMat &keypoints);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.ocl.cpp:\n  187          if (maxCounter > 0)\n  188          {\n  189:             if(!interpolateKeypoint(maxCounter, keypoints, octave, layer_rows, maxFeatures))\n  190                  return false;\n  191          }\n  ...\n  431  }\n  432  \n  433: bool SURF_OCL::interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int max_features)\n  434  {\n  435      size_t localThreads[3]  = {3, 3, 3};\n  436      size_t globalThreads[3] = {maxCounter*localThreads[0], localThreads[1], 3};\n  437  \n  438:     ocl::Kernel kerInterp(\"SURF_interpolateKeypoint\", ocl::xfeatures2d::surf_oclsrc, kerOpts);\n  439  \n  440      return kerInterp.args(ocl::KernelArg::ReadOnlyNoSize(det),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/opencl/surf.cl:\n  453  // INTERPOLATION\n  454  __kernel\n  455: void SURF_interpolateKeypoint(\n  456      __global const float * det,\n  457      int det_step, int det_offset,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp:\n   67      @param dense_flow output dense matching (two-channel CV_32F image)\n   68       */\n   69:     CV_WRAP virtual void interpolate(InputArray from_image, InputArray from_points,\n   70                                       InputArray to_image  , InputArray to_points,\n   71                                       OutputArray dense_flow) = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/misc/python/test/test_sparse_match_interpolator.py:\n   27          interpolator.setFGSSigma(1.5)\n   28  \n   29:         dense_flow = interpolator.interpolate(src, from_points, src, to_points)\n   30  \n   31          self.assertTrue(cv.norm(dense_flow, ref_flow, cv.NORM_INF) <= MAX_DIF)\n   ..\n   64          interpolator.setFGSLambda(500.0)\n   65          interpolator.setFGSSigma(1.5)\n   66:         dense_flow = interpolator.interpolate(src0, from_points, src1, to_points)\n   67          self.assertTrue(cv.norm(dense_flow, ref_flow, cv.NORM_INF) <= MAX_DIF)\n   68          self.assertTrue(cv.norm(dense_flow, ref_flow, cv.NORM_L1) <= (MAX_MEAN_DIF * dense_flow.shape[0] * dense_flow.shape[1]))\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 2199              /* update lower y limit (start) for the new 'column'.\n 2200  \n 2201:             We need to interpolate the y value that corresponds to the\n 2202              lower side of the rectangle. The first thing is to decide if\n 2203              the corresponding side is\n ....\n 2206              vx[3],vy[3] to vx[2],vy[2]\n 2207  \n 2208:             Then, the side is interpolated for the x value of the\n 2209              'column'. But, if the side is vertical (as it could happen if\n 2210              the rectangle is vertical and we are dealing with the first\n ....\n 2245              /* update upper y limit (end) for the new 'column'.\n 2246  \n 2247:             We need to interpolate the y value that corresponds to the\n 2248              upper side of the rectangle. The first thing is to decide if\n 2249              the corresponding side is\n ....\n 2252              vx[1],vy[1] to vx[2],vy[2]\n 2253  \n 2254:             Then, the side is interpolated for the x value of the\n 2255              'column'. But, if the side is vertical (as it could happen if\n 2256              the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/sparse_match_interpolators.cpp:\n   78  public:\n   79      static Ptr<EdgeAwareInterpolatorImpl> create();\n   80:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n   81  \n   82  protected:\n   ..\n  171  }\n  172  \n  173: void EdgeAwareInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray, InputArray to_points, OutputArray dense_flow)\n  174  {\n  175      CV_Assert( !from_image.empty() && (from_image.depth() == CV_8U) && (from_image.channels() == 3 || from_image.channels() == 1) );\n  ...\n  906  public:\n  907      static Ptr<RICInterpolatorImpl> create();\n  908:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n  909  \n  910  protected:\n  ...\n 1109  };\n 1110  \n 1111: void RICInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow)\n 1112  {\n 1113      CV_Assert(!from_image.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_sparse_match_interpolator.cpp:\n   90      interpolator->setFGSLambda(500.0f);\n   91      interpolator->setFGSSigma(1.5f);\n   92:     interpolator->interpolate(src,from_points,Mat(),to_points,res_flow);\n   93  \n   94      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n   ..\n   97      Mat from_point_mat(from_points);\n   98      Mat to_points_mat(to_points);\n   99:     interpolator->interpolate(src,from_point_mat,Mat(),to_points_mat,res_flow);\n  100  \n  101      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  146      interpolator->setFGSLambda(500.f);\n  147      interpolator->setFGSSigma(1.5f);\n  148:     interpolator->interpolate(src, from_points, src1, to_points, res_flow);\n  149  \n  150      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  153      Mat from_point_mat(from_points);\n  154      Mat to_points_mat(to_points);\n  155:     interpolator->interpolate(src, from_point_mat, src1, to_points_mat, res_flow);\n  156  \n  157      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  205          cv::setNumThreads(nThreads);\n  206          Mat resMultiThread;\n  207:         interpolator->interpolate(from,from_points,Mat(),to_points,resMultiThread);\n  208  \n  209          cv::setNumThreads(1);\n  210          Mat resSingleThread;\n  211:         interpolator->interpolate(from,from_points,Mat(),to_points,resSingleThread);\n  212  \n  213          EXPECT_LE(cv::norm(resSingleThread, resMultiThread, NORM_INF), MAX_DIF);\n\n/home/roman/Projects/plot-cv/quickjs/curl.static:\n    <binary>\n\n/home/roman/Projects/plot-cv/quickjs/opencv-4.5.4-xenial.tar.gz:\n    File too large, skipping\n\n/home/roman/Projects/plot-cv/quickjs/qjscalc:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/deps/nuklear.h:\n 11414                      scy = y;\n 11415                      if (!(vertices[off+i+1].type & 1)) {\n 11416:                         /* next point is also a curve point, so interpolate an on-point curve */\n 11417                          sx = (x + (nk_int) vertices[off+i+1].x) >> 1;\n 11418                          sy = (y + (nk_int) vertices[off+i+1].y) >> 1;\n .....\n 11434                  if (!(flags & 1))\n 11435                  { /* if it's a curve */\n 11436:                     if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */\n 11437                          nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 11438                      cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/imstb_truetype.h:\n 1741                 scy = y;\n 1742                 if (!(vertices[off+i+1].type & 1)) {\n 1743:                   // next point is also a curve point, so interpolate an on-point curve\n 1744                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1745                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1760           } else {\n 1761              if (!(flags & 1)) { // if it's a curve\n 1762:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1763                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1764                 cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-modules/glGet.xml:\n 1925                    the maximum number of interpolators available for processing varying variables used by\n 1926                    vertex and fragment shaders. This value represents the number of vector\n 1927:                   values that can be interpolated; varying variables declared as matrices and arrays\n 1928                    will consume multiple interpolators. The value must be at least 15.\n 1929                </p>\n\n/home/roman/Projects/plot-cv/quickjs/qjs-modules/glTexParameter.xml:\n 1216                    <mi mathvariant=\"italic\">r</mi>\n 1217                  </math>\n 1218:                 is the current interpolated texture coordinate, and\n 1219                  <math overflow=\"scroll\">\n 1220                    <msub>\n ....\n 1258                    <dd>\n 1259                      <p>\n 1260:                       Specifies that the interpolated and clamped\n 1261                        <math overflow=\"scroll\">\n 1262                          <mi mathvariant=\"italic\">r</mi>\n\n/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test3.xml:\n 1925                    the maximum number of interpolators available for processing varying variables used by\n 1926                    vertex and fragment shaders. This value represents the number of vector\n 1927:                   values that can be interpolated; varying variables declared as matrices and arrays\n 1928                    will consume multiple interpolators. The value must be at least 15.\n 1929                </p>\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/nanovg.h:\n  196  \n  197  \n  198: // Linearly interpolates from color c0 to c1, and returns resulting color value.\n  199  NVGcolor nvgLerpRGBA(NVGcolor c0, NVGcolor c1, float u);\n  200  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_image.h:\n 1443  //        - allows good upsampling (see next)\n 1444  //    high-quality\n 1445: //      - upsampled channels are bilinearly interpolated, even across blocks\n 1446  //      - quality integer IDCT derived from IJG's 'slow'\n 1447  //    performance\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_truetype.h:\n 1771                 scy = y;\n 1772                 if (!(vertices[off+i+1].type & 1)) {\n 1773:                   // next point is also a curve point, so interpolate an on-point curve\n 1774                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1775                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1790           } else {\n 1791              if (!(flags & 1)) { // if it's a curve\n 1792:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1793                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1794                 cx = x;\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/uftrace.data/3720907.dat:\n    File too large, skipping\n\n/home/roman/Projects/plot-cv/uftrace.data/libgmp.so.10.sym:\n  466  0000000000051f20 T __gmpn_toom_eval_pm2exp\n  467  00000000000521f0 T __gmpn_toom_eval_pm2rexp\n  468: 0000000000052480 T __gmpn_toom_interpolate_5pts\n  469: 0000000000052700 T __gmpn_toom_interpolate_6pts\n  470: 0000000000052b70 T __gmpn_toom_interpolate_7pts\n  471: 00000000000530d0 T __gmpn_toom_interpolate_8pts\n  472: 00000000000537b0 T __gmpn_toom_interpolate_12pts\n  473: 0000000000054820 T __gmpn_toom_interpolate_16pts\n  474  00000000000560e0 T __gmpn_ni_invertappr\n  475  00000000000567a0 T __gmpn_invertappr\n\n429 matches across 128 files\n\n\nSearching 0 files for \"interpolate\" (regex, case sensitive)\n\n0 matches\n\nSearching 10264 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/libwebsockets/lib/drivers/led/led-seq.c:\n   27  \n   28  /*\n   29:  * 64 entry interpolated CIE correction\n   30   * https://en.wikipedia.org/wiki/Lightness\n   31   */\n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/libwebsockets/lib/drivers/pwm/pwm.c:\n   33  \t    0,   158,   630,  1411,  2494,  3869,  5522,  7437,\n   34  \t 9597, 11980, 14562, 17321, 20228, 23225, 26374, 29555,\n   35: \t32767 /* to interpolate against */\n   36  };\n   37  \n   38  /*\n   39   * Elaborate the 90 degree phase table to 360 degrees and offset to +32768,\n   40:  * notice for the last sample we have to interpolate against a 17th sample\n   41   * reflecting full scale to avoid clipping due to interpolation against the\n   42   * 16th sample again\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/deps/nuklear.h:\n 11414                      scy = y;\n 11415                      if (!(vertices[off+i+1].type & 1)) {\n 11416:                         /* next point is also a curve point, so interpolate an on-point curve */\n 11417                          sx = (x + (nk_int) vertices[off+i+1].x) >> 1;\n 11418                          sy = (y + (nk_int) vertices[off+i+1].y) >> 1;\n .....\n 11434                  if (!(flags & 1))\n 11435                  { /* if it's a curve */\n 11436:                     if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */\n 11437                          nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 11438                      cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/imstb_truetype.h:\n 1741                 scy = y;\n 1742                 if (!(vertices[off+i+1].type & 1)) {\n 1743:                   // next point is also a curve point, so interpolate an on-point curve\n 1744                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1745                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1760           } else {\n 1761              if (!(flags & 1)) { // if it's a curve\n 1762:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1763                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1764                 cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_image.h:\n 1443  //        - allows good upsampling (see next)\n 1444  //    high-quality\n 1445: //      - upsampled channels are bilinearly interpolated, even across blocks\n 1446  //      - quality integer IDCT derived from IJG's 'slow'\n 1447  //    performance\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/nanovg.h:\n  196  \n  197  \n  198: // Linearly interpolates from color c0 to c1, and returns resulting color value.\n  199  NVGcolor nvgLerpRGBA(NVGcolor c0, NVGcolor c1, float u);\n  200  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_truetype.h:\n 1771                 scy = y;\n 1772                 if (!(vertices[off+i+1].type & 1)) {\n 1773:                   // next point is also a curve point, so interpolate an on-point curve\n 1774                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1775                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1790           } else {\n 1791              if (!(flags & 1)) { // if it's a curve\n 1792:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1793                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1794                 cx = x;\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/opencv/disabled/detect_board_charuco.cpp:\n  194        cv::aruco::refineDetectedMarkers(image, board, markerCorners, markerIds, rejectedMarkers, camMatrix, distCoeffs);\n  195  \n  196:     // interpolate charuco corners\n  197:     int interpolatedCorners = 0;\n  198      if(markerIds.size() > 0)\n  199:       interpolatedCorners = cv::aruco::interpolateCornersCharuco(\n  200            markerCorners, markerIds, image, charucoboard, charucoCorners, charucoIds, camMatrix, distCoeffs);\n  201  \n  ...\n  223        cv::aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, cv::noArray(), cv::Scalar(100, 0, 255));\n  224  \n  225:     if(interpolatedCorners > 0) {\n  226        cv::Scalar color;\n  227        color = cv::Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/imgui/imstb_truetype.h:\n 1934            scy = y;\n 1935            if(!(vertices[off + i + 1].type & 1)) {\n 1936:             // next point is also a curve point, so interpolate an on-point curve\n 1937              sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;\n 1938              sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;\n ....\n 1953        } else {\n 1954          if(!(flags & 1)) { // if it's a curve\n 1955:           if(was_off)      // two off-curve control points in a row means interpolate an on-curve\n 1956                             // midpoint\n 1957              stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.hpp:\n  116      bool findMaximaInLayer(int counterOffset, int octave, int layer_rows, int layer_cols);\n  117  \n  118:     bool interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int maxFeatures);\n  119  \n  120      bool calcOrientation(UMat &keypoints);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/msd.cpp:\n  263               * @param scale scale of the key-point over the image pyramid\n  264               * @param saliency pointer to the saliency array\n  265:              * @param p_res interpolated coordinates of the key-point referred to the lowest level of the pyramid (i.e. in the ref. frame of the input image)\n  266               * @return false if the current key-point has to be rejected, true otherwise\n  267               */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.ocl.cpp:\n  187          if (maxCounter > 0)\n  188          {\n  189:             if(!interpolateKeypoint(maxCounter, keypoints, octave, layer_rows, maxFeatures))\n  190                  return false;\n  191          }\n  ...\n  431  }\n  432  \n  433: bool SURF_OCL::interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int max_features)\n  434  {\n  435      size_t localThreads[3]  = {3, 3, 3};\n  436      size_t globalThreads[3] = {maxCounter*localThreads[0], localThreads[1], 3};\n  437  \n  438:     ocl::Kernel kerInterp(\"SURF_interpolateKeypoint\", ocl::xfeatures2d::surf_oclsrc, kerOpts);\n  439  \n  440      return kerInterp.args(ocl::KernelArg::ReadOnlyNoSize(det),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/daisy.cpp:\n  371  \n  372  \n  373: static float interpolate_peak( float left, float center, float right )\n  374  {\n  375      if( center < 0.0 )\n  ...\n 1409                 next -= m_orientation_resolution;\n 1410  \n 1411:             peak = interpolate_peak(hist.at<float>(prev), hist.at<float>(max_ind), hist.at<float>(next));\n 1412              angle = (float)( ((float)max_ind + peak)*360.0/m_orientation_resolution );\n 1413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.cpp:\n  220   * approximated using central differences. The linear system Ax = b is then\n  221   * solved, where A is the Hessian, b is the negative gradient, and x is the\n  222:  * offset of the interpolated maxima coordinates from the initial estimate.\n  223   * This is equivalent to an iteration of Netwon's optimisation algorithm.\n  224   *\n  ...\n  232   */\n  233  static int\n  234: interpolateKeypoint( float N9[3][9], int dx, int dy, int ds, KeyPoint& kpt )\n  235  {\n  236      Vec3f b(-(N9[1][5]-N9[1][3])/2,  // Negative 1st deriv with respect to x\n  ...\n  433                      /* Interpolate maxima location within the 3x3x3 neighbourhood  */\n  434                      int ds = size - sizes[layer-1];\n  435:                     int interp_ok = interpolateKeypoint( N9, sampleStep, sampleStep, ds, kpt );\n  436  \n  437                      /* Sometimes the interpolation step gives a negative size etc. */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparsetodenseflow.cpp:\n  106      gd->setFGSLambda(fgs_lambda);\n  107      gd->setFGSSigma (fgs_sigma);\n  108:     gd->interpolate(prev,points_filtered,cur,dst_points_filtered,dense_flow);\n  109  }\n  110  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlofflow.cpp:\n  218              gd->setFGSSigma(fgs_sigma);\n  219              gd->setUsePostProcessing(use_post_proc);\n  220:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  221          }\n  222          else if (interp_type == InterpolationType::INTERP_RIC)\n  ...\n  230              gd->setUseGlobalSmootherFilter(use_post_proc);\n  231              gd->setUseVariationalRefinement(false);\n  232:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  233          }\n  234          else\n  ...\n  237              GaussianBlur(prevImage, blurredPrevImage, cv::Size(5, 5), -1);\n  238              std::vector<uchar> status(filtered_currPoints.size(), 1);\n  239:             interpolate_irregular_nn_raster(filtered_prevPoints, filtered_currPoints, status, blurredPrevImage).copyTo(dense_flow);\n  240              std::vector<Mat> vecMats;\n  241              std::vector<Mat> vecMats2(2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.cpp:\n  115  }\n  116  \n  117: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n  118      const std::vector<Point2f> & nextPoints,\n  119      const std::vector<uchar> & status,\n  ...\n  241  }\n  242  \n  243: Mat interpolate_irregular_knn(\n  244      const std::vector<Point2f> & _prevPoints,\n  245      const std::vector<Point2f> & _nextPoints,\n  ...\n  401  \n  402  \n  403: Mat interpolate_irregular_nn(\n  404      const std::vector<Point2f> & _prevPoints,\n  405      const std::vector<Point2f> & _nextPoints,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.hpp:\n   12  Mat sgeo_dist(const Mat& gra, int y, int x, float max, Mat &prev);\n   13  Mat sgeo_dist(const Mat& gra, const std::vector<Point2f> & points, float max, Mat &prev);\n   14: Mat interpolate_irregular_nw(const Mat &in, const Mat &mask, const Mat &color_img, float max_d, float bandwidth, float pixeldistance);\n   15: Mat interpolate_irregular_nn(\n   16      const std::vector<Point2f> & prevPoints,\n   17      const std::vector<Point2f> & nextPoints,\n   ..\n   19      const Mat &color_img,\n   20      float pixeldistance);\n   21: Mat interpolate_irregular_knn(\n   22      const std::vector<Point2f> & _prevPoints,\n   23      const std::vector<Point2f> & _nextPoints,\n   ..\n   27      float pixeldistance);\n   28  \n   29: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n   30      const std::vector<Point2f> & nextPoints,\n   31      const std::vector<uchar> & status,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_sparse_match_interpolator.cpp:\n   90      interpolator->setFGSLambda(500.0f);\n   91      interpolator->setFGSSigma(1.5f);\n   92:     interpolator->interpolate(src,from_points,Mat(),to_points,res_flow);\n   93  \n   94      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n   ..\n   97      Mat from_point_mat(from_points);\n   98      Mat to_points_mat(to_points);\n   99:     interpolator->interpolate(src,from_point_mat,Mat(),to_points_mat,res_flow);\n  100  \n  101      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  146      interpolator->setFGSLambda(500.f);\n  147      interpolator->setFGSSigma(1.5f);\n  148:     interpolator->interpolate(src, from_points, src1, to_points, res_flow);\n  149  \n  150      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  153      Mat from_point_mat(from_points);\n  154      Mat to_points_mat(to_points);\n  155:     interpolator->interpolate(src, from_point_mat, src1, to_points_mat, res_flow);\n  156  \n  157      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  205          cv::setNumThreads(nThreads);\n  206          Mat resMultiThread;\n  207:         interpolator->interpolate(from,from_points,Mat(),to_points,resMultiThread);\n  208  \n  209          cv::setNumThreads(1);\n  210          Mat resSingleThread;\n  211:         interpolator->interpolate(from,from_points,Mat(),to_points,resSingleThread);\n  212  \n  213          EXPECT_LE(cv::norm(resSingleThread, resMultiThread, NORM_INF), MAX_DIF);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp:\n   67      @param dense_flow output dense matching (two-channel CV_32F image)\n   68       */\n   69:     CV_WRAP virtual void interpolate(InputArray from_image, InputArray from_points,\n   70                                       InputArray to_image  , InputArray to_points,\n   71                                       OutputArray dense_flow) = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/sparse_match_interpolators.cpp:\n   78  public:\n   79      static Ptr<EdgeAwareInterpolatorImpl> create();\n   80:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n   81  \n   82  protected:\n   ..\n  171  }\n  172  \n  173: void EdgeAwareInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray, InputArray to_points, OutputArray dense_flow)\n  174  {\n  175      CV_Assert( !from_image.empty() && (from_image.depth() == CV_8U) && (from_image.channels() == 3 || from_image.channels() == 1) );\n  ...\n  906  public:\n  907      static Ptr<RICInterpolatorImpl> create();\n  908:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n  909  \n  910  protected:\n  ...\n 1109  };\n 1110  \n 1111: void RICInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow)\n 1112  {\n 1113      CV_Assert(!from_image.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 2199              /* update lower y limit (start) for the new 'column'.\n 2200  \n 2201:             We need to interpolate the y value that corresponds to the\n 2202              lower side of the rectangle. The first thing is to decide if\n 2203              the corresponding side is\n ....\n 2206              vx[3],vy[3] to vx[2],vy[2]\n 2207  \n 2208:             Then, the side is interpolated for the x value of the\n 2209              'column'. But, if the side is vertical (as it could happen if\n 2210              the rectangle is vertical and we are dealing with the first\n ....\n 2245              /* update upper y limit (end) for the new 'column'.\n 2246  \n 2247:             We need to interpolate the y value that corresponds to the\n 2248              upper side of the rectangle. The first thing is to decide if\n 2249              the corresponding side is\n ....\n 2252              vx[1],vy[1] to vx[2],vy[2]\n 2253  \n 2254:             Then, the side is interpolated for the x value of the\n 2255              'column'. But, if the side is vertical (as it could happen if\n 2256              the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/nonrigid_icp.cpp:\n  306                  continue;\n  307  \n  308:             // TODO: interpolate Vg instead of simply converting projected coords to int\n  309              Vg.at<Vec3f>(y, x) = vertImage.at<Vec3f>((int)newCoords.y, (int)newCoords.x);\n  310  \n  311:             // bilinearly interpolate newPoints under newCoords point\n  312              int xi = cvFloor(newCoords.x), yi = cvFloor(newCoords.y);\n  313              float tx  = newCoords.x - xi, ty = newCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.hpp:\n   74      virtual TsdfVoxel at(const Vec3i& volumeIdx) const;\n   75  \n   76:     float interpolateVoxel(const cv::Point3f& p) const;\n   77      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   78  \n   79  #if USE_INTRINSICS\n   80:     float interpolateVoxel(const v_float32x4& p) const;\n   81      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   82  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/hash_tsdf.cpp:\n  126  \n  127  \n  128:     float interpolateVoxelPoint(const Point3f& point) const;\n  129:     float interpolateVoxel(const cv::Point3f& point) const;\n  130      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  131  \n  ...\n  421  \n  422  #if USE_INTRINSICS\n  423: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  424  {\n  425      v_float32x4 v0246, v1357;\n  ...\n  440  \n  441  #else\n  442: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  443  {\n  444      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  454  #endif\n  455  \n  456: float HashTSDFVolumeCPU::interpolateVoxelPoint(const Point3f& point) const\n  457  {\n  458      const Vec3i neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n  ...\n  495      }\n  496  \n  497:     return interpolate(tx, ty, tz, vx);\n  498  }\n  499  \n  500: inline float HashTSDFVolumeCPU::interpolateVoxel(const cv::Point3f& point) const\n  501  {\n  502:     return interpolateVoxelPoint(point * voxelSizeInv);\n  503  }\n  504  \n  ...\n  631      float tz = ptVox.z - iptVox[2];\n  632  \n  633:     normal[0] = interpolate(tx, ty, tz, cxv);\n  634:     normal[1] = interpolate(tx, ty, tz, cyv);\n  635:     normal[2] = interpolate(tx, ty, tz, czv);\n  636  #endif\n  637  \n  ...\n  921  \n  922  \n  923:     float interpolateVoxelPoint(const Point3f& point) const;\n  924:     float interpolateVoxel(const cv::Point3f& point) const;\n  925      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  926  \n  ...\n 1380  }\n 1381  \n 1382: float HashTSDFVolumeGPU::interpolateVoxelPoint(const Point3f& point) const\n 1383  {\n 1384      const Vec3i local_neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n ....\n 1421      }\n 1422  \n 1423:     return interpolate(tx, ty, tz, vx);\n 1424  }\n 1425  \n 1426: inline float HashTSDFVolumeGPU::interpolateVoxel(const cv::Point3f& point) const\n 1427  {\n 1428:     return interpolateVoxelPoint(point * voxelSizeInv);\n 1429  }\n 1430  \n ....\n 1556      float tz = ptVox.z - iptVox[2];\n 1557  \n 1558:     normal[0] = interpolate(tx, ty, tz, cxv);\n 1559:     normal[1] = interpolate(tx, ty, tz, cyv);\n 1560:     normal[2] = interpolate(tx, ty, tz, czv);\n 1561  #endif\n 1562      float nv = sqrt(normal[0] * normal[0] +\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/fast_icp.cpp:\n  243                      continue;\n  244  \n  245:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  246                  v_float32x4 oldP;\n  247                  v_float32x4 oldN;\n  ...\n  390                      continue;\n  391  \n  392:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  393                  int xi = cvFloor(oldCoords.x), yi = cvFloor(oldCoords.y);\n  394                  float tx  = oldCoords.x - xi, ty = oldCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.cpp:\n  137  #if USE_INTRINSICS\n  138  // all coordinate checks should be done in inclosing cycle\n  139: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  140  {\n  141      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  142:     return interpolateVoxel(p);\n  143  }\n  144  \n  145: inline float TSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  146  {\n  147      // tx, ty, tz = floor(p)\n  ...\n  184  }\n  185  #else\n  186: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  187  {\n  188      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  438                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  439                      v_float32x4 next    = (orig + dir * v_setall_f32(tmin));\n  440:                     float f = volume.interpolateVoxel(next), fnext = f;\n  441  \n  442                      //raymarch\n  ...\n  455                          if(fnext != f)\n  456                          {\n  457:                             fnext = volume.interpolateVoxel(next);\n  458  \n  459                              // when ray crosses a surface\n  ...\n  466  \n  467                      // if ray penetrates a surface from outside\n  468:                     // linearly interpolate t between two f values\n  469                      if(f > 0.f && fnext < 0.f)\n  470                      {\n  471                          v_float32x4 tp = next - rayStep;\n  472:                         float ft    = volume.interpolateVoxel(tp);\n  473:                         float ftdt  = volume.interpolateVoxel(next);\n  474                          float ts = tmin + tstep*(steps - ft/(ftdt - ft));\n  475  \n  ...\n  547                      Point3f rayStep = dir * tstep;\n  548                      Point3f next = (orig + dir * tmin);\n  549:                     float f = volume.interpolateVoxel(next), fnext = f;\n  550  \n  551                      //raymarch\n  ...\n  564                          if(fnext != f)\n  565                          {\n  566:                             fnext = volume.interpolateVoxel(next);\n  567                              // when ray crosses a surface\n  568                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  573                      }\n  574                      // if ray penetrates a surface from outside\n  575:                     // linearly interpolate t between two f values\n  576                      if(f > 0.f && fnext < 0.f)\n  577                      {\n  578                          Point3f tp    = next - rayStep;\n  579:                         float ft   = volume.interpolateVoxel(tp);\n  580:                         float ftdt = volume.interpolateVoxel(next);\n  581                          // float t = tmin + steps*tstep;\n  582                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  692                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  693                  {\n  694:                     //linearly interpolate coordinate\n  695                      float Vn    = Vc + vol.voxelSize;\n  696                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/warpfield.cpp:\n  212  \n  213          Affine3f pose = DQB(weights, transforms);\n  214:         // linearly interpolate translations\n  215          Vec3f translation(0,0,0);\n  216          float totalWeight = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/dynafu_tsdf.cpp:\n   48      virtual void reset() override;\n   49  \n   50:     volumeType interpolateVoxel(cv::Point3f p) const;\n   51      Point3f getNormalVoxel(cv::Point3f p) const;\n   52  \n   ..\n   59  \n   60  private:\n   61:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const;\n   62  };\n   63  \n   ..\n  330  }\n  331  \n  332: inline volumeType TSDFVolumeCPU::interpolateVoxel(Point3f p) const\n  333  {\n  334      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  472                      Point3f rayStep = dir * tstep;\n  473                      Point3f next = (orig + dir * tmin);\n  474:                     volumeType f = volume.interpolateVoxel(next), fnext = f;\n  475  \n  476                      //raymarch\n  ...\n  489                          if(fnext != f)\n  490                          {\n  491:                             fnext = volume.interpolateVoxel(next);\n  492  \n  493                              // when ray crosses a surface\n  ...\n  500  \n  501                      // if ray penetrates a surface from outside\n  502:                     // linearly interpolate t between two f values\n  503                      if(f > 0.f && fnext < 0.f)\n  504                      {\n  505                          Point3f tp = next - rayStep;\n  506:                         volumeType ft   = volume.interpolateVoxel(tp);\n  507:                         volumeType ftdt = volume.interpolateVoxel(next);\n  508                          // float t = tmin + steps*tstep;\n  509                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  621                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  622                  {\n  623:                     //linearly interpolate coordinate\n  624                      float Vn = Vc + vol.voxelSize;\n  625                      float dinv = 1.f/(abs(v0)+abs(vd));\n  ...\n  790      }\n  791  \n  792:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const\n  793      {\n  794          float dV = 0.5f;\n  ...\n  835  \n  836                      if (edgeTable[cubeIndex] & 1)\n  837:                         vertices[0] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[1],\n  838                                                             tsdfValues[0], tsdfValues[1]);\n  839                      if (edgeTable[cubeIndex] & 2)\n  840:                         vertices[1] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[2],\n  841                                                             tsdfValues[1], tsdfValues[2]);\n  842                      if (edgeTable[cubeIndex] & 4)\n  843:                         vertices[2] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[3],\n  844                                                             tsdfValues[2], tsdfValues[3]);\n  845                      if (edgeTable[cubeIndex] & 8)\n  846:                         vertices[3] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[0],\n  847                                                             tsdfValues[3], tsdfValues[0]);\n  848                      if (edgeTable[cubeIndex] & 16)\n  849:                         vertices[4] = basePt + interpolate(mcNeighbourPts[4], mcNeighbourPts[5],\n  850                                                             tsdfValues[4], tsdfValues[5]);\n  851                      if (edgeTable[cubeIndex] & 32)\n  852:                         vertices[5] = basePt + interpolate(mcNeighbourPts[5], mcNeighbourPts[6],\n  853                                                             tsdfValues[5], tsdfValues[6]);\n  854                      if (edgeTable[cubeIndex] & 64)\n  855:                         vertices[6] = basePt + interpolate(mcNeighbourPts[6], mcNeighbourPts[7],\n  856                                                             tsdfValues[6], tsdfValues[7]);\n  857                      if (edgeTable[cubeIndex] & 128)\n  858:                         vertices[7] = basePt + interpolate(mcNeighbourPts[7], mcNeighbourPts[4],\n  859                                                             tsdfValues[7], tsdfValues[4]);\n  860                      if (edgeTable[cubeIndex] & 256)\n  861:                         vertices[8] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[4],\n  862                                                             tsdfValues[0], tsdfValues[4]);\n  863                      if (edgeTable[cubeIndex] & 512)\n  864:                         vertices[9] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[5],\n  865                                                             tsdfValues[1], tsdfValues[5]);\n  866                      if (edgeTable[cubeIndex] & 1024)\n  867:                         vertices[10] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[6],\n  868                                                              tsdfValues[2], tsdfValues[6]);\n  869                      if (edgeTable[cubeIndex] & 2048)\n  870:                         vertices[11] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[7],\n  871                                                              tsdfValues[3], tsdfValues[7]);\n  872  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf_functions.cpp:\n  249  \n  250                      depthType v;\n  251:                     // bilinearly interpolate depth at projected\n  252                      {\n  253                          const v_float32x4& pt = projected;\n  ...\n  284                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  285                              v_float32x4 ty = v_setall_f32(t.get0());\n  286:                             // vx is y-interpolated between rows 0 and 1\n  287                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  288                              float v0 = vx.get0();\n  ...\n  514  \n  515                      depthType v;\n  516:                     // bilinearly interpolate depth at projected\n  517                      {\n  518                          const v_float32x4& pt = projected;\n  ...\n  549                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  550                              v_float32x4 ty = v_setall_f32(t.get0());\n  551:                             // vx is y-interpolated between rows 0 and 1\n  552                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  553                              float v0 = vx.get0();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/colored_tsdf.cpp:\n   85      virtual RGBTsdfVoxel at(const Vec3i& volumeIdx) const;\n   86  \n   87:     float interpolateVoxel(const cv::Point3f& p) const;\n   88      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   89:     float interpolateColor(float tx, float ty, float tz, float vx[8]) const;\n   90      Point3f getColorVoxel(const cv::Point3f& p) const;\n   91  \n   92  #if USE_INTRINSICS\n   93:     float interpolateVoxel(const v_float32x4& p) const;\n   94      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   95      v_float32x4 getColorVoxel(const v_float32x4& p) const;\n   ..\n  185  #if USE_INTRINSICS\n  186  // all coordinate checks should be done in inclosing cycle\n  187: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  188  {\n  189      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  190:     return interpolateVoxel(p);\n  191  }\n  192  \n  193: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  194  {\n  195      // tx, ty, tz = floor(p)\n  ...\n  232  }\n  233  #else\n  234: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  235  {\n  236      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  384  \n  385  #if USE_INTRINSICS\n  386: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  387  {\n  388      v_float32x4 v0246, v1357;\n  ...\n  402  }\n  403  #else\n  404: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  405  {\n  406      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  463      float ty = t.get0(); t = v_rotate_right<1>(t);\n  464      float tz = t.get0();\n  465:     rgb[0] = interpolateColor(tx, ty, tz, r);\n  466:     rgb[1] = interpolateColor(tx, ty, tz, g);\n  467:     rgb[2] = interpolateColor(tx, ty, tz, b);\n  468      rgb[3] = 0.f;\n  469  #else\n  ...\n  512      float tz = ptVox.z - iptVox[2];\n  513  \n  514:     res=Point3f(interpolateColor(tx, ty, tz, r),\n  515:                 interpolateColor(tx, ty, tz, g),\n  516:                 interpolateColor(tx, ty, tz, b));\n  517  #else\n  518      res=Point3f(volData[coordBase].r, volData[coordBase].g, volData[coordBase].b);\n  ...\n  627                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  628                      v_float32x4 next = (orig + dir * v_setall_f32(tmin));\n  629:                     float f = volume.interpolateVoxel(next), fnext = f;\n  630  \n  631                      //raymarch\n  ...\n  644                          if (fnext != f)\n  645                          {\n  646:                             fnext = volume.interpolateVoxel(next);\n  647  \n  648                              // when ray crosses a surface\n  ...\n  655  \n  656                      // if ray penetrates a surface from outside\n  657:                     // linearly interpolate t between two f values\n  658                      if (f > 0.f && fnext < 0.f)\n  659                      {\n  660                          v_float32x4 tp = next - rayStep;\n  661:                         float ft = volume.interpolateVoxel(tp);\n  662:                         float ftdt = volume.interpolateVoxel(next);\n  663                          float ts = tmin + tstep * (steps - ft / (ftdt - ft));\n  664  \n  ...\n  740                      Point3f rayStep = dir * tstep;\n  741                      Point3f next = (orig + dir * tmin);\n  742:                     float f = volume.interpolateVoxel(next), fnext = f;\n  743  \n  744                      //raymarch\n  ...\n  757                          if(fnext != f)\n  758                          {\n  759:                             fnext = volume.interpolateVoxel(next);\n  760                              // when ray crosses a surface\n  761                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  766                      }\n  767                      // if ray penetrates a surface from outside\n  768:                     // linearly interpolate t between two f values\n  769                      if(f > 0.f && fnext < 0.f)\n  770                      {\n  771                          Point3f tp    = next - rayStep;\n  772:                         float ft   = volume.interpolateVoxel(tp);\n  773:                         float ftdt = volume.interpolateVoxel(next);\n  774                          // float t = tmin + steps*tstep;\n  775                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  893                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  894                  {\n  895:                     //linearly interpolate coordinate\n  896                      float Vn    = Vc + vol.voxelSize;\n  897                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapaffine.cpp:\n   80  \n   81      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   82:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   83      // remap will not touch them).\n   84      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapshift.cpp:\n   81  \n   82      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   83:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   84      // remap will not touch them).\n   85      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapprojec.cpp:\n   83  \n   84      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   85:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   86      // remap will not touch them).\n   87      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retina_ocl.cpp:\n 1155      demultiplex(ocl_multiplexed_input, _demultiplexedTempBuffer);\n 1156  \n 1157:     // interpolate the demultiplexed frame depending on the color sampling method\n 1158      if (!adaptiveFiltering)\n 1159      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.hpp:\n  243          // protected functions\n  244          void _initColorSampling();\n  245:         void _interpolateImageDemultiplexedImage(float *inputOutputBuffer);\n  246:         void _interpolateSingleChannelImage111(float *inputOutputBuffer);\n  247:         void _interpolateBayerRGBchannels(float *inputOutputBuffer);\n  248          void _applyRIFfilter(const float *sourceBuffer, float *destinationBuffer);\n  249          void _getNormalizedContoursImage(const float *inputFrame, float *outputFrame);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.cpp:\n  264          _demultiplexedTempBuffer[*(colorSamplingPRT++)]=*(multiplexedColorFramePtr++);\n  265  \n  266:     // interpolate the demultiplexed frame depending on the color sampling method\n  267      if (!adaptiveFiltering)\n  268:         _interpolateImageDemultiplexedImage(&_demultiplexedTempBuffer[0]);\n  269  \n  270      // low pass filtering the demultiplexed frame\n  ...\n  453  }\n  454  \n  455: void RetinaColor::_interpolateImageDemultiplexedImage(float *inputOutputBuffer)\n  456  {\n  457  \n  ...\n  460  \n  461      case RETINA_COLOR_RANDOM:\n  462:         return; // no need to interpolate\n  463          break;\n  464  \n  465      case RETINA_COLOR_DIAGONAL:\n  466:         _interpolateSingleChannelImage111(inputOutputBuffer);\n  467          break;\n  468  \n  469      case RETINA_COLOR_BAYER: // default sets bayer sampling\n  470:         _interpolateBayerRGBchannels(inputOutputBuffer);\n  471          break;\n  472      default:\n  ...\n  479  }\n  480  \n  481: void RetinaColor::_interpolateSingleChannelImage111(float *inputOutputBuffer)\n  482  {\n  483      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows(); ++indexr)\n  ...\n  499  }\n  500  \n  501: void RetinaColor::_interpolateBayerRGBchannels(float *inputOutputBuffer)\n  502  {\n  503      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows()-1; indexr+=2)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/tutorial_charuco_create_detect.cpp:\n   59                  std::vector<cv::Point2f> charucoCorners;\n   60                  std::vector<int> charucoIds;\n   61:                 cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);\n   62                  //! [charidcor]\n   63                  // if at least one charuco corner detected\n   ..\n  110              std::vector<cv::Point2f> charucoCorners;\n  111              std::vector<int> charucoIds;\n  112:             cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds);\n  113              //! [charidcorwc]\n  114              // if at least one charuco corner detected\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/detect_board_charuco.cpp:\n  173                                           camMatrix, distCoeffs);\n  174  \n  175:         // interpolate charuco corners\n  176:         int interpolatedCorners = 0;\n  177          if(markerIds.size() > 0)\n  178:             interpolatedCorners =\n  179:                 aruco::interpolateCornersCharuco(markerCorners, markerIds, image, charucoboard,\n  180                                                   charucoCorners, charucoIds, camMatrix, distCoeffs);\n  181  \n  ...\n  207              aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, noArray(), Scalar(100, 0, 255));\n  208  \n  209:         if(interpolatedCorners > 0) {\n  210              Scalar color;\n  211              color = Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/calibrate_camera_charuco.cpp:\n  178          if(refindStrategy) aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  179  \n  180:         // interpolate charuco corners\n  181          Mat currentCharucoCorners, currentCharucoIds;\n  182          if(ids.size() > 0)\n  183:             aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners,\n  184                                               currentCharucoIds);\n  185  \n  ...\n  248  \n  249      for(int i = 0; i < nFrames; i++) {\n  250:         // interpolate using camera parameters\n  251          Mat currentCharucoCorners, currentCharucoIds;\n  252:         aruco::interpolateCornersCharuco(allCorners[i], allIds[i], allImgs[i], charucoboard,\n  253                                           currentCharucoCorners, currentCharucoIds, cameraMatrix,\n  254                                           distCoeffs);\n  ...\n  280      cout << \"Calibration saved to \" << outputFile << endl;\n  281  \n  282:     // show interpolated charuco corners for debugging\n  283      if(showChessboardCorners) {\n  284          for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/test/test_charucodetection.cpp:\n  256                  }\n  257  \n  258:                 // interpolate charuco corners\n  259                  vector< Point2f > charucoCorners;\n  260                  vector< int > charucoIds;\n  261  \n  262                  if(iter % 2 == 0) {\n  263:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  264                                                       charucoIds);\n  265                  } else {\n  266:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  267                                                       charucoIds, cameraMatrix, distCoeffs);\n  268                  }\n  ...\n  354                  }\n  355  \n  356:                 // interpolate charuco corners\n  357                  vector< Point2f > charucoCorners;\n  358                  vector< int > charucoIds;\n  359  \n  360                  if(iter % 2 == 0) {\n  361:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  362                                                       charucoIds);\n  363                  } else {\n  364:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  365                                                       charucoIds, cameraMatrix, distCoeffs);\n  366                  }\n  ...\n  719  \n  720      cv::Mat c_ids, c_corners;\n  721:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids, K);\n  722      cv::Mat corners_reshaped = c_corners.reshape(1);\n  723  \n  ...\n  727      c_ids = cv::Mat();\n  728      c_corners = cv::Mat();\n  729:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids);\n  730      corners_reshaped = c_corners.reshape(1);\n  731  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp:\n  434   *\n  435   * This function tries to find markers that were not detected in the basic detecMarkers function.\n  436:  * First, based on the current detected marker and the board layout, the function interpolates\n  437   * the position of the missing markers. Then it tries to find correspondence between the reprojected\n  438   * markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n  439   * parameters.\n  440   * If camera parameters and distortion coefficients are provided, missing markers are reprojected\n  441:  * using projectPoint function. If not, missing marker projections are interpolated using global\n  442   * homography, and all the marker corners in the board must have the same Z coordinate.\n  443   */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp:\n  141   * should be sent in corners and ids parameters.\n  142   * @param board layout of ChArUco board.\n  143:  * @param charucoCorners interpolated chessboard corners\n  144:  * @param charucoIds interpolated chessboard corners identifiers\n  145   * @param cameraMatrix optional 3x3 floating-point camera matrix\n  146   * \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n  ...\n  154   * Only visible corners are returned. For each corner, its corresponding identifier is\n  155   * also returned in charucoIds.\n  156:  * The function returns the number of interpolated corners.\n  157   */\n  158: CV_EXPORTS_W int interpolateCornersCharuco(InputArrayOfArrays markerCorners, InputArray markerIds,\n  159                                             InputArray image, const Ptr<CharucoBoard> &board,\n  160                                             OutputArray charucoCorners, OutputArray charucoIds,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/aruco.cpp:\n  749   * @param nContours, contour-container\n  750   */\n  751: static Point3f _interpolate2Dline(const std::vector<cv::Point2f>& nContours){\n  752  \tfloat minX, minY, maxX, maxY;\n  753  \tminX = maxX = nContours[0].x;\n  ...\n  864  \tPoint3f lines[4];\n  865  \tfor(int i=0; i<4; i++){\n  866: \t\tlines[i]=_interpolate2Dline(cntPts[i]);\n  867  \t}\n  868  \n  ...\n 1723          }\n 1724  \n 1725:         // interpolate tiny marker to marker position in markerZone\n 1726          inCorners[0] = Point2f(-0.5f, -0.5f);\n 1727          inCorners[1] = Point2f(marker.cols - 0.5f, -0.5f);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/charuco.cpp:\n  394    * Interpolate charuco corners using approximated pose estimation\n  395    */\n  396: static int _interpolateCornersCharucoApproxCalib(InputArrayOfArrays _markerCorners,\n  397                                                   InputArray _markerIds, InputArray _image,\n  398                                                   const Ptr<CharucoBoard> &_board,\n  ...\n  438    * Interpolate charuco corners using local homography\n  439    */\n  440: static int _interpolateCornersCharucoLocalHom(InputArrayOfArrays _markerCorners,\n  441                                                InputArray _markerIds, InputArray _image,\n  442                                                const Ptr<CharucoBoard> &_board,\n  ...\n  482          Point2f objPoint2D = Point2f(_board->chessboardCorners[i].x, _board->chessboardCorners[i].y);\n  483  \n  484:         vector< Point2f > interpolatedPositions;\n  485          for(unsigned int j = 0; j < _board->nearestMarkerIdx[i].size(); j++) {\n  486              int markerId = _board->ids[_board->nearestMarkerIdx[i][j]];\n  ...\n  498                  in.push_back(objPoint2D);\n  499                  perspectiveTransform(in, out, transformations[markerIdx]);\n  500:                 interpolatedPositions.push_back(out[0]);\n  501              }\n  502          }\n  503  \n  504          // none of the closest markers detected\n  505:         if(interpolatedPositions.size() == 0) continue;\n  506  \n  507          // more than one closest marker detected, take middle point\n  508:         if(interpolatedPositions.size() > 1) {\n  509:             allChessboardImgPoints[i] = (interpolatedPositions[0] + interpolatedPositions[1]) / 2.;\n  510          }\n  511          // a single closest marker detected\n  512:         else allChessboardImgPoints[i] = interpolatedPositions[0];\n  513      }\n  514  \n  ...\n  529  /**\n  530    */\n  531: int interpolateCornersCharuco(InputArrayOfArrays _markerCorners, InputArray _markerIds,\n  532                                InputArray _image, const Ptr<CharucoBoard> &_board,\n  533                                OutputArray _charucoCorners, OutputArray _charucoIds,\n  ...\n  536      // if camera parameters are avaible, use approximated calibration\n  537      if(_cameraMatrix.total() != 0) {\n  538:         _interpolateCornersCharucoApproxCalib(_markerCorners, _markerIds, _image, _board,\n  539                                                       _cameraMatrix, _distCoeffs, _charucoCorners,\n  540                                                       _charucoIds);\n  ...\n  542      // else use local homography\n  543      else {\n  544:         _interpolateCornersCharucoLocalHom(_markerCorners, _markerIds, _image, _board,\n  545                                                    _charucoCorners, _charucoIds);\n  546      }\n  ...\n  791              }\n  792  \n  793:             // interpolate the charuco corners of the diamond\n  794              vector< Point2f > currentMarkerCorners;\n  795              Mat aux;\n  796:             interpolateCornersCharuco(currentMarker, currentMarkerId, grey, _charucoDiamondLayout,\n  797                                        currentMarkerCorners, aux, _cameraMatrix, _distCoeffs);\n  798  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/include/opencv2/viz/widgets.hpp:\n  665              @param radius Radius of the spheres.\n  666              @param from Color for first sphere.\n  667:             @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  668               */\n  669              WTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/misc/python/python_viz.hpp:\n  841      @param radius Radius of the spheres.\n  842      @param from Color for first sphere.\n  843:     @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  844       */\n  845      CV_WRAP PyWTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy.hpp:\n  219  @param newFrame Output image.\n  220  @param buf Temporary buffer, will have width x 6\\*height size, CV_32FC1 type and contain 6\n  221: GpuMat: occlusion masks for first frame, occlusion masks for second, interpolated forward\n  222: horizontal flow, interpolated forward vertical flow, interpolated backward horizontal flow,\n  223: interpolated backward vertical flow.\n  224  @param stream Stream for the asynchronous version.\n  225   */\n  226: CV_EXPORTS void interpolateFrames(const GpuMat& frame0, const GpuMat& frame1,\n  227                                    const GpuMat& fu, const GpuMat& fv,\n  228                                    const GpuMat& bu, const GpuMat& bv,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy/NCVPyramid.hpp:\n   56      {\n   57          CV_EXPORTS void downsampleX2(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   58:         CV_EXPORTS void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   59      }\n   60  }}}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/image_pyramid.cpp:\n  136          }\n  137  \n  138:         cv::cuda::device::pyramid::interpolateFrom1(lastLayer, outImg, outImg.depth(), outImg.channels(), StreamAccessor::getStream(stream));\n  139      }\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp:\n   48  #if !defined (HAVE_CUDA) || !defined (HAVE_OPENCV_CUDALEGACY) || defined (CUDA_DISABLER)\n   49  \n   50: void cv::cuda::interpolateFrames(const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, float, GpuMat&, GpuMat&, Stream&) { throw_no_cuda(); }\n   51  \n   52  #else\n   53  \n   54: void cv::cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv,\n   55                                  float pos, GpuMat& newFrame, GpuMat& buf, Stream& s)\n   56  {\n   ..\n   71      GpuMat occ1 = buf.rowRange(1 * frame0.rows, 2 * frame0.rows);\n   72  \n   73:     // interpolated forward flow\n   74      GpuMat fui = buf.rowRange(2 * frame0.rows, 3 * frame0.rows);\n   75      GpuMat fvi = buf.rowRange(3 * frame0.rows, 4 * frame0.rows);\n   76  \n   77:     // interpolated backward flow\n   78      GpuMat bui = buf.rowRange(4 * frame0.rows, 5 * frame0.rows);\n   79      GpuMat bvi = buf.rowRange(5 * frame0.rows, 6 * frame0.rows);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/lbph_faces.cpp:\n  241          for(int i=radius; i < src.rows-radius;i++) {\n  242              for(int j=radius;j < src.cols-radius;j++) {\n  243:                 // calculate interpolated value\n  244                  float t = static_cast<float>(w1*src.at<_Tp>(i+fy,j+fx) + w2*src.at<_Tp>(i+fy,j+cx) + w3*src.at<_Tp>(i+cy,j+fx) + w4*src.at<_Tp>(i+cy,j+cx));\n  245                  // floating point precision, so check some machine-dependent epsilon\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/column_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/row_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n313 matches across 82 files\n\n\nSearching 8052 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/deps/nuklear.h:\n 11414                      scy = y;\n 11415                      if (!(vertices[off+i+1].type & 1)) {\n 11416:                         /* next point is also a curve point, so interpolate an on-point curve */\n 11417                          sx = (x + (nk_int) vertices[off+i+1].x) >> 1;\n 11418                          sy = (y + (nk_int) vertices[off+i+1].y) >> 1;\n .....\n 11434                  if (!(flags & 1))\n 11435                  { /* if it's a curve */\n 11436:                     if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */\n 11437                          nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 11438                      cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/imstb_truetype.h:\n 1741                 scy = y;\n 1742                 if (!(vertices[off+i+1].type & 1)) {\n 1743:                   // next point is also a curve point, so interpolate an on-point curve\n 1744                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1745                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1760           } else {\n 1761              if (!(flags & 1)) { // if it's a curve\n 1762:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1763                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1764                 cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_image.h:\n 1443  //        - allows good upsampling (see next)\n 1444  //    high-quality\n 1445: //      - upsampled channels are bilinearly interpolated, even across blocks\n 1446  //      - quality integer IDCT derived from IJG's 'slow'\n 1447  //    performance\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/nanovg.h:\n  196  \n  197  \n  198: // Linearly interpolates from color c0 to c1, and returns resulting color value.\n  199  NVGcolor nvgLerpRGBA(NVGcolor c0, NVGcolor c1, float u);\n  200  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_truetype.h:\n 1771                 scy = y;\n 1772                 if (!(vertices[off+i+1].type & 1)) {\n 1773:                   // next point is also a curve point, so interpolate an on-point curve\n 1774                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1775                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1790           } else {\n 1791              if (!(flags & 1)) { // if it's a curve\n 1792:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1793                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1794                 cx = x;\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/opencv/disabled/detect_board_charuco.cpp:\n  194        cv::aruco::refineDetectedMarkers(image, board, markerCorners, markerIds, rejectedMarkers, camMatrix, distCoeffs);\n  195  \n  196:     // interpolate charuco corners\n  197:     int interpolatedCorners = 0;\n  198      if(markerIds.size() > 0)\n  199:       interpolatedCorners = cv::aruco::interpolateCornersCharuco(\n  200            markerCorners, markerIds, image, charucoboard, charucoCorners, charucoIds, camMatrix, distCoeffs);\n  201  \n  ...\n  223        cv::aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, cv::noArray(), cv::Scalar(100, 0, 255));\n  224  \n  225:     if(interpolatedCorners > 0) {\n  226        cv::Scalar color;\n  227        color = cv::Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/imgui/imstb_truetype.h:\n 1934            scy = y;\n 1935            if(!(vertices[off + i + 1].type & 1)) {\n 1936:             // next point is also a curve point, so interpolate an on-point curve\n 1937              sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;\n 1938              sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;\n ....\n 1953        } else {\n 1954          if(!(flags & 1)) { // if it's a curve\n 1955:           if(was_off)      // two off-curve control points in a row means interpolate an on-curve\n 1956                             // midpoint\n 1957              stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.hpp:\n  116      bool findMaximaInLayer(int counterOffset, int octave, int layer_rows, int layer_cols);\n  117  \n  118:     bool interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int maxFeatures);\n  119  \n  120      bool calcOrientation(UMat &keypoints);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/msd.cpp:\n  263               * @param scale scale of the key-point over the image pyramid\n  264               * @param saliency pointer to the saliency array\n  265:              * @param p_res interpolated coordinates of the key-point referred to the lowest level of the pyramid (i.e. in the ref. frame of the input image)\n  266               * @return false if the current key-point has to be rejected, true otherwise\n  267               */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.ocl.cpp:\n  187          if (maxCounter > 0)\n  188          {\n  189:             if(!interpolateKeypoint(maxCounter, keypoints, octave, layer_rows, maxFeatures))\n  190                  return false;\n  191          }\n  ...\n  431  }\n  432  \n  433: bool SURF_OCL::interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int max_features)\n  434  {\n  435      size_t localThreads[3]  = {3, 3, 3};\n  436      size_t globalThreads[3] = {maxCounter*localThreads[0], localThreads[1], 3};\n  437  \n  438:     ocl::Kernel kerInterp(\"SURF_interpolateKeypoint\", ocl::xfeatures2d::surf_oclsrc, kerOpts);\n  439  \n  440      return kerInterp.args(ocl::KernelArg::ReadOnlyNoSize(det),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/daisy.cpp:\n  371  \n  372  \n  373: static float interpolate_peak( float left, float center, float right )\n  374  {\n  375      if( center < 0.0 )\n  ...\n 1409                 next -= m_orientation_resolution;\n 1410  \n 1411:             peak = interpolate_peak(hist.at<float>(prev), hist.at<float>(max_ind), hist.at<float>(next));\n 1412              angle = (float)( ((float)max_ind + peak)*360.0/m_orientation_resolution );\n 1413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.cpp:\n  220   * approximated using central differences. The linear system Ax = b is then\n  221   * solved, where A is the Hessian, b is the negative gradient, and x is the\n  222:  * offset of the interpolated maxima coordinates from the initial estimate.\n  223   * This is equivalent to an iteration of Netwon's optimisation algorithm.\n  224   *\n  ...\n  232   */\n  233  static int\n  234: interpolateKeypoint( float N9[3][9], int dx, int dy, int ds, KeyPoint& kpt )\n  235  {\n  236      Vec3f b(-(N9[1][5]-N9[1][3])/2,  // Negative 1st deriv with respect to x\n  ...\n  433                      /* Interpolate maxima location within the 3x3x3 neighbourhood  */\n  434                      int ds = size - sizes[layer-1];\n  435:                     int interp_ok = interpolateKeypoint( N9, sampleStep, sampleStep, ds, kpt );\n  436  \n  437                      /* Sometimes the interpolation step gives a negative size etc. */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparsetodenseflow.cpp:\n  106      gd->setFGSLambda(fgs_lambda);\n  107      gd->setFGSSigma (fgs_sigma);\n  108:     gd->interpolate(prev,points_filtered,cur,dst_points_filtered,dense_flow);\n  109  }\n  110  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlofflow.cpp:\n  218              gd->setFGSSigma(fgs_sigma);\n  219              gd->setUsePostProcessing(use_post_proc);\n  220:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  221          }\n  222          else if (interp_type == InterpolationType::INTERP_RIC)\n  ...\n  230              gd->setUseGlobalSmootherFilter(use_post_proc);\n  231              gd->setUseVariationalRefinement(false);\n  232:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  233          }\n  234          else\n  ...\n  237              GaussianBlur(prevImage, blurredPrevImage, cv::Size(5, 5), -1);\n  238              std::vector<uchar> status(filtered_currPoints.size(), 1);\n  239:             interpolate_irregular_nn_raster(filtered_prevPoints, filtered_currPoints, status, blurredPrevImage).copyTo(dense_flow);\n  240              std::vector<Mat> vecMats;\n  241              std::vector<Mat> vecMats2(2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.cpp:\n  115  }\n  116  \n  117: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n  118      const std::vector<Point2f> & nextPoints,\n  119      const std::vector<uchar> & status,\n  ...\n  241  }\n  242  \n  243: Mat interpolate_irregular_knn(\n  244      const std::vector<Point2f> & _prevPoints,\n  245      const std::vector<Point2f> & _nextPoints,\n  ...\n  401  \n  402  \n  403: Mat interpolate_irregular_nn(\n  404      const std::vector<Point2f> & _prevPoints,\n  405      const std::vector<Point2f> & _nextPoints,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.hpp:\n   12  Mat sgeo_dist(const Mat& gra, int y, int x, float max, Mat &prev);\n   13  Mat sgeo_dist(const Mat& gra, const std::vector<Point2f> & points, float max, Mat &prev);\n   14: Mat interpolate_irregular_nw(const Mat &in, const Mat &mask, const Mat &color_img, float max_d, float bandwidth, float pixeldistance);\n   15: Mat interpolate_irregular_nn(\n   16      const std::vector<Point2f> & prevPoints,\n   17      const std::vector<Point2f> & nextPoints,\n   ..\n   19      const Mat &color_img,\n   20      float pixeldistance);\n   21: Mat interpolate_irregular_knn(\n   22      const std::vector<Point2f> & _prevPoints,\n   23      const std::vector<Point2f> & _nextPoints,\n   ..\n   27      float pixeldistance);\n   28  \n   29: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n   30      const std::vector<Point2f> & nextPoints,\n   31      const std::vector<uchar> & status,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_sparse_match_interpolator.cpp:\n   90      interpolator->setFGSLambda(500.0f);\n   91      interpolator->setFGSSigma(1.5f);\n   92:     interpolator->interpolate(src,from_points,Mat(),to_points,res_flow);\n   93  \n   94      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n   ..\n   97      Mat from_point_mat(from_points);\n   98      Mat to_points_mat(to_points);\n   99:     interpolator->interpolate(src,from_point_mat,Mat(),to_points_mat,res_flow);\n  100  \n  101      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  146      interpolator->setFGSLambda(500.f);\n  147      interpolator->setFGSSigma(1.5f);\n  148:     interpolator->interpolate(src, from_points, src1, to_points, res_flow);\n  149  \n  150      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  153      Mat from_point_mat(from_points);\n  154      Mat to_points_mat(to_points);\n  155:     interpolator->interpolate(src, from_point_mat, src1, to_points_mat, res_flow);\n  156  \n  157      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  205          cv::setNumThreads(nThreads);\n  206          Mat resMultiThread;\n  207:         interpolator->interpolate(from,from_points,Mat(),to_points,resMultiThread);\n  208  \n  209          cv::setNumThreads(1);\n  210          Mat resSingleThread;\n  211:         interpolator->interpolate(from,from_points,Mat(),to_points,resSingleThread);\n  212  \n  213          EXPECT_LE(cv::norm(resSingleThread, resMultiThread, NORM_INF), MAX_DIF);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp:\n   67      @param dense_flow output dense matching (two-channel CV_32F image)\n   68       */\n   69:     CV_WRAP virtual void interpolate(InputArray from_image, InputArray from_points,\n   70                                       InputArray to_image  , InputArray to_points,\n   71                                       OutputArray dense_flow) = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/sparse_match_interpolators.cpp:\n   78  public:\n   79      static Ptr<EdgeAwareInterpolatorImpl> create();\n   80:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n   81  \n   82  protected:\n   ..\n  171  }\n  172  \n  173: void EdgeAwareInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray, InputArray to_points, OutputArray dense_flow)\n  174  {\n  175      CV_Assert( !from_image.empty() && (from_image.depth() == CV_8U) && (from_image.channels() == 3 || from_image.channels() == 1) );\n  ...\n  906  public:\n  907      static Ptr<RICInterpolatorImpl> create();\n  908:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n  909  \n  910  protected:\n  ...\n 1109  };\n 1110  \n 1111: void RICInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow)\n 1112  {\n 1113      CV_Assert(!from_image.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 2199              /* update lower y limit (start) for the new 'column'.\n 2200  \n 2201:             We need to interpolate the y value that corresponds to the\n 2202              lower side of the rectangle. The first thing is to decide if\n 2203              the corresponding side is\n ....\n 2206              vx[3],vy[3] to vx[2],vy[2]\n 2207  \n 2208:             Then, the side is interpolated for the x value of the\n 2209              'column'. But, if the side is vertical (as it could happen if\n 2210              the rectangle is vertical and we are dealing with the first\n ....\n 2245              /* update upper y limit (end) for the new 'column'.\n 2246  \n 2247:             We need to interpolate the y value that corresponds to the\n 2248              upper side of the rectangle. The first thing is to decide if\n 2249              the corresponding side is\n ....\n 2252              vx[1],vy[1] to vx[2],vy[2]\n 2253  \n 2254:             Then, the side is interpolated for the x value of the\n 2255              'column'. But, if the side is vertical (as it could happen if\n 2256              the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/nonrigid_icp.cpp:\n  306                  continue;\n  307  \n  308:             // TODO: interpolate Vg instead of simply converting projected coords to int\n  309              Vg.at<Vec3f>(y, x) = vertImage.at<Vec3f>((int)newCoords.y, (int)newCoords.x);\n  310  \n  311:             // bilinearly interpolate newPoints under newCoords point\n  312              int xi = cvFloor(newCoords.x), yi = cvFloor(newCoords.y);\n  313              float tx  = newCoords.x - xi, ty = newCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.hpp:\n   74      virtual TsdfVoxel at(const Vec3i& volumeIdx) const;\n   75  \n   76:     float interpolateVoxel(const cv::Point3f& p) const;\n   77      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   78  \n   79  #if USE_INTRINSICS\n   80:     float interpolateVoxel(const v_float32x4& p) const;\n   81      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   82  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/hash_tsdf.cpp:\n  126  \n  127  \n  128:     float interpolateVoxelPoint(const Point3f& point) const;\n  129:     float interpolateVoxel(const cv::Point3f& point) const;\n  130      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  131  \n  ...\n  421  \n  422  #if USE_INTRINSICS\n  423: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  424  {\n  425      v_float32x4 v0246, v1357;\n  ...\n  440  \n  441  #else\n  442: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  443  {\n  444      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  454  #endif\n  455  \n  456: float HashTSDFVolumeCPU::interpolateVoxelPoint(const Point3f& point) const\n  457  {\n  458      const Vec3i neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n  ...\n  495      }\n  496  \n  497:     return interpolate(tx, ty, tz, vx);\n  498  }\n  499  \n  500: inline float HashTSDFVolumeCPU::interpolateVoxel(const cv::Point3f& point) const\n  501  {\n  502:     return interpolateVoxelPoint(point * voxelSizeInv);\n  503  }\n  504  \n  ...\n  631      float tz = ptVox.z - iptVox[2];\n  632  \n  633:     normal[0] = interpolate(tx, ty, tz, cxv);\n  634:     normal[1] = interpolate(tx, ty, tz, cyv);\n  635:     normal[2] = interpolate(tx, ty, tz, czv);\n  636  #endif\n  637  \n  ...\n  921  \n  922  \n  923:     float interpolateVoxelPoint(const Point3f& point) const;\n  924:     float interpolateVoxel(const cv::Point3f& point) const;\n  925      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  926  \n  ...\n 1380  }\n 1381  \n 1382: float HashTSDFVolumeGPU::interpolateVoxelPoint(const Point3f& point) const\n 1383  {\n 1384      const Vec3i local_neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n ....\n 1421      }\n 1422  \n 1423:     return interpolate(tx, ty, tz, vx);\n 1424  }\n 1425  \n 1426: inline float HashTSDFVolumeGPU::interpolateVoxel(const cv::Point3f& point) const\n 1427  {\n 1428:     return interpolateVoxelPoint(point * voxelSizeInv);\n 1429  }\n 1430  \n ....\n 1556      float tz = ptVox.z - iptVox[2];\n 1557  \n 1558:     normal[0] = interpolate(tx, ty, tz, cxv);\n 1559:     normal[1] = interpolate(tx, ty, tz, cyv);\n 1560:     normal[2] = interpolate(tx, ty, tz, czv);\n 1561  #endif\n 1562      float nv = sqrt(normal[0] * normal[0] +\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/fast_icp.cpp:\n  243                      continue;\n  244  \n  245:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  246                  v_float32x4 oldP;\n  247                  v_float32x4 oldN;\n  ...\n  390                      continue;\n  391  \n  392:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  393                  int xi = cvFloor(oldCoords.x), yi = cvFloor(oldCoords.y);\n  394                  float tx  = oldCoords.x - xi, ty = oldCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.cpp:\n  137  #if USE_INTRINSICS\n  138  // all coordinate checks should be done in inclosing cycle\n  139: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  140  {\n  141      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  142:     return interpolateVoxel(p);\n  143  }\n  144  \n  145: inline float TSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  146  {\n  147      // tx, ty, tz = floor(p)\n  ...\n  184  }\n  185  #else\n  186: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  187  {\n  188      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  438                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  439                      v_float32x4 next    = (orig + dir * v_setall_f32(tmin));\n  440:                     float f = volume.interpolateVoxel(next), fnext = f;\n  441  \n  442                      //raymarch\n  ...\n  455                          if(fnext != f)\n  456                          {\n  457:                             fnext = volume.interpolateVoxel(next);\n  458  \n  459                              // when ray crosses a surface\n  ...\n  466  \n  467                      // if ray penetrates a surface from outside\n  468:                     // linearly interpolate t between two f values\n  469                      if(f > 0.f && fnext < 0.f)\n  470                      {\n  471                          v_float32x4 tp = next - rayStep;\n  472:                         float ft    = volume.interpolateVoxel(tp);\n  473:                         float ftdt  = volume.interpolateVoxel(next);\n  474                          float ts = tmin + tstep*(steps - ft/(ftdt - ft));\n  475  \n  ...\n  547                      Point3f rayStep = dir * tstep;\n  548                      Point3f next = (orig + dir * tmin);\n  549:                     float f = volume.interpolateVoxel(next), fnext = f;\n  550  \n  551                      //raymarch\n  ...\n  564                          if(fnext != f)\n  565                          {\n  566:                             fnext = volume.interpolateVoxel(next);\n  567                              // when ray crosses a surface\n  568                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  573                      }\n  574                      // if ray penetrates a surface from outside\n  575:                     // linearly interpolate t between two f values\n  576                      if(f > 0.f && fnext < 0.f)\n  577                      {\n  578                          Point3f tp    = next - rayStep;\n  579:                         float ft   = volume.interpolateVoxel(tp);\n  580:                         float ftdt = volume.interpolateVoxel(next);\n  581                          // float t = tmin + steps*tstep;\n  582                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  692                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  693                  {\n  694:                     //linearly interpolate coordinate\n  695                      float Vn    = Vc + vol.voxelSize;\n  696                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/warpfield.cpp:\n  212  \n  213          Affine3f pose = DQB(weights, transforms);\n  214:         // linearly interpolate translations\n  215          Vec3f translation(0,0,0);\n  216          float totalWeight = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/dynafu_tsdf.cpp:\n   48      virtual void reset() override;\n   49  \n   50:     volumeType interpolateVoxel(cv::Point3f p) const;\n   51      Point3f getNormalVoxel(cv::Point3f p) const;\n   52  \n   ..\n   59  \n   60  private:\n   61:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const;\n   62  };\n   63  \n   ..\n  330  }\n  331  \n  332: inline volumeType TSDFVolumeCPU::interpolateVoxel(Point3f p) const\n  333  {\n  334      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  472                      Point3f rayStep = dir * tstep;\n  473                      Point3f next = (orig + dir * tmin);\n  474:                     volumeType f = volume.interpolateVoxel(next), fnext = f;\n  475  \n  476                      //raymarch\n  ...\n  489                          if(fnext != f)\n  490                          {\n  491:                             fnext = volume.interpolateVoxel(next);\n  492  \n  493                              // when ray crosses a surface\n  ...\n  500  \n  501                      // if ray penetrates a surface from outside\n  502:                     // linearly interpolate t between two f values\n  503                      if(f > 0.f && fnext < 0.f)\n  504                      {\n  505                          Point3f tp = next - rayStep;\n  506:                         volumeType ft   = volume.interpolateVoxel(tp);\n  507:                         volumeType ftdt = volume.interpolateVoxel(next);\n  508                          // float t = tmin + steps*tstep;\n  509                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  621                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  622                  {\n  623:                     //linearly interpolate coordinate\n  624                      float Vn = Vc + vol.voxelSize;\n  625                      float dinv = 1.f/(abs(v0)+abs(vd));\n  ...\n  790      }\n  791  \n  792:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const\n  793      {\n  794          float dV = 0.5f;\n  ...\n  835  \n  836                      if (edgeTable[cubeIndex] & 1)\n  837:                         vertices[0] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[1],\n  838                                                             tsdfValues[0], tsdfValues[1]);\n  839                      if (edgeTable[cubeIndex] & 2)\n  840:                         vertices[1] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[2],\n  841                                                             tsdfValues[1], tsdfValues[2]);\n  842                      if (edgeTable[cubeIndex] & 4)\n  843:                         vertices[2] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[3],\n  844                                                             tsdfValues[2], tsdfValues[3]);\n  845                      if (edgeTable[cubeIndex] & 8)\n  846:                         vertices[3] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[0],\n  847                                                             tsdfValues[3], tsdfValues[0]);\n  848                      if (edgeTable[cubeIndex] & 16)\n  849:                         vertices[4] = basePt + interpolate(mcNeighbourPts[4], mcNeighbourPts[5],\n  850                                                             tsdfValues[4], tsdfValues[5]);\n  851                      if (edgeTable[cubeIndex] & 32)\n  852:                         vertices[5] = basePt + interpolate(mcNeighbourPts[5], mcNeighbourPts[6],\n  853                                                             tsdfValues[5], tsdfValues[6]);\n  854                      if (edgeTable[cubeIndex] & 64)\n  855:                         vertices[6] = basePt + interpolate(mcNeighbourPts[6], mcNeighbourPts[7],\n  856                                                             tsdfValues[6], tsdfValues[7]);\n  857                      if (edgeTable[cubeIndex] & 128)\n  858:                         vertices[7] = basePt + interpolate(mcNeighbourPts[7], mcNeighbourPts[4],\n  859                                                             tsdfValues[7], tsdfValues[4]);\n  860                      if (edgeTable[cubeIndex] & 256)\n  861:                         vertices[8] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[4],\n  862                                                             tsdfValues[0], tsdfValues[4]);\n  863                      if (edgeTable[cubeIndex] & 512)\n  864:                         vertices[9] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[5],\n  865                                                             tsdfValues[1], tsdfValues[5]);\n  866                      if (edgeTable[cubeIndex] & 1024)\n  867:                         vertices[10] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[6],\n  868                                                              tsdfValues[2], tsdfValues[6]);\n  869                      if (edgeTable[cubeIndex] & 2048)\n  870:                         vertices[11] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[7],\n  871                                                              tsdfValues[3], tsdfValues[7]);\n  872  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf_functions.cpp:\n  249  \n  250                      depthType v;\n  251:                     // bilinearly interpolate depth at projected\n  252                      {\n  253                          const v_float32x4& pt = projected;\n  ...\n  284                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  285                              v_float32x4 ty = v_setall_f32(t.get0());\n  286:                             // vx is y-interpolated between rows 0 and 1\n  287                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  288                              float v0 = vx.get0();\n  ...\n  514  \n  515                      depthType v;\n  516:                     // bilinearly interpolate depth at projected\n  517                      {\n  518                          const v_float32x4& pt = projected;\n  ...\n  549                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  550                              v_float32x4 ty = v_setall_f32(t.get0());\n  551:                             // vx is y-interpolated between rows 0 and 1\n  552                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  553                              float v0 = vx.get0();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/colored_tsdf.cpp:\n   85      virtual RGBTsdfVoxel at(const Vec3i& volumeIdx) const;\n   86  \n   87:     float interpolateVoxel(const cv::Point3f& p) const;\n   88      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   89:     float interpolateColor(float tx, float ty, float tz, float vx[8]) const;\n   90      Point3f getColorVoxel(const cv::Point3f& p) const;\n   91  \n   92  #if USE_INTRINSICS\n   93:     float interpolateVoxel(const v_float32x4& p) const;\n   94      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   95      v_float32x4 getColorVoxel(const v_float32x4& p) const;\n   ..\n  185  #if USE_INTRINSICS\n  186  // all coordinate checks should be done in inclosing cycle\n  187: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  188  {\n  189      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  190:     return interpolateVoxel(p);\n  191  }\n  192  \n  193: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  194  {\n  195      // tx, ty, tz = floor(p)\n  ...\n  232  }\n  233  #else\n  234: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  235  {\n  236      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  384  \n  385  #if USE_INTRINSICS\n  386: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  387  {\n  388      v_float32x4 v0246, v1357;\n  ...\n  402  }\n  403  #else\n  404: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  405  {\n  406      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  463      float ty = t.get0(); t = v_rotate_right<1>(t);\n  464      float tz = t.get0();\n  465:     rgb[0] = interpolateColor(tx, ty, tz, r);\n  466:     rgb[1] = interpolateColor(tx, ty, tz, g);\n  467:     rgb[2] = interpolateColor(tx, ty, tz, b);\n  468      rgb[3] = 0.f;\n  469  #else\n  ...\n  512      float tz = ptVox.z - iptVox[2];\n  513  \n  514:     res=Point3f(interpolateColor(tx, ty, tz, r),\n  515:                 interpolateColor(tx, ty, tz, g),\n  516:                 interpolateColor(tx, ty, tz, b));\n  517  #else\n  518      res=Point3f(volData[coordBase].r, volData[coordBase].g, volData[coordBase].b);\n  ...\n  627                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  628                      v_float32x4 next = (orig + dir * v_setall_f32(tmin));\n  629:                     float f = volume.interpolateVoxel(next), fnext = f;\n  630  \n  631                      //raymarch\n  ...\n  644                          if (fnext != f)\n  645                          {\n  646:                             fnext = volume.interpolateVoxel(next);\n  647  \n  648                              // when ray crosses a surface\n  ...\n  655  \n  656                      // if ray penetrates a surface from outside\n  657:                     // linearly interpolate t between two f values\n  658                      if (f > 0.f && fnext < 0.f)\n  659                      {\n  660                          v_float32x4 tp = next - rayStep;\n  661:                         float ft = volume.interpolateVoxel(tp);\n  662:                         float ftdt = volume.interpolateVoxel(next);\n  663                          float ts = tmin + tstep * (steps - ft / (ftdt - ft));\n  664  \n  ...\n  740                      Point3f rayStep = dir * tstep;\n  741                      Point3f next = (orig + dir * tmin);\n  742:                     float f = volume.interpolateVoxel(next), fnext = f;\n  743  \n  744                      //raymarch\n  ...\n  757                          if(fnext != f)\n  758                          {\n  759:                             fnext = volume.interpolateVoxel(next);\n  760                              // when ray crosses a surface\n  761                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  766                      }\n  767                      // if ray penetrates a surface from outside\n  768:                     // linearly interpolate t between two f values\n  769                      if(f > 0.f && fnext < 0.f)\n  770                      {\n  771                          Point3f tp    = next - rayStep;\n  772:                         float ft   = volume.interpolateVoxel(tp);\n  773:                         float ftdt = volume.interpolateVoxel(next);\n  774                          // float t = tmin + steps*tstep;\n  775                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  893                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  894                  {\n  895:                     //linearly interpolate coordinate\n  896                      float Vn    = Vc + vol.voxelSize;\n  897                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapaffine.cpp:\n   80  \n   81      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   82:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   83      // remap will not touch them).\n   84      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapshift.cpp:\n   81  \n   82      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   83:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   84      // remap will not touch them).\n   85      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapprojec.cpp:\n   83  \n   84      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   85:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   86      // remap will not touch them).\n   87      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retina_ocl.cpp:\n 1155      demultiplex(ocl_multiplexed_input, _demultiplexedTempBuffer);\n 1156  \n 1157:     // interpolate the demultiplexed frame depending on the color sampling method\n 1158      if (!adaptiveFiltering)\n 1159      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.hpp:\n  243          // protected functions\n  244          void _initColorSampling();\n  245:         void _interpolateImageDemultiplexedImage(float *inputOutputBuffer);\n  246:         void _interpolateSingleChannelImage111(float *inputOutputBuffer);\n  247:         void _interpolateBayerRGBchannels(float *inputOutputBuffer);\n  248          void _applyRIFfilter(const float *sourceBuffer, float *destinationBuffer);\n  249          void _getNormalizedContoursImage(const float *inputFrame, float *outputFrame);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.cpp:\n  264          _demultiplexedTempBuffer[*(colorSamplingPRT++)]=*(multiplexedColorFramePtr++);\n  265  \n  266:     // interpolate the demultiplexed frame depending on the color sampling method\n  267      if (!adaptiveFiltering)\n  268:         _interpolateImageDemultiplexedImage(&_demultiplexedTempBuffer[0]);\n  269  \n  270      // low pass filtering the demultiplexed frame\n  ...\n  453  }\n  454  \n  455: void RetinaColor::_interpolateImageDemultiplexedImage(float *inputOutputBuffer)\n  456  {\n  457  \n  ...\n  460  \n  461      case RETINA_COLOR_RANDOM:\n  462:         return; // no need to interpolate\n  463          break;\n  464  \n  465      case RETINA_COLOR_DIAGONAL:\n  466:         _interpolateSingleChannelImage111(inputOutputBuffer);\n  467          break;\n  468  \n  469      case RETINA_COLOR_BAYER: // default sets bayer sampling\n  470:         _interpolateBayerRGBchannels(inputOutputBuffer);\n  471          break;\n  472      default:\n  ...\n  479  }\n  480  \n  481: void RetinaColor::_interpolateSingleChannelImage111(float *inputOutputBuffer)\n  482  {\n  483      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows(); ++indexr)\n  ...\n  499  }\n  500  \n  501: void RetinaColor::_interpolateBayerRGBchannels(float *inputOutputBuffer)\n  502  {\n  503      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows()-1; indexr+=2)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/tutorial_charuco_create_detect.cpp:\n   59                  std::vector<cv::Point2f> charucoCorners;\n   60                  std::vector<int> charucoIds;\n   61:                 cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);\n   62                  //! [charidcor]\n   63                  // if at least one charuco corner detected\n   ..\n  110              std::vector<cv::Point2f> charucoCorners;\n  111              std::vector<int> charucoIds;\n  112:             cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds);\n  113              //! [charidcorwc]\n  114              // if at least one charuco corner detected\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/detect_board_charuco.cpp:\n  173                                           camMatrix, distCoeffs);\n  174  \n  175:         // interpolate charuco corners\n  176:         int interpolatedCorners = 0;\n  177          if(markerIds.size() > 0)\n  178:             interpolatedCorners =\n  179:                 aruco::interpolateCornersCharuco(markerCorners, markerIds, image, charucoboard,\n  180                                                   charucoCorners, charucoIds, camMatrix, distCoeffs);\n  181  \n  ...\n  207              aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, noArray(), Scalar(100, 0, 255));\n  208  \n  209:         if(interpolatedCorners > 0) {\n  210              Scalar color;\n  211              color = Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/calibrate_camera_charuco.cpp:\n  178          if(refindStrategy) aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  179  \n  180:         // interpolate charuco corners\n  181          Mat currentCharucoCorners, currentCharucoIds;\n  182          if(ids.size() > 0)\n  183:             aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners,\n  184                                               currentCharucoIds);\n  185  \n  ...\n  248  \n  249      for(int i = 0; i < nFrames; i++) {\n  250:         // interpolate using camera parameters\n  251          Mat currentCharucoCorners, currentCharucoIds;\n  252:         aruco::interpolateCornersCharuco(allCorners[i], allIds[i], allImgs[i], charucoboard,\n  253                                           currentCharucoCorners, currentCharucoIds, cameraMatrix,\n  254                                           distCoeffs);\n  ...\n  280      cout << \"Calibration saved to \" << outputFile << endl;\n  281  \n  282:     // show interpolated charuco corners for debugging\n  283      if(showChessboardCorners) {\n  284          for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/test/test_charucodetection.cpp:\n  256                  }\n  257  \n  258:                 // interpolate charuco corners\n  259                  vector< Point2f > charucoCorners;\n  260                  vector< int > charucoIds;\n  261  \n  262                  if(iter % 2 == 0) {\n  263:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  264                                                       charucoIds);\n  265                  } else {\n  266:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  267                                                       charucoIds, cameraMatrix, distCoeffs);\n  268                  }\n  ...\n  354                  }\n  355  \n  356:                 // interpolate charuco corners\n  357                  vector< Point2f > charucoCorners;\n  358                  vector< int > charucoIds;\n  359  \n  360                  if(iter % 2 == 0) {\n  361:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  362                                                       charucoIds);\n  363                  } else {\n  364:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  365                                                       charucoIds, cameraMatrix, distCoeffs);\n  366                  }\n  ...\n  719  \n  720      cv::Mat c_ids, c_corners;\n  721:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids, K);\n  722      cv::Mat corners_reshaped = c_corners.reshape(1);\n  723  \n  ...\n  727      c_ids = cv::Mat();\n  728      c_corners = cv::Mat();\n  729:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids);\n  730      corners_reshaped = c_corners.reshape(1);\n  731  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp:\n  434   *\n  435   * This function tries to find markers that were not detected in the basic detecMarkers function.\n  436:  * First, based on the current detected marker and the board layout, the function interpolates\n  437   * the position of the missing markers. Then it tries to find correspondence between the reprojected\n  438   * markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n  439   * parameters.\n  440   * If camera parameters and distortion coefficients are provided, missing markers are reprojected\n  441:  * using projectPoint function. If not, missing marker projections are interpolated using global\n  442   * homography, and all the marker corners in the board must have the same Z coordinate.\n  443   */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp:\n  141   * should be sent in corners and ids parameters.\n  142   * @param board layout of ChArUco board.\n  143:  * @param charucoCorners interpolated chessboard corners\n  144:  * @param charucoIds interpolated chessboard corners identifiers\n  145   * @param cameraMatrix optional 3x3 floating-point camera matrix\n  146   * \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n  ...\n  154   * Only visible corners are returned. For each corner, its corresponding identifier is\n  155   * also returned in charucoIds.\n  156:  * The function returns the number of interpolated corners.\n  157   */\n  158: CV_EXPORTS_W int interpolateCornersCharuco(InputArrayOfArrays markerCorners, InputArray markerIds,\n  159                                             InputArray image, const Ptr<CharucoBoard> &board,\n  160                                             OutputArray charucoCorners, OutputArray charucoIds,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/aruco.cpp:\n  749   * @param nContours, contour-container\n  750   */\n  751: static Point3f _interpolate2Dline(const std::vector<cv::Point2f>& nContours){\n  752  \tfloat minX, minY, maxX, maxY;\n  753  \tminX = maxX = nContours[0].x;\n  ...\n  864  \tPoint3f lines[4];\n  865  \tfor(int i=0; i<4; i++){\n  866: \t\tlines[i]=_interpolate2Dline(cntPts[i]);\n  867  \t}\n  868  \n  ...\n 1723          }\n 1724  \n 1725:         // interpolate tiny marker to marker position in markerZone\n 1726          inCorners[0] = Point2f(-0.5f, -0.5f);\n 1727          inCorners[1] = Point2f(marker.cols - 0.5f, -0.5f);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/charuco.cpp:\n  394    * Interpolate charuco corners using approximated pose estimation\n  395    */\n  396: static int _interpolateCornersCharucoApproxCalib(InputArrayOfArrays _markerCorners,\n  397                                                   InputArray _markerIds, InputArray _image,\n  398                                                   const Ptr<CharucoBoard> &_board,\n  ...\n  438    * Interpolate charuco corners using local homography\n  439    */\n  440: static int _interpolateCornersCharucoLocalHom(InputArrayOfArrays _markerCorners,\n  441                                                InputArray _markerIds, InputArray _image,\n  442                                                const Ptr<CharucoBoard> &_board,\n  ...\n  482          Point2f objPoint2D = Point2f(_board->chessboardCorners[i].x, _board->chessboardCorners[i].y);\n  483  \n  484:         vector< Point2f > interpolatedPositions;\n  485          for(unsigned int j = 0; j < _board->nearestMarkerIdx[i].size(); j++) {\n  486              int markerId = _board->ids[_board->nearestMarkerIdx[i][j]];\n  ...\n  498                  in.push_back(objPoint2D);\n  499                  perspectiveTransform(in, out, transformations[markerIdx]);\n  500:                 interpolatedPositions.push_back(out[0]);\n  501              }\n  502          }\n  503  \n  504          // none of the closest markers detected\n  505:         if(interpolatedPositions.size() == 0) continue;\n  506  \n  507          // more than one closest marker detected, take middle point\n  508:         if(interpolatedPositions.size() > 1) {\n  509:             allChessboardImgPoints[i] = (interpolatedPositions[0] + interpolatedPositions[1]) / 2.;\n  510          }\n  511          // a single closest marker detected\n  512:         else allChessboardImgPoints[i] = interpolatedPositions[0];\n  513      }\n  514  \n  ...\n  529  /**\n  530    */\n  531: int interpolateCornersCharuco(InputArrayOfArrays _markerCorners, InputArray _markerIds,\n  532                                InputArray _image, const Ptr<CharucoBoard> &_board,\n  533                                OutputArray _charucoCorners, OutputArray _charucoIds,\n  ...\n  536      // if camera parameters are avaible, use approximated calibration\n  537      if(_cameraMatrix.total() != 0) {\n  538:         _interpolateCornersCharucoApproxCalib(_markerCorners, _markerIds, _image, _board,\n  539                                                       _cameraMatrix, _distCoeffs, _charucoCorners,\n  540                                                       _charucoIds);\n  ...\n  542      // else use local homography\n  543      else {\n  544:         _interpolateCornersCharucoLocalHom(_markerCorners, _markerIds, _image, _board,\n  545                                                    _charucoCorners, _charucoIds);\n  546      }\n  ...\n  791              }\n  792  \n  793:             // interpolate the charuco corners of the diamond\n  794              vector< Point2f > currentMarkerCorners;\n  795              Mat aux;\n  796:             interpolateCornersCharuco(currentMarker, currentMarkerId, grey, _charucoDiamondLayout,\n  797                                        currentMarkerCorners, aux, _cameraMatrix, _distCoeffs);\n  798  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/include/opencv2/viz/widgets.hpp:\n  665              @param radius Radius of the spheres.\n  666              @param from Color for first sphere.\n  667:             @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  668               */\n  669              WTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/misc/python/python_viz.hpp:\n  841      @param radius Radius of the spheres.\n  842      @param from Color for first sphere.\n  843:     @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  844       */\n  845      CV_WRAP PyWTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy.hpp:\n  219  @param newFrame Output image.\n  220  @param buf Temporary buffer, will have width x 6\\*height size, CV_32FC1 type and contain 6\n  221: GpuMat: occlusion masks for first frame, occlusion masks for second, interpolated forward\n  222: horizontal flow, interpolated forward vertical flow, interpolated backward horizontal flow,\n  223: interpolated backward vertical flow.\n  224  @param stream Stream for the asynchronous version.\n  225   */\n  226: CV_EXPORTS void interpolateFrames(const GpuMat& frame0, const GpuMat& frame1,\n  227                                    const GpuMat& fu, const GpuMat& fv,\n  228                                    const GpuMat& bu, const GpuMat& bv,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy/NCVPyramid.hpp:\n   56      {\n   57          CV_EXPORTS void downsampleX2(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   58:         CV_EXPORTS void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   59      }\n   60  }}}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/image_pyramid.cpp:\n  136          }\n  137  \n  138:         cv::cuda::device::pyramid::interpolateFrom1(lastLayer, outImg, outImg.depth(), outImg.channels(), StreamAccessor::getStream(stream));\n  139      }\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp:\n   48  #if !defined (HAVE_CUDA) || !defined (HAVE_OPENCV_CUDALEGACY) || defined (CUDA_DISABLER)\n   49  \n   50: void cv::cuda::interpolateFrames(const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, float, GpuMat&, GpuMat&, Stream&) { throw_no_cuda(); }\n   51  \n   52  #else\n   53  \n   54: void cv::cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv,\n   55                                  float pos, GpuMat& newFrame, GpuMat& buf, Stream& s)\n   56  {\n   ..\n   71      GpuMat occ1 = buf.rowRange(1 * frame0.rows, 2 * frame0.rows);\n   72  \n   73:     // interpolated forward flow\n   74      GpuMat fui = buf.rowRange(2 * frame0.rows, 3 * frame0.rows);\n   75      GpuMat fvi = buf.rowRange(3 * frame0.rows, 4 * frame0.rows);\n   76  \n   77:     // interpolated backward flow\n   78      GpuMat bui = buf.rowRange(4 * frame0.rows, 5 * frame0.rows);\n   79      GpuMat bvi = buf.rowRange(5 * frame0.rows, 6 * frame0.rows);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/lbph_faces.cpp:\n  241          for(int i=radius; i < src.rows-radius;i++) {\n  242              for(int j=radius;j < src.cols-radius;j++) {\n  243:                 // calculate interpolated value\n  244                  float t = static_cast<float>(w1*src.at<_Tp>(i+fy,j+fx) + w2*src.at<_Tp>(i+fy,j+cx) + w3*src.at<_Tp>(i+cy,j+fx) + w4*src.at<_Tp>(i+cy,j+cx));\n  245                  // floating point precision, so check some machine-dependent epsilon\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/column_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/row_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n310 matches across 80 files\n\n\nSearching 10264 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/libwebsockets/lib/drivers/led/led-seq.c:\n   27  \n   28  /*\n   29:  * 64 entry interpolated CIE correction\n   30   * https://en.wikipedia.org/wiki/Lightness\n   31   */\n\n/home/roman/Projects/plot-cv/quickjs/qjs-net/libwebsockets/lib/drivers/pwm/pwm.c:\n   33  \t    0,   158,   630,  1411,  2494,  3869,  5522,  7437,\n   34  \t 9597, 11980, 14562, 17321, 20228, 23225, 26374, 29555,\n   35: \t32767 /* to interpolate against */\n   36  };\n   37  \n   38  /*\n   39   * Elaborate the 90 degree phase table to 360 degrees and offset to +32768,\n   40:  * notice for the last sample we have to interpolate against a 17th sample\n   41   * reflecting full scale to avoid clipping due to interpolation against the\n   42   * 16th sample again\n\n/home/roman/Projects/plot-cv/quickjs/qjs-glfw/glfw/deps/nuklear.h:\n 11414                      scy = y;\n 11415                      if (!(vertices[off+i+1].type & 1)) {\n 11416:                         /* next point is also a curve point, so interpolate an on-point curve */\n 11417                          sx = (x + (nk_int) vertices[off+i+1].x) >> 1;\n 11418                          sy = (y + (nk_int) vertices[off+i+1].y) >> 1;\n .....\n 11434                  if (!(flags & 1))\n 11435                  { /* if it's a curve */\n 11436:                     if (was_off) /* two off-curve control points in a row means interpolate an on-curve midpoint */\n 11437                          nk_tt_setvertex(&vertices[num_vertices++], NK_TT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 11438                      cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/imstb_truetype.h:\n 1741                 scy = y;\n 1742                 if (!(vertices[off+i+1].type & 1)) {\n 1743:                   // next point is also a curve point, so interpolate an on-point curve\n 1744                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1745                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1760           } else {\n 1761              if (!(flags & 1)) { // if it's a curve\n 1762:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1763                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1764                 cx = x;\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_image.h:\n 1443  //        - allows good upsampling (see next)\n 1444  //    high-quality\n 1445: //      - upsampled channels are bilinearly interpolated, even across blocks\n 1446  //      - quality integer IDCT derived from IJG's 'slow'\n 1447  //    performance\n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/nanovg.h:\n  196  \n  197  \n  198: // Linearly interpolates from color c0 to c1, and returns resulting color value.\n  199  NVGcolor nvgLerpRGBA(NVGcolor c0, NVGcolor c1, float u);\n  200  \n\n/home/roman/Projects/plot-cv/quickjs/qjs-nanovg/nanovg/src/stb_truetype.h:\n 1771                 scy = y;\n 1772                 if (!(vertices[off+i+1].type & 1)) {\n 1773:                   // next point is also a curve point, so interpolate an on-point curve\n 1774                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1775                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1790           } else {\n 1791              if (!(flags & 1)) { // if it's a curve\n 1792:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1793                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1794                 cx = x;\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/opencv/disabled/detect_board_charuco.cpp:\n  194        cv::aruco::refineDetectedMarkers(image, board, markerCorners, markerIds, rejectedMarkers, camMatrix, distCoeffs);\n  195  \n  196:     // interpolate charuco corners\n  197:     int interpolatedCorners = 0;\n  198      if(markerIds.size() > 0)\n  199:       interpolatedCorners = cv::aruco::interpolateCornersCharuco(\n  200            markerCorners, markerIds, image, charucoboard, charucoCorners, charucoIds, camMatrix, distCoeffs);\n  201  \n  ...\n  223        cv::aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, cv::noArray(), cv::Scalar(100, 0, 255));\n  224  \n  225:     if(interpolatedCorners > 0) {\n  226        cv::Scalar color;\n  227        color = cv::Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/imgui/imstb_truetype.h:\n 1934            scy = y;\n 1935            if(!(vertices[off + i + 1].type & 1)) {\n 1936:             // next point is also a curve point, so interpolate an on-point curve\n 1937              sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;\n 1938              sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;\n ....\n 1953        } else {\n 1954          if(!(flags & 1)) { // if it's a curve\n 1955:           if(was_off)      // two off-curve control points in a row means interpolate an on-curve\n 1956                             // midpoint\n 1957              stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.hpp:\n  116      bool findMaximaInLayer(int counterOffset, int octave, int layer_rows, int layer_cols);\n  117  \n  118:     bool interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int maxFeatures);\n  119  \n  120      bool calcOrientation(UMat &keypoints);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/msd.cpp:\n  263               * @param scale scale of the key-point over the image pyramid\n  264               * @param saliency pointer to the saliency array\n  265:              * @param p_res interpolated coordinates of the key-point referred to the lowest level of the pyramid (i.e. in the ref. frame of the input image)\n  266               * @return false if the current key-point has to be rejected, true otherwise\n  267               */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.ocl.cpp:\n  187          if (maxCounter > 0)\n  188          {\n  189:             if(!interpolateKeypoint(maxCounter, keypoints, octave, layer_rows, maxFeatures))\n  190                  return false;\n  191          }\n  ...\n  431  }\n  432  \n  433: bool SURF_OCL::interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int max_features)\n  434  {\n  435      size_t localThreads[3]  = {3, 3, 3};\n  436      size_t globalThreads[3] = {maxCounter*localThreads[0], localThreads[1], 3};\n  437  \n  438:     ocl::Kernel kerInterp(\"SURF_interpolateKeypoint\", ocl::xfeatures2d::surf_oclsrc, kerOpts);\n  439  \n  440      return kerInterp.args(ocl::KernelArg::ReadOnlyNoSize(det),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/daisy.cpp:\n  371  \n  372  \n  373: static float interpolate_peak( float left, float center, float right )\n  374  {\n  375      if( center < 0.0 )\n  ...\n 1409                 next -= m_orientation_resolution;\n 1410  \n 1411:             peak = interpolate_peak(hist.at<float>(prev), hist.at<float>(max_ind), hist.at<float>(next));\n 1412              angle = (float)( ((float)max_ind + peak)*360.0/m_orientation_resolution );\n 1413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.cpp:\n  220   * approximated using central differences. The linear system Ax = b is then\n  221   * solved, where A is the Hessian, b is the negative gradient, and x is the\n  222:  * offset of the interpolated maxima coordinates from the initial estimate.\n  223   * This is equivalent to an iteration of Netwon's optimisation algorithm.\n  224   *\n  ...\n  232   */\n  233  static int\n  234: interpolateKeypoint( float N9[3][9], int dx, int dy, int ds, KeyPoint& kpt )\n  235  {\n  236      Vec3f b(-(N9[1][5]-N9[1][3])/2,  // Negative 1st deriv with respect to x\n  ...\n  433                      /* Interpolate maxima location within the 3x3x3 neighbourhood  */\n  434                      int ds = size - sizes[layer-1];\n  435:                     int interp_ok = interpolateKeypoint( N9, sampleStep, sampleStep, ds, kpt );\n  436  \n  437                      /* Sometimes the interpolation step gives a negative size etc. */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparsetodenseflow.cpp:\n  106      gd->setFGSLambda(fgs_lambda);\n  107      gd->setFGSSigma (fgs_sigma);\n  108:     gd->interpolate(prev,points_filtered,cur,dst_points_filtered,dense_flow);\n  109  }\n  110  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlofflow.cpp:\n  218              gd->setFGSSigma(fgs_sigma);\n  219              gd->setUsePostProcessing(use_post_proc);\n  220:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  221          }\n  222          else if (interp_type == InterpolationType::INTERP_RIC)\n  ...\n  230              gd->setUseGlobalSmootherFilter(use_post_proc);\n  231              gd->setUseVariationalRefinement(false);\n  232:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  233          }\n  234          else\n  ...\n  237              GaussianBlur(prevImage, blurredPrevImage, cv::Size(5, 5), -1);\n  238              std::vector<uchar> status(filtered_currPoints.size(), 1);\n  239:             interpolate_irregular_nn_raster(filtered_prevPoints, filtered_currPoints, status, blurredPrevImage).copyTo(dense_flow);\n  240              std::vector<Mat> vecMats;\n  241              std::vector<Mat> vecMats2(2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.cpp:\n  115  }\n  116  \n  117: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n  118      const std::vector<Point2f> & nextPoints,\n  119      const std::vector<uchar> & status,\n  ...\n  241  }\n  242  \n  243: Mat interpolate_irregular_knn(\n  244      const std::vector<Point2f> & _prevPoints,\n  245      const std::vector<Point2f> & _nextPoints,\n  ...\n  401  \n  402  \n  403: Mat interpolate_irregular_nn(\n  404      const std::vector<Point2f> & _prevPoints,\n  405      const std::vector<Point2f> & _nextPoints,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.hpp:\n   12  Mat sgeo_dist(const Mat& gra, int y, int x, float max, Mat &prev);\n   13  Mat sgeo_dist(const Mat& gra, const std::vector<Point2f> & points, float max, Mat &prev);\n   14: Mat interpolate_irregular_nw(const Mat &in, const Mat &mask, const Mat &color_img, float max_d, float bandwidth, float pixeldistance);\n   15: Mat interpolate_irregular_nn(\n   16      const std::vector<Point2f> & prevPoints,\n   17      const std::vector<Point2f> & nextPoints,\n   ..\n   19      const Mat &color_img,\n   20      float pixeldistance);\n   21: Mat interpolate_irregular_knn(\n   22      const std::vector<Point2f> & _prevPoints,\n   23      const std::vector<Point2f> & _nextPoints,\n   ..\n   27      float pixeldistance);\n   28  \n   29: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n   30      const std::vector<Point2f> & nextPoints,\n   31      const std::vector<uchar> & status,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_sparse_match_interpolator.cpp:\n   90      interpolator->setFGSLambda(500.0f);\n   91      interpolator->setFGSSigma(1.5f);\n   92:     interpolator->interpolate(src,from_points,Mat(),to_points,res_flow);\n   93  \n   94      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n   ..\n   97      Mat from_point_mat(from_points);\n   98      Mat to_points_mat(to_points);\n   99:     interpolator->interpolate(src,from_point_mat,Mat(),to_points_mat,res_flow);\n  100  \n  101      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  146      interpolator->setFGSLambda(500.f);\n  147      interpolator->setFGSSigma(1.5f);\n  148:     interpolator->interpolate(src, from_points, src1, to_points, res_flow);\n  149  \n  150      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  153      Mat from_point_mat(from_points);\n  154      Mat to_points_mat(to_points);\n  155:     interpolator->interpolate(src, from_point_mat, src1, to_points_mat, res_flow);\n  156  \n  157      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  205          cv::setNumThreads(nThreads);\n  206          Mat resMultiThread;\n  207:         interpolator->interpolate(from,from_points,Mat(),to_points,resMultiThread);\n  208  \n  209          cv::setNumThreads(1);\n  210          Mat resSingleThread;\n  211:         interpolator->interpolate(from,from_points,Mat(),to_points,resSingleThread);\n  212  \n  213          EXPECT_LE(cv::norm(resSingleThread, resMultiThread, NORM_INF), MAX_DIF);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp:\n   67      @param dense_flow output dense matching (two-channel CV_32F image)\n   68       */\n   69:     CV_WRAP virtual void interpolate(InputArray from_image, InputArray from_points,\n   70                                       InputArray to_image  , InputArray to_points,\n   71                                       OutputArray dense_flow) = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/sparse_match_interpolators.cpp:\n   78  public:\n   79      static Ptr<EdgeAwareInterpolatorImpl> create();\n   80:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n   81  \n   82  protected:\n   ..\n  171  }\n  172  \n  173: void EdgeAwareInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray, InputArray to_points, OutputArray dense_flow)\n  174  {\n  175      CV_Assert( !from_image.empty() && (from_image.depth() == CV_8U) && (from_image.channels() == 3 || from_image.channels() == 1) );\n  ...\n  906  public:\n  907      static Ptr<RICInterpolatorImpl> create();\n  908:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n  909  \n  910  protected:\n  ...\n 1109  };\n 1110  \n 1111: void RICInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow)\n 1112  {\n 1113      CV_Assert(!from_image.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 2199              /* update lower y limit (start) for the new 'column'.\n 2200  \n 2201:             We need to interpolate the y value that corresponds to the\n 2202              lower side of the rectangle. The first thing is to decide if\n 2203              the corresponding side is\n ....\n 2206              vx[3],vy[3] to vx[2],vy[2]\n 2207  \n 2208:             Then, the side is interpolated for the x value of the\n 2209              'column'. But, if the side is vertical (as it could happen if\n 2210              the rectangle is vertical and we are dealing with the first\n ....\n 2245              /* update upper y limit (end) for the new 'column'.\n 2246  \n 2247:             We need to interpolate the y value that corresponds to the\n 2248              upper side of the rectangle. The first thing is to decide if\n 2249              the corresponding side is\n ....\n 2252              vx[1],vy[1] to vx[2],vy[2]\n 2253  \n 2254:             Then, the side is interpolated for the x value of the\n 2255              'column'. But, if the side is vertical (as it could happen if\n 2256              the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/nonrigid_icp.cpp:\n  306                  continue;\n  307  \n  308:             // TODO: interpolate Vg instead of simply converting projected coords to int\n  309              Vg.at<Vec3f>(y, x) = vertImage.at<Vec3f>((int)newCoords.y, (int)newCoords.x);\n  310  \n  311:             // bilinearly interpolate newPoints under newCoords point\n  312              int xi = cvFloor(newCoords.x), yi = cvFloor(newCoords.y);\n  313              float tx  = newCoords.x - xi, ty = newCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.hpp:\n   74      virtual TsdfVoxel at(const Vec3i& volumeIdx) const;\n   75  \n   76:     float interpolateVoxel(const cv::Point3f& p) const;\n   77      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   78  \n   79  #if USE_INTRINSICS\n   80:     float interpolateVoxel(const v_float32x4& p) const;\n   81      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   82  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/hash_tsdf.cpp:\n  126  \n  127  \n  128:     float interpolateVoxelPoint(const Point3f& point) const;\n  129:     float interpolateVoxel(const cv::Point3f& point) const;\n  130      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  131  \n  ...\n  421  \n  422  #if USE_INTRINSICS\n  423: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  424  {\n  425      v_float32x4 v0246, v1357;\n  ...\n  440  \n  441  #else\n  442: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  443  {\n  444      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  454  #endif\n  455  \n  456: float HashTSDFVolumeCPU::interpolateVoxelPoint(const Point3f& point) const\n  457  {\n  458      const Vec3i neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n  ...\n  495      }\n  496  \n  497:     return interpolate(tx, ty, tz, vx);\n  498  }\n  499  \n  500: inline float HashTSDFVolumeCPU::interpolateVoxel(const cv::Point3f& point) const\n  501  {\n  502:     return interpolateVoxelPoint(point * voxelSizeInv);\n  503  }\n  504  \n  ...\n  631      float tz = ptVox.z - iptVox[2];\n  632  \n  633:     normal[0] = interpolate(tx, ty, tz, cxv);\n  634:     normal[1] = interpolate(tx, ty, tz, cyv);\n  635:     normal[2] = interpolate(tx, ty, tz, czv);\n  636  #endif\n  637  \n  ...\n  921  \n  922  \n  923:     float interpolateVoxelPoint(const Point3f& point) const;\n  924:     float interpolateVoxel(const cv::Point3f& point) const;\n  925      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  926  \n  ...\n 1380  }\n 1381  \n 1382: float HashTSDFVolumeGPU::interpolateVoxelPoint(const Point3f& point) const\n 1383  {\n 1384      const Vec3i local_neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n ....\n 1421      }\n 1422  \n 1423:     return interpolate(tx, ty, tz, vx);\n 1424  }\n 1425  \n 1426: inline float HashTSDFVolumeGPU::interpolateVoxel(const cv::Point3f& point) const\n 1427  {\n 1428:     return interpolateVoxelPoint(point * voxelSizeInv);\n 1429  }\n 1430  \n ....\n 1556      float tz = ptVox.z - iptVox[2];\n 1557  \n 1558:     normal[0] = interpolate(tx, ty, tz, cxv);\n 1559:     normal[1] = interpolate(tx, ty, tz, cyv);\n 1560:     normal[2] = interpolate(tx, ty, tz, czv);\n 1561  #endif\n 1562      float nv = sqrt(normal[0] * normal[0] +\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/fast_icp.cpp:\n  243                      continue;\n  244  \n  245:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  246                  v_float32x4 oldP;\n  247                  v_float32x4 oldN;\n  ...\n  390                      continue;\n  391  \n  392:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  393                  int xi = cvFloor(oldCoords.x), yi = cvFloor(oldCoords.y);\n  394                  float tx  = oldCoords.x - xi, ty = oldCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.cpp:\n  137  #if USE_INTRINSICS\n  138  // all coordinate checks should be done in inclosing cycle\n  139: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  140  {\n  141      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  142:     return interpolateVoxel(p);\n  143  }\n  144  \n  145: inline float TSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  146  {\n  147      // tx, ty, tz = floor(p)\n  ...\n  184  }\n  185  #else\n  186: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  187  {\n  188      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  438                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  439                      v_float32x4 next    = (orig + dir * v_setall_f32(tmin));\n  440:                     float f = volume.interpolateVoxel(next), fnext = f;\n  441  \n  442                      //raymarch\n  ...\n  455                          if(fnext != f)\n  456                          {\n  457:                             fnext = volume.interpolateVoxel(next);\n  458  \n  459                              // when ray crosses a surface\n  ...\n  466  \n  467                      // if ray penetrates a surface from outside\n  468:                     // linearly interpolate t between two f values\n  469                      if(f > 0.f && fnext < 0.f)\n  470                      {\n  471                          v_float32x4 tp = next - rayStep;\n  472:                         float ft    = volume.interpolateVoxel(tp);\n  473:                         float ftdt  = volume.interpolateVoxel(next);\n  474                          float ts = tmin + tstep*(steps - ft/(ftdt - ft));\n  475  \n  ...\n  547                      Point3f rayStep = dir * tstep;\n  548                      Point3f next = (orig + dir * tmin);\n  549:                     float f = volume.interpolateVoxel(next), fnext = f;\n  550  \n  551                      //raymarch\n  ...\n  564                          if(fnext != f)\n  565                          {\n  566:                             fnext = volume.interpolateVoxel(next);\n  567                              // when ray crosses a surface\n  568                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  573                      }\n  574                      // if ray penetrates a surface from outside\n  575:                     // linearly interpolate t between two f values\n  576                      if(f > 0.f && fnext < 0.f)\n  577                      {\n  578                          Point3f tp    = next - rayStep;\n  579:                         float ft   = volume.interpolateVoxel(tp);\n  580:                         float ftdt = volume.interpolateVoxel(next);\n  581                          // float t = tmin + steps*tstep;\n  582                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  692                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  693                  {\n  694:                     //linearly interpolate coordinate\n  695                      float Vn    = Vc + vol.voxelSize;\n  696                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/warpfield.cpp:\n  212  \n  213          Affine3f pose = DQB(weights, transforms);\n  214:         // linearly interpolate translations\n  215          Vec3f translation(0,0,0);\n  216          float totalWeight = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/dynafu_tsdf.cpp:\n   48      virtual void reset() override;\n   49  \n   50:     volumeType interpolateVoxel(cv::Point3f p) const;\n   51      Point3f getNormalVoxel(cv::Point3f p) const;\n   52  \n   ..\n   59  \n   60  private:\n   61:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const;\n   62  };\n   63  \n   ..\n  330  }\n  331  \n  332: inline volumeType TSDFVolumeCPU::interpolateVoxel(Point3f p) const\n  333  {\n  334      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  472                      Point3f rayStep = dir * tstep;\n  473                      Point3f next = (orig + dir * tmin);\n  474:                     volumeType f = volume.interpolateVoxel(next), fnext = f;\n  475  \n  476                      //raymarch\n  ...\n  489                          if(fnext != f)\n  490                          {\n  491:                             fnext = volume.interpolateVoxel(next);\n  492  \n  493                              // when ray crosses a surface\n  ...\n  500  \n  501                      // if ray penetrates a surface from outside\n  502:                     // linearly interpolate t between two f values\n  503                      if(f > 0.f && fnext < 0.f)\n  504                      {\n  505                          Point3f tp = next - rayStep;\n  506:                         volumeType ft   = volume.interpolateVoxel(tp);\n  507:                         volumeType ftdt = volume.interpolateVoxel(next);\n  508                          // float t = tmin + steps*tstep;\n  509                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  621                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  622                  {\n  623:                     //linearly interpolate coordinate\n  624                      float Vn = Vc + vol.voxelSize;\n  625                      float dinv = 1.f/(abs(v0)+abs(vd));\n  ...\n  790      }\n  791  \n  792:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const\n  793      {\n  794          float dV = 0.5f;\n  ...\n  835  \n  836                      if (edgeTable[cubeIndex] & 1)\n  837:                         vertices[0] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[1],\n  838                                                             tsdfValues[0], tsdfValues[1]);\n  839                      if (edgeTable[cubeIndex] & 2)\n  840:                         vertices[1] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[2],\n  841                                                             tsdfValues[1], tsdfValues[2]);\n  842                      if (edgeTable[cubeIndex] & 4)\n  843:                         vertices[2] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[3],\n  844                                                             tsdfValues[2], tsdfValues[3]);\n  845                      if (edgeTable[cubeIndex] & 8)\n  846:                         vertices[3] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[0],\n  847                                                             tsdfValues[3], tsdfValues[0]);\n  848                      if (edgeTable[cubeIndex] & 16)\n  849:                         vertices[4] = basePt + interpolate(mcNeighbourPts[4], mcNeighbourPts[5],\n  850                                                             tsdfValues[4], tsdfValues[5]);\n  851                      if (edgeTable[cubeIndex] & 32)\n  852:                         vertices[5] = basePt + interpolate(mcNeighbourPts[5], mcNeighbourPts[6],\n  853                                                             tsdfValues[5], tsdfValues[6]);\n  854                      if (edgeTable[cubeIndex] & 64)\n  855:                         vertices[6] = basePt + interpolate(mcNeighbourPts[6], mcNeighbourPts[7],\n  856                                                             tsdfValues[6], tsdfValues[7]);\n  857                      if (edgeTable[cubeIndex] & 128)\n  858:                         vertices[7] = basePt + interpolate(mcNeighbourPts[7], mcNeighbourPts[4],\n  859                                                             tsdfValues[7], tsdfValues[4]);\n  860                      if (edgeTable[cubeIndex] & 256)\n  861:                         vertices[8] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[4],\n  862                                                             tsdfValues[0], tsdfValues[4]);\n  863                      if (edgeTable[cubeIndex] & 512)\n  864:                         vertices[9] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[5],\n  865                                                             tsdfValues[1], tsdfValues[5]);\n  866                      if (edgeTable[cubeIndex] & 1024)\n  867:                         vertices[10] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[6],\n  868                                                              tsdfValues[2], tsdfValues[6]);\n  869                      if (edgeTable[cubeIndex] & 2048)\n  870:                         vertices[11] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[7],\n  871                                                              tsdfValues[3], tsdfValues[7]);\n  872  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf_functions.cpp:\n  249  \n  250                      depthType v;\n  251:                     // bilinearly interpolate depth at projected\n  252                      {\n  253                          const v_float32x4& pt = projected;\n  ...\n  284                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  285                              v_float32x4 ty = v_setall_f32(t.get0());\n  286:                             // vx is y-interpolated between rows 0 and 1\n  287                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  288                              float v0 = vx.get0();\n  ...\n  514  \n  515                      depthType v;\n  516:                     // bilinearly interpolate depth at projected\n  517                      {\n  518                          const v_float32x4& pt = projected;\n  ...\n  549                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  550                              v_float32x4 ty = v_setall_f32(t.get0());\n  551:                             // vx is y-interpolated between rows 0 and 1\n  552                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  553                              float v0 = vx.get0();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/colored_tsdf.cpp:\n   85      virtual RGBTsdfVoxel at(const Vec3i& volumeIdx) const;\n   86  \n   87:     float interpolateVoxel(const cv::Point3f& p) const;\n   88      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   89:     float interpolateColor(float tx, float ty, float tz, float vx[8]) const;\n   90      Point3f getColorVoxel(const cv::Point3f& p) const;\n   91  \n   92  #if USE_INTRINSICS\n   93:     float interpolateVoxel(const v_float32x4& p) const;\n   94      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   95      v_float32x4 getColorVoxel(const v_float32x4& p) const;\n   ..\n  185  #if USE_INTRINSICS\n  186  // all coordinate checks should be done in inclosing cycle\n  187: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  188  {\n  189      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  190:     return interpolateVoxel(p);\n  191  }\n  192  \n  193: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  194  {\n  195      // tx, ty, tz = floor(p)\n  ...\n  232  }\n  233  #else\n  234: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  235  {\n  236      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  384  \n  385  #if USE_INTRINSICS\n  386: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  387  {\n  388      v_float32x4 v0246, v1357;\n  ...\n  402  }\n  403  #else\n  404: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  405  {\n  406      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  463      float ty = t.get0(); t = v_rotate_right<1>(t);\n  464      float tz = t.get0();\n  465:     rgb[0] = interpolateColor(tx, ty, tz, r);\n  466:     rgb[1] = interpolateColor(tx, ty, tz, g);\n  467:     rgb[2] = interpolateColor(tx, ty, tz, b);\n  468      rgb[3] = 0.f;\n  469  #else\n  ...\n  512      float tz = ptVox.z - iptVox[2];\n  513  \n  514:     res=Point3f(interpolateColor(tx, ty, tz, r),\n  515:                 interpolateColor(tx, ty, tz, g),\n  516:                 interpolateColor(tx, ty, tz, b));\n  517  #else\n  518      res=Point3f(volData[coordBase].r, volData[coordBase].g, volData[coordBase].b);\n  ...\n  627                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  628                      v_float32x4 next = (orig + dir * v_setall_f32(tmin));\n  629:                     float f = volume.interpolateVoxel(next), fnext = f;\n  630  \n  631                      //raymarch\n  ...\n  644                          if (fnext != f)\n  645                          {\n  646:                             fnext = volume.interpolateVoxel(next);\n  647  \n  648                              // when ray crosses a surface\n  ...\n  655  \n  656                      // if ray penetrates a surface from outside\n  657:                     // linearly interpolate t between two f values\n  658                      if (f > 0.f && fnext < 0.f)\n  659                      {\n  660                          v_float32x4 tp = next - rayStep;\n  661:                         float ft = volume.interpolateVoxel(tp);\n  662:                         float ftdt = volume.interpolateVoxel(next);\n  663                          float ts = tmin + tstep * (steps - ft / (ftdt - ft));\n  664  \n  ...\n  740                      Point3f rayStep = dir * tstep;\n  741                      Point3f next = (orig + dir * tmin);\n  742:                     float f = volume.interpolateVoxel(next), fnext = f;\n  743  \n  744                      //raymarch\n  ...\n  757                          if(fnext != f)\n  758                          {\n  759:                             fnext = volume.interpolateVoxel(next);\n  760                              // when ray crosses a surface\n  761                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  766                      }\n  767                      // if ray penetrates a surface from outside\n  768:                     // linearly interpolate t between two f values\n  769                      if(f > 0.f && fnext < 0.f)\n  770                      {\n  771                          Point3f tp    = next - rayStep;\n  772:                         float ft   = volume.interpolateVoxel(tp);\n  773:                         float ftdt = volume.interpolateVoxel(next);\n  774                          // float t = tmin + steps*tstep;\n  775                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  893                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  894                  {\n  895:                     //linearly interpolate coordinate\n  896                      float Vn    = Vc + vol.voxelSize;\n  897                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapaffine.cpp:\n   80  \n   81      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   82:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   83      // remap will not touch them).\n   84      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapshift.cpp:\n   81  \n   82      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   83:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   84      // remap will not touch them).\n   85      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapprojec.cpp:\n   83  \n   84      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   85:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   86      // remap will not touch them).\n   87      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retina_ocl.cpp:\n 1155      demultiplex(ocl_multiplexed_input, _demultiplexedTempBuffer);\n 1156  \n 1157:     // interpolate the demultiplexed frame depending on the color sampling method\n 1158      if (!adaptiveFiltering)\n 1159      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.hpp:\n  243          // protected functions\n  244          void _initColorSampling();\n  245:         void _interpolateImageDemultiplexedImage(float *inputOutputBuffer);\n  246:         void _interpolateSingleChannelImage111(float *inputOutputBuffer);\n  247:         void _interpolateBayerRGBchannels(float *inputOutputBuffer);\n  248          void _applyRIFfilter(const float *sourceBuffer, float *destinationBuffer);\n  249          void _getNormalizedContoursImage(const float *inputFrame, float *outputFrame);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.cpp:\n  264          _demultiplexedTempBuffer[*(colorSamplingPRT++)]=*(multiplexedColorFramePtr++);\n  265  \n  266:     // interpolate the demultiplexed frame depending on the color sampling method\n  267      if (!adaptiveFiltering)\n  268:         _interpolateImageDemultiplexedImage(&_demultiplexedTempBuffer[0]);\n  269  \n  270      // low pass filtering the demultiplexed frame\n  ...\n  453  }\n  454  \n  455: void RetinaColor::_interpolateImageDemultiplexedImage(float *inputOutputBuffer)\n  456  {\n  457  \n  ...\n  460  \n  461      case RETINA_COLOR_RANDOM:\n  462:         return; // no need to interpolate\n  463          break;\n  464  \n  465      case RETINA_COLOR_DIAGONAL:\n  466:         _interpolateSingleChannelImage111(inputOutputBuffer);\n  467          break;\n  468  \n  469      case RETINA_COLOR_BAYER: // default sets bayer sampling\n  470:         _interpolateBayerRGBchannels(inputOutputBuffer);\n  471          break;\n  472      default:\n  ...\n  479  }\n  480  \n  481: void RetinaColor::_interpolateSingleChannelImage111(float *inputOutputBuffer)\n  482  {\n  483      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows(); ++indexr)\n  ...\n  499  }\n  500  \n  501: void RetinaColor::_interpolateBayerRGBchannels(float *inputOutputBuffer)\n  502  {\n  503      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows()-1; indexr+=2)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/tutorial_charuco_create_detect.cpp:\n   59                  std::vector<cv::Point2f> charucoCorners;\n   60                  std::vector<int> charucoIds;\n   61:                 cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);\n   62                  //! [charidcor]\n   63                  // if at least one charuco corner detected\n   ..\n  110              std::vector<cv::Point2f> charucoCorners;\n  111              std::vector<int> charucoIds;\n  112:             cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds);\n  113              //! [charidcorwc]\n  114              // if at least one charuco corner detected\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/detect_board_charuco.cpp:\n  173                                           camMatrix, distCoeffs);\n  174  \n  175:         // interpolate charuco corners\n  176:         int interpolatedCorners = 0;\n  177          if(markerIds.size() > 0)\n  178:             interpolatedCorners =\n  179:                 aruco::interpolateCornersCharuco(markerCorners, markerIds, image, charucoboard,\n  180                                                   charucoCorners, charucoIds, camMatrix, distCoeffs);\n  181  \n  ...\n  207              aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, noArray(), Scalar(100, 0, 255));\n  208  \n  209:         if(interpolatedCorners > 0) {\n  210              Scalar color;\n  211              color = Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/calibrate_camera_charuco.cpp:\n  178          if(refindStrategy) aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  179  \n  180:         // interpolate charuco corners\n  181          Mat currentCharucoCorners, currentCharucoIds;\n  182          if(ids.size() > 0)\n  183:             aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners,\n  184                                               currentCharucoIds);\n  185  \n  ...\n  248  \n  249      for(int i = 0; i < nFrames; i++) {\n  250:         // interpolate using camera parameters\n  251          Mat currentCharucoCorners, currentCharucoIds;\n  252:         aruco::interpolateCornersCharuco(allCorners[i], allIds[i], allImgs[i], charucoboard,\n  253                                           currentCharucoCorners, currentCharucoIds, cameraMatrix,\n  254                                           distCoeffs);\n  ...\n  280      cout << \"Calibration saved to \" << outputFile << endl;\n  281  \n  282:     // show interpolated charuco corners for debugging\n  283      if(showChessboardCorners) {\n  284          for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/test/test_charucodetection.cpp:\n  256                  }\n  257  \n  258:                 // interpolate charuco corners\n  259                  vector< Point2f > charucoCorners;\n  260                  vector< int > charucoIds;\n  261  \n  262                  if(iter % 2 == 0) {\n  263:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  264                                                       charucoIds);\n  265                  } else {\n  266:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  267                                                       charucoIds, cameraMatrix, distCoeffs);\n  268                  }\n  ...\n  354                  }\n  355  \n  356:                 // interpolate charuco corners\n  357                  vector< Point2f > charucoCorners;\n  358                  vector< int > charucoIds;\n  359  \n  360                  if(iter % 2 == 0) {\n  361:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  362                                                       charucoIds);\n  363                  } else {\n  364:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  365                                                       charucoIds, cameraMatrix, distCoeffs);\n  366                  }\n  ...\n  719  \n  720      cv::Mat c_ids, c_corners;\n  721:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids, K);\n  722      cv::Mat corners_reshaped = c_corners.reshape(1);\n  723  \n  ...\n  727      c_ids = cv::Mat();\n  728      c_corners = cv::Mat();\n  729:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids);\n  730      corners_reshaped = c_corners.reshape(1);\n  731  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp:\n  434   *\n  435   * This function tries to find markers that were not detected in the basic detecMarkers function.\n  436:  * First, based on the current detected marker and the board layout, the function interpolates\n  437   * the position of the missing markers. Then it tries to find correspondence between the reprojected\n  438   * markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n  439   * parameters.\n  440   * If camera parameters and distortion coefficients are provided, missing markers are reprojected\n  441:  * using projectPoint function. If not, missing marker projections are interpolated using global\n  442   * homography, and all the marker corners in the board must have the same Z coordinate.\n  443   */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp:\n  141   * should be sent in corners and ids parameters.\n  142   * @param board layout of ChArUco board.\n  143:  * @param charucoCorners interpolated chessboard corners\n  144:  * @param charucoIds interpolated chessboard corners identifiers\n  145   * @param cameraMatrix optional 3x3 floating-point camera matrix\n  146   * \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n  ...\n  154   * Only visible corners are returned. For each corner, its corresponding identifier is\n  155   * also returned in charucoIds.\n  156:  * The function returns the number of interpolated corners.\n  157   */\n  158: CV_EXPORTS_W int interpolateCornersCharuco(InputArrayOfArrays markerCorners, InputArray markerIds,\n  159                                             InputArray image, const Ptr<CharucoBoard> &board,\n  160                                             OutputArray charucoCorners, OutputArray charucoIds,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/aruco.cpp:\n  749   * @param nContours, contour-container\n  750   */\n  751: static Point3f _interpolate2Dline(const std::vector<cv::Point2f>& nContours){\n  752  \tfloat minX, minY, maxX, maxY;\n  753  \tminX = maxX = nContours[0].x;\n  ...\n  864  \tPoint3f lines[4];\n  865  \tfor(int i=0; i<4; i++){\n  866: \t\tlines[i]=_interpolate2Dline(cntPts[i]);\n  867  \t}\n  868  \n  ...\n 1723          }\n 1724  \n 1725:         // interpolate tiny marker to marker position in markerZone\n 1726          inCorners[0] = Point2f(-0.5f, -0.5f);\n 1727          inCorners[1] = Point2f(marker.cols - 0.5f, -0.5f);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/charuco.cpp:\n  394    * Interpolate charuco corners using approximated pose estimation\n  395    */\n  396: static int _interpolateCornersCharucoApproxCalib(InputArrayOfArrays _markerCorners,\n  397                                                   InputArray _markerIds, InputArray _image,\n  398                                                   const Ptr<CharucoBoard> &_board,\n  ...\n  438    * Interpolate charuco corners using local homography\n  439    */\n  440: static int _interpolateCornersCharucoLocalHom(InputArrayOfArrays _markerCorners,\n  441                                                InputArray _markerIds, InputArray _image,\n  442                                                const Ptr<CharucoBoard> &_board,\n  ...\n  482          Point2f objPoint2D = Point2f(_board->chessboardCorners[i].x, _board->chessboardCorners[i].y);\n  483  \n  484:         vector< Point2f > interpolatedPositions;\n  485          for(unsigned int j = 0; j < _board->nearestMarkerIdx[i].size(); j++) {\n  486              int markerId = _board->ids[_board->nearestMarkerIdx[i][j]];\n  ...\n  498                  in.push_back(objPoint2D);\n  499                  perspectiveTransform(in, out, transformations[markerIdx]);\n  500:                 interpolatedPositions.push_back(out[0]);\n  501              }\n  502          }\n  503  \n  504          // none of the closest markers detected\n  505:         if(interpolatedPositions.size() == 0) continue;\n  506  \n  507          // more than one closest marker detected, take middle point\n  508:         if(interpolatedPositions.size() > 1) {\n  509:             allChessboardImgPoints[i] = (interpolatedPositions[0] + interpolatedPositions[1]) / 2.;\n  510          }\n  511          // a single closest marker detected\n  512:         else allChessboardImgPoints[i] = interpolatedPositions[0];\n  513      }\n  514  \n  ...\n  529  /**\n  530    */\n  531: int interpolateCornersCharuco(InputArrayOfArrays _markerCorners, InputArray _markerIds,\n  532                                InputArray _image, const Ptr<CharucoBoard> &_board,\n  533                                OutputArray _charucoCorners, OutputArray _charucoIds,\n  ...\n  536      // if camera parameters are avaible, use approximated calibration\n  537      if(_cameraMatrix.total() != 0) {\n  538:         _interpolateCornersCharucoApproxCalib(_markerCorners, _markerIds, _image, _board,\n  539                                                       _cameraMatrix, _distCoeffs, _charucoCorners,\n  540                                                       _charucoIds);\n  ...\n  542      // else use local homography\n  543      else {\n  544:         _interpolateCornersCharucoLocalHom(_markerCorners, _markerIds, _image, _board,\n  545                                                    _charucoCorners, _charucoIds);\n  546      }\n  ...\n  791              }\n  792  \n  793:             // interpolate the charuco corners of the diamond\n  794              vector< Point2f > currentMarkerCorners;\n  795              Mat aux;\n  796:             interpolateCornersCharuco(currentMarker, currentMarkerId, grey, _charucoDiamondLayout,\n  797                                        currentMarkerCorners, aux, _cameraMatrix, _distCoeffs);\n  798  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/include/opencv2/viz/widgets.hpp:\n  665              @param radius Radius of the spheres.\n  666              @param from Color for first sphere.\n  667:             @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  668               */\n  669              WTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/misc/python/python_viz.hpp:\n  841      @param radius Radius of the spheres.\n  842      @param from Color for first sphere.\n  843:     @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  844       */\n  845      CV_WRAP PyWTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy.hpp:\n  219  @param newFrame Output image.\n  220  @param buf Temporary buffer, will have width x 6\\*height size, CV_32FC1 type and contain 6\n  221: GpuMat: occlusion masks for first frame, occlusion masks for second, interpolated forward\n  222: horizontal flow, interpolated forward vertical flow, interpolated backward horizontal flow,\n  223: interpolated backward vertical flow.\n  224  @param stream Stream for the asynchronous version.\n  225   */\n  226: CV_EXPORTS void interpolateFrames(const GpuMat& frame0, const GpuMat& frame1,\n  227                                    const GpuMat& fu, const GpuMat& fv,\n  228                                    const GpuMat& bu, const GpuMat& bv,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy/NCVPyramid.hpp:\n   56      {\n   57          CV_EXPORTS void downsampleX2(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   58:         CV_EXPORTS void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   59      }\n   60  }}}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/image_pyramid.cpp:\n  136          }\n  137  \n  138:         cv::cuda::device::pyramid::interpolateFrom1(lastLayer, outImg, outImg.depth(), outImg.channels(), StreamAccessor::getStream(stream));\n  139      }\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp:\n   48  #if !defined (HAVE_CUDA) || !defined (HAVE_OPENCV_CUDALEGACY) || defined (CUDA_DISABLER)\n   49  \n   50: void cv::cuda::interpolateFrames(const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, float, GpuMat&, GpuMat&, Stream&) { throw_no_cuda(); }\n   51  \n   52  #else\n   53  \n   54: void cv::cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv,\n   55                                  float pos, GpuMat& newFrame, GpuMat& buf, Stream& s)\n   56  {\n   ..\n   71      GpuMat occ1 = buf.rowRange(1 * frame0.rows, 2 * frame0.rows);\n   72  \n   73:     // interpolated forward flow\n   74      GpuMat fui = buf.rowRange(2 * frame0.rows, 3 * frame0.rows);\n   75      GpuMat fvi = buf.rowRange(3 * frame0.rows, 4 * frame0.rows);\n   76  \n   77:     // interpolated backward flow\n   78      GpuMat bui = buf.rowRange(4 * frame0.rows, 5 * frame0.rows);\n   79      GpuMat bvi = buf.rowRange(5 * frame0.rows, 6 * frame0.rows);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/lbph_faces.cpp:\n  241          for(int i=radius; i < src.rows-radius;i++) {\n  242              for(int j=radius;j < src.cols-radius;j++) {\n  243:                 // calculate interpolated value\n  244                  float t = static_cast<float>(w1*src.at<_Tp>(i+fy,j+fx) + w2*src.at<_Tp>(i+fy,j+cx) + w3*src.at<_Tp>(i+cy,j+fx) + w4*src.at<_Tp>(i+cy,j+cx));\n  245                  // floating point precision, so check some machine-dependent epsilon\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/column_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/row_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n313 matches across 82 files\n\n\nSearching 7926 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/quickjs/qjs-imgui/imgui/imstb_truetype.h:\n 1741                 scy = y;\n 1742                 if (!(vertices[off+i+1].type & 1)) {\n 1743:                   // next point is also a curve point, so interpolate an on-point curve\n 1744                    sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;\n 1745                    sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;\n ....\n 1760           } else {\n 1761              if (!(flags & 1)) { // if it's a curve\n 1762:                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint\n 1763                    stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);\n 1764                 cx = x;\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/opencv/disabled/detect_board_charuco.cpp:\n  194        cv::aruco::refineDetectedMarkers(image, board, markerCorners, markerIds, rejectedMarkers, camMatrix, distCoeffs);\n  195  \n  196:     // interpolate charuco corners\n  197:     int interpolatedCorners = 0;\n  198      if(markerIds.size() > 0)\n  199:       interpolatedCorners = cv::aruco::interpolateCornersCharuco(\n  200            markerCorners, markerIds, image, charucoboard, charucoCorners, charucoIds, camMatrix, distCoeffs);\n  201  \n  ...\n  223        cv::aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, cv::noArray(), cv::Scalar(100, 0, 255));\n  224  \n  225:     if(interpolatedCorners > 0) {\n  226        cv::Scalar color;\n  227        color = cv::Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/imgui/imstb_truetype.h:\n 1934            scy = y;\n 1935            if(!(vertices[off + i + 1].type & 1)) {\n 1936:             // next point is also a curve point, so interpolate an on-point curve\n 1937              sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;\n 1938              sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;\n ....\n 1953        } else {\n 1954          if(!(flags & 1)) { // if it's a curve\n 1955:           if(was_off)      // two off-curve control points in a row means interpolate an on-curve\n 1956                             // midpoint\n 1957              stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.hpp:\n  116      bool findMaximaInLayer(int counterOffset, int octave, int layer_rows, int layer_cols);\n  117  \n  118:     bool interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int maxFeatures);\n  119  \n  120      bool calcOrientation(UMat &keypoints);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/msd.cpp:\n  263               * @param scale scale of the key-point over the image pyramid\n  264               * @param saliency pointer to the saliency array\n  265:              * @param p_res interpolated coordinates of the key-point referred to the lowest level of the pyramid (i.e. in the ref. frame of the input image)\n  266               * @return false if the current key-point has to be rejected, true otherwise\n  267               */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.ocl.cpp:\n  187          if (maxCounter > 0)\n  188          {\n  189:             if(!interpolateKeypoint(maxCounter, keypoints, octave, layer_rows, maxFeatures))\n  190                  return false;\n  191          }\n  ...\n  431  }\n  432  \n  433: bool SURF_OCL::interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int max_features)\n  434  {\n  435      size_t localThreads[3]  = {3, 3, 3};\n  436      size_t globalThreads[3] = {maxCounter*localThreads[0], localThreads[1], 3};\n  437  \n  438:     ocl::Kernel kerInterp(\"SURF_interpolateKeypoint\", ocl::xfeatures2d::surf_oclsrc, kerOpts);\n  439  \n  440      return kerInterp.args(ocl::KernelArg::ReadOnlyNoSize(det),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/daisy.cpp:\n  371  \n  372  \n  373: static float interpolate_peak( float left, float center, float right )\n  374  {\n  375      if( center < 0.0 )\n  ...\n 1409                 next -= m_orientation_resolution;\n 1410  \n 1411:             peak = interpolate_peak(hist.at<float>(prev), hist.at<float>(max_ind), hist.at<float>(next));\n 1412              angle = (float)( ((float)max_ind + peak)*360.0/m_orientation_resolution );\n 1413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.cpp:\n  220   * approximated using central differences. The linear system Ax = b is then\n  221   * solved, where A is the Hessian, b is the negative gradient, and x is the\n  222:  * offset of the interpolated maxima coordinates from the initial estimate.\n  223   * This is equivalent to an iteration of Netwon's optimisation algorithm.\n  224   *\n  ...\n  232   */\n  233  static int\n  234: interpolateKeypoint( float N9[3][9], int dx, int dy, int ds, KeyPoint& kpt )\n  235  {\n  236      Vec3f b(-(N9[1][5]-N9[1][3])/2,  // Negative 1st deriv with respect to x\n  ...\n  433                      /* Interpolate maxima location within the 3x3x3 neighbourhood  */\n  434                      int ds = size - sizes[layer-1];\n  435:                     int interp_ok = interpolateKeypoint( N9, sampleStep, sampleStep, ds, kpt );\n  436  \n  437                      /* Sometimes the interpolation step gives a negative size etc. */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparsetodenseflow.cpp:\n  106      gd->setFGSLambda(fgs_lambda);\n  107      gd->setFGSSigma (fgs_sigma);\n  108:     gd->interpolate(prev,points_filtered,cur,dst_points_filtered,dense_flow);\n  109  }\n  110  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlofflow.cpp:\n  218              gd->setFGSSigma(fgs_sigma);\n  219              gd->setUsePostProcessing(use_post_proc);\n  220:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  221          }\n  222          else if (interp_type == InterpolationType::INTERP_RIC)\n  ...\n  230              gd->setUseGlobalSmootherFilter(use_post_proc);\n  231              gd->setUseVariationalRefinement(false);\n  232:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  233          }\n  234          else\n  ...\n  237              GaussianBlur(prevImage, blurredPrevImage, cv::Size(5, 5), -1);\n  238              std::vector<uchar> status(filtered_currPoints.size(), 1);\n  239:             interpolate_irregular_nn_raster(filtered_prevPoints, filtered_currPoints, status, blurredPrevImage).copyTo(dense_flow);\n  240              std::vector<Mat> vecMats;\n  241              std::vector<Mat> vecMats2(2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.cpp:\n  115  }\n  116  \n  117: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n  118      const std::vector<Point2f> & nextPoints,\n  119      const std::vector<uchar> & status,\n  ...\n  241  }\n  242  \n  243: Mat interpolate_irregular_knn(\n  244      const std::vector<Point2f> & _prevPoints,\n  245      const std::vector<Point2f> & _nextPoints,\n  ...\n  401  \n  402  \n  403: Mat interpolate_irregular_nn(\n  404      const std::vector<Point2f> & _prevPoints,\n  405      const std::vector<Point2f> & _nextPoints,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.hpp:\n   12  Mat sgeo_dist(const Mat& gra, int y, int x, float max, Mat &prev);\n   13  Mat sgeo_dist(const Mat& gra, const std::vector<Point2f> & points, float max, Mat &prev);\n   14: Mat interpolate_irregular_nw(const Mat &in, const Mat &mask, const Mat &color_img, float max_d, float bandwidth, float pixeldistance);\n   15: Mat interpolate_irregular_nn(\n   16      const std::vector<Point2f> & prevPoints,\n   17      const std::vector<Point2f> & nextPoints,\n   ..\n   19      const Mat &color_img,\n   20      float pixeldistance);\n   21: Mat interpolate_irregular_knn(\n   22      const std::vector<Point2f> & _prevPoints,\n   23      const std::vector<Point2f> & _nextPoints,\n   ..\n   27      float pixeldistance);\n   28  \n   29: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n   30      const std::vector<Point2f> & nextPoints,\n   31      const std::vector<uchar> & status,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_sparse_match_interpolator.cpp:\n   90      interpolator->setFGSLambda(500.0f);\n   91      interpolator->setFGSSigma(1.5f);\n   92:     interpolator->interpolate(src,from_points,Mat(),to_points,res_flow);\n   93  \n   94      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n   ..\n   97      Mat from_point_mat(from_points);\n   98      Mat to_points_mat(to_points);\n   99:     interpolator->interpolate(src,from_point_mat,Mat(),to_points_mat,res_flow);\n  100  \n  101      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  146      interpolator->setFGSLambda(500.f);\n  147      interpolator->setFGSSigma(1.5f);\n  148:     interpolator->interpolate(src, from_points, src1, to_points, res_flow);\n  149  \n  150      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  153      Mat from_point_mat(from_points);\n  154      Mat to_points_mat(to_points);\n  155:     interpolator->interpolate(src, from_point_mat, src1, to_points_mat, res_flow);\n  156  \n  157      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  205          cv::setNumThreads(nThreads);\n  206          Mat resMultiThread;\n  207:         interpolator->interpolate(from,from_points,Mat(),to_points,resMultiThread);\n  208  \n  209          cv::setNumThreads(1);\n  210          Mat resSingleThread;\n  211:         interpolator->interpolate(from,from_points,Mat(),to_points,resSingleThread);\n  212  \n  213          EXPECT_LE(cv::norm(resSingleThread, resMultiThread, NORM_INF), MAX_DIF);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp:\n   67      @param dense_flow output dense matching (two-channel CV_32F image)\n   68       */\n   69:     CV_WRAP virtual void interpolate(InputArray from_image, InputArray from_points,\n   70                                       InputArray to_image  , InputArray to_points,\n   71                                       OutputArray dense_flow) = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/sparse_match_interpolators.cpp:\n   78  public:\n   79      static Ptr<EdgeAwareInterpolatorImpl> create();\n   80:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n   81  \n   82  protected:\n   ..\n  171  }\n  172  \n  173: void EdgeAwareInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray, InputArray to_points, OutputArray dense_flow)\n  174  {\n  175      CV_Assert( !from_image.empty() && (from_image.depth() == CV_8U) && (from_image.channels() == 3 || from_image.channels() == 1) );\n  ...\n  906  public:\n  907      static Ptr<RICInterpolatorImpl> create();\n  908:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n  909  \n  910  protected:\n  ...\n 1109  };\n 1110  \n 1111: void RICInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow)\n 1112  {\n 1113      CV_Assert(!from_image.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 2199              /* update lower y limit (start) for the new 'column'.\n 2200  \n 2201:             We need to interpolate the y value that corresponds to the\n 2202              lower side of the rectangle. The first thing is to decide if\n 2203              the corresponding side is\n ....\n 2206              vx[3],vy[3] to vx[2],vy[2]\n 2207  \n 2208:             Then, the side is interpolated for the x value of the\n 2209              'column'. But, if the side is vertical (as it could happen if\n 2210              the rectangle is vertical and we are dealing with the first\n ....\n 2245              /* update upper y limit (end) for the new 'column'.\n 2246  \n 2247:             We need to interpolate the y value that corresponds to the\n 2248              upper side of the rectangle. The first thing is to decide if\n 2249              the corresponding side is\n ....\n 2252              vx[1],vy[1] to vx[2],vy[2]\n 2253  \n 2254:             Then, the side is interpolated for the x value of the\n 2255              'column'. But, if the side is vertical (as it could happen if\n 2256              the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/nonrigid_icp.cpp:\n  306                  continue;\n  307  \n  308:             // TODO: interpolate Vg instead of simply converting projected coords to int\n  309              Vg.at<Vec3f>(y, x) = vertImage.at<Vec3f>((int)newCoords.y, (int)newCoords.x);\n  310  \n  311:             // bilinearly interpolate newPoints under newCoords point\n  312              int xi = cvFloor(newCoords.x), yi = cvFloor(newCoords.y);\n  313              float tx  = newCoords.x - xi, ty = newCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.hpp:\n   74      virtual TsdfVoxel at(const Vec3i& volumeIdx) const;\n   75  \n   76:     float interpolateVoxel(const cv::Point3f& p) const;\n   77      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   78  \n   79  #if USE_INTRINSICS\n   80:     float interpolateVoxel(const v_float32x4& p) const;\n   81      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   82  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/hash_tsdf.cpp:\n  126  \n  127  \n  128:     float interpolateVoxelPoint(const Point3f& point) const;\n  129:     float interpolateVoxel(const cv::Point3f& point) const;\n  130      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  131  \n  ...\n  421  \n  422  #if USE_INTRINSICS\n  423: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  424  {\n  425      v_float32x4 v0246, v1357;\n  ...\n  440  \n  441  #else\n  442: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  443  {\n  444      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  454  #endif\n  455  \n  456: float HashTSDFVolumeCPU::interpolateVoxelPoint(const Point3f& point) const\n  457  {\n  458      const Vec3i neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n  ...\n  495      }\n  496  \n  497:     return interpolate(tx, ty, tz, vx);\n  498  }\n  499  \n  500: inline float HashTSDFVolumeCPU::interpolateVoxel(const cv::Point3f& point) const\n  501  {\n  502:     return interpolateVoxelPoint(point * voxelSizeInv);\n  503  }\n  504  \n  ...\n  631      float tz = ptVox.z - iptVox[2];\n  632  \n  633:     normal[0] = interpolate(tx, ty, tz, cxv);\n  634:     normal[1] = interpolate(tx, ty, tz, cyv);\n  635:     normal[2] = interpolate(tx, ty, tz, czv);\n  636  #endif\n  637  \n  ...\n  921  \n  922  \n  923:     float interpolateVoxelPoint(const Point3f& point) const;\n  924:     float interpolateVoxel(const cv::Point3f& point) const;\n  925      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  926  \n  ...\n 1380  }\n 1381  \n 1382: float HashTSDFVolumeGPU::interpolateVoxelPoint(const Point3f& point) const\n 1383  {\n 1384      const Vec3i local_neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n ....\n 1421      }\n 1422  \n 1423:     return interpolate(tx, ty, tz, vx);\n 1424  }\n 1425  \n 1426: inline float HashTSDFVolumeGPU::interpolateVoxel(const cv::Point3f& point) const\n 1427  {\n 1428:     return interpolateVoxelPoint(point * voxelSizeInv);\n 1429  }\n 1430  \n ....\n 1556      float tz = ptVox.z - iptVox[2];\n 1557  \n 1558:     normal[0] = interpolate(tx, ty, tz, cxv);\n 1559:     normal[1] = interpolate(tx, ty, tz, cyv);\n 1560:     normal[2] = interpolate(tx, ty, tz, czv);\n 1561  #endif\n 1562      float nv = sqrt(normal[0] * normal[0] +\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/fast_icp.cpp:\n  243                      continue;\n  244  \n  245:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  246                  v_float32x4 oldP;\n  247                  v_float32x4 oldN;\n  ...\n  390                      continue;\n  391  \n  392:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  393                  int xi = cvFloor(oldCoords.x), yi = cvFloor(oldCoords.y);\n  394                  float tx  = oldCoords.x - xi, ty = oldCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.cpp:\n  137  #if USE_INTRINSICS\n  138  // all coordinate checks should be done in inclosing cycle\n  139: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  140  {\n  141      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  142:     return interpolateVoxel(p);\n  143  }\n  144  \n  145: inline float TSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  146  {\n  147      // tx, ty, tz = floor(p)\n  ...\n  184  }\n  185  #else\n  186: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  187  {\n  188      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  438                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  439                      v_float32x4 next    = (orig + dir * v_setall_f32(tmin));\n  440:                     float f = volume.interpolateVoxel(next), fnext = f;\n  441  \n  442                      //raymarch\n  ...\n  455                          if(fnext != f)\n  456                          {\n  457:                             fnext = volume.interpolateVoxel(next);\n  458  \n  459                              // when ray crosses a surface\n  ...\n  466  \n  467                      // if ray penetrates a surface from outside\n  468:                     // linearly interpolate t between two f values\n  469                      if(f > 0.f && fnext < 0.f)\n  470                      {\n  471                          v_float32x4 tp = next - rayStep;\n  472:                         float ft    = volume.interpolateVoxel(tp);\n  473:                         float ftdt  = volume.interpolateVoxel(next);\n  474                          float ts = tmin + tstep*(steps - ft/(ftdt - ft));\n  475  \n  ...\n  547                      Point3f rayStep = dir * tstep;\n  548                      Point3f next = (orig + dir * tmin);\n  549:                     float f = volume.interpolateVoxel(next), fnext = f;\n  550  \n  551                      //raymarch\n  ...\n  564                          if(fnext != f)\n  565                          {\n  566:                             fnext = volume.interpolateVoxel(next);\n  567                              // when ray crosses a surface\n  568                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  573                      }\n  574                      // if ray penetrates a surface from outside\n  575:                     // linearly interpolate t between two f values\n  576                      if(f > 0.f && fnext < 0.f)\n  577                      {\n  578                          Point3f tp    = next - rayStep;\n  579:                         float ft   = volume.interpolateVoxel(tp);\n  580:                         float ftdt = volume.interpolateVoxel(next);\n  581                          // float t = tmin + steps*tstep;\n  582                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  692                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  693                  {\n  694:                     //linearly interpolate coordinate\n  695                      float Vn    = Vc + vol.voxelSize;\n  696                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/warpfield.cpp:\n  212  \n  213          Affine3f pose = DQB(weights, transforms);\n  214:         // linearly interpolate translations\n  215          Vec3f translation(0,0,0);\n  216          float totalWeight = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/dynafu_tsdf.cpp:\n   48      virtual void reset() override;\n   49  \n   50:     volumeType interpolateVoxel(cv::Point3f p) const;\n   51      Point3f getNormalVoxel(cv::Point3f p) const;\n   52  \n   ..\n   59  \n   60  private:\n   61:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const;\n   62  };\n   63  \n   ..\n  330  }\n  331  \n  332: inline volumeType TSDFVolumeCPU::interpolateVoxel(Point3f p) const\n  333  {\n  334      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  472                      Point3f rayStep = dir * tstep;\n  473                      Point3f next = (orig + dir * tmin);\n  474:                     volumeType f = volume.interpolateVoxel(next), fnext = f;\n  475  \n  476                      //raymarch\n  ...\n  489                          if(fnext != f)\n  490                          {\n  491:                             fnext = volume.interpolateVoxel(next);\n  492  \n  493                              // when ray crosses a surface\n  ...\n  500  \n  501                      // if ray penetrates a surface from outside\n  502:                     // linearly interpolate t between two f values\n  503                      if(f > 0.f && fnext < 0.f)\n  504                      {\n  505                          Point3f tp = next - rayStep;\n  506:                         volumeType ft   = volume.interpolateVoxel(tp);\n  507:                         volumeType ftdt = volume.interpolateVoxel(next);\n  508                          // float t = tmin + steps*tstep;\n  509                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  621                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  622                  {\n  623:                     //linearly interpolate coordinate\n  624                      float Vn = Vc + vol.voxelSize;\n  625                      float dinv = 1.f/(abs(v0)+abs(vd));\n  ...\n  790      }\n  791  \n  792:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const\n  793      {\n  794          float dV = 0.5f;\n  ...\n  835  \n  836                      if (edgeTable[cubeIndex] & 1)\n  837:                         vertices[0] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[1],\n  838                                                             tsdfValues[0], tsdfValues[1]);\n  839                      if (edgeTable[cubeIndex] & 2)\n  840:                         vertices[1] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[2],\n  841                                                             tsdfValues[1], tsdfValues[2]);\n  842                      if (edgeTable[cubeIndex] & 4)\n  843:                         vertices[2] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[3],\n  844                                                             tsdfValues[2], tsdfValues[3]);\n  845                      if (edgeTable[cubeIndex] & 8)\n  846:                         vertices[3] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[0],\n  847                                                             tsdfValues[3], tsdfValues[0]);\n  848                      if (edgeTable[cubeIndex] & 16)\n  849:                         vertices[4] = basePt + interpolate(mcNeighbourPts[4], mcNeighbourPts[5],\n  850                                                             tsdfValues[4], tsdfValues[5]);\n  851                      if (edgeTable[cubeIndex] & 32)\n  852:                         vertices[5] = basePt + interpolate(mcNeighbourPts[5], mcNeighbourPts[6],\n  853                                                             tsdfValues[5], tsdfValues[6]);\n  854                      if (edgeTable[cubeIndex] & 64)\n  855:                         vertices[6] = basePt + interpolate(mcNeighbourPts[6], mcNeighbourPts[7],\n  856                                                             tsdfValues[6], tsdfValues[7]);\n  857                      if (edgeTable[cubeIndex] & 128)\n  858:                         vertices[7] = basePt + interpolate(mcNeighbourPts[7], mcNeighbourPts[4],\n  859                                                             tsdfValues[7], tsdfValues[4]);\n  860                      if (edgeTable[cubeIndex] & 256)\n  861:                         vertices[8] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[4],\n  862                                                             tsdfValues[0], tsdfValues[4]);\n  863                      if (edgeTable[cubeIndex] & 512)\n  864:                         vertices[9] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[5],\n  865                                                             tsdfValues[1], tsdfValues[5]);\n  866                      if (edgeTable[cubeIndex] & 1024)\n  867:                         vertices[10] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[6],\n  868                                                              tsdfValues[2], tsdfValues[6]);\n  869                      if (edgeTable[cubeIndex] & 2048)\n  870:                         vertices[11] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[7],\n  871                                                              tsdfValues[3], tsdfValues[7]);\n  872  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf_functions.cpp:\n  249  \n  250                      depthType v;\n  251:                     // bilinearly interpolate depth at projected\n  252                      {\n  253                          const v_float32x4& pt = projected;\n  ...\n  284                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  285                              v_float32x4 ty = v_setall_f32(t.get0());\n  286:                             // vx is y-interpolated between rows 0 and 1\n  287                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  288                              float v0 = vx.get0();\n  ...\n  514  \n  515                      depthType v;\n  516:                     // bilinearly interpolate depth at projected\n  517                      {\n  518                          const v_float32x4& pt = projected;\n  ...\n  549                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  550                              v_float32x4 ty = v_setall_f32(t.get0());\n  551:                             // vx is y-interpolated between rows 0 and 1\n  552                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  553                              float v0 = vx.get0();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/colored_tsdf.cpp:\n   85      virtual RGBTsdfVoxel at(const Vec3i& volumeIdx) const;\n   86  \n   87:     float interpolateVoxel(const cv::Point3f& p) const;\n   88      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   89:     float interpolateColor(float tx, float ty, float tz, float vx[8]) const;\n   90      Point3f getColorVoxel(const cv::Point3f& p) const;\n   91  \n   92  #if USE_INTRINSICS\n   93:     float interpolateVoxel(const v_float32x4& p) const;\n   94      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   95      v_float32x4 getColorVoxel(const v_float32x4& p) const;\n   ..\n  185  #if USE_INTRINSICS\n  186  // all coordinate checks should be done in inclosing cycle\n  187: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  188  {\n  189      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  190:     return interpolateVoxel(p);\n  191  }\n  192  \n  193: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  194  {\n  195      // tx, ty, tz = floor(p)\n  ...\n  232  }\n  233  #else\n  234: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  235  {\n  236      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  384  \n  385  #if USE_INTRINSICS\n  386: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  387  {\n  388      v_float32x4 v0246, v1357;\n  ...\n  402  }\n  403  #else\n  404: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  405  {\n  406      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  463      float ty = t.get0(); t = v_rotate_right<1>(t);\n  464      float tz = t.get0();\n  465:     rgb[0] = interpolateColor(tx, ty, tz, r);\n  466:     rgb[1] = interpolateColor(tx, ty, tz, g);\n  467:     rgb[2] = interpolateColor(tx, ty, tz, b);\n  468      rgb[3] = 0.f;\n  469  #else\n  ...\n  512      float tz = ptVox.z - iptVox[2];\n  513  \n  514:     res=Point3f(interpolateColor(tx, ty, tz, r),\n  515:                 interpolateColor(tx, ty, tz, g),\n  516:                 interpolateColor(tx, ty, tz, b));\n  517  #else\n  518      res=Point3f(volData[coordBase].r, volData[coordBase].g, volData[coordBase].b);\n  ...\n  627                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  628                      v_float32x4 next = (orig + dir * v_setall_f32(tmin));\n  629:                     float f = volume.interpolateVoxel(next), fnext = f;\n  630  \n  631                      //raymarch\n  ...\n  644                          if (fnext != f)\n  645                          {\n  646:                             fnext = volume.interpolateVoxel(next);\n  647  \n  648                              // when ray crosses a surface\n  ...\n  655  \n  656                      // if ray penetrates a surface from outside\n  657:                     // linearly interpolate t between two f values\n  658                      if (f > 0.f && fnext < 0.f)\n  659                      {\n  660                          v_float32x4 tp = next - rayStep;\n  661:                         float ft = volume.interpolateVoxel(tp);\n  662:                         float ftdt = volume.interpolateVoxel(next);\n  663                          float ts = tmin + tstep * (steps - ft / (ftdt - ft));\n  664  \n  ...\n  740                      Point3f rayStep = dir * tstep;\n  741                      Point3f next = (orig + dir * tmin);\n  742:                     float f = volume.interpolateVoxel(next), fnext = f;\n  743  \n  744                      //raymarch\n  ...\n  757                          if(fnext != f)\n  758                          {\n  759:                             fnext = volume.interpolateVoxel(next);\n  760                              // when ray crosses a surface\n  761                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  766                      }\n  767                      // if ray penetrates a surface from outside\n  768:                     // linearly interpolate t between two f values\n  769                      if(f > 0.f && fnext < 0.f)\n  770                      {\n  771                          Point3f tp    = next - rayStep;\n  772:                         float ft   = volume.interpolateVoxel(tp);\n  773:                         float ftdt = volume.interpolateVoxel(next);\n  774                          // float t = tmin + steps*tstep;\n  775                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  893                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  894                  {\n  895:                     //linearly interpolate coordinate\n  896                      float Vn    = Vc + vol.voxelSize;\n  897                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapaffine.cpp:\n   80  \n   81      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   82:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   83      // remap will not touch them).\n   84      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapshift.cpp:\n   81  \n   82      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   83:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   84      // remap will not touch them).\n   85      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapprojec.cpp:\n   83  \n   84      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   85:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   86      // remap will not touch them).\n   87      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retina_ocl.cpp:\n 1155      demultiplex(ocl_multiplexed_input, _demultiplexedTempBuffer);\n 1156  \n 1157:     // interpolate the demultiplexed frame depending on the color sampling method\n 1158      if (!adaptiveFiltering)\n 1159      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.hpp:\n  243          // protected functions\n  244          void _initColorSampling();\n  245:         void _interpolateImageDemultiplexedImage(float *inputOutputBuffer);\n  246:         void _interpolateSingleChannelImage111(float *inputOutputBuffer);\n  247:         void _interpolateBayerRGBchannels(float *inputOutputBuffer);\n  248          void _applyRIFfilter(const float *sourceBuffer, float *destinationBuffer);\n  249          void _getNormalizedContoursImage(const float *inputFrame, float *outputFrame);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.cpp:\n  264          _demultiplexedTempBuffer[*(colorSamplingPRT++)]=*(multiplexedColorFramePtr++);\n  265  \n  266:     // interpolate the demultiplexed frame depending on the color sampling method\n  267      if (!adaptiveFiltering)\n  268:         _interpolateImageDemultiplexedImage(&_demultiplexedTempBuffer[0]);\n  269  \n  270      // low pass filtering the demultiplexed frame\n  ...\n  453  }\n  454  \n  455: void RetinaColor::_interpolateImageDemultiplexedImage(float *inputOutputBuffer)\n  456  {\n  457  \n  ...\n  460  \n  461      case RETINA_COLOR_RANDOM:\n  462:         return; // no need to interpolate\n  463          break;\n  464  \n  465      case RETINA_COLOR_DIAGONAL:\n  466:         _interpolateSingleChannelImage111(inputOutputBuffer);\n  467          break;\n  468  \n  469      case RETINA_COLOR_BAYER: // default sets bayer sampling\n  470:         _interpolateBayerRGBchannels(inputOutputBuffer);\n  471          break;\n  472      default:\n  ...\n  479  }\n  480  \n  481: void RetinaColor::_interpolateSingleChannelImage111(float *inputOutputBuffer)\n  482  {\n  483      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows(); ++indexr)\n  ...\n  499  }\n  500  \n  501: void RetinaColor::_interpolateBayerRGBchannels(float *inputOutputBuffer)\n  502  {\n  503      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows()-1; indexr+=2)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/tutorial_charuco_create_detect.cpp:\n   59                  std::vector<cv::Point2f> charucoCorners;\n   60                  std::vector<int> charucoIds;\n   61:                 cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);\n   62                  //! [charidcor]\n   63                  // if at least one charuco corner detected\n   ..\n  110              std::vector<cv::Point2f> charucoCorners;\n  111              std::vector<int> charucoIds;\n  112:             cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds);\n  113              //! [charidcorwc]\n  114              // if at least one charuco corner detected\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/detect_board_charuco.cpp:\n  173                                           camMatrix, distCoeffs);\n  174  \n  175:         // interpolate charuco corners\n  176:         int interpolatedCorners = 0;\n  177          if(markerIds.size() > 0)\n  178:             interpolatedCorners =\n  179:                 aruco::interpolateCornersCharuco(markerCorners, markerIds, image, charucoboard,\n  180                                                   charucoCorners, charucoIds, camMatrix, distCoeffs);\n  181  \n  ...\n  207              aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, noArray(), Scalar(100, 0, 255));\n  208  \n  209:         if(interpolatedCorners > 0) {\n  210              Scalar color;\n  211              color = Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/calibrate_camera_charuco.cpp:\n  178          if(refindStrategy) aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  179  \n  180:         // interpolate charuco corners\n  181          Mat currentCharucoCorners, currentCharucoIds;\n  182          if(ids.size() > 0)\n  183:             aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners,\n  184                                               currentCharucoIds);\n  185  \n  ...\n  248  \n  249      for(int i = 0; i < nFrames; i++) {\n  250:         // interpolate using camera parameters\n  251          Mat currentCharucoCorners, currentCharucoIds;\n  252:         aruco::interpolateCornersCharuco(allCorners[i], allIds[i], allImgs[i], charucoboard,\n  253                                           currentCharucoCorners, currentCharucoIds, cameraMatrix,\n  254                                           distCoeffs);\n  ...\n  280      cout << \"Calibration saved to \" << outputFile << endl;\n  281  \n  282:     // show interpolated charuco corners for debugging\n  283      if(showChessboardCorners) {\n  284          for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/test/test_charucodetection.cpp:\n  256                  }\n  257  \n  258:                 // interpolate charuco corners\n  259                  vector< Point2f > charucoCorners;\n  260                  vector< int > charucoIds;\n  261  \n  262                  if(iter % 2 == 0) {\n  263:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  264                                                       charucoIds);\n  265                  } else {\n  266:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  267                                                       charucoIds, cameraMatrix, distCoeffs);\n  268                  }\n  ...\n  354                  }\n  355  \n  356:                 // interpolate charuco corners\n  357                  vector< Point2f > charucoCorners;\n  358                  vector< int > charucoIds;\n  359  \n  360                  if(iter % 2 == 0) {\n  361:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  362                                                       charucoIds);\n  363                  } else {\n  364:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  365                                                       charucoIds, cameraMatrix, distCoeffs);\n  366                  }\n  ...\n  719  \n  720      cv::Mat c_ids, c_corners;\n  721:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids, K);\n  722      cv::Mat corners_reshaped = c_corners.reshape(1);\n  723  \n  ...\n  727      c_ids = cv::Mat();\n  728      c_corners = cv::Mat();\n  729:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids);\n  730      corners_reshaped = c_corners.reshape(1);\n  731  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp:\n  434   *\n  435   * This function tries to find markers that were not detected in the basic detecMarkers function.\n  436:  * First, based on the current detected marker and the board layout, the function interpolates\n  437   * the position of the missing markers. Then it tries to find correspondence between the reprojected\n  438   * markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n  439   * parameters.\n  440   * If camera parameters and distortion coefficients are provided, missing markers are reprojected\n  441:  * using projectPoint function. If not, missing marker projections are interpolated using global\n  442   * homography, and all the marker corners in the board must have the same Z coordinate.\n  443   */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp:\n  141   * should be sent in corners and ids parameters.\n  142   * @param board layout of ChArUco board.\n  143:  * @param charucoCorners interpolated chessboard corners\n  144:  * @param charucoIds interpolated chessboard corners identifiers\n  145   * @param cameraMatrix optional 3x3 floating-point camera matrix\n  146   * \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n  ...\n  154   * Only visible corners are returned. For each corner, its corresponding identifier is\n  155   * also returned in charucoIds.\n  156:  * The function returns the number of interpolated corners.\n  157   */\n  158: CV_EXPORTS_W int interpolateCornersCharuco(InputArrayOfArrays markerCorners, InputArray markerIds,\n  159                                             InputArray image, const Ptr<CharucoBoard> &board,\n  160                                             OutputArray charucoCorners, OutputArray charucoIds,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/aruco.cpp:\n  749   * @param nContours, contour-container\n  750   */\n  751: static Point3f _interpolate2Dline(const std::vector<cv::Point2f>& nContours){\n  752  \tfloat minX, minY, maxX, maxY;\n  753  \tminX = maxX = nContours[0].x;\n  ...\n  864  \tPoint3f lines[4];\n  865  \tfor(int i=0; i<4; i++){\n  866: \t\tlines[i]=_interpolate2Dline(cntPts[i]);\n  867  \t}\n  868  \n  ...\n 1723          }\n 1724  \n 1725:         // interpolate tiny marker to marker position in markerZone\n 1726          inCorners[0] = Point2f(-0.5f, -0.5f);\n 1727          inCorners[1] = Point2f(marker.cols - 0.5f, -0.5f);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/charuco.cpp:\n  394    * Interpolate charuco corners using approximated pose estimation\n  395    */\n  396: static int _interpolateCornersCharucoApproxCalib(InputArrayOfArrays _markerCorners,\n  397                                                   InputArray _markerIds, InputArray _image,\n  398                                                   const Ptr<CharucoBoard> &_board,\n  ...\n  438    * Interpolate charuco corners using local homography\n  439    */\n  440: static int _interpolateCornersCharucoLocalHom(InputArrayOfArrays _markerCorners,\n  441                                                InputArray _markerIds, InputArray _image,\n  442                                                const Ptr<CharucoBoard> &_board,\n  ...\n  482          Point2f objPoint2D = Point2f(_board->chessboardCorners[i].x, _board->chessboardCorners[i].y);\n  483  \n  484:         vector< Point2f > interpolatedPositions;\n  485          for(unsigned int j = 0; j < _board->nearestMarkerIdx[i].size(); j++) {\n  486              int markerId = _board->ids[_board->nearestMarkerIdx[i][j]];\n  ...\n  498                  in.push_back(objPoint2D);\n  499                  perspectiveTransform(in, out, transformations[markerIdx]);\n  500:                 interpolatedPositions.push_back(out[0]);\n  501              }\n  502          }\n  503  \n  504          // none of the closest markers detected\n  505:         if(interpolatedPositions.size() == 0) continue;\n  506  \n  507          // more than one closest marker detected, take middle point\n  508:         if(interpolatedPositions.size() > 1) {\n  509:             allChessboardImgPoints[i] = (interpolatedPositions[0] + interpolatedPositions[1]) / 2.;\n  510          }\n  511          // a single closest marker detected\n  512:         else allChessboardImgPoints[i] = interpolatedPositions[0];\n  513      }\n  514  \n  ...\n  529  /**\n  530    */\n  531: int interpolateCornersCharuco(InputArrayOfArrays _markerCorners, InputArray _markerIds,\n  532                                InputArray _image, const Ptr<CharucoBoard> &_board,\n  533                                OutputArray _charucoCorners, OutputArray _charucoIds,\n  ...\n  536      // if camera parameters are avaible, use approximated calibration\n  537      if(_cameraMatrix.total() != 0) {\n  538:         _interpolateCornersCharucoApproxCalib(_markerCorners, _markerIds, _image, _board,\n  539                                                       _cameraMatrix, _distCoeffs, _charucoCorners,\n  540                                                       _charucoIds);\n  ...\n  542      // else use local homography\n  543      else {\n  544:         _interpolateCornersCharucoLocalHom(_markerCorners, _markerIds, _image, _board,\n  545                                                    _charucoCorners, _charucoIds);\n  546      }\n  ...\n  791              }\n  792  \n  793:             // interpolate the charuco corners of the diamond\n  794              vector< Point2f > currentMarkerCorners;\n  795              Mat aux;\n  796:             interpolateCornersCharuco(currentMarker, currentMarkerId, grey, _charucoDiamondLayout,\n  797                                        currentMarkerCorners, aux, _cameraMatrix, _distCoeffs);\n  798  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/include/opencv2/viz/widgets.hpp:\n  665              @param radius Radius of the spheres.\n  666              @param from Color for first sphere.\n  667:             @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  668               */\n  669              WTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/misc/python/python_viz.hpp:\n  841      @param radius Radius of the spheres.\n  842      @param from Color for first sphere.\n  843:     @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  844       */\n  845      CV_WRAP PyWTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy.hpp:\n  219  @param newFrame Output image.\n  220  @param buf Temporary buffer, will have width x 6\\*height size, CV_32FC1 type and contain 6\n  221: GpuMat: occlusion masks for first frame, occlusion masks for second, interpolated forward\n  222: horizontal flow, interpolated forward vertical flow, interpolated backward horizontal flow,\n  223: interpolated backward vertical flow.\n  224  @param stream Stream for the asynchronous version.\n  225   */\n  226: CV_EXPORTS void interpolateFrames(const GpuMat& frame0, const GpuMat& frame1,\n  227                                    const GpuMat& fu, const GpuMat& fv,\n  228                                    const GpuMat& bu, const GpuMat& bv,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy/NCVPyramid.hpp:\n   56      {\n   57          CV_EXPORTS void downsampleX2(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   58:         CV_EXPORTS void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   59      }\n   60  }}}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/image_pyramid.cpp:\n  136          }\n  137  \n  138:         cv::cuda::device::pyramid::interpolateFrom1(lastLayer, outImg, outImg.depth(), outImg.channels(), StreamAccessor::getStream(stream));\n  139      }\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp:\n   48  #if !defined (HAVE_CUDA) || !defined (HAVE_OPENCV_CUDALEGACY) || defined (CUDA_DISABLER)\n   49  \n   50: void cv::cuda::interpolateFrames(const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, float, GpuMat&, GpuMat&, Stream&) { throw_no_cuda(); }\n   51  \n   52  #else\n   53  \n   54: void cv::cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv,\n   55                                  float pos, GpuMat& newFrame, GpuMat& buf, Stream& s)\n   56  {\n   ..\n   71      GpuMat occ1 = buf.rowRange(1 * frame0.rows, 2 * frame0.rows);\n   72  \n   73:     // interpolated forward flow\n   74      GpuMat fui = buf.rowRange(2 * frame0.rows, 3 * frame0.rows);\n   75      GpuMat fvi = buf.rowRange(3 * frame0.rows, 4 * frame0.rows);\n   76  \n   77:     // interpolated backward flow\n   78      GpuMat bui = buf.rowRange(4 * frame0.rows, 5 * frame0.rows);\n   79      GpuMat bvi = buf.rowRange(5 * frame0.rows, 6 * frame0.rows);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/lbph_faces.cpp:\n  241          for(int i=radius; i < src.rows-radius;i++) {\n  242              for(int j=radius;j < src.cols-radius;j++) {\n  243:                 // calculate interpolated value\n  244                  float t = static_cast<float>(w1*src.at<_Tp>(i+fy,j+fx) + w2*src.at<_Tp>(i+fy,j+cx) + w3*src.at<_Tp>(i+cy,j+fx) + w4*src.at<_Tp>(i+cy,j+cx));\n  245                  // floating point precision, so check some machine-dependent epsilon\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/column_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/row_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n304 matches across 76 files\n\n\nSearching 7785 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/opencv/disabled/detect_board_charuco.cpp:\n  194        cv::aruco::refineDetectedMarkers(image, board, markerCorners, markerIds, rejectedMarkers, camMatrix, distCoeffs);\n  195  \n  196:     // interpolate charuco corners\n  197:     int interpolatedCorners = 0;\n  198      if(markerIds.size() > 0)\n  199:       interpolatedCorners = cv::aruco::interpolateCornersCharuco(\n  200            markerCorners, markerIds, image, charucoboard, charucoCorners, charucoIds, camMatrix, distCoeffs);\n  201  \n  ...\n  223        cv::aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, cv::noArray(), cv::Scalar(100, 0, 255));\n  224  \n  225:     if(interpolatedCorners > 0) {\n  226        cv::Scalar color;\n  227        color = cv::Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.hpp:\n  116      bool findMaximaInLayer(int counterOffset, int octave, int layer_rows, int layer_cols);\n  117  \n  118:     bool interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int maxFeatures);\n  119  \n  120      bool calcOrientation(UMat &keypoints);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/msd.cpp:\n  263               * @param scale scale of the key-point over the image pyramid\n  264               * @param saliency pointer to the saliency array\n  265:              * @param p_res interpolated coordinates of the key-point referred to the lowest level of the pyramid (i.e. in the ref. frame of the input image)\n  266               * @return false if the current key-point has to be rejected, true otherwise\n  267               */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.ocl.cpp:\n  187          if (maxCounter > 0)\n  188          {\n  189:             if(!interpolateKeypoint(maxCounter, keypoints, octave, layer_rows, maxFeatures))\n  190                  return false;\n  191          }\n  ...\n  431  }\n  432  \n  433: bool SURF_OCL::interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int max_features)\n  434  {\n  435      size_t localThreads[3]  = {3, 3, 3};\n  436      size_t globalThreads[3] = {maxCounter*localThreads[0], localThreads[1], 3};\n  437  \n  438:     ocl::Kernel kerInterp(\"SURF_interpolateKeypoint\", ocl::xfeatures2d::surf_oclsrc, kerOpts);\n  439  \n  440      return kerInterp.args(ocl::KernelArg::ReadOnlyNoSize(det),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/daisy.cpp:\n  371  \n  372  \n  373: static float interpolate_peak( float left, float center, float right )\n  374  {\n  375      if( center < 0.0 )\n  ...\n 1409                 next -= m_orientation_resolution;\n 1410  \n 1411:             peak = interpolate_peak(hist.at<float>(prev), hist.at<float>(max_ind), hist.at<float>(next));\n 1412              angle = (float)( ((float)max_ind + peak)*360.0/m_orientation_resolution );\n 1413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.cpp:\n  220   * approximated using central differences. The linear system Ax = b is then\n  221   * solved, where A is the Hessian, b is the negative gradient, and x is the\n  222:  * offset of the interpolated maxima coordinates from the initial estimate.\n  223   * This is equivalent to an iteration of Netwon's optimisation algorithm.\n  224   *\n  ...\n  232   */\n  233  static int\n  234: interpolateKeypoint( float N9[3][9], int dx, int dy, int ds, KeyPoint& kpt )\n  235  {\n  236      Vec3f b(-(N9[1][5]-N9[1][3])/2,  // Negative 1st deriv with respect to x\n  ...\n  433                      /* Interpolate maxima location within the 3x3x3 neighbourhood  */\n  434                      int ds = size - sizes[layer-1];\n  435:                     int interp_ok = interpolateKeypoint( N9, sampleStep, sampleStep, ds, kpt );\n  436  \n  437                      /* Sometimes the interpolation step gives a negative size etc. */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparsetodenseflow.cpp:\n  106      gd->setFGSLambda(fgs_lambda);\n  107      gd->setFGSSigma (fgs_sigma);\n  108:     gd->interpolate(prev,points_filtered,cur,dst_points_filtered,dense_flow);\n  109  }\n  110  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlofflow.cpp:\n  218              gd->setFGSSigma(fgs_sigma);\n  219              gd->setUsePostProcessing(use_post_proc);\n  220:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  221          }\n  222          else if (interp_type == InterpolationType::INTERP_RIC)\n  ...\n  230              gd->setUseGlobalSmootherFilter(use_post_proc);\n  231              gd->setUseVariationalRefinement(false);\n  232:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  233          }\n  234          else\n  ...\n  237              GaussianBlur(prevImage, blurredPrevImage, cv::Size(5, 5), -1);\n  238              std::vector<uchar> status(filtered_currPoints.size(), 1);\n  239:             interpolate_irregular_nn_raster(filtered_prevPoints, filtered_currPoints, status, blurredPrevImage).copyTo(dense_flow);\n  240              std::vector<Mat> vecMats;\n  241              std::vector<Mat> vecMats2(2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.cpp:\n  115  }\n  116  \n  117: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n  118      const std::vector<Point2f> & nextPoints,\n  119      const std::vector<uchar> & status,\n  ...\n  241  }\n  242  \n  243: Mat interpolate_irregular_knn(\n  244      const std::vector<Point2f> & _prevPoints,\n  245      const std::vector<Point2f> & _nextPoints,\n  ...\n  401  \n  402  \n  403: Mat interpolate_irregular_nn(\n  404      const std::vector<Point2f> & _prevPoints,\n  405      const std::vector<Point2f> & _nextPoints,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.hpp:\n   12  Mat sgeo_dist(const Mat& gra, int y, int x, float max, Mat &prev);\n   13  Mat sgeo_dist(const Mat& gra, const std::vector<Point2f> & points, float max, Mat &prev);\n   14: Mat interpolate_irregular_nw(const Mat &in, const Mat &mask, const Mat &color_img, float max_d, float bandwidth, float pixeldistance);\n   15: Mat interpolate_irregular_nn(\n   16      const std::vector<Point2f> & prevPoints,\n   17      const std::vector<Point2f> & nextPoints,\n   ..\n   19      const Mat &color_img,\n   20      float pixeldistance);\n   21: Mat interpolate_irregular_knn(\n   22      const std::vector<Point2f> & _prevPoints,\n   23      const std::vector<Point2f> & _nextPoints,\n   ..\n   27      float pixeldistance);\n   28  \n   29: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n   30      const std::vector<Point2f> & nextPoints,\n   31      const std::vector<uchar> & status,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_sparse_match_interpolator.cpp:\n   90      interpolator->setFGSLambda(500.0f);\n   91      interpolator->setFGSSigma(1.5f);\n   92:     interpolator->interpolate(src,from_points,Mat(),to_points,res_flow);\n   93  \n   94      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n   ..\n   97      Mat from_point_mat(from_points);\n   98      Mat to_points_mat(to_points);\n   99:     interpolator->interpolate(src,from_point_mat,Mat(),to_points_mat,res_flow);\n  100  \n  101      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  146      interpolator->setFGSLambda(500.f);\n  147      interpolator->setFGSSigma(1.5f);\n  148:     interpolator->interpolate(src, from_points, src1, to_points, res_flow);\n  149  \n  150      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  153      Mat from_point_mat(from_points);\n  154      Mat to_points_mat(to_points);\n  155:     interpolator->interpolate(src, from_point_mat, src1, to_points_mat, res_flow);\n  156  \n  157      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  205          cv::setNumThreads(nThreads);\n  206          Mat resMultiThread;\n  207:         interpolator->interpolate(from,from_points,Mat(),to_points,resMultiThread);\n  208  \n  209          cv::setNumThreads(1);\n  210          Mat resSingleThread;\n  211:         interpolator->interpolate(from,from_points,Mat(),to_points,resSingleThread);\n  212  \n  213          EXPECT_LE(cv::norm(resSingleThread, resMultiThread, NORM_INF), MAX_DIF);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp:\n   67      @param dense_flow output dense matching (two-channel CV_32F image)\n   68       */\n   69:     CV_WRAP virtual void interpolate(InputArray from_image, InputArray from_points,\n   70                                       InputArray to_image  , InputArray to_points,\n   71                                       OutputArray dense_flow) = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/sparse_match_interpolators.cpp:\n   78  public:\n   79      static Ptr<EdgeAwareInterpolatorImpl> create();\n   80:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n   81  \n   82  protected:\n   ..\n  171  }\n  172  \n  173: void EdgeAwareInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray, InputArray to_points, OutputArray dense_flow)\n  174  {\n  175      CV_Assert( !from_image.empty() && (from_image.depth() == CV_8U) && (from_image.channels() == 3 || from_image.channels() == 1) );\n  ...\n  906  public:\n  907      static Ptr<RICInterpolatorImpl> create();\n  908:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n  909  \n  910  protected:\n  ...\n 1109  };\n 1110  \n 1111: void RICInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow)\n 1112  {\n 1113      CV_Assert(!from_image.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 2199              /* update lower y limit (start) for the new 'column'.\n 2200  \n 2201:             We need to interpolate the y value that corresponds to the\n 2202              lower side of the rectangle. The first thing is to decide if\n 2203              the corresponding side is\n ....\n 2206              vx[3],vy[3] to vx[2],vy[2]\n 2207  \n 2208:             Then, the side is interpolated for the x value of the\n 2209              'column'. But, if the side is vertical (as it could happen if\n 2210              the rectangle is vertical and we are dealing with the first\n ....\n 2245              /* update upper y limit (end) for the new 'column'.\n 2246  \n 2247:             We need to interpolate the y value that corresponds to the\n 2248              upper side of the rectangle. The first thing is to decide if\n 2249              the corresponding side is\n ....\n 2252              vx[1],vy[1] to vx[2],vy[2]\n 2253  \n 2254:             Then, the side is interpolated for the x value of the\n 2255              'column'. But, if the side is vertical (as it could happen if\n 2256              the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/nonrigid_icp.cpp:\n  306                  continue;\n  307  \n  308:             // TODO: interpolate Vg instead of simply converting projected coords to int\n  309              Vg.at<Vec3f>(y, x) = vertImage.at<Vec3f>((int)newCoords.y, (int)newCoords.x);\n  310  \n  311:             // bilinearly interpolate newPoints under newCoords point\n  312              int xi = cvFloor(newCoords.x), yi = cvFloor(newCoords.y);\n  313              float tx  = newCoords.x - xi, ty = newCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.hpp:\n   74      virtual TsdfVoxel at(const Vec3i& volumeIdx) const;\n   75  \n   76:     float interpolateVoxel(const cv::Point3f& p) const;\n   77      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   78  \n   79  #if USE_INTRINSICS\n   80:     float interpolateVoxel(const v_float32x4& p) const;\n   81      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   82  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/hash_tsdf.cpp:\n  126  \n  127  \n  128:     float interpolateVoxelPoint(const Point3f& point) const;\n  129:     float interpolateVoxel(const cv::Point3f& point) const;\n  130      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  131  \n  ...\n  421  \n  422  #if USE_INTRINSICS\n  423: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  424  {\n  425      v_float32x4 v0246, v1357;\n  ...\n  440  \n  441  #else\n  442: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  443  {\n  444      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  454  #endif\n  455  \n  456: float HashTSDFVolumeCPU::interpolateVoxelPoint(const Point3f& point) const\n  457  {\n  458      const Vec3i neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n  ...\n  495      }\n  496  \n  497:     return interpolate(tx, ty, tz, vx);\n  498  }\n  499  \n  500: inline float HashTSDFVolumeCPU::interpolateVoxel(const cv::Point3f& point) const\n  501  {\n  502:     return interpolateVoxelPoint(point * voxelSizeInv);\n  503  }\n  504  \n  ...\n  631      float tz = ptVox.z - iptVox[2];\n  632  \n  633:     normal[0] = interpolate(tx, ty, tz, cxv);\n  634:     normal[1] = interpolate(tx, ty, tz, cyv);\n  635:     normal[2] = interpolate(tx, ty, tz, czv);\n  636  #endif\n  637  \n  ...\n  921  \n  922  \n  923:     float interpolateVoxelPoint(const Point3f& point) const;\n  924:     float interpolateVoxel(const cv::Point3f& point) const;\n  925      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  926  \n  ...\n 1380  }\n 1381  \n 1382: float HashTSDFVolumeGPU::interpolateVoxelPoint(const Point3f& point) const\n 1383  {\n 1384      const Vec3i local_neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n ....\n 1421      }\n 1422  \n 1423:     return interpolate(tx, ty, tz, vx);\n 1424  }\n 1425  \n 1426: inline float HashTSDFVolumeGPU::interpolateVoxel(const cv::Point3f& point) const\n 1427  {\n 1428:     return interpolateVoxelPoint(point * voxelSizeInv);\n 1429  }\n 1430  \n ....\n 1556      float tz = ptVox.z - iptVox[2];\n 1557  \n 1558:     normal[0] = interpolate(tx, ty, tz, cxv);\n 1559:     normal[1] = interpolate(tx, ty, tz, cyv);\n 1560:     normal[2] = interpolate(tx, ty, tz, czv);\n 1561  #endif\n 1562      float nv = sqrt(normal[0] * normal[0] +\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/fast_icp.cpp:\n  243                      continue;\n  244  \n  245:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  246                  v_float32x4 oldP;\n  247                  v_float32x4 oldN;\n  ...\n  390                      continue;\n  391  \n  392:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  393                  int xi = cvFloor(oldCoords.x), yi = cvFloor(oldCoords.y);\n  394                  float tx  = oldCoords.x - xi, ty = oldCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.cpp:\n  137  #if USE_INTRINSICS\n  138  // all coordinate checks should be done in inclosing cycle\n  139: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  140  {\n  141      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  142:     return interpolateVoxel(p);\n  143  }\n  144  \n  145: inline float TSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  146  {\n  147      // tx, ty, tz = floor(p)\n  ...\n  184  }\n  185  #else\n  186: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  187  {\n  188      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  438                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  439                      v_float32x4 next    = (orig + dir * v_setall_f32(tmin));\n  440:                     float f = volume.interpolateVoxel(next), fnext = f;\n  441  \n  442                      //raymarch\n  ...\n  455                          if(fnext != f)\n  456                          {\n  457:                             fnext = volume.interpolateVoxel(next);\n  458  \n  459                              // when ray crosses a surface\n  ...\n  466  \n  467                      // if ray penetrates a surface from outside\n  468:                     // linearly interpolate t between two f values\n  469                      if(f > 0.f && fnext < 0.f)\n  470                      {\n  471                          v_float32x4 tp = next - rayStep;\n  472:                         float ft    = volume.interpolateVoxel(tp);\n  473:                         float ftdt  = volume.interpolateVoxel(next);\n  474                          float ts = tmin + tstep*(steps - ft/(ftdt - ft));\n  475  \n  ...\n  547                      Point3f rayStep = dir * tstep;\n  548                      Point3f next = (orig + dir * tmin);\n  549:                     float f = volume.interpolateVoxel(next), fnext = f;\n  550  \n  551                      //raymarch\n  ...\n  564                          if(fnext != f)\n  565                          {\n  566:                             fnext = volume.interpolateVoxel(next);\n  567                              // when ray crosses a surface\n  568                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  573                      }\n  574                      // if ray penetrates a surface from outside\n  575:                     // linearly interpolate t between two f values\n  576                      if(f > 0.f && fnext < 0.f)\n  577                      {\n  578                          Point3f tp    = next - rayStep;\n  579:                         float ft   = volume.interpolateVoxel(tp);\n  580:                         float ftdt = volume.interpolateVoxel(next);\n  581                          // float t = tmin + steps*tstep;\n  582                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  692                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  693                  {\n  694:                     //linearly interpolate coordinate\n  695                      float Vn    = Vc + vol.voxelSize;\n  696                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/warpfield.cpp:\n  212  \n  213          Affine3f pose = DQB(weights, transforms);\n  214:         // linearly interpolate translations\n  215          Vec3f translation(0,0,0);\n  216          float totalWeight = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/dynafu_tsdf.cpp:\n   48      virtual void reset() override;\n   49  \n   50:     volumeType interpolateVoxel(cv::Point3f p) const;\n   51      Point3f getNormalVoxel(cv::Point3f p) const;\n   52  \n   ..\n   59  \n   60  private:\n   61:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const;\n   62  };\n   63  \n   ..\n  330  }\n  331  \n  332: inline volumeType TSDFVolumeCPU::interpolateVoxel(Point3f p) const\n  333  {\n  334      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  472                      Point3f rayStep = dir * tstep;\n  473                      Point3f next = (orig + dir * tmin);\n  474:                     volumeType f = volume.interpolateVoxel(next), fnext = f;\n  475  \n  476                      //raymarch\n  ...\n  489                          if(fnext != f)\n  490                          {\n  491:                             fnext = volume.interpolateVoxel(next);\n  492  \n  493                              // when ray crosses a surface\n  ...\n  500  \n  501                      // if ray penetrates a surface from outside\n  502:                     // linearly interpolate t between two f values\n  503                      if(f > 0.f && fnext < 0.f)\n  504                      {\n  505                          Point3f tp = next - rayStep;\n  506:                         volumeType ft   = volume.interpolateVoxel(tp);\n  507:                         volumeType ftdt = volume.interpolateVoxel(next);\n  508                          // float t = tmin + steps*tstep;\n  509                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  621                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  622                  {\n  623:                     //linearly interpolate coordinate\n  624                      float Vn = Vc + vol.voxelSize;\n  625                      float dinv = 1.f/(abs(v0)+abs(vd));\n  ...\n  790      }\n  791  \n  792:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const\n  793      {\n  794          float dV = 0.5f;\n  ...\n  835  \n  836                      if (edgeTable[cubeIndex] & 1)\n  837:                         vertices[0] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[1],\n  838                                                             tsdfValues[0], tsdfValues[1]);\n  839                      if (edgeTable[cubeIndex] & 2)\n  840:                         vertices[1] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[2],\n  841                                                             tsdfValues[1], tsdfValues[2]);\n  842                      if (edgeTable[cubeIndex] & 4)\n  843:                         vertices[2] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[3],\n  844                                                             tsdfValues[2], tsdfValues[3]);\n  845                      if (edgeTable[cubeIndex] & 8)\n  846:                         vertices[3] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[0],\n  847                                                             tsdfValues[3], tsdfValues[0]);\n  848                      if (edgeTable[cubeIndex] & 16)\n  849:                         vertices[4] = basePt + interpolate(mcNeighbourPts[4], mcNeighbourPts[5],\n  850                                                             tsdfValues[4], tsdfValues[5]);\n  851                      if (edgeTable[cubeIndex] & 32)\n  852:                         vertices[5] = basePt + interpolate(mcNeighbourPts[5], mcNeighbourPts[6],\n  853                                                             tsdfValues[5], tsdfValues[6]);\n  854                      if (edgeTable[cubeIndex] & 64)\n  855:                         vertices[6] = basePt + interpolate(mcNeighbourPts[6], mcNeighbourPts[7],\n  856                                                             tsdfValues[6], tsdfValues[7]);\n  857                      if (edgeTable[cubeIndex] & 128)\n  858:                         vertices[7] = basePt + interpolate(mcNeighbourPts[7], mcNeighbourPts[4],\n  859                                                             tsdfValues[7], tsdfValues[4]);\n  860                      if (edgeTable[cubeIndex] & 256)\n  861:                         vertices[8] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[4],\n  862                                                             tsdfValues[0], tsdfValues[4]);\n  863                      if (edgeTable[cubeIndex] & 512)\n  864:                         vertices[9] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[5],\n  865                                                             tsdfValues[1], tsdfValues[5]);\n  866                      if (edgeTable[cubeIndex] & 1024)\n  867:                         vertices[10] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[6],\n  868                                                              tsdfValues[2], tsdfValues[6]);\n  869                      if (edgeTable[cubeIndex] & 2048)\n  870:                         vertices[11] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[7],\n  871                                                              tsdfValues[3], tsdfValues[7]);\n  872  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf_functions.cpp:\n  249  \n  250                      depthType v;\n  251:                     // bilinearly interpolate depth at projected\n  252                      {\n  253                          const v_float32x4& pt = projected;\n  ...\n  284                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  285                              v_float32x4 ty = v_setall_f32(t.get0());\n  286:                             // vx is y-interpolated between rows 0 and 1\n  287                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  288                              float v0 = vx.get0();\n  ...\n  514  \n  515                      depthType v;\n  516:                     // bilinearly interpolate depth at projected\n  517                      {\n  518                          const v_float32x4& pt = projected;\n  ...\n  549                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  550                              v_float32x4 ty = v_setall_f32(t.get0());\n  551:                             // vx is y-interpolated between rows 0 and 1\n  552                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  553                              float v0 = vx.get0();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/colored_tsdf.cpp:\n   85      virtual RGBTsdfVoxel at(const Vec3i& volumeIdx) const;\n   86  \n   87:     float interpolateVoxel(const cv::Point3f& p) const;\n   88      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   89:     float interpolateColor(float tx, float ty, float tz, float vx[8]) const;\n   90      Point3f getColorVoxel(const cv::Point3f& p) const;\n   91  \n   92  #if USE_INTRINSICS\n   93:     float interpolateVoxel(const v_float32x4& p) const;\n   94      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   95      v_float32x4 getColorVoxel(const v_float32x4& p) const;\n   ..\n  185  #if USE_INTRINSICS\n  186  // all coordinate checks should be done in inclosing cycle\n  187: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  188  {\n  189      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  190:     return interpolateVoxel(p);\n  191  }\n  192  \n  193: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  194  {\n  195      // tx, ty, tz = floor(p)\n  ...\n  232  }\n  233  #else\n  234: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  235  {\n  236      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  384  \n  385  #if USE_INTRINSICS\n  386: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  387  {\n  388      v_float32x4 v0246, v1357;\n  ...\n  402  }\n  403  #else\n  404: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  405  {\n  406      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  463      float ty = t.get0(); t = v_rotate_right<1>(t);\n  464      float tz = t.get0();\n  465:     rgb[0] = interpolateColor(tx, ty, tz, r);\n  466:     rgb[1] = interpolateColor(tx, ty, tz, g);\n  467:     rgb[2] = interpolateColor(tx, ty, tz, b);\n  468      rgb[3] = 0.f;\n  469  #else\n  ...\n  512      float tz = ptVox.z - iptVox[2];\n  513  \n  514:     res=Point3f(interpolateColor(tx, ty, tz, r),\n  515:                 interpolateColor(tx, ty, tz, g),\n  516:                 interpolateColor(tx, ty, tz, b));\n  517  #else\n  518      res=Point3f(volData[coordBase].r, volData[coordBase].g, volData[coordBase].b);\n  ...\n  627                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  628                      v_float32x4 next = (orig + dir * v_setall_f32(tmin));\n  629:                     float f = volume.interpolateVoxel(next), fnext = f;\n  630  \n  631                      //raymarch\n  ...\n  644                          if (fnext != f)\n  645                          {\n  646:                             fnext = volume.interpolateVoxel(next);\n  647  \n  648                              // when ray crosses a surface\n  ...\n  655  \n  656                      // if ray penetrates a surface from outside\n  657:                     // linearly interpolate t between two f values\n  658                      if (f > 0.f && fnext < 0.f)\n  659                      {\n  660                          v_float32x4 tp = next - rayStep;\n  661:                         float ft = volume.interpolateVoxel(tp);\n  662:                         float ftdt = volume.interpolateVoxel(next);\n  663                          float ts = tmin + tstep * (steps - ft / (ftdt - ft));\n  664  \n  ...\n  740                      Point3f rayStep = dir * tstep;\n  741                      Point3f next = (orig + dir * tmin);\n  742:                     float f = volume.interpolateVoxel(next), fnext = f;\n  743  \n  744                      //raymarch\n  ...\n  757                          if(fnext != f)\n  758                          {\n  759:                             fnext = volume.interpolateVoxel(next);\n  760                              // when ray crosses a surface\n  761                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  766                      }\n  767                      // if ray penetrates a surface from outside\n  768:                     // linearly interpolate t between two f values\n  769                      if(f > 0.f && fnext < 0.f)\n  770                      {\n  771                          Point3f tp    = next - rayStep;\n  772:                         float ft   = volume.interpolateVoxel(tp);\n  773:                         float ftdt = volume.interpolateVoxel(next);\n  774                          // float t = tmin + steps*tstep;\n  775                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  893                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  894                  {\n  895:                     //linearly interpolate coordinate\n  896                      float Vn    = Vc + vol.voxelSize;\n  897                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapaffine.cpp:\n   80  \n   81      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   82:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   83      // remap will not touch them).\n   84      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapshift.cpp:\n   81  \n   82      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   83:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   84      // remap will not touch them).\n   85      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapprojec.cpp:\n   83  \n   84      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   85:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   86      // remap will not touch them).\n   87      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retina_ocl.cpp:\n 1155      demultiplex(ocl_multiplexed_input, _demultiplexedTempBuffer);\n 1156  \n 1157:     // interpolate the demultiplexed frame depending on the color sampling method\n 1158      if (!adaptiveFiltering)\n 1159      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.hpp:\n  243          // protected functions\n  244          void _initColorSampling();\n  245:         void _interpolateImageDemultiplexedImage(float *inputOutputBuffer);\n  246:         void _interpolateSingleChannelImage111(float *inputOutputBuffer);\n  247:         void _interpolateBayerRGBchannels(float *inputOutputBuffer);\n  248          void _applyRIFfilter(const float *sourceBuffer, float *destinationBuffer);\n  249          void _getNormalizedContoursImage(const float *inputFrame, float *outputFrame);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.cpp:\n  264          _demultiplexedTempBuffer[*(colorSamplingPRT++)]=*(multiplexedColorFramePtr++);\n  265  \n  266:     // interpolate the demultiplexed frame depending on the color sampling method\n  267      if (!adaptiveFiltering)\n  268:         _interpolateImageDemultiplexedImage(&_demultiplexedTempBuffer[0]);\n  269  \n  270      // low pass filtering the demultiplexed frame\n  ...\n  453  }\n  454  \n  455: void RetinaColor::_interpolateImageDemultiplexedImage(float *inputOutputBuffer)\n  456  {\n  457  \n  ...\n  460  \n  461      case RETINA_COLOR_RANDOM:\n  462:         return; // no need to interpolate\n  463          break;\n  464  \n  465      case RETINA_COLOR_DIAGONAL:\n  466:         _interpolateSingleChannelImage111(inputOutputBuffer);\n  467          break;\n  468  \n  469      case RETINA_COLOR_BAYER: // default sets bayer sampling\n  470:         _interpolateBayerRGBchannels(inputOutputBuffer);\n  471          break;\n  472      default:\n  ...\n  479  }\n  480  \n  481: void RetinaColor::_interpolateSingleChannelImage111(float *inputOutputBuffer)\n  482  {\n  483      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows(); ++indexr)\n  ...\n  499  }\n  500  \n  501: void RetinaColor::_interpolateBayerRGBchannels(float *inputOutputBuffer)\n  502  {\n  503      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows()-1; indexr+=2)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/tutorial_charuco_create_detect.cpp:\n   59                  std::vector<cv::Point2f> charucoCorners;\n   60                  std::vector<int> charucoIds;\n   61:                 cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);\n   62                  //! [charidcor]\n   63                  // if at least one charuco corner detected\n   ..\n  110              std::vector<cv::Point2f> charucoCorners;\n  111              std::vector<int> charucoIds;\n  112:             cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds);\n  113              //! [charidcorwc]\n  114              // if at least one charuco corner detected\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/detect_board_charuco.cpp:\n  173                                           camMatrix, distCoeffs);\n  174  \n  175:         // interpolate charuco corners\n  176:         int interpolatedCorners = 0;\n  177          if(markerIds.size() > 0)\n  178:             interpolatedCorners =\n  179:                 aruco::interpolateCornersCharuco(markerCorners, markerIds, image, charucoboard,\n  180                                                   charucoCorners, charucoIds, camMatrix, distCoeffs);\n  181  \n  ...\n  207              aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, noArray(), Scalar(100, 0, 255));\n  208  \n  209:         if(interpolatedCorners > 0) {\n  210              Scalar color;\n  211              color = Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/calibrate_camera_charuco.cpp:\n  178          if(refindStrategy) aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  179  \n  180:         // interpolate charuco corners\n  181          Mat currentCharucoCorners, currentCharucoIds;\n  182          if(ids.size() > 0)\n  183:             aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners,\n  184                                               currentCharucoIds);\n  185  \n  ...\n  248  \n  249      for(int i = 0; i < nFrames; i++) {\n  250:         // interpolate using camera parameters\n  251          Mat currentCharucoCorners, currentCharucoIds;\n  252:         aruco::interpolateCornersCharuco(allCorners[i], allIds[i], allImgs[i], charucoboard,\n  253                                           currentCharucoCorners, currentCharucoIds, cameraMatrix,\n  254                                           distCoeffs);\n  ...\n  280      cout << \"Calibration saved to \" << outputFile << endl;\n  281  \n  282:     // show interpolated charuco corners for debugging\n  283      if(showChessboardCorners) {\n  284          for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/test/test_charucodetection.cpp:\n  256                  }\n  257  \n  258:                 // interpolate charuco corners\n  259                  vector< Point2f > charucoCorners;\n  260                  vector< int > charucoIds;\n  261  \n  262                  if(iter % 2 == 0) {\n  263:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  264                                                       charucoIds);\n  265                  } else {\n  266:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  267                                                       charucoIds, cameraMatrix, distCoeffs);\n  268                  }\n  ...\n  354                  }\n  355  \n  356:                 // interpolate charuco corners\n  357                  vector< Point2f > charucoCorners;\n  358                  vector< int > charucoIds;\n  359  \n  360                  if(iter % 2 == 0) {\n  361:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  362                                                       charucoIds);\n  363                  } else {\n  364:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  365                                                       charucoIds, cameraMatrix, distCoeffs);\n  366                  }\n  ...\n  719  \n  720      cv::Mat c_ids, c_corners;\n  721:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids, K);\n  722      cv::Mat corners_reshaped = c_corners.reshape(1);\n  723  \n  ...\n  727      c_ids = cv::Mat();\n  728      c_corners = cv::Mat();\n  729:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids);\n  730      corners_reshaped = c_corners.reshape(1);\n  731  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp:\n  434   *\n  435   * This function tries to find markers that were not detected in the basic detecMarkers function.\n  436:  * First, based on the current detected marker and the board layout, the function interpolates\n  437   * the position of the missing markers. Then it tries to find correspondence between the reprojected\n  438   * markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n  439   * parameters.\n  440   * If camera parameters and distortion coefficients are provided, missing markers are reprojected\n  441:  * using projectPoint function. If not, missing marker projections are interpolated using global\n  442   * homography, and all the marker corners in the board must have the same Z coordinate.\n  443   */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp:\n  141   * should be sent in corners and ids parameters.\n  142   * @param board layout of ChArUco board.\n  143:  * @param charucoCorners interpolated chessboard corners\n  144:  * @param charucoIds interpolated chessboard corners identifiers\n  145   * @param cameraMatrix optional 3x3 floating-point camera matrix\n  146   * \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n  ...\n  154   * Only visible corners are returned. For each corner, its corresponding identifier is\n  155   * also returned in charucoIds.\n  156:  * The function returns the number of interpolated corners.\n  157   */\n  158: CV_EXPORTS_W int interpolateCornersCharuco(InputArrayOfArrays markerCorners, InputArray markerIds,\n  159                                             InputArray image, const Ptr<CharucoBoard> &board,\n  160                                             OutputArray charucoCorners, OutputArray charucoIds,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/aruco.cpp:\n  749   * @param nContours, contour-container\n  750   */\n  751: static Point3f _interpolate2Dline(const std::vector<cv::Point2f>& nContours){\n  752  \tfloat minX, minY, maxX, maxY;\n  753  \tminX = maxX = nContours[0].x;\n  ...\n  864  \tPoint3f lines[4];\n  865  \tfor(int i=0; i<4; i++){\n  866: \t\tlines[i]=_interpolate2Dline(cntPts[i]);\n  867  \t}\n  868  \n  ...\n 1723          }\n 1724  \n 1725:         // interpolate tiny marker to marker position in markerZone\n 1726          inCorners[0] = Point2f(-0.5f, -0.5f);\n 1727          inCorners[1] = Point2f(marker.cols - 0.5f, -0.5f);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/charuco.cpp:\n  394    * Interpolate charuco corners using approximated pose estimation\n  395    */\n  396: static int _interpolateCornersCharucoApproxCalib(InputArrayOfArrays _markerCorners,\n  397                                                   InputArray _markerIds, InputArray _image,\n  398                                                   const Ptr<CharucoBoard> &_board,\n  ...\n  438    * Interpolate charuco corners using local homography\n  439    */\n  440: static int _interpolateCornersCharucoLocalHom(InputArrayOfArrays _markerCorners,\n  441                                                InputArray _markerIds, InputArray _image,\n  442                                                const Ptr<CharucoBoard> &_board,\n  ...\n  482          Point2f objPoint2D = Point2f(_board->chessboardCorners[i].x, _board->chessboardCorners[i].y);\n  483  \n  484:         vector< Point2f > interpolatedPositions;\n  485          for(unsigned int j = 0; j < _board->nearestMarkerIdx[i].size(); j++) {\n  486              int markerId = _board->ids[_board->nearestMarkerIdx[i][j]];\n  ...\n  498                  in.push_back(objPoint2D);\n  499                  perspectiveTransform(in, out, transformations[markerIdx]);\n  500:                 interpolatedPositions.push_back(out[0]);\n  501              }\n  502          }\n  503  \n  504          // none of the closest markers detected\n  505:         if(interpolatedPositions.size() == 0) continue;\n  506  \n  507          // more than one closest marker detected, take middle point\n  508:         if(interpolatedPositions.size() > 1) {\n  509:             allChessboardImgPoints[i] = (interpolatedPositions[0] + interpolatedPositions[1]) / 2.;\n  510          }\n  511          // a single closest marker detected\n  512:         else allChessboardImgPoints[i] = interpolatedPositions[0];\n  513      }\n  514  \n  ...\n  529  /**\n  530    */\n  531: int interpolateCornersCharuco(InputArrayOfArrays _markerCorners, InputArray _markerIds,\n  532                                InputArray _image, const Ptr<CharucoBoard> &_board,\n  533                                OutputArray _charucoCorners, OutputArray _charucoIds,\n  ...\n  536      // if camera parameters are avaible, use approximated calibration\n  537      if(_cameraMatrix.total() != 0) {\n  538:         _interpolateCornersCharucoApproxCalib(_markerCorners, _markerIds, _image, _board,\n  539                                                       _cameraMatrix, _distCoeffs, _charucoCorners,\n  540                                                       _charucoIds);\n  ...\n  542      // else use local homography\n  543      else {\n  544:         _interpolateCornersCharucoLocalHom(_markerCorners, _markerIds, _image, _board,\n  545                                                    _charucoCorners, _charucoIds);\n  546      }\n  ...\n  791              }\n  792  \n  793:             // interpolate the charuco corners of the diamond\n  794              vector< Point2f > currentMarkerCorners;\n  795              Mat aux;\n  796:             interpolateCornersCharuco(currentMarker, currentMarkerId, grey, _charucoDiamondLayout,\n  797                                        currentMarkerCorners, aux, _cameraMatrix, _distCoeffs);\n  798  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/include/opencv2/viz/widgets.hpp:\n  665              @param radius Radius of the spheres.\n  666              @param from Color for first sphere.\n  667:             @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  668               */\n  669              WTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/misc/python/python_viz.hpp:\n  841      @param radius Radius of the spheres.\n  842      @param from Color for first sphere.\n  843:     @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  844       */\n  845      CV_WRAP PyWTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy.hpp:\n  219  @param newFrame Output image.\n  220  @param buf Temporary buffer, will have width x 6\\*height size, CV_32FC1 type and contain 6\n  221: GpuMat: occlusion masks for first frame, occlusion masks for second, interpolated forward\n  222: horizontal flow, interpolated forward vertical flow, interpolated backward horizontal flow,\n  223: interpolated backward vertical flow.\n  224  @param stream Stream for the asynchronous version.\n  225   */\n  226: CV_EXPORTS void interpolateFrames(const GpuMat& frame0, const GpuMat& frame1,\n  227                                    const GpuMat& fu, const GpuMat& fv,\n  228                                    const GpuMat& bu, const GpuMat& bv,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy/NCVPyramid.hpp:\n   56      {\n   57          CV_EXPORTS void downsampleX2(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   58:         CV_EXPORTS void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   59      }\n   60  }}}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/image_pyramid.cpp:\n  136          }\n  137  \n  138:         cv::cuda::device::pyramid::interpolateFrom1(lastLayer, outImg, outImg.depth(), outImg.channels(), StreamAccessor::getStream(stream));\n  139      }\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp:\n   48  #if !defined (HAVE_CUDA) || !defined (HAVE_OPENCV_CUDALEGACY) || defined (CUDA_DISABLER)\n   49  \n   50: void cv::cuda::interpolateFrames(const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, float, GpuMat&, GpuMat&, Stream&) { throw_no_cuda(); }\n   51  \n   52  #else\n   53  \n   54: void cv::cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv,\n   55                                  float pos, GpuMat& newFrame, GpuMat& buf, Stream& s)\n   56  {\n   ..\n   71      GpuMat occ1 = buf.rowRange(1 * frame0.rows, 2 * frame0.rows);\n   72  \n   73:     // interpolated forward flow\n   74      GpuMat fui = buf.rowRange(2 * frame0.rows, 3 * frame0.rows);\n   75      GpuMat fvi = buf.rowRange(3 * frame0.rows, 4 * frame0.rows);\n   76  \n   77:     // interpolated backward flow\n   78      GpuMat bui = buf.rowRange(4 * frame0.rows, 5 * frame0.rows);\n   79      GpuMat bvi = buf.rowRange(5 * frame0.rows, 6 * frame0.rows);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/lbph_faces.cpp:\n  241          for(int i=radius; i < src.rows-radius;i++) {\n  242              for(int j=radius;j < src.cols-radius;j++) {\n  243:                 // calculate interpolated value\n  244                  float t = static_cast<float>(w1*src.at<_Tp>(i+fy,j+fx) + w2*src.at<_Tp>(i+fy,j+cx) + w3*src.at<_Tp>(i+cy,j+fx) + w4*src.at<_Tp>(i+cy,j+cx));\n  245                  // floating point precision, so check some machine-dependent epsilon\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/column_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/row_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n300 matches across 74 files\n\n\nSearching 7631 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.hpp:\n  116      bool findMaximaInLayer(int counterOffset, int octave, int layer_rows, int layer_cols);\n  117  \n  118:     bool interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int maxFeatures);\n  119  \n  120      bool calcOrientation(UMat &keypoints);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/msd.cpp:\n  263               * @param scale scale of the key-point over the image pyramid\n  264               * @param saliency pointer to the saliency array\n  265:              * @param p_res interpolated coordinates of the key-point referred to the lowest level of the pyramid (i.e. in the ref. frame of the input image)\n  266               * @return false if the current key-point has to be rejected, true otherwise\n  267               */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.ocl.cpp:\n  187          if (maxCounter > 0)\n  188          {\n  189:             if(!interpolateKeypoint(maxCounter, keypoints, octave, layer_rows, maxFeatures))\n  190                  return false;\n  191          }\n  ...\n  431  }\n  432  \n  433: bool SURF_OCL::interpolateKeypoint(int maxCounter, UMat &keypoints, int octave, int layer_rows, int max_features)\n  434  {\n  435      size_t localThreads[3]  = {3, 3, 3};\n  436      size_t globalThreads[3] = {maxCounter*localThreads[0], localThreads[1], 3};\n  437  \n  438:     ocl::Kernel kerInterp(\"SURF_interpolateKeypoint\", ocl::xfeatures2d::surf_oclsrc, kerOpts);\n  439  \n  440      return kerInterp.args(ocl::KernelArg::ReadOnlyNoSize(det),\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/daisy.cpp:\n  371  \n  372  \n  373: static float interpolate_peak( float left, float center, float right )\n  374  {\n  375      if( center < 0.0 )\n  ...\n 1409                 next -= m_orientation_resolution;\n 1410  \n 1411:             peak = interpolate_peak(hist.at<float>(prev), hist.at<float>(max_ind), hist.at<float>(next));\n 1412              angle = (float)( ((float)max_ind + peak)*360.0/m_orientation_resolution );\n 1413  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/xfeatures2d/src/surf.cpp:\n  220   * approximated using central differences. The linear system Ax = b is then\n  221   * solved, where A is the Hessian, b is the negative gradient, and x is the\n  222:  * offset of the interpolated maxima coordinates from the initial estimate.\n  223   * This is equivalent to an iteration of Netwon's optimisation algorithm.\n  224   *\n  ...\n  232   */\n  233  static int\n  234: interpolateKeypoint( float N9[3][9], int dx, int dy, int ds, KeyPoint& kpt )\n  235  {\n  236      Vec3f b(-(N9[1][5]-N9[1][3])/2,  // Negative 1st deriv with respect to x\n  ...\n  433                      /* Interpolate maxima location within the 3x3x3 neighbourhood  */\n  434                      int ds = size - sizes[layer-1];\n  435:                     int interp_ok = interpolateKeypoint( N9, sampleStep, sampleStep, ds, kpt );\n  436  \n  437                      /* Sometimes the interpolation step gives a negative size etc. */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/sparsetodenseflow.cpp:\n  106      gd->setFGSLambda(fgs_lambda);\n  107      gd->setFGSSigma (fgs_sigma);\n  108:     gd->interpolate(prev,points_filtered,cur,dst_points_filtered,dense_flow);\n  109  }\n  110  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlofflow.cpp:\n  218              gd->setFGSSigma(fgs_sigma);\n  219              gd->setUsePostProcessing(use_post_proc);\n  220:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  221          }\n  222          else if (interp_type == InterpolationType::INTERP_RIC)\n  ...\n  230              gd->setUseGlobalSmootherFilter(use_post_proc);\n  231              gd->setUseVariationalRefinement(false);\n  232:             gd->interpolate(prevImage, filtered_prevPoints, currImage, filtered_currPoints, dense_flow);\n  233          }\n  234          else\n  ...\n  237              GaussianBlur(prevImage, blurredPrevImage, cv::Size(5, 5), -1);\n  238              std::vector<uchar> status(filtered_currPoints.size(), 1);\n  239:             interpolate_irregular_nn_raster(filtered_prevPoints, filtered_currPoints, status, blurredPrevImage).copyTo(dense_flow);\n  240              std::vector<Mat> vecMats;\n  241              std::vector<Mat> vecMats2(2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.cpp:\n  115  }\n  116  \n  117: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n  118      const std::vector<Point2f> & nextPoints,\n  119      const std::vector<uchar> & status,\n  ...\n  241  }\n  242  \n  243: Mat interpolate_irregular_knn(\n  244      const std::vector<Point2f> & _prevPoints,\n  245      const std::vector<Point2f> & _nextPoints,\n  ...\n  401  \n  402  \n  403: Mat interpolate_irregular_nn(\n  404      const std::vector<Point2f> & _prevPoints,\n  405      const std::vector<Point2f> & _nextPoints,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/optflow/src/rlof/geo_interpolation.hpp:\n   12  Mat sgeo_dist(const Mat& gra, int y, int x, float max, Mat &prev);\n   13  Mat sgeo_dist(const Mat& gra, const std::vector<Point2f> & points, float max, Mat &prev);\n   14: Mat interpolate_irregular_nw(const Mat &in, const Mat &mask, const Mat &color_img, float max_d, float bandwidth, float pixeldistance);\n   15: Mat interpolate_irregular_nn(\n   16      const std::vector<Point2f> & prevPoints,\n   17      const std::vector<Point2f> & nextPoints,\n   ..\n   19      const Mat &color_img,\n   20      float pixeldistance);\n   21: Mat interpolate_irregular_knn(\n   22      const std::vector<Point2f> & _prevPoints,\n   23      const std::vector<Point2f> & _nextPoints,\n   ..\n   27      float pixeldistance);\n   28  \n   29: Mat interpolate_irregular_nn_raster(const std::vector<Point2f> & prevPoints,\n   30      const std::vector<Point2f> & nextPoints,\n   31      const std::vector<uchar> & status,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/test/test_sparse_match_interpolator.cpp:\n   90      interpolator->setFGSLambda(500.0f);\n   91      interpolator->setFGSSigma(1.5f);\n   92:     interpolator->interpolate(src,from_points,Mat(),to_points,res_flow);\n   93  \n   94      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n   ..\n   97      Mat from_point_mat(from_points);\n   98      Mat to_points_mat(to_points);\n   99:     interpolator->interpolate(src,from_point_mat,Mat(),to_points_mat,res_flow);\n  100  \n  101      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  146      interpolator->setFGSLambda(500.f);\n  147      interpolator->setFGSSigma(1.5f);\n  148:     interpolator->interpolate(src, from_points, src1, to_points, res_flow);\n  149  \n  150      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  153      Mat from_point_mat(from_points);\n  154      Mat to_points_mat(to_points);\n  155:     interpolator->interpolate(src, from_point_mat, src1, to_points_mat, res_flow);\n  156  \n  157      EXPECT_LE(cv::norm(res_flow, ref_flow, NORM_INF), MAX_DIF);\n  ...\n  205          cv::setNumThreads(nThreads);\n  206          Mat resMultiThread;\n  207:         interpolator->interpolate(from,from_points,Mat(),to_points,resMultiThread);\n  208  \n  209          cv::setNumThreads(1);\n  210          Mat resSingleThread;\n  211:         interpolator->interpolate(from,from_points,Mat(),to_points,resSingleThread);\n  212  \n  213          EXPECT_LE(cv::norm(resSingleThread, resMultiThread, NORM_INF), MAX_DIF);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/include/opencv2/ximgproc/sparse_match_interpolator.hpp:\n   67      @param dense_flow output dense matching (two-channel CV_32F image)\n   68       */\n   69:     CV_WRAP virtual void interpolate(InputArray from_image, InputArray from_points,\n   70                                       InputArray to_image  , InputArray to_points,\n   71                                       OutputArray dense_flow) = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/sparse_match_interpolators.cpp:\n   78  public:\n   79      static Ptr<EdgeAwareInterpolatorImpl> create();\n   80:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n   81  \n   82  protected:\n   ..\n  171  }\n  172  \n  173: void EdgeAwareInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray, InputArray to_points, OutputArray dense_flow)\n  174  {\n  175      CV_Assert( !from_image.empty() && (from_image.depth() == CV_8U) && (from_image.channels() == 3 || from_image.channels() == 1) );\n  ...\n  906  public:\n  907      static Ptr<RICInterpolatorImpl> create();\n  908:     void interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow) CV_OVERRIDE;\n  909  \n  910  protected:\n  ...\n 1109  };\n 1110  \n 1111: void RICInterpolatorImpl::interpolate(InputArray from_image, InputArray from_points, InputArray to_image, InputArray to_points, OutputArray dense_flow)\n 1112  {\n 1113      CV_Assert(!from_image.empty());\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/ximgproc/src/edge_drawing.cpp:\n 2199              /* update lower y limit (start) for the new 'column'.\n 2200  \n 2201:             We need to interpolate the y value that corresponds to the\n 2202              lower side of the rectangle. The first thing is to decide if\n 2203              the corresponding side is\n ....\n 2206              vx[3],vy[3] to vx[2],vy[2]\n 2207  \n 2208:             Then, the side is interpolated for the x value of the\n 2209              'column'. But, if the side is vertical (as it could happen if\n 2210              the rectangle is vertical and we are dealing with the first\n ....\n 2245              /* update upper y limit (end) for the new 'column'.\n 2246  \n 2247:             We need to interpolate the y value that corresponds to the\n 2248              upper side of the rectangle. The first thing is to decide if\n 2249              the corresponding side is\n ....\n 2252              vx[1],vy[1] to vx[2],vy[2]\n 2253  \n 2254:             Then, the side is interpolated for the x value of the\n 2255              'column'. But, if the side is vertical (as it could happen if\n 2256              the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/nonrigid_icp.cpp:\n  306                  continue;\n  307  \n  308:             // TODO: interpolate Vg instead of simply converting projected coords to int\n  309              Vg.at<Vec3f>(y, x) = vertImage.at<Vec3f>((int)newCoords.y, (int)newCoords.x);\n  310  \n  311:             // bilinearly interpolate newPoints under newCoords point\n  312              int xi = cvFloor(newCoords.x), yi = cvFloor(newCoords.y);\n  313              float tx  = newCoords.x - xi, ty = newCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.hpp:\n   74      virtual TsdfVoxel at(const Vec3i& volumeIdx) const;\n   75  \n   76:     float interpolateVoxel(const cv::Point3f& p) const;\n   77      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   78  \n   79  #if USE_INTRINSICS\n   80:     float interpolateVoxel(const v_float32x4& p) const;\n   81      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   82  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/hash_tsdf.cpp:\n  126  \n  127  \n  128:     float interpolateVoxelPoint(const Point3f& point) const;\n  129:     float interpolateVoxel(const cv::Point3f& point) const;\n  130      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  131  \n  ...\n  421  \n  422  #if USE_INTRINSICS\n  423: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  424  {\n  425      v_float32x4 v0246, v1357;\n  ...\n  440  \n  441  #else\n  442: inline float interpolate(float tx, float ty, float tz, float vx[8])\n  443  {\n  444      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  454  #endif\n  455  \n  456: float HashTSDFVolumeCPU::interpolateVoxelPoint(const Point3f& point) const\n  457  {\n  458      const Vec3i neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n  ...\n  495      }\n  496  \n  497:     return interpolate(tx, ty, tz, vx);\n  498  }\n  499  \n  500: inline float HashTSDFVolumeCPU::interpolateVoxel(const cv::Point3f& point) const\n  501  {\n  502:     return interpolateVoxelPoint(point * voxelSizeInv);\n  503  }\n  504  \n  ...\n  631      float tz = ptVox.z - iptVox[2];\n  632  \n  633:     normal[0] = interpolate(tx, ty, tz, cxv);\n  634:     normal[1] = interpolate(tx, ty, tz, cyv);\n  635:     normal[2] = interpolate(tx, ty, tz, czv);\n  636  #endif\n  637  \n  ...\n  921  \n  922  \n  923:     float interpolateVoxelPoint(const Point3f& point) const;\n  924:     float interpolateVoxel(const cv::Point3f& point) const;\n  925      Point3f getNormalVoxel(const cv::Point3f& p) const;\n  926  \n  ...\n 1380  }\n 1381  \n 1382: float HashTSDFVolumeGPU::interpolateVoxelPoint(const Point3f& point) const\n 1383  {\n 1384      const Vec3i local_neighbourCoords[] = { {0, 0, 0}, {0, 0, 1}, {0, 1, 0}, {0, 1, 1},\n ....\n 1421      }\n 1422  \n 1423:     return interpolate(tx, ty, tz, vx);\n 1424  }\n 1425  \n 1426: inline float HashTSDFVolumeGPU::interpolateVoxel(const cv::Point3f& point) const\n 1427  {\n 1428:     return interpolateVoxelPoint(point * voxelSizeInv);\n 1429  }\n 1430  \n ....\n 1556      float tz = ptVox.z - iptVox[2];\n 1557  \n 1558:     normal[0] = interpolate(tx, ty, tz, cxv);\n 1559:     normal[1] = interpolate(tx, ty, tz, cyv);\n 1560:     normal[2] = interpolate(tx, ty, tz, czv);\n 1561  #endif\n 1562      float nv = sqrt(normal[0] * normal[0] +\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/fast_icp.cpp:\n  243                      continue;\n  244  \n  245:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  246                  v_float32x4 oldP;\n  247                  v_float32x4 oldN;\n  ...\n  390                      continue;\n  391  \n  392:                 // bilinearly interpolate oldPts and oldNrm under oldCoords point\n  393                  int xi = cvFloor(oldCoords.x), yi = cvFloor(oldCoords.y);\n  394                  float tx  = oldCoords.x - xi, ty = oldCoords.y - yi;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf.cpp:\n  137  #if USE_INTRINSICS\n  138  // all coordinate checks should be done in inclosing cycle\n  139: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  140  {\n  141      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  142:     return interpolateVoxel(p);\n  143  }\n  144  \n  145: inline float TSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  146  {\n  147      // tx, ty, tz = floor(p)\n  ...\n  184  }\n  185  #else\n  186: inline float TSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  187  {\n  188      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  438                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  439                      v_float32x4 next    = (orig + dir * v_setall_f32(tmin));\n  440:                     float f = volume.interpolateVoxel(next), fnext = f;\n  441  \n  442                      //raymarch\n  ...\n  455                          if(fnext != f)\n  456                          {\n  457:                             fnext = volume.interpolateVoxel(next);\n  458  \n  459                              // when ray crosses a surface\n  ...\n  466  \n  467                      // if ray penetrates a surface from outside\n  468:                     // linearly interpolate t between two f values\n  469                      if(f > 0.f && fnext < 0.f)\n  470                      {\n  471                          v_float32x4 tp = next - rayStep;\n  472:                         float ft    = volume.interpolateVoxel(tp);\n  473:                         float ftdt  = volume.interpolateVoxel(next);\n  474                          float ts = tmin + tstep*(steps - ft/(ftdt - ft));\n  475  \n  ...\n  547                      Point3f rayStep = dir * tstep;\n  548                      Point3f next = (orig + dir * tmin);\n  549:                     float f = volume.interpolateVoxel(next), fnext = f;\n  550  \n  551                      //raymarch\n  ...\n  564                          if(fnext != f)\n  565                          {\n  566:                             fnext = volume.interpolateVoxel(next);\n  567                              // when ray crosses a surface\n  568                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  573                      }\n  574                      // if ray penetrates a surface from outside\n  575:                     // linearly interpolate t between two f values\n  576                      if(f > 0.f && fnext < 0.f)\n  577                      {\n  578                          Point3f tp    = next - rayStep;\n  579:                         float ft   = volume.interpolateVoxel(tp);\n  580:                         float ftdt = volume.interpolateVoxel(next);\n  581                          // float t = tmin + steps*tstep;\n  582                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  692                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  693                  {\n  694:                     //linearly interpolate coordinate\n  695                      float Vn    = Vc + vol.voxelSize;\n  696                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/warpfield.cpp:\n  212  \n  213          Affine3f pose = DQB(weights, transforms);\n  214:         // linearly interpolate translations\n  215          Vec3f translation(0,0,0);\n  216          float totalWeight = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/dynafu_tsdf.cpp:\n   48      virtual void reset() override;\n   49  \n   50:     volumeType interpolateVoxel(cv::Point3f p) const;\n   51      Point3f getNormalVoxel(cv::Point3f p) const;\n   52  \n   ..\n   59  \n   60  private:\n   61:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const;\n   62  };\n   63  \n   ..\n  330  }\n  331  \n  332: inline volumeType TSDFVolumeCPU::interpolateVoxel(Point3f p) const\n  333  {\n  334      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  472                      Point3f rayStep = dir * tstep;\n  473                      Point3f next = (orig + dir * tmin);\n  474:                     volumeType f = volume.interpolateVoxel(next), fnext = f;\n  475  \n  476                      //raymarch\n  ...\n  489                          if(fnext != f)\n  490                          {\n  491:                             fnext = volume.interpolateVoxel(next);\n  492  \n  493                              // when ray crosses a surface\n  ...\n  500  \n  501                      // if ray penetrates a surface from outside\n  502:                     // linearly interpolate t between two f values\n  503                      if(f > 0.f && fnext < 0.f)\n  504                      {\n  505                          Point3f tp = next - rayStep;\n  506:                         volumeType ft   = volume.interpolateVoxel(tp);\n  507:                         volumeType ftdt = volume.interpolateVoxel(next);\n  508                          // float t = tmin + steps*tstep;\n  509                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  621                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  622                  {\n  623:                     //linearly interpolate coordinate\n  624                      float Vn = Vc + vol.voxelSize;\n  625                      float dinv = 1.f/(abs(v0)+abs(vd));\n  ...\n  790      }\n  791  \n  792:     Point3f interpolate(Point3f p1, Point3f p2, float v1, float v2) const\n  793      {\n  794          float dV = 0.5f;\n  ...\n  835  \n  836                      if (edgeTable[cubeIndex] & 1)\n  837:                         vertices[0] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[1],\n  838                                                             tsdfValues[0], tsdfValues[1]);\n  839                      if (edgeTable[cubeIndex] & 2)\n  840:                         vertices[1] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[2],\n  841                                                             tsdfValues[1], tsdfValues[2]);\n  842                      if (edgeTable[cubeIndex] & 4)\n  843:                         vertices[2] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[3],\n  844                                                             tsdfValues[2], tsdfValues[3]);\n  845                      if (edgeTable[cubeIndex] & 8)\n  846:                         vertices[3] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[0],\n  847                                                             tsdfValues[3], tsdfValues[0]);\n  848                      if (edgeTable[cubeIndex] & 16)\n  849:                         vertices[4] = basePt + interpolate(mcNeighbourPts[4], mcNeighbourPts[5],\n  850                                                             tsdfValues[4], tsdfValues[5]);\n  851                      if (edgeTable[cubeIndex] & 32)\n  852:                         vertices[5] = basePt + interpolate(mcNeighbourPts[5], mcNeighbourPts[6],\n  853                                                             tsdfValues[5], tsdfValues[6]);\n  854                      if (edgeTable[cubeIndex] & 64)\n  855:                         vertices[6] = basePt + interpolate(mcNeighbourPts[6], mcNeighbourPts[7],\n  856                                                             tsdfValues[6], tsdfValues[7]);\n  857                      if (edgeTable[cubeIndex] & 128)\n  858:                         vertices[7] = basePt + interpolate(mcNeighbourPts[7], mcNeighbourPts[4],\n  859                                                             tsdfValues[7], tsdfValues[4]);\n  860                      if (edgeTable[cubeIndex] & 256)\n  861:                         vertices[8] = basePt + interpolate(mcNeighbourPts[0], mcNeighbourPts[4],\n  862                                                             tsdfValues[0], tsdfValues[4]);\n  863                      if (edgeTable[cubeIndex] & 512)\n  864:                         vertices[9] = basePt + interpolate(mcNeighbourPts[1], mcNeighbourPts[5],\n  865                                                             tsdfValues[1], tsdfValues[5]);\n  866                      if (edgeTable[cubeIndex] & 1024)\n  867:                         vertices[10] = basePt + interpolate(mcNeighbourPts[2], mcNeighbourPts[6],\n  868                                                              tsdfValues[2], tsdfValues[6]);\n  869                      if (edgeTable[cubeIndex] & 2048)\n  870:                         vertices[11] = basePt + interpolate(mcNeighbourPts[3], mcNeighbourPts[7],\n  871                                                              tsdfValues[3], tsdfValues[7]);\n  872  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/tsdf_functions.cpp:\n  249  \n  250                      depthType v;\n  251:                     // bilinearly interpolate depth at projected\n  252                      {\n  253                          const v_float32x4& pt = projected;\n  ...\n  284                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  285                              v_float32x4 ty = v_setall_f32(t.get0());\n  286:                             // vx is y-interpolated between rows 0 and 1\n  287                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  288                              float v0 = vx.get0();\n  ...\n  514  \n  515                      depthType v;\n  516:                     // bilinearly interpolate depth at projected\n  517                      {\n  518                          const v_float32x4& pt = projected;\n  ...\n  549                              t = v_reinterpret_as_f32(v_rotate_right<1>(v_reinterpret_as_u32(t)));\n  550                              v_float32x4 ty = v_setall_f32(t.get0());\n  551:                             // vx is y-interpolated between rows 0 and 1\n  552                              v_float32x4 vx = v001 + ty * (v101 - v001);\n  553                              float v0 = vx.get0();\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/rgbd/src/colored_tsdf.cpp:\n   85      virtual RGBTsdfVoxel at(const Vec3i& volumeIdx) const;\n   86  \n   87:     float interpolateVoxel(const cv::Point3f& p) const;\n   88      Point3f getNormalVoxel(const cv::Point3f& p) const;\n   89:     float interpolateColor(float tx, float ty, float tz, float vx[8]) const;\n   90      Point3f getColorVoxel(const cv::Point3f& p) const;\n   91  \n   92  #if USE_INTRINSICS\n   93:     float interpolateVoxel(const v_float32x4& p) const;\n   94      v_float32x4 getNormalVoxel(const v_float32x4& p) const;\n   95      v_float32x4 getColorVoxel(const v_float32x4& p) const;\n   ..\n  185  #if USE_INTRINSICS\n  186  // all coordinate checks should be done in inclosing cycle\n  187: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& _p) const\n  188  {\n  189      v_float32x4 p(_p.x, _p.y, _p.z, 0);\n  190:     return interpolateVoxel(p);\n  191  }\n  192  \n  193: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const v_float32x4& p) const\n  194  {\n  195      // tx, ty, tz = floor(p)\n  ...\n  232  }\n  233  #else\n  234: inline float ColoredTSDFVolumeCPU::interpolateVoxel(const Point3f& p) const\n  235  {\n  236      int xdim = volDims[0], ydim = volDims[1], zdim = volDims[2];\n  ...\n  384  \n  385  #if USE_INTRINSICS\n  386: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  387  {\n  388      v_float32x4 v0246, v1357;\n  ...\n  402  }\n  403  #else\n  404: inline float ColoredTSDFVolumeCPU::interpolateColor(float tx, float ty, float tz, float vx[8]) const\n  405  {\n  406      float v00 = vx[0] + tz * (vx[1] - vx[0]);\n  ...\n  463      float ty = t.get0(); t = v_rotate_right<1>(t);\n  464      float tz = t.get0();\n  465:     rgb[0] = interpolateColor(tx, ty, tz, r);\n  466:     rgb[1] = interpolateColor(tx, ty, tz, g);\n  467:     rgb[2] = interpolateColor(tx, ty, tz, b);\n  468      rgb[3] = 0.f;\n  469  #else\n  ...\n  512      float tz = ptVox.z - iptVox[2];\n  513  \n  514:     res=Point3f(interpolateColor(tx, ty, tz, r),\n  515:                 interpolateColor(tx, ty, tz, g),\n  516:                 interpolateColor(tx, ty, tz, b));\n  517  #else\n  518      res=Point3f(volData[coordBase].r, volData[coordBase].g, volData[coordBase].b);\n  ...\n  627                      v_float32x4 rayStep = dir * v_setall_f32(tstep);\n  628                      v_float32x4 next = (orig + dir * v_setall_f32(tmin));\n  629:                     float f = volume.interpolateVoxel(next), fnext = f;\n  630  \n  631                      //raymarch\n  ...\n  644                          if (fnext != f)\n  645                          {\n  646:                             fnext = volume.interpolateVoxel(next);\n  647  \n  648                              // when ray crosses a surface\n  ...\n  655  \n  656                      // if ray penetrates a surface from outside\n  657:                     // linearly interpolate t between two f values\n  658                      if (f > 0.f && fnext < 0.f)\n  659                      {\n  660                          v_float32x4 tp = next - rayStep;\n  661:                         float ft = volume.interpolateVoxel(tp);\n  662:                         float ftdt = volume.interpolateVoxel(next);\n  663                          float ts = tmin + tstep * (steps - ft / (ftdt - ft));\n  664  \n  ...\n  740                      Point3f rayStep = dir * tstep;\n  741                      Point3f next = (orig + dir * tmin);\n  742:                     float f = volume.interpolateVoxel(next), fnext = f;\n  743  \n  744                      //raymarch\n  ...\n  757                          if(fnext != f)\n  758                          {\n  759:                             fnext = volume.interpolateVoxel(next);\n  760                              // when ray crosses a surface\n  761                              if(std::signbit(f) != std::signbit(fnext))\n  ...\n  766                      }\n  767                      // if ray penetrates a surface from outside\n  768:                     // linearly interpolate t between two f values\n  769                      if(f > 0.f && fnext < 0.f)\n  770                      {\n  771                          Point3f tp    = next - rayStep;\n  772:                         float ft   = volume.interpolateVoxel(tp);\n  773:                         float ftdt = volume.interpolateVoxel(next);\n  774                          // float t = tmin + steps*tstep;\n  775                          // float ts = t - tstep*ft/(ftdt - ft);\n  ...\n  893                  if((v0 > 0 && vd < 0) || (v0 < 0 && vd > 0))\n  894                  {\n  895:                     //linearly interpolate coordinate\n  896                      float Vn    = Vc + vol.voxelSize;\n  897                      float dinv  = 1.f/(abs(v0)+abs(vd));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapaffine.cpp:\n   80  \n   81      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   82:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   83      // remap will not touch them).\n   84      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapshift.cpp:\n   81  \n   82      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   83:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   84      // remap will not touch them).\n   85      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/reg/src/mapprojec.cpp:\n   83  \n   84      //remap(img1, img2, dest_c, dest_r, INTER_CUBIC, BORDER_REPLICATE);\n   85:     // Parts that cannot be interpolated will be as in img1 (BORDER_TRANSPARENT means that\n   86      // remap will not touch them).\n   87      img1.copyTo(img2);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retina_ocl.cpp:\n 1155      demultiplex(ocl_multiplexed_input, _demultiplexedTempBuffer);\n 1156  \n 1157:     // interpolate the demultiplexed frame depending on the color sampling method\n 1158      if (!adaptiveFiltering)\n 1159      {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.hpp:\n  243          // protected functions\n  244          void _initColorSampling();\n  245:         void _interpolateImageDemultiplexedImage(float *inputOutputBuffer);\n  246:         void _interpolateSingleChannelImage111(float *inputOutputBuffer);\n  247:         void _interpolateBayerRGBchannels(float *inputOutputBuffer);\n  248          void _applyRIFfilter(const float *sourceBuffer, float *destinationBuffer);\n  249          void _getNormalizedContoursImage(const float *inputFrame, float *outputFrame);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/bioinspired/src/retinacolor.cpp:\n  264          _demultiplexedTempBuffer[*(colorSamplingPRT++)]=*(multiplexedColorFramePtr++);\n  265  \n  266:     // interpolate the demultiplexed frame depending on the color sampling method\n  267      if (!adaptiveFiltering)\n  268:         _interpolateImageDemultiplexedImage(&_demultiplexedTempBuffer[0]);\n  269  \n  270      // low pass filtering the demultiplexed frame\n  ...\n  453  }\n  454  \n  455: void RetinaColor::_interpolateImageDemultiplexedImage(float *inputOutputBuffer)\n  456  {\n  457  \n  ...\n  460  \n  461      case RETINA_COLOR_RANDOM:\n  462:         return; // no need to interpolate\n  463          break;\n  464  \n  465      case RETINA_COLOR_DIAGONAL:\n  466:         _interpolateSingleChannelImage111(inputOutputBuffer);\n  467          break;\n  468  \n  469      case RETINA_COLOR_BAYER: // default sets bayer sampling\n  470:         _interpolateBayerRGBchannels(inputOutputBuffer);\n  471          break;\n  472      default:\n  ...\n  479  }\n  480  \n  481: void RetinaColor::_interpolateSingleChannelImage111(float *inputOutputBuffer)\n  482  {\n  483      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows(); ++indexr)\n  ...\n  499  }\n  500  \n  501: void RetinaColor::_interpolateBayerRGBchannels(float *inputOutputBuffer)\n  502  {\n  503      for (unsigned int indexr=0 ; indexr<_filterOutput.getNBrows()-1; indexr+=2)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/tutorial_charuco_create_detect.cpp:\n   59                  std::vector<cv::Point2f> charucoCorners;\n   60                  std::vector<int> charucoIds;\n   61:                 cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);\n   62                  //! [charidcor]\n   63                  // if at least one charuco corner detected\n   ..\n  110              std::vector<cv::Point2f> charucoCorners;\n  111              std::vector<int> charucoIds;\n  112:             cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, image, board, charucoCorners, charucoIds);\n  113              //! [charidcorwc]\n  114              // if at least one charuco corner detected\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/detect_board_charuco.cpp:\n  173                                           camMatrix, distCoeffs);\n  174  \n  175:         // interpolate charuco corners\n  176:         int interpolatedCorners = 0;\n  177          if(markerIds.size() > 0)\n  178:             interpolatedCorners =\n  179:                 aruco::interpolateCornersCharuco(markerCorners, markerIds, image, charucoboard,\n  180                                                   charucoCorners, charucoIds, camMatrix, distCoeffs);\n  181  \n  ...\n  207              aruco::drawDetectedMarkers(imageCopy, rejectedMarkers, noArray(), Scalar(100, 0, 255));\n  208  \n  209:         if(interpolatedCorners > 0) {\n  210              Scalar color;\n  211              color = Scalar(255, 0, 0);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/samples/calibrate_camera_charuco.cpp:\n  178          if(refindStrategy) aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  179  \n  180:         // interpolate charuco corners\n  181          Mat currentCharucoCorners, currentCharucoIds;\n  182          if(ids.size() > 0)\n  183:             aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners,\n  184                                               currentCharucoIds);\n  185  \n  ...\n  248  \n  249      for(int i = 0; i < nFrames; i++) {\n  250:         // interpolate using camera parameters\n  251          Mat currentCharucoCorners, currentCharucoIds;\n  252:         aruco::interpolateCornersCharuco(allCorners[i], allIds[i], allImgs[i], charucoboard,\n  253                                           currentCharucoCorners, currentCharucoIds, cameraMatrix,\n  254                                           distCoeffs);\n  ...\n  280      cout << \"Calibration saved to \" << outputFile << endl;\n  281  \n  282:     // show interpolated charuco corners for debugging\n  283      if(showChessboardCorners) {\n  284          for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/test/test_charucodetection.cpp:\n  256                  }\n  257  \n  258:                 // interpolate charuco corners\n  259                  vector< Point2f > charucoCorners;\n  260                  vector< int > charucoIds;\n  261  \n  262                  if(iter % 2 == 0) {\n  263:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  264                                                       charucoIds);\n  265                  } else {\n  266:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  267                                                       charucoIds, cameraMatrix, distCoeffs);\n  268                  }\n  ...\n  354                  }\n  355  \n  356:                 // interpolate charuco corners\n  357                  vector< Point2f > charucoCorners;\n  358                  vector< int > charucoIds;\n  359  \n  360                  if(iter % 2 == 0) {\n  361:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  362                                                       charucoIds);\n  363                  } else {\n  364:                     aruco::interpolateCornersCharuco(corners, ids, img, board, charucoCorners,\n  365                                                       charucoIds, cameraMatrix, distCoeffs);\n  366                  }\n  ...\n  719  \n  720      cv::Mat c_ids, c_corners;\n  721:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids, K);\n  722      cv::Mat corners_reshaped = c_corners.reshape(1);\n  723  \n  ...\n  727      c_ids = cv::Mat();\n  728      c_corners = cv::Mat();\n  729:     cv::aruco::interpolateCornersCharuco(corners, ids, gray, board, c_corners, c_ids);\n  730      corners_reshaped = c_corners.reshape(1);\n  731  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco.hpp:\n  434   *\n  435   * This function tries to find markers that were not detected in the basic detecMarkers function.\n  436:  * First, based on the current detected marker and the board layout, the function interpolates\n  437   * the position of the missing markers. Then it tries to find correspondence between the reprojected\n  438   * markers and the rejected candidates based on the minRepDistance and errorCorrectionRate\n  439   * parameters.\n  440   * If camera parameters and distortion coefficients are provided, missing markers are reprojected\n  441:  * using projectPoint function. If not, missing marker projections are interpolated using global\n  442   * homography, and all the marker corners in the board must have the same Z coordinate.\n  443   */\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/include/opencv2/aruco/charuco.hpp:\n  141   * should be sent in corners and ids parameters.\n  142   * @param board layout of ChArUco board.\n  143:  * @param charucoCorners interpolated chessboard corners\n  144:  * @param charucoIds interpolated chessboard corners identifiers\n  145   * @param cameraMatrix optional 3x3 floating-point camera matrix\n  146   * \\f$A = \\vecthreethree{f_x}{0}{c_x}{0}{f_y}{c_y}{0}{0}{1}\\f$\n  ...\n  154   * Only visible corners are returned. For each corner, its corresponding identifier is\n  155   * also returned in charucoIds.\n  156:  * The function returns the number of interpolated corners.\n  157   */\n  158: CV_EXPORTS_W int interpolateCornersCharuco(InputArrayOfArrays markerCorners, InputArray markerIds,\n  159                                             InputArray image, const Ptr<CharucoBoard> &board,\n  160                                             OutputArray charucoCorners, OutputArray charucoIds,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/aruco.cpp:\n  749   * @param nContours, contour-container\n  750   */\n  751: static Point3f _interpolate2Dline(const std::vector<cv::Point2f>& nContours){\n  752  \tfloat minX, minY, maxX, maxY;\n  753  \tminX = maxX = nContours[0].x;\n  ...\n  864  \tPoint3f lines[4];\n  865  \tfor(int i=0; i<4; i++){\n  866: \t\tlines[i]=_interpolate2Dline(cntPts[i]);\n  867  \t}\n  868  \n  ...\n 1723          }\n 1724  \n 1725:         // interpolate tiny marker to marker position in markerZone\n 1726          inCorners[0] = Point2f(-0.5f, -0.5f);\n 1727          inCorners[1] = Point2f(marker.cols - 0.5f, -0.5f);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/aruco/src/charuco.cpp:\n  394    * Interpolate charuco corners using approximated pose estimation\n  395    */\n  396: static int _interpolateCornersCharucoApproxCalib(InputArrayOfArrays _markerCorners,\n  397                                                   InputArray _markerIds, InputArray _image,\n  398                                                   const Ptr<CharucoBoard> &_board,\n  ...\n  438    * Interpolate charuco corners using local homography\n  439    */\n  440: static int _interpolateCornersCharucoLocalHom(InputArrayOfArrays _markerCorners,\n  441                                                InputArray _markerIds, InputArray _image,\n  442                                                const Ptr<CharucoBoard> &_board,\n  ...\n  482          Point2f objPoint2D = Point2f(_board->chessboardCorners[i].x, _board->chessboardCorners[i].y);\n  483  \n  484:         vector< Point2f > interpolatedPositions;\n  485          for(unsigned int j = 0; j < _board->nearestMarkerIdx[i].size(); j++) {\n  486              int markerId = _board->ids[_board->nearestMarkerIdx[i][j]];\n  ...\n  498                  in.push_back(objPoint2D);\n  499                  perspectiveTransform(in, out, transformations[markerIdx]);\n  500:                 interpolatedPositions.push_back(out[0]);\n  501              }\n  502          }\n  503  \n  504          // none of the closest markers detected\n  505:         if(interpolatedPositions.size() == 0) continue;\n  506  \n  507          // more than one closest marker detected, take middle point\n  508:         if(interpolatedPositions.size() > 1) {\n  509:             allChessboardImgPoints[i] = (interpolatedPositions[0] + interpolatedPositions[1]) / 2.;\n  510          }\n  511          // a single closest marker detected\n  512:         else allChessboardImgPoints[i] = interpolatedPositions[0];\n  513      }\n  514  \n  ...\n  529  /**\n  530    */\n  531: int interpolateCornersCharuco(InputArrayOfArrays _markerCorners, InputArray _markerIds,\n  532                                InputArray _image, const Ptr<CharucoBoard> &_board,\n  533                                OutputArray _charucoCorners, OutputArray _charucoIds,\n  ...\n  536      // if camera parameters are avaible, use approximated calibration\n  537      if(_cameraMatrix.total() != 0) {\n  538:         _interpolateCornersCharucoApproxCalib(_markerCorners, _markerIds, _image, _board,\n  539                                                       _cameraMatrix, _distCoeffs, _charucoCorners,\n  540                                                       _charucoIds);\n  ...\n  542      // else use local homography\n  543      else {\n  544:         _interpolateCornersCharucoLocalHom(_markerCorners, _markerIds, _image, _board,\n  545                                                    _charucoCorners, _charucoIds);\n  546      }\n  ...\n  791              }\n  792  \n  793:             // interpolate the charuco corners of the diamond\n  794              vector< Point2f > currentMarkerCorners;\n  795              Mat aux;\n  796:             interpolateCornersCharuco(currentMarker, currentMarkerId, grey, _charucoDiamondLayout,\n  797                                        currentMarkerCorners, aux, _cameraMatrix, _distCoeffs);\n  798  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/include/opencv2/viz/widgets.hpp:\n  665              @param radius Radius of the spheres.\n  666              @param from Color for first sphere.\n  667:             @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  668               */\n  669              WTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/viz/misc/python/python_viz.hpp:\n  841      @param radius Radius of the spheres.\n  842      @param from Color for first sphere.\n  843:     @param to Color for last sphere. Intermediate spheres will have interpolated color.\n  844       */\n  845      CV_WRAP PyWTrajectorySpheres(InputArray path, double line_length = 0.05, double radius = 0.007,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy.hpp:\n  219  @param newFrame Output image.\n  220  @param buf Temporary buffer, will have width x 6\\*height size, CV_32FC1 type and contain 6\n  221: GpuMat: occlusion masks for first frame, occlusion masks for second, interpolated forward\n  222: horizontal flow, interpolated forward vertical flow, interpolated backward horizontal flow,\n  223: interpolated backward vertical flow.\n  224  @param stream Stream for the asynchronous version.\n  225   */\n  226: CV_EXPORTS void interpolateFrames(const GpuMat& frame0, const GpuMat& frame1,\n  227                                    const GpuMat& fu, const GpuMat& fv,\n  228                                    const GpuMat& bu, const GpuMat& bv,\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/include/opencv2/cudalegacy/NCVPyramid.hpp:\n   56      {\n   57          CV_EXPORTS void downsampleX2(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   58:         CV_EXPORTS void interpolateFrom1(PtrStepSzb src, PtrStepSzb dst, int depth, int cn, cudaStream_t stream);\n   59      }\n   60  }}}\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/image_pyramid.cpp:\n  136          }\n  137  \n  138:         cv::cuda::device::pyramid::interpolateFrom1(lastLayer, outImg, outImg.depth(), outImg.channels(), StreamAccessor::getStream(stream));\n  139      }\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudalegacy/src/interpolate_frames.cpp:\n   48  #if !defined (HAVE_CUDA) || !defined (HAVE_OPENCV_CUDALEGACY) || defined (CUDA_DISABLER)\n   49  \n   50: void cv::cuda::interpolateFrames(const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, const GpuMat&, float, GpuMat&, GpuMat&, Stream&) { throw_no_cuda(); }\n   51  \n   52  #else\n   53  \n   54: void cv::cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv,\n   55                                  float pos, GpuMat& newFrame, GpuMat& buf, Stream& s)\n   56  {\n   ..\n   71      GpuMat occ1 = buf.rowRange(1 * frame0.rows, 2 * frame0.rows);\n   72  \n   73:     // interpolated forward flow\n   74      GpuMat fui = buf.rowRange(2 * frame0.rows, 3 * frame0.rows);\n   75      GpuMat fvi = buf.rowRange(3 * frame0.rows, 4 * frame0.rows);\n   76  \n   77:     // interpolated backward flow\n   78      GpuMat bui = buf.rowRange(4 * frame0.rows, 5 * frame0.rows);\n   79      GpuMat bvi = buf.rowRange(5 * frame0.rows, 6 * frame0.rows);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/face/src/lbph_faces.cpp:\n  241          for(int i=radius; i < src.rows-radius;i++) {\n  242              for(int j=radius;j < src.cols-radius;j++) {\n  243:                 // calculate interpolated value\n  244                  float t = static_cast<float>(w1*src.at<_Tp>(i+fy,j+fx) + w2*src.at<_Tp>(i+fy,j+cx) + w3*src.at<_Tp>(i+cy,j+fx) + w4*src.at<_Tp>(i+cy,j+cx));\n  245                  // floating point precision, so check some machine-dependent epsilon\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/column_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv_contrib/modules/cudafilters/src/cuda/row_filter.hpp:\n   44  #include \"opencv2/core/cuda/saturate_cast.hpp\"\n   45  #include \"opencv2/core/cuda/vec_math.hpp\"\n   46: #include \"opencv2/core/cuda/border_interpolate.hpp\"\n   47  \n   48  using namespace cv::cuda;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n295 matches across 73 files\n\n\nSearching 5629 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libpng/png.c:\n 3720     lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;\n 3721  \n 3722:    /* Now we need to interpolate the factor, this requires a division by the top\n 3723      * 8 bits.  Do this with maximum precision.\n 3724      */\n ....\n 3727     /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,\n 3728      * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly\n 3729:     * 16 bits to interpolate to get the low bits of the result.  Round the\n 3730      * answer.  Note that the end point values are scaled by 64 to retain overall\n 3731      * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling.c:\n   28  //  [a b]\n   29  //  [c d]\n   30: // we interpolate u/v as:\n   31  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n   32  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/dsp/upsampling_mips_dsp_r2.c:\n  136  //  [a b]\n  137  //  [c d]\n  138: // we interpolate u/v as:\n  139  //  ([9*a + 3*b + 3*c +   d    3*a + 9*b + 3*c +   d] + [8 8]) / 16\n  140  //  ([3*a +   b + 9*c + 3*d      a + 3*b + 3*c + 9*d]   [8 8]) / 16\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_rescale_enc.c:\n  248        return 0;\n  249      }\n  250:     // In order to correctly interpolate colors, we need to apply the alpha\n  251      // weighting first (black-matting), scale the RGB values, and remove\n  252      // the premultiplication afterward (while preserving the alpha channel).\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/quant_enc.c:\n  346    const double exp_max = 0.9;\n  347    const double slope = (exp_min - exp_max) / (amax - amin);\n  348:   // Linearly interpolate 'expn' from exp_min to exp_max\n  349    // in the [amin, amax] range.\n  350    const double expn = (alpha > amax) ? exp_min\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/libwebp/src/enc/picture_csp_enc.c:\n  116    const int v0 = kLinearToGammaTab[tab_pos];\n  117    const int v1 = kLinearToGammaTab[tab_pos + 1];\n  118:   const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   // interpolate\n  119    assert(tab_pos + 1 < kGammaTabSize + 1);\n  120    return y;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/3rdparty/openexr/Imath/ImathQuat.h:\n  500      // Assumes q1 and q2 are normalized and that q1 != -q2.\n  501      //\n  502:     // This method does *not* interpolate along the shortest\n  503      // arc between q1 and q2.  If you desire interpolation\n  504      // along the shortest arc, and q1^q2 is negative, then\n  ...\n  507      //\n  508      // The implementation of squad() depends on a slerp()\n  509:     // that interpolates as is, without the automatic\n  510      // flipping.\n  511      //\n  ...\n  564      // for q1 and the qb represents the out-tangent for q2.\n  565      // \n  566:     // The q1 q2 is the cubic segment being interpolated. \n  567      // The q0 is from the previous adjacent segment and q3 is \n  568      // from the next adjacent segment. The q0 and q3 are used\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/samples/cpp/tutorial_code/imgcodecs/GDAL_IO/gdal-image.cpp:\n  100      }\n  101  \n  102:     // interpolate the color\n  103      return lerp( color_range[idx].first, color_range[idx+1].first, t);\n  104  }\n  ...\n  136      cv::Point2d leftSide  = lerp(tl, bl, ry);\n  137  \n  138:     // compute the actual Lat/Lon coordinate of the interpolated coordinate\n  139      return lerp( leftSide, rightSide, rx );\n  140  }\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/features2d/src/brisk.cpp:\n  228  \n  229  private:\n  230:   // access gray values (smoothed/interpolated)\n  231    inline int\n  232    value(const cv::Mat& mat, float xf, float yf, float scale) const;\n  ...\n  278    refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;\n  279  \n  280:   // interpolated score access with recalculation when needed:\n  281    inline int\n  282    getScoreAbove(const int layer, const int x_layer, const int y_layer) const;\n  ...\n  538      const uchar* ptr = &image.at<uchar>(y, x);\n  539      size_t step = image.step;\n  540:     // just interpolate:\n  541      ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +\n  542                r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];\n  ...\n 1045  }\n 1046  \n 1047: // interpolated score access with recalculation when needed:\n 1048  inline int\n 1049  BriskScaleSpace::getScoreAbove(const int layer, const int x_layer, const int y_layer) const\n ....\n 1388      if (scale > 1.0)\n 1389      {\n 1390:       // interpolate the position:\n 1391        const float r0 = (1.5f - scale) / .5f;\n 1392        const float r1 = 1.0f - r0;\n ....\n 1398        if (layer == 0)\n 1399        {\n 1400:         // interpolate the position:\n 1401          const float r0 = (scale - 0.5f) / 0.5f;\n 1402          const float r_1 = 1.0f - r0;\n ....\n 1406        else\n 1407        {\n 1408:         // interpolate the position:\n 1409          const float r0 = (scale - 0.75f) / 0.25f;\n 1410          const float r_1 = 1.0f - r0;\n ....\n 1441      if (scale > 1.0)\n 1442      {\n 1443:       // interpolate the position:\n 1444        const float r0 = 4.0f - scale * 3.0f;\n 1445        const float r1 = 1.0f - r0;\n ....\n 1449      else\n 1450      {\n 1451:       // interpolate the position:\n 1452        const float r0 = scale * 3.0f - 2.0f;\n 1453        const float r_1 = 1.0f - r0;\n ....\n 2240  }\n 2241  \n 2242: // access gray values (smoothed/interpolated)\n 2243  inline int\n 2244  BriskLayer::value(const cv::Mat& mat, float xf, float yf, float scale_in) const\n ....\n 2264      const int r_y_1 = (1024 - r_y);\n 2265      const uchar* ptr = image.ptr() + x + y * imagecols;\n 2266:     // just interpolate:\n 2267      ret_val = (r_x_1 * r_y_1 * int(*ptr));\n 2268      ptr++;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/dualquaternion.hpp:\n  131   * To extract the instance of Affine3, see toAffine3();\n  132   *\n  133:  * If two quaternions \\f$q_0, q_1\\f$ are needed to be interpolated, you can use sclerp()\n  134   * ```\n  135   * DualQuatd::sclerp(q0, q1, t)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/core/include/opencv2/core/quaternion.hpp:\n  189   * To extract the rotation vector, see toRotVec()\n  190   *\n  191:  * If there are two quaternions \\f$q_0, q_1\\f$ are needed to interpolate, you can use nlerp(), slerp() or spline()\n  192   * ```\n  193   * Quatd::nlerp(q0, q1, t)\n  ...\n 1076       * For two quaternions, this interpolation curve can be displayed as:\n 1077       * \\f[Lerp(q_0, q_1, t) = (1 - t)q_0 + tq_1.\\f]\n 1078:      * Obviously, the lerp will interpolate along a straight line if we think of \\f$q_0\\f$ and \\f$q_1\\f$ as a vector\n 1079       * in a two-dimensional space. When \\f$t = 0\\f$, it returns \\f$q_0\\f$ and when \\f$t= 1\\f$, it returns \\f$q_1\\f$.\n 1080       * \\f$t\\f$ should to be ranged in \\f$[0, 1]\\f$ normally.\n ....\n 1135       * @param assumeUnit if QUAT_ASSUME_UNIT, all input quaternions assume to be unit quaternion. Otherwise, all input\n 1136       * quaternions will be normalized inside the function.\n 1137:      * @param directChange if QUAT_ASSUME_UNIT, squad will find the nearest path to interpolate.\n 1138       * @sa interPoint, spline\n 1139       */\n ....\n 1172       * For example:\n 1173       *\n 1174:      * If there are three double quaternions \\f$v_0, v_1, v_2\\f$ waiting to be interpolated.\n 1175       *\n 1176       * Interpolation between \\f$v_0\\f$ and \\f$v_1\\f$ with a ratio \\f$t_0\\f$ could be calculated as\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/dnn/src/layers/resize_layer.cpp:\n   14  #include \"../ie_ngraph.hpp\"\n   15  #if INF_ENGINE_VER_MAJOR_GT(INF_ENGINE_RELEASE_2020_4)\n   16: #include <ngraph/op/interpolate.hpp>\n   17  #else\n   18: #include <ngraph/op/experimental/layers/interpolate.hpp>\n   19  #endif\n   20  #endif\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/gapi/include/opencv2/gapi/imgproc.hpp:\n  537  \n  538  The function applies an arbitrary linear filter to an image. When\n  539: the aperture is partially outside the image, the function interpolates outlier pixel values\n  540  according to the specified border mode.\n  541  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/video/src/dis_flow.cpp:\n  520      v_expand(I0_row_8, I0_row_4_left, I0_row_4_right);                                                                 \\\n  521                                                                                                                         \\\n  522:     /* Compute diffs between I0 and bilinearly interpolated I1: */                                                     \\\n  523      I_diff_left = w00v * v_cvt_f32(v_reinterpret_as_s32(I1_row_4_left)) +                                              \\\n  524                    w01v * v_cvt_f32(v_reinterpret_as_s32(I1_row_shifted_4_left)) +                                      \\\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/test/test_imgwarp_strict.cpp:\n  371  namespace\n  372  {\n  373:     void interpolateLinear(float x, float* coeffs)\n  374      {\n  375          coeffs[0] = 1.f - x;\n  ...\n  377      }\n  378  \n  379:     void interpolateCubic(float x, float* coeffs)\n  380      {\n  381          const float A = -0.75f;\n  ...\n  387      }\n  388  \n  389:     void interpolateLanczos4(float x, float* coeffs)\n  390      {\n  391          static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  415      }\n  416  \n  417:     typedef void (*interpolate_method)(float x, float* coeffs);\n  418:     interpolate_method inter_array[] = { &interpolateLinear, &interpolateCubic, &interpolateLanczos4 };\n  419  }\n  420  \n  ...\n  600      else if (interpolation == INTER_LINEAR || interpolation == INTER_LINEAR_EXACT || interpolation == INTER_CUBIC || interpolation == INTER_LANCZOS4)\n  601      {\n  602:         interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : interpolation == INTER_LINEAR_EXACT ? 5 : 1)];\n  603          size_t elemsize = _src.elemSize();\n  604  \n  ...\n  945  \n  946      float ix[8], w[16];\n  947:     interpolate_method inter_func = inter_array[interpolation - (interpolation == INTER_LANCZOS4 ? 2 : 1)];\n  948  \n  949      for (int dy = 0; dy < dsize.height; ++dy)\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/include/opencv2/imgproc.hpp:\n  118  where a polynomial function is fit into some neighborhood of the computed pixel \\f$(f_x(x,y),\n  119  f_y(x,y))\\f$, and then the value of the polynomial at \\f$(f_x(x,y), f_y(x,y))\\f$ is taken as the\n  120: interpolated pixel value. In OpenCV, you can choose between several interpolation methods. See\n  121  resize for details.\n  122  \n  ...\n 1620  \n 1621  The function applies an arbitrary linear filter to an image. In-place operation is supported. When\n 1622: the aperture is partially outside the image, the function interpolates outlier pixel values\n 1623  according to the specified border mode.\n 1624  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/demosaicing.cpp:\n 1476                  v_float32x4 ngf1 = _0_5 / v_cvt_s16f32_hi(ng);\n 1477  \n 1478:                 // now interpolate r, g & b\n 1479                  t0 = v_reinterpret_as_u16(v_reinterpret_as_s16(GRs) - v_reinterpret_as_s16(RGs));\n 1480                  t1 = v_reinterpret_as_u16(v_reinterpret_as_s16(Bs) -  v_reinterpret_as_s16(RGs));\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.hpp:\n   65  {\n   66  #if CV_TRY_SSE4_1\n   67: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width);\n   68  void convertMaps_32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, ushort* dst2, int width);\n   69  void convertMaps_32f2c16s_SSE41(const float* src1f, short* dst1, ushort* dst2, int width);\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.cpp:\n  144  static short Lanczos4Tab_i[INTER_TAB_SIZE2][8][8];\n  145  \n  146: static inline void interpolateLinear( float x, float* coeffs )\n  147  {\n  148      coeffs[0] = 1.f - x;\n  ...\n  150  }\n  151  \n  152: static inline void interpolateCubic( float x, float* coeffs )\n  153  {\n  154      const float A = -0.75f;\n  ...\n  160  }\n  161  \n  162: static inline void interpolateLanczos4( float x, float* coeffs )\n  163  {\n  164      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n  194      {\n  195          for( int i = 0; i < tabsz; i++, tab += 2 )\n  196:             interpolateLinear( i*scale, tab );\n  197      }\n  198      else if( method == INTER_CUBIC )\n  199      {\n  200          for( int i = 0; i < tabsz; i++, tab += 4 )\n  201:             interpolateCubic( i*scale, tab );\n  202      }\n  203      else if( method == INTER_LANCZOS4 )\n  204      {\n  205          for( int i = 0; i < tabsz; i++, tab += 8 )\n  206:             interpolateLanczos4( i*scale, tab );\n  207      }\n  208      else\n  ...\n 1826  void cv::convertMaps( InputArray _map1, InputArray _map2,\n 1827                        OutputArray _dstmap1, OutputArray _dstmap2,\n 1828:                       int dstm1type, bool nninterpolate )\n 1829  {\n 1830      CV_INSTRUMENT_REGION();\n ....\n 1835      int m1type = m1->type(), m2type = m2->type();\n 1836  \n 1837:     CV_Assert( (m1type == CV_16SC2 && (nninterpolate || m2type == CV_16UC1 || m2type == CV_16SC1)) ||\n 1838:                (m2type == CV_16SC2 && (nninterpolate || m1type == CV_16UC1 || m1type == CV_16SC1)) ||\n 1839                 (m1type == CV_32FC1 && m2type == CV_32FC1) ||\n 1840                 (m1type == CV_32FC2 && m2->empty()) );\n ....\n 1852      dstmap1 = _dstmap1.getMat();\n 1853  \n 1854:     if( !nninterpolate && dstm1type != CV_32FC2 )\n 1855      {\n 1856          _dstmap2.create( size, dstm1type == CV_16SC2 ? CV_16UC1 : CV_32FC1 );\n ....\n 1860          _dstmap2.release();\n 1861  \n 1862:     if( m1type == dstm1type || (nninterpolate &&\n 1863          ((m1type == CV_16SC2 && dstm1type == CV_32FC2) ||\n 1864          (m1type == CV_32FC2 && dstm1type == CV_16SC2))) )\n ....\n 1912          if( m1type == CV_32FC1 && dstm1type == CV_16SC2 )\n 1913          {\n 1914:             if( nninterpolate )\n 1915              {\n 1916                  #if CV_TRY_SSE4_1\n 1917                  if (useSSE4_1)\n 1918:                     opt_SSE4_1::convertMaps_nninterpolate32f1c16s_SSE41(src1f, src2f, dst1, size.width);\n 1919                  else\n 1920                  #endif\n ....\n 1986          else if( m1type == CV_32FC2 && dstm1type == CV_16SC2 )\n 1987          {\n 1988:             if( nninterpolate )\n 1989              {\n 1990                  #if CV_SIMD128\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/color_lab.cpp:\n   47  \n   48  \n   49: // interpolates value of a function at x, 0 <= x <= n using a cubic spline.\n   50  template<typename _Tp> static inline _Tp splineInterpolate(_Tp x, const _Tp* tab, int n)\n   51  {\n   ..\n 1383      v_uint16x8 fracZ = (inZ >> (lab_base_shift - 8 - 1)) & bitMaskReg;\n 1384  \n 1385:     //load values to interpolate for pix0, pix1, .., pix7\n 1386      v_int16x8 a0, a1, a2, a3, a4, a5, a6, a7;\n 1387      v_int16x8 b0, b1, b2, b3, b4, b5, b6, b7;\n ....\n 3247  };\n 3248  \n 3249: struct RGB2Luvinterpolate\n 3250  {\n 3251      typedef uchar channel_type;\n 3252  \n 3253:     RGB2Luvinterpolate( int _srccn, int _blueIdx, const float* /* _coeffs */,\n 3254                          const float* /* _whitept */, bool /*_srgb*/ )\n 3255      : srccn(_srccn), blueIdx(_blueIdx)\n ....\n 3521      int srccn;\n 3522      RGB2Luvfloat fcvt;\n 3523:     RGB2Luvinterpolate icvt;\n 3524  \n 3525      bool useInterpolation;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/imgwarp.sse4_1.cpp:\n   56  {\n   57  \n   58: void convertMaps_nninterpolate32f1c16s_SSE41(const float* src1f, const float* src2f, short* dst1, int width)\n   59  {\n   60      int x = 0;\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/resize.cpp:\n  906  const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;\n  907  \n  908: static inline void interpolateCubic( float x, float* coeffs )\n  909  {\n  910      const float A = -0.75f;\n  ...\n  916  }\n  917  \n  918: static inline void interpolateLanczos4( float x, float* coeffs )\n  919  {\n  920      static const double s45 = 0.70710678118654752440084436210485;\n  ...\n 3972  \n 3973          if( interpolation == INTER_CUBIC )\n 3974:             interpolateCubic( fx, cbuf );\n 3975          else if( interpolation == INTER_LANCZOS4 )\n 3976:             interpolateLanczos4( fx, cbuf );\n 3977          else\n 3978          {\n ....\n 4013          yofs[dy] = sy;\n 4014          if( interpolation == INTER_CUBIC )\n 4015:             interpolateCubic( fy, cbuf );\n 4016          else if( interpolation == INTER_LANCZOS4 )\n 4017:             interpolateLanczos4( fy, cbuf );\n 4018          else\n 4019          {\n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/modules/imgproc/src/colormap.cpp:\n   81      Mat X = sortMatrixRowsByIndices(X_,sort_indices);\n   82      Mat Y = sortMatrixRowsByIndices(Y_,sort_indices);\n   83:     // interpolated values\n   84      Mat yi = Mat::zeros(XI.size(), XI.type());\n   85      for(int i = 0; i < n; i++) {\n   ..\n  149          void operator()(InputArray src, OutputArray dst) const;\n  150  \n  151:         // Setup base map to interpolate from.\n  152          //not used: virtual void init(int n) = 0;\n  153  \n\n/home/roman/Projects/plot-cv/qjs-opencv/opencv/apps/interactive-calibration/frameProcessor.cpp:\n   84      cv::Mat currentCharucoCorners, currentCharucoIds;\n   85      if(ids.size() > 0)\n   86:         cv::aruco::interpolateCornersCharuco(corners, ids, frame, mCharucoBoard, currentCharucoCorners,\n   87                                           currentCharucoIds);\n   88      if(ids.size() > 0) cv::aruco::drawDetectedMarkers(frame, corners);\n\n91 matches across 28 files\n\n\nSearching 2153 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n16 matches across 4 files\n\n\nSearching 3423 files for \"interpolate\" (regex, case sensitive)\n\n/home/roman/Projects/plot-cv/libs.js:\n 6803    Point[name] = (point, ...args) => Point.prototype[name].call(Point(point), ...args);\n 6804  }\n 6805: Point.interpolate = (p1, p2, a) => {\n 6806    a = Util.clamp(0, 1, a);\n 6807    return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\n ....\n 7619  \n 7620  Line.prototype.pointAt = function(pos) {\n 7621:   return Point.interpolate(...this.toPoints(), pos);\n 7622  \n 7623    //return new Point(pos * (this.x2 - this.x1) + this.x1, pos * (this.y2 - this.y1) + this.y1);\n\n/home/roman/Projects/plot-cv/opencv/calibrate_camera_charuco.cpp:\n  241        cv::aruco::refineDetectedMarkers(image, board, corners, ids, rejected);\n  242  \n  243:     // interpolate charuco corners\n  244      cv::Mat currentCharucoCorners, currentCharucoIds;\n  245      if(ids.size() > 0)\n  246:       cv::aruco::interpolateCornersCharuco(corners, ids, image, charucoboard, currentCharucoCorners, currentCharucoIds);\n  247  \n  248      // draw results\n  ...\n  324  \n  325    for(int i = 0; i < nFrames; i++) {\n  326:     // interpolate using camera parameters\n  327      cv::Mat currentCharucoCorners, currentCharucoIds;\n  328:     cv::aruco::interpolateCornersCharuco(\n  329          allCorners[i], allIds[i], allImgs[i], charucoboard, currentCharucoCorners, currentCharucoIds, cameraMatrix, distCoeffs);\n  330  \n  ...\n  353    cout << \"Calibration saved to \" << outputFile << endl;\n  354  \n  355:   // show interpolated charuco corners for debugging\n  356    if(showChessboardCorners) {\n  357      for(unsigned int frame = 0; frame < filteredImages.size(); frame++) {\n\n/home/roman/Projects/plot-cv/src/stb_image.h:\n 2032  //        - allows good upsampling (see next)\n 2033  //    high-quality\n 2034: //      - upsampled channels are bilinearly interpolated, even across blocks\n 2035  //      - quality integer IDCT derived from IJG's 'slow'\n 2036  //    performance\n\n/home/roman/Projects/plot-cv/lib/geom/splinePoints.js:\n   10  }\n   11  \n   12: function interpolate(p0, p1, p2, p3, t) {\n   13    let v0 = (p2 - p0) * 0.5;\n   14    let v1 = (p3 - p1) * 0.5;\n   ..\n   47      let step = 1 / numSteps;\n   48      for(let t = 0; t < 1; t += step) {\n   49:       let x = interpolate(points[c0][0], points[c1][0], points[c2][0], points[c3][0], t);\n   50:       let y = interpolate(points[c0][1], points[c1][1], points[c2][1], points[c3][1], t);\n   51:       let z = interpolate(points[c0][2], points[c1][2], points[c2][2], points[c3][2], t);\n   52        subpoints.push([x, y, z]);\n   53      }\n\n/home/roman/Projects/plot-cv/lib/geom/line.js:\n  258  \n  259  Line.prototype.pointAt = function(pos) {\n  260:   return Point.interpolate(...this.toPoints(), pos);\n  261  \n  262    //return new Point(pos * (this.x2 - this.x1) + this.x1, pos * (this.y2 - this.y1) + this.y1);\n\n/home/roman/Projects/plot-cv/lib/geom/point.js:\n  339    Point[name] = (point, ...args) => Point.prototype[name].call(Point(point), ...args);\n  340  }\n  341: Point.interpolate = (p1, p2, a) => {\n  342    a = Util.clamp(0, 1, a);\n  343    return new Point(p1.x * (1.0 - a) + p2.x * a, p1.y * (1.0 - a) + p2.y * a);\n\n/home/roman/Projects/plot-cv/qjs-opencv/psimpl.hpp:\n  281      \\param[in] fraction     the fraction used during interpolation\n  282      \\param[in] result       the interpolation result (p1 + fraction * (p2 - p1))\n  283:     \\return                 one beyond the last coordinate of the interpolated\n  284     point\n  285  */\n  286  template<unsigned DIM, class InputIterator, class OutputIterator>\n  287  inline OutputIterator\n  288: interpolate(InputIterator p1, InputIterator p2, float fraction, OutputIterator result) {\n  289    typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n  290  \n  ...\n  344  \n  345    value_type proj[DIM]; // p projected onto line (l1, l2)\n  346:   interpolate<DIM>(l1, l2, fraction, proj);\n  347  \n  348    return point_distance2<DIM>(p, proj);\n  ...\n  385  \n  386    value_type proj[DIM]; // p projected onto segement (s1, s2)\n  387:   interpolate<DIM>(s1, s2, fraction, proj);\n  388  \n  389    return point_distance2<DIM>(p, proj);\n  ...\n  421  \n  422    value_type proj[DIM]; // p projected onto ray (r1, r2)\n  423:   interpolate<DIM>(r1, r2, fraction, proj);\n  424  \n  425    return point_distance2<DIM>(p, proj);\n\n/home/roman/Projects/plot-cv/qjs-opencv/lsd/src/lsd.cpp:\n  602      centered on the coordinates of the required sample. In this way,\n  603      when applied, it gives directly the result of convolving the image\n  604:     with the kernel and interpolated to that particular position.\n  605  \n  606      A fast algorithm is done using the separability of the Gaussian\n  ...\n 1366      /* update lower y limit (start) for the new 'column'.\n 1367  \n 1368:        We need to interpolate the y value that corresponds to the\n 1369         lower side of the rectangle. The first thing is to decide if\n 1370         the corresponding side is\n ....\n 1373           vx[3],vy[3] to vx[2],vy[2]\n 1374  \n 1375:        Then, the side is interpolated for the x value of the\n 1376         'column'. But, if the side is vertical (as it could happen if\n 1377         the rectangle is vertical and we are dealing with the first\n ....\n 1386      /* update upper y limit (end) for the new 'column'.\n 1387  \n 1388:        We need to interpolate the y value that corresponds to the\n 1389         upper side of the rectangle. The first thing is to decide if\n 1390         the corresponding side is\n ....\n 1393           vx[1],vy[1] to vx[2],vy[2]\n 1394  \n 1395:        Then, the side is interpolated for the x value of the\n 1396         'column'. But, if the side is vertical (as it could happen if\n 1397         the rectangle is vertical and we are dealing with the first\n\n/home/roman/Projects/plot-cv/inst/x86_64-linux-xenial/usr/local/bin/wscli.js:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/inst/x86_64-linux-xenial/usr/local/bin/list-exports.js:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/inst/x86_64-linux-xenial/usr/local/bin/resolve-imports.js:\n    ERROR: Unable to open file\n\n/home/roman/Projects/plot-cv/inst/x86_64-linux-xenial/usr/local/bin/extract-structs.js:\n    ERROR: Unable to open file\n\n24 matches across 8 files\n",
			"settings":
			{
				"buffer_size": 959616,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "libs.js",
			"settings":
			{
				"buffer_size": 309340,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "127.0.0.1.har",
			"settings":
			{
				"buffer_size": 3835935,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"out",
				"Browse Mode: Outline (Right)"
			],
			[
				"prettier",
				"Formatter: Beautify With Prettier"
			],
			[
				"json",
				"Pretty JSON: Format JSON"
			],
			[
				"list pack",
				"Package Control: List Packages"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"edit ",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"edit",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"outli",
				"Browse Mode: Outline (Right)"
			],
			[
				"outline",
				"Browse Mode: Outline (Right)"
			],
			[
				"debugger",
				"Preferences: Debugger Settings"
			],
			[
				"add re",
				"Package Control: Add Repository"
			],
			[
				"scheme",
				"Color Scheme Editor: Edit current color scheme"
			],
			[
				"outlin",
				"Browse Mode: Outline (Right)"
			],
			[
				"INSTALL",
				"Package Control: Install Package"
			],
			[
				"",
				"Arithmetic"
			],
			[
				"disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: disable",
				"Package Control: Disable Package"
			],
			[
				"Package Control: ",
				"Package Control: Disable Package"
			],
			[
				"adap",
				"Debugger: Install Adapters"
			],
			[
				"install ada",
				"Debugger: Install Adapters"
			],
			[
				"adapter",
				"Debugger: Install Adapters"
			],
			[
				"debug",
				"Debugger: Install Adapters"
			],
			[
				"Package Control: remove",
				"Package Control: Remove Package"
			],
			[
				"debu",
				"Debugger: Install Adapters"
			],
			[
				"instal",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 289.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Projects/plot-cv"
	],
	"file_history":
	[
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/functions.cmake",
		"/home/roman/Projects/plot-cv/plot-cv.sublime-project",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/location.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-textcode.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-inspect.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/util.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/tty.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/path.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/path.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/qjsm.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/resolve-imports.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tutf8e/README.md",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tutf8e/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tutf8e/src/tutf8e.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tutf8e/include/tutf8e/iso_8859_15.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tutf8e/include/tutf8e.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/buffer-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/buffer-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_textcode.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-textcode.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-stream.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/CMakeLists.txt",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-path.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/queue.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/jslexer.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/clexer.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/lexer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/fs.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_lexer.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/list-exports.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/repl.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/lexer/ecmascript.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/js-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-stream.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/streams.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_streams.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/lexer/csv.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/js-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-misc.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/libutf/include/libutf.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/char-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/char-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/libutf/src/libutf.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/ringbuffer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/defines.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-sockets.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/debug.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_stream.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/src/queue.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/include/ringbuffer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-lexer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-location.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-xml.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-location.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-mmap.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/extract-structs.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-internal.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lexer.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/token.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/token.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/buffer-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/buffer-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/char-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/location.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/location.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lexer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/queue.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/queue.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/js-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/js-utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-stringdecoder.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/qjsm.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/err",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/doc/latex/unionVector.tex",
		"/home/roman/.config/sublime-text/Packages/User/Themes/[ Argonaut ].tmTheme",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/vector.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-blob.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-internal.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_repl.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/path.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/path.h",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-sockets.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/utils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-archive.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/predicate.c",
		"/usr/include/archive.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/debug.h",
		"/home/roman/Projects/plot-cv/quickjs/cutils.c",
		"/home/roman/Projects/plot-cv/quickjs/cutils.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_repeater.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-deep.c.orig",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-tree-walker.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_dom.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/cmake/FindQuickJS.cmake",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/dom.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/property-enumeration.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/property-enumeration.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-syscallerror.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/tests/test_treewalker.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/char-utils.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/xpath.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-child-process.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/child-process.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-repeater.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/predicate.h",
		"/home/roman/Projects/plot-cv/quickjs/list.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/lib/extendArray.js",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/defines.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-pointer.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-pointer.h",
		"/home/roman/Projects/plot-cv/quickjs/quickjs.c",
		"/home/roman/Projects/plot-cv/quickjs/quickjs-libc.c",
		"/usr/lib/gcc/x86_64-linux-gnu/11/include/stdatomic.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-gpio.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/quickjs-predicate.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/debug.c",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/ringbuffer.h",
		"/home/roman/Projects/plot-cv/quickjs/quickjs-libc.h",
		"/home/roman/Projects/plot-cv/quickjs/qjs-modules/flexbox-intrinsic-sizing-horiz-1-ref.json"
	],
	"find":
	{
		"height": 29.0
	},
	"find_in_files":
	{
		"height": 130.0,
		"where_history":
		[
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,*.js,-*/libwebsockets/*,-*/glfw/*,-*/nanovg/*,-*/imgui/*,-*/disabled/*,-*/qjs-opencv/opencv*/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,-*/libwebsockets/*,-*/glfw/*,-*/nanovg/*,-*/imgui/*,-*/disabled/*,-*/qjs-opencv/opencv*/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,-*/libwebsockets/*,-*/glfw/*,-*/nanovg/*,-*/imgui/*,-*/disabled/*,-*/opencv_contrib/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,-*/libwebsockets/*,-*/glfw/*,-*/nanovg/*,-*/imgui/*,-*/disabled/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,-*/libwebsockets/*,-*/glfw/*,-*/nanovg/*,-*/imgui/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,-*/libwebsockets/*,-*/glfw/*,-*/nanovg/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,-*/(libwebsockets|glfw|nanovg)/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h,-*/libwebsockets/*",
			"/home/roman/Projects/plot-cv,*.cpp,*.c,*.hpp,*.h",
			"/home/roman/Projects/plot-cv,*.[ch]pp,*.[ch]",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"function ws",
			"dl\\(",
			"rotate =",
			"rotate",
			"begin",
			"context",
			"new GL$",
			"GLFW",
			"context =",
			"interpolate",
			"1\\.0 -",
			"alpha, ",
			"1 -",
			"1\\.0 -",
			"WINDOW_",
			"GLFW",
			"Window"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
				{
					"buffer": 0,
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6715,
						"regions":
						{
						},
						"selection":
						[
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"current_file": "/home/roman/Projects/plot-cv/quickjs/quickjs-libc.c",
							"function_name_status_row": 28,
							"outline_rename_mode": false,
							"symkeys":
							[
								[
									1595,
									1599
								],
								[
									1778,
									1790
								],
								[
									1847,
									1854
								],
								[
									2112,
									2122
								],
								[
									2377,
									2390
								],
								[
									2468,
									2485
								],
								[
									2586,
									2595
								],
								[
									2787,
									2802
								],
								[
									2987,
									3006
								],
								[
									3114,
									3136
								],
								[
									3622,
									3635
								],
								[
									3731,
									3747
								],
								[
									3864,
									3874
								],
								[
									3935,
									3953
								],
								[
									9579,
									9591
								],
								[
									10456,
									10469
								],
								[
									11091,
									11106
								],
								[
									11677,
									11696
								],
								[
									11862,
									11881
								],
								[
									13029,
									13054
								],
								[
									14500,
									14516
								],
								[
									15417,
									15428
								],
								[
									15628,
									15641
								],
								[
									15977,
									15983
								],
								[
									16369,
									16377
								],
								[
									16462,
									16475
								],
								[
									16891,
									16906
								],
								[
									17246,
									17263
								],
								[
									18054,
									18063
								],
								[
									18204,
									18221
								],
								[
									18312,
									18327
								],
								[
									18621,
									18634
								],
								[
									20039,
									20048
								],
								[
									20063,
									20084
								],
								[
									20375,
									20387
								],
								[
									20469,
									20484
								],
								[
									20690,
									20709
								],
								[
									21039,
									21054
								],
								[
									21489,
									21508
								],
								[
									21665,
									21676
								],
								[
									22457,
									22469
								],
								[
									23236,
									23249
								],
								[
									23916,
									23930
								],
								[
									24194,
									24208
								],
								[
									24350,
									24363
								],
								[
									24505,
									24520
								],
								[
									24766,
									24782
								],
								[
									25268,
									25285
								],
								[
									25731,
									25749
								],
								[
									25966,
									25983
								],
								[
									26187,
									26203
								],
								[
									26568,
									26584
								],
								[
									27079,
									27094
								],
								[
									27297,
									27314
								],
								[
									27519,
									27539
								],
								[
									27745,
									27763
								],
								[
									27969,
									27991
								],
								[
									28708,
									28727
								],
								[
									29435,
									29459
								],
								[
									30338,
									30357
								],
								[
									30562,
									30581
								],
								[
									30874,
									30889
								],
								[
									30911,
									30927
								],
								[
									30945,
									30965
								],
								[
									31274,
									31289
								],
								[
									31477,
									31490
								],
								[
									35075,
									35078
								],
								[
									37698,
									37709
								],
								[
									38506,
									38524
								],
								[
									38955,
									38965
								],
								[
									39667,
									39678
								],
								[
									39909,
									39919
								],
								[
									40458,
									40474
								],
								[
									41169,
									41181
								],
								[
									41424,
									41443
								],
								[
									42084,
									42120
								],
								[
									42136,
									42167
								],
								[
									42191,
									42206
								],
								[
									42767,
									42786
								],
								[
									43395,
									43404
								],
								[
									43546,
									43561
								],
								[
									44218,
									44230
								],
								[
									44753,
									44765
								],
								[
									45241,
									45255
								],
								[
									45370,
									45377
								],
								[
									45614,
									45629
								],
								[
									45803,
									45823
								],
								[
									46942,
									46949
								],
								[
									47212,
									47219
								],
								[
									47352,
									47369
								],
								[
									47541,
									47553
								],
								[
									48918,
									48929
								],
								[
									49146,
									49157
								],
								[
									49294,
									49306
								],
								[
									49447,
									49457
								],
								[
									49599,
									49620
								],
								[
									49817,
									49833
								],
								[
									50028,
									50044
								],
								[
									50843,
									50861
								],
								[
									51247,
									51259
								],
								[
									51658,
									51668
								],
								[
									53599,
									53614
								],
								[
									53707,
									53728
								],
								[
									55356,
									55377
								],
								[
									55474,
									55484
								],
								[
									58654,
									58668
								],
								[
									59023,
									59040
								],
								[
									59192,
									59204
								],
								[
									59469,
									59480
								],
								[
									59782,
									59793
								],
								[
									60328,
									60341
								],
								[
									61123,
									61137
								],
								[
									61283,
									61293
								],
								[
									64241,
									64254
								],
								[
									64391,
									64403
								],
								[
									65178,
									65189
								],
								[
									65728,
									65736
								],
								[
									65949,
									65963
								],
								[
									66393,
									66406
								],
								[
									66916,
									66930
								],
								[
									67381,
									67391
								],
								[
									68819,
									68829
								],
								[
									70019,
									70029
								],
								[
									74727,
									74740
								],
								[
									75407,
									75417
								],
								[
									75890,
									75900
								],
								[
									76227,
									76236
								],
								[
									76481,
									76491
								],
								[
									76960,
									76972
								],
								[
									77193,
									77207
								],
								[
									77265,
									77276
								],
								[
									77392,
									77406
								],
								[
									77537,
									77549
								],
								[
									77727,
									77738
								],
								[
									77998,
									78008
								],
								[
									78186,
									78205
								],
								[
									78611,
									78630
								],
								[
									78723,
									78738
								],
								[
									78945,
									78965
								],
								[
									79443,
									79455
								],
								[
									79678,
									79697
								],
								[
									80082,
									80093
								],
								[
									81121,
									81144
								],
								[
									82027,
									82049
								],
								[
									82072,
									82096
								],
								[
									82129,
									82143
								],
								[
									84487,
									84508
								],
								[
									86260,
									86283
								],
								[
									87258,
									87281
								],
								[
									87840,
									87874
								],
								[
									88005,
									88016
								],
								[
									88058,
									88069
								],
								[
									88113,
									88124
								],
								[
									88162,
									88173
								],
								[
									88195,
									88206
								],
								[
									88231,
									88238
								],
								[
									91021,
									91031
								],
								[
									92235,
									92252
								],
								[
									92617,
									92625
								],
								[
									93007,
									93025
								],
								[
									93887,
									93907
								],
								[
									94582,
									94602
								],
								[
									95414,
									95425
								],
								[
									95657,
									95675
								],
								[
									96032,
									96049
								],
								[
									96220,
									96252
								],
								[
									96527,
									96538
								],
								[
									96896,
									96914
								]
							],
							"symlist":
							[
								"â€”â“‚â€“ pipe ( ) â€¦ â€” macro function",
								"\tâ“‰  sighandler_t ; â€” typedef",
								"\tâ“‚  environ â€¦ â€” macro object",
								"\tâ“‚  USE_WORKER â€¦ â€” macro object",
								"\tâ“‰  JSOSRWHandler ; â€” typedef",
								"\tâ“‰  JSOSSignalHandler ; â€” typedef",
								"\tâ“‰  JSOSTimer ; â€” typedef",
								"\tâ“‰  JSWorkerMessage ; â€” typedef",
								"\tâ“‰  JSWorkerMessagePipe ; â€” typedef",
								"\tâ“‰  JSWorkerMessageHandler ; â€” typedef",
								"\tâ“‰  JSThreadState ; â€” typedef",
								"â€”â’»â€“ js_std_dbuf_init ( ) { â€¦ } â€” function",
								"â€”â’»â€“ my_isdigit ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_printf_internal ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_load_file ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_loadScript ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_loadFile ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_module_loader_so ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_module_loader_so ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_module_set_import_meta ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_module_loader ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_exit ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_getenv ( ) { â€¦ } â€” function",
								"â€”â’»â€“ setenv ( ) { â€¦ } â€” function",
								"â€”â’»â€“ unsetenv ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_setenv ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_unsetenv ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_getenviron ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_gc ( ) { â€¦ } â€” function",
								"â€”â’»â€“ interrupt_handler ( ) { â€¦ } â€” function",
								"â€”â’»â€“ get_bool_option ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_evalScript ( ) { â€¦ } â€” function",
								"\tâ“‰  JSSTDFile ; â€” typedef",
								"â€”â’»â€“ js_std_file_finalizer ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_get_errno ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_strerror ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_parseExtJSON ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_new_std_file ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_set_error_object ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_open ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_popen ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_fdopen ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_tmpfile ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_sprintf ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_printf ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_get ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_puts ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_close ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_printf ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_flush ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_tell ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_seek ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_eof ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_error ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_clearerr ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_fileno ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_read_write ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_getline ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_readAsString ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_getByte ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_file_putByte ( ) { â€¦ } â€” function",
								"\tâ“‚  URL_GET_PROGRAM â€¦ â€” macro object",
								"\tâ“‚  URL_GET_BUF_SIZE â€¦ â€” macro object",
								"â€”â’»â€“ http_get_header_line ( ) { â€¦ } â€” function",
								"â€”â’»â€“ http_get_status ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_urlGet ( ) { â€¦ } â€” function",
								"â€”â“‚â€“ DEF ( ) â€¦ â€” macro function",
								"â€”â’»â€“ js_std_init ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_init_module_std ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_open ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_close ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_seek ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_read_write ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_isatty ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_ttyGetWinSize ( ) { â€¦ } â€” function",
								"\tâ“‚  __ENABLE_VIRTUAL_TERMINAL_PROCESSING â€¦ â€” macro object",
								"\tâ“‚  __ENABLE_VIRTUAL_TERMINAL_INPUT â€¦ â€” macro object",
								"â€”â’»â€“ js_os_ttySetRaw ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_ttyGetWinSize ( ) { â€¦ } â€” function",
								"â€”â’»â€“ term_exit ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_ttySetRaw ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_remove ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_rename ( ) { â€¦ } â€” function",
								"â€”â’»â€“ is_main_thread ( ) { â€¦ } â€” function",
								"â€”â’»â€“ find_rh ( ) { â€¦ } â€” function",
								"â€”â’»â€“ free_rw_handler ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_setReadHandler ( ) { â€¦ } â€” function",
								"â€”â’»â€“ find_sh ( ) { â€¦ } â€” function",
								"â€”â’»â€“ free_sh ( ) { â€¦ } â€” function",
								"â€”â’»â€“ os_signal_handler ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_signal ( ) { â€¦ } â€” function",
								"â€”â’»â€“ get_time_ms ( ) { â€¦ } â€” function",
								"â€”â’»â€“ get_time_ms ( ) { â€¦ } â€” function",
								"â€”â’»â€“ unlink_timer ( ) { â€¦ } â€” function",
								"â€”â’»â€“ free_timer ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_timer_finalizer ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_timer_mark ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_setTimeout ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_clearTimeout ( ) { â€¦ } â€” function",
								"â€”â’»â€“ call_handler ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_poll ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_free_message ( ) { â€¦ } â€” function",
								"â€”â’»â€“ handle_posted_message ( ) { â€¦ } â€” function",
								"â€”â’»â€“ handle_posted_message ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_poll ( ) { â€¦ } â€” function",
								"â€”â’»â€“ make_obj_error ( ) { â€¦ } â€” function",
								"â€”â’»â€“ make_string_error ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_getcwd ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_chdir ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_mkdir ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_readdir ( ) { â€¦ } â€” function",
								"â€”â’»â€“ timespec_to_ms ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_stat ( ) { â€¦ } â€” function",
								"â€”â’»â€“ ms_to_timeval ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_utimes ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_sleep ( ) { â€¦ } â€” function",
								"â€”â’»â€“ realpath ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_realpath ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_symlink ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_readlink ( ) { â€¦ } â€” function",
								"â€”â’»â€“ build_envp ( ) { â€¦ } â€” function",
								"â€”â’»â€“ my_execvpe ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_exec ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_waitpid ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_pipe ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_kill ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_dup ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_os_dup2 ( ) { â€¦ } â€” function",
								"\tâ“‰  JSWorkerData ; â€” typedef",
								"\tâ“‰  WorkerFuncArgs ; â€” typedef",
								"\tâ“‰  JSSABHeader ; â€” typedef",
								"â€”â’»â€“ atomic_add_int ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_sab_alloc ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_sab_free ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_sab_dup ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_new_message_pipe ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_dup_message_pipe ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_free_message ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_free_message_pipe ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_free_port ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_worker_finalizer ( ) { â€¦ } â€” function",
								"â€”â’»â€“ worker_func ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_worker_ctor_internal ( ) { â€¦ } â€” function",
								"â€”â’»â€“ JS_GetModuleLoaderFunc ( ) { â€¦ } â€” function",
								"â€”â’»â€“ JS_GetModuleLoaderOpaque ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_worker_ctor ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_worker_postMessage ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_worker_set_onmessage ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_worker_get_onmessage ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_set_worker_new_context_func ( ) { â€¦ } â€” function",
								"\tâ“‚  OS_PLATFORM â€¦ â€” macro object",
								"\tâ“‚  OS_PLATFORM â€¦ â€” macro object",
								"\tâ“‚  OS_PLATFORM â€¦ â€” macro object",
								"\tâ“‚  OS_PLATFORM â€¦ â€” macro object",
								"\tâ“‚  OS_PLATFORM â€¦ â€” macro object",
								"â€”â“‚â€“ OS_FLAG ( ) â€¦ â€” macro function",
								"â€”â’»â€“ js_os_init ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_init_module_os ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_print ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_add_helpers ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_init_handlers ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_free_handlers ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_dump_obj ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_dump_error1 ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_dump_error ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_promise_rejection_tracker ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_loop ( ) { â€¦ } â€” function",
								"â€”â’»â€“ js_std_eval_binary ( ) { â€¦ } â€” function"
							],
							"syntax": "Packages/Outline/outline.hidden-tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647430555.87,
							"tabs_extra_last_activated_sheet_index": 0,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
				{
					"buffer": 1,
					"file": "test-opencv.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20449,
						"regions":
						{
						},
						"selection":
						[
							[
								2511,
								2513
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 18,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647430711.78,
							"tabs_extra_last_activated_sheet_index": 0,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 972.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "qjs-opencv/js/cvHighGUI.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5001,
						"regions":
						{
						},
						"selection":
						[
							[
								236,
								243
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 0,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647413406.3,
							"tabs_extra_last_activated_sheet_index": 1,
							"translate_tabs_to_spaces": true,
							"word_wrap": false
						},
						"translation.x": 1364.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "lib/util.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 184762,
						"regions":
						{
						},
						"selection":
						[
							[
								23558,
								23641
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 796,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647413404.6,
							"tabs_extra_last_activated_sheet_index": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 14709.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "test-glfw.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4498,
						"regions":
						{
						},
						"selection":
						[
							[
								4094,
								4094
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 111,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647429440.59,
							"tabs_extra_last_activated_sheet_index": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1679.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "test-nanovg.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3656,
						"regions":
						{
						},
						"selection":
						[
							[
								1610,
								1610
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 51,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647430681.83,
							"tabs_extra_last_activated_sheet_index": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 212.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "draw-utils.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4941,
						"regions":
						{
						},
						"selection":
						[
							[
								406,
								406
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 6,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647434283.57,
							"tabs_extra_last_activated_sheet_index": 5,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "qjs-opencv/point.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2553,
						"regions":
						{
						},
						"selection":
						[
							[
								118,
								121
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 0,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647434286.5,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "lib/geom/point.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11150,
						"regions":
						{
						},
						"selection":
						[
							[
								5747,
								5456
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 209,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647469419.82,
							"tabs_extra_last_activated_sheet_index": 7,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2364.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "check-discogs.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5103,
						"regions":
						{
						},
						"selection":
						[
							[
								4130,
								4130
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 137,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647515593.58,
							"tabs_extra_last_activated_sheet_index": 8,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1895.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "lib/devtools.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31892,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 0,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647642431.82,
							"tabs_extra_last_activated_sheet_index": 9,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7811.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "quickjs/quickjs-libc.c",
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 97640,
						"regions":
						{
						},
						"selection":
						[
							[
								24778,
								24782
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": -1,
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647712327.26,
							"tabs_extra_last_activated_sheet_index": 10,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 19026.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "lib/color/rgba.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22482,
						"regions":
						{
						},
						"selection":
						[
							[
								15464,
								15467
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 471,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647414442.51,
							"tabs_extra_last_activated_sheet_index": 4,
							"tabs_extra_moving":
							[
								6,
								1
							],
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 8534.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 13,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 959616,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions": "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",
								"scope": ""
							}
						},
						"selection":
						[
							[
								953528,
								953528
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"detect_indentation": false,
							"function_name_status_row": 18263,
							"line_numbers": false,
							"output_tag": 13,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"tabs_extra_last_activated": 1647414441.48,
							"tabs_extra_last_activated_sheet_index": 5,
							"tabs_extra_moving":
							[
								6,
								1
							],
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 377891.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "libs.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 309340,
						"regions":
						{
						},
						"selection":
						[
							[
								197736,
								197591
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 6804,
							"syntax": "Packages/JavaScriptNext - ES6 Syntax/JavaScriptNext.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647415308.03,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 128841.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"stack_multiselect": false,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "127.0.0.1.har",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3835935,
						"regions":
						{
						},
						"selection":
						[
							[
								1599528,
								1599528
							]
						],
						"settings":
						{
							"auto_complete_triggers":
							[
								{
									"characters": "./",
									"selector": "text.html, text.xml"
								},
								{
									"rhs_empty": true,
									"selector": "punctuation.accessor"
								}
							],
							"function_name_status_row": 12439,
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"tabs_extra_last_activated": 1647414272.3,
							"tabs_extra_last_activated_sheet_index": 6,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 502477.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 29.0
	},
	"input":
	{
		"height": 42.0
	},
	"layout":
	{
		"cells":
		[
			[
				2,
				0,
				3,
				2
			],
			[
				0,
				0,
				2,
				2
			]
		],
		"cols":
		[
			0.0,
			0.2,
			0.8,
			1.0
		],
		"rows":
		[
			0.0,
			0.5,
			1.0
		]
	},
	"menu_visible": true,
	"output.Debugger":
	{
		"height": 0.0
	},
	"output.Protocol":
	{
		"height": 0.0
	},
	"output.Protocol(139621681009616)":
	{
		"height": 0.0
	},
	"output.Protocol(139717987054208)":
	{
		"height": 0.0
	},
	"output.Protocol(139737090363696)":
	{
		"height": 0.0
	},
	"output.Protocol(140057995355088)":
	{
		"height": 0.0
	},
	"output.Protocol(140274144933008)":
	{
		"height": 0.0
	},
	"output.Protocol(140481508860304)":
	{
		"height": 0.0
	},
	"output.Protocol(140517145502288)":
	{
		"height": 0.0
	},
	"output.Protocol(140603239275824)":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "plot-cv.sublime-project",
	"replace":
	{
		"height": 54.0
	},
	"save_all_on_build": false,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"quickjs-libc",
				"quickjs/quickjs-libc.c"
			],
			[
				"devtoo",
				"lib/devtools.js"
			],
			[
				"check-disc",
				"check-discogs.js"
			],
			[
				"point.js",
				"lib/geom/point.js"
			],
			[
				"draw-ut",
				"draw-utils.js"
			],
			[
				"draw-utils",
				"draw-utils.js"
			],
			[
				"test-nan",
				"test-nanovg.js"
			],
			[
				"rgba.js",
				"lib/color/rgba.js"
			],
			[
				"util.js",
				"lib/util.js"
			],
			[
				"cvHigh",
				"qjs-opencv/js/cvHighGUI.js"
			],
			[
				"test-glfw",
				"test-glfw.js"
			],
			[
				"test-opencv",
				"test-opencv.js"
			],
			[
				"path.h",
				"include/path.h"
			],
			[
				"location.h",
				"include/location.h"
			],
			[
				"utils.h",
				"include/utils.h"
			],
			[
				"utils.c",
				"src/utils.c"
			],
			[
				"qjsm.c",
				"src/qjsm.c"
			],
			[
				"resolve",
				"resolve-imports.js"
			],
			[
				"resolve-im",
				"resolve-imports.js"
			],
			[
				"l",
				"quickjs-lexer.c"
			],
			[
				"resolve-impo",
				"resolve-imports.js"
			],
			[
				"path.c",
				"src/path.c"
			],
			[
				"qjsm",
				"src/qjsm.c"
			],
			[
				"quickjs-mi",
				"quickjs-misc.c"
			],
			[
				"cmakelist",
				"CMakeLists.txt"
			],
			[
				"list-ex",
				"list-exports.js"
			],
			[
				"repl.j",
				"lib/repl.js"
			],
			[
				"js-u",
				"src/js-utils.c"
			],
			[
				"js-ut",
				"include/js-utils.h"
			],
			[
				"streams.js",
				"tests/test_streams.js"
			],
			[
				"buffer",
				"src/buffer-utils.c"
			],
			[
				"test_te",
				"tests/test_textcode.js"
			],
			[
				"quickjs-lexe",
				"quickjs-lexer.c"
			],
			[
				"extract-str",
				"extract-structs.js"
			],
			[
				"sockets",
				"quickjs-sockets.c"
			],
			[
				"repl.js",
				"lib/repl.js"
			],
			[
				"list-exp",
				"list-exports.js"
			],
			[
				"token.c",
				"token.c"
			],
			[
				"quickjs-le",
				"quickjs-lexer.c"
			],
			[
				"jsutil",
				"js-utils.c"
			],
			[
				"quickjs-sock",
				"quickjs-sockets.h"
			],
			[
				"quickjs-location",
				"quickjs-location.h"
			],
			[
				"quickjs-loca",
				"quickjs-location.c"
			],
			[
				"CMake",
				"CMakeLists.txt"
			],
			[
				"char-ut",
				"char-utils.h"
			],
			[
				"buff",
				"buffer-utils.h"
			],
			[
				"test_dom",
				"tests/test_dom.js"
			],
			[
				"quickjs-xml",
				"quickjs-xml.c"
			],
			[
				"dom.js",
				"lib/dom.js"
			],
			[
				"location",
				"location.c"
			],
			[
				"quickjs-child",
				"quickjs-child-process.c"
			],
			[
				"cmakeli",
				"CMakeLists.txt"
			],
			[
				"CMakeLi",
				"CMakeLists.txt"
			],
			[
				"xpath",
				"lib/xpath.js"
			],
			[
				"defines.h",
				"defines.h"
			],
			[
				"queue.c",
				"queue.c"
			],
			[
				"extend",
				"lib/extendArray.js"
			],
			[
				"quickjs-sockets",
				"quickjs-sockets.c"
			],
			[
				"lexer",
				"quickjs-lexer.c"
			],
			[
				"buffer-ut",
				"buffer-utils.h"
			],
			[
				"ringbuf",
				"ringbuffer.h"
			],
			[
				"debug.h",
				"debug.h"
			],
			[
				"debug.c",
				"debug.c"
			],
			[
				"quickjs-lexer.c",
				"quickjs-lexer.c"
			],
			[
				"quickjs-loc",
				"quickjs-location.c"
			],
			[
				"xml.c",
				"quickjs-xml.c"
			],
			[
				"test-dia",
				"build/android64/CMakeFiles/qjs-predicate-static.dir/quickjs-predicate.c.o.d"
			],
			[
				"util.",
				"lib/util.js"
			],
			[
				"resol",
				"resolve-imports.js"
			],
			[
				"quickjs-pa",
				"quickjs-path.c"
			],
			[
				"util",
				"lib/util.js"
			],
			[
				"quickjs-mis",
				"quickjs-misc.c"
			],
			[
				"location.c",
				"quickjs-location.c"
			],
			[
				"quickjs-in",
				"quickjs-inspect.c"
			],
			[
				"extra",
				"extract-structs.js"
			],
			[
				"-inspe",
				"quickjs-inspect.c"
			],
			[
				"proper",
				"property-enumeration.h"
			],
			[
				"vector",
				"vector.h"
			],
			[
				"dom.j",
				"lib/dom.js"
			],
			[
				"res",
				"resolve-imports.js"
			],
			[
				"lexre",
				"lexer.c"
			],
			[
				"lexer.c",
				"quickjs-lexer.c"
			],
			[
				"pointer",
				"pointer.c"
			],
			[
				"vector.h",
				"vector.h"
			],
			[
				"lexer.h",
				"lexer.h"
			],
			[
				"quickjs.h",
				"~/Projects/plot-cv/quickjs/quickjs.h"
			],
			[
				"archive",
				"quickjs-archive.c"
			],
			[
				"pointer.c",
				"quickjs-pointer.c"
			],
			[
				"spect.c",
				"quickjs-inspect.c"
			],
			[
				"blob.c",
				"quickjs-blob.c"
			],
			[
				"repea",
				"quickjs-repeater.c"
			],
			[
				"loca",
				"quickjs-location.c"
			],
			[
				"bjson.c",
				"quickjs-bjson.c"
			],
			[
				"pred",
				"predicate.c"
			],
			[
				"char-u",
				"char-utils.h"
			],
			[
				"predi",
				"predicate.h"
			],
			[
				"virtua",
				"virtual-properties.c"
			],
			[
				"pointre",
				"pointer.c"
			],
			[
				"deep.c",
				"quickjs-deep.c"
			],
			[
				"child-",
				"child-process.c"
			],
			[
				"child-pro",
				"quickjs-child-process.c"
			],
			[
				"gpio.c",
				"quickjs-gpio.c"
			],
			[
				"buffer-u",
				"buffer-utils.c"
			],
			[
				"ointer.h",
				"pointer.h"
			],
			[
				"defin",
				"defines.h"
			],
			[
				"defines",
				"defines.h"
			],
			[
				"cutils.h",
				"char-utils.h"
			],
			[
				"debu",
				"debug.h"
			],
			[
				"repl",
				"lib/repl.js"
			],
			[
				"test_le",
				"tests/test_lexer.js"
			],
			[
				"test_lexer",
				"tests/test_lexer.js"
			],
			[
				"quickjs-pat",
				"quickjs-path.c"
			],
			[
				"test",
				"tests/test_stack.js"
			],
			[
				"jsutils",
				"CMakeFiles/qjs-syscallerror-static.dir/utils.c.o.d"
			],
			[
				"jslexe",
				"lib/jslexer.js"
			],
			[
				"inspect.c",
				"quickjs-inspect.c"
			],
			[
				"fs.js",
				"lib/fs.js"
			],
			[
				"quickjs-pre",
				"quickjs-predicate.c"
			],
			[
				"xpath.j",
				"lib/xpath.js"
			],
			[
				"predicate.h",
				"predicate.h"
			],
			[
				"test_sock",
				"tests/test_sockets.js"
			],
			[
				"sockets.c",
				"quickjs-sockets.c"
			],
			[
				"list.h",
				"~/Projects/plot-cv/quickjs/list.h"
			],
			[
				"queue",
				"queue.c"
			],
			[
				"test_xml",
				"tests/test_xml.js"
			],
			[
				"quickjs-ins",
				"quickjs-inspect.c"
			],
			[
				"test_wa",
				"tests/test_watch.js"
			],
			[
				"cmakelists",
				"CMakeLists.txt"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Projects/plot-cv/plot-cv.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 370.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"WS"
			]
		],
		"width": 970.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 294.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
